<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="线程池,">










<meta name="description" content="线程池">
<meta name="keywords" content="线程池">
<meta property="og:type" content="article">
<meta property="og:title" content="线程池-ThreadPoolExecutor">
<meta property="og:url" content="http://yannischeng.com/线程池-ThreadPoolExecutor/index.html">
<meta property="og:site_name" content="YannisCheng&#39;s Technology Blogs">
<meta property="og:description" content="线程池">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/threadpool.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png">
<meta property="og:updated_time" content="2019-02-23T23:54:27.314Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程池-ThreadPoolExecutor">
<meta name="twitter:description" content="线程池">
<meta name="twitter:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/threadpool.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yannischeng.com/线程池-ThreadPoolExecutor/">





  <title>线程池-ThreadPoolExecutor | YannisCheng's Technology Blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YannisCheng's Technology Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不必一味的讨好别人，每个人都有自己的活法。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yannischeng.com/线程池-ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YannisCheng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://oy991qm3u.bkt.clouddn.com/%E6%A2%B5%E9%AB%98.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YannisCheng's Technology Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">线程池-ThreadPoolExecutor</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T11:20:55+08:00">
                2019-02-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-02-24T07:54:27+08:00">
                2019-02-24
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,130 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    

    
        <div class="post-tags">
          
            <a href="/tags/线程池/" rel="tag"># 线程池</a>
          
        </div>
      

    
    
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    YannisCheng
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yannischeng.com/线程池-ThreadPoolExecutor/" title="线程池-ThreadPoolExecutor">http://yannischeng.com/线程池-ThreadPoolExecutor/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    尊重个人劳动成果，转载请注明出处。 ─=≡Σ(((つ•̀ω•́)つ))
  </li>
</ul>

      </div>
    



    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>线程池</p>
<a id="more"></a>
<h1 id="1-Executor-接口"><a href="#1-Executor-接口" class="headerlink" title="1. Executor 接口"></a>1. Executor 接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池的顶级接口。定义了方法 <code>execute(Runnable)</code>，该方法接收一个<strong>Runnable</strong>实例，用来执行一个任务，该任务即是一个实现<strong>Runnable</strong>接口的类。</p>
<p>此服务方法无返回值，原因是因为实现<strong>Runnable</strong>接口的类的run方法是无返回（void）的。</p>
<p>常用方法 ： <code>void execute（execute）</code></p>
<p>作用 ： 启动并执行线程任务</p>
<h1 id="2-ExecutorService-接口"><a href="#2-ExecutorService-接口" class="headerlink" title="2. ExecutorService 接口"></a>2. ExecutorService 接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">        </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">        </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承自 <strong>Executor接口</strong>，提供了更多的方法调用，例如关闭方法<code>shutdown()</code>，有返回值的<code>submit()</code>。</p>
<h1 id="3-Executors-使用"><a href="#3-Executors-使用" class="headerlink" title="3. Executors 使用"></a>3. Executors 使用</h1><ul>
<li>Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</li>
<li>Executors.newSingleThreadExecutor();    //创建容量为1的缓冲池</li>
<li>Executors.newFixedThreadPool(int);       //创建固定容量大小的缓冲池</li>
</ul>
<p><strong>三个方法的具体实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h1><blockquote>
<p>参考：<a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></p>
</blockquote>
<p>使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p><strong>线程池</strong>使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务。</p>
<h2 id="4-1-ThreadPoolExecutor类继承关系"><a href="#4-1-ThreadPoolExecutor类继承关系" class="headerlink" title="4.1 ThreadPoolExecutor类继承关系"></a>4.1 ThreadPoolExecutor类继承关系</h2><p><strong>流程图描述</strong>：</p>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/threadpool.png" alt></p>
<p><strong>文字描述</strong>：</p>
<ol>
<li><p>首先线程池判断 <strong>核心线程池</strong> 是否已满（&lt; corePoolSize）？没满：创建一个工作线程来执行任务；满了:  则进入下个流程。</p>
</li>
<li><p>其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</p>
</li>
<li><p>最后线程池判断整个线程池是否已满（&lt; maximumPoolSize ？）？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</p>
</li>
</ol>
<h2 id="4-2-构造函数中的各个参数含义："><a href="#4-2-构造函数中的各个参数含义：" class="headerlink" title="4.2 构造函数中的各个参数含义："></a>4.2 构造函数中的各个参数含义：</h2><ul>
<li><strong>1. int corePoolSize：</strong></li>
<li><strong>2. int maximumPoolSize：</strong></li>
<li><strong>3. long keepAliveTime：</strong></li>
<li><strong>4. TimeUnit  unit：</strong></li>
<li><strong>5. BlockingQueue<runnable> workQueue：</runnable></strong></li>
<li><strong>6. ThreadFactory threadFactory：</strong></li>
<li><strong>7. RejectedExecutionHandler handler：</strong></li>
</ul>
<h4 id="1-int-corePoolSize："><a href="#1-int-corePoolSize：" class="headerlink" title="1. int corePoolSize："></a>1. int corePoolSize：</h4><p> 核心池的大小（例如：正式工人。就是线程池大小），这个参数跟后面讲述的线程池的实现原理有非常大的关系。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 <code>corePoolSize</code> 后，就会把到达的任务放到 <code>缓存队列</code> 当中；</p>
<h4 id="2-int-maximumPoolSize："><a href="#2-int-maximumPoolSize：" class="headerlink" title="2. int maximumPoolSize："></a>2. int maximumPoolSize：</h4><p> 线程池最大线程数（例如：正式工人 + 临时工人。任务量突然过大时的一种补救措施），它表示在线程池中最多能创建多少个线程。</p>
<h4 id="3-long-keepAliveTime："><a href="#3-long-keepAliveTime：" class="headerlink" title="3. long keepAliveTime："></a>3. long keepAliveTime：</h4><p> 表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用。但是如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
<h4 id="4-TimeUnit-unit："><a href="#4-TimeUnit-unit：" class="headerlink" title="4. TimeUnit  unit："></a>4. TimeUnit  unit：</h4><p>  参数<code>keepAliveTime</code>的时间单位，有7种取值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure>
<h4 id="5-BlockingQueue-workQueue："><a href="#5-BlockingQueue-workQueue：" class="headerlink" title="5. BlockingQueue workQueue："></a>5. BlockingQueue<runnable> workQueue：</runnable></h4><p> 一个阻塞队列，用来存储等待执行的任务。阻塞队列有以下几种选择，一般使用<code>LinkedBlockingQueue</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure>
<h4 id="6-ThreadFactory-threadFactory："><a href="#6-ThreadFactory-threadFactory：" class="headerlink" title="6. ThreadFactory threadFactory："></a>6. ThreadFactory threadFactory：</h4><p>线程工厂，主要用来创建线程。</p>
<h4 id="7-RejectedExecutionHandler-handler："><a href="#7-RejectedExecutionHandler-handler：" class="headerlink" title="7. RejectedExecutionHandler handler："></a>7. RejectedExecutionHandler handler：</h4><p>表示当拒绝处理任务时的策略，有以下四种取值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>
<h4 id="allowCoreThreadTimeOut-boolean-value-参数设置"><a href="#allowCoreThreadTimeOut-boolean-value-参数设置" class="headerlink" title="allowCoreThreadTimeOut(boolean value)参数设置"></a>allowCoreThreadTimeOut(boolean value)参数设置</h4><p>源代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">line : <span class="number">1669</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">    <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">        allowCoreThreadTimeOut = value;</span><br><span class="line">        <span class="keyword">if</span> (value)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法在 <code>boolean == true</code> 时，最终会调用: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeInterrupt</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-主要方法："><a href="#4-3-主要方法：" class="headerlink" title="4.3 主要方法："></a>4.3 主要方法：</h2><ul>
<li><code>execute()</code> 方法实际上是 <strong>Executor</strong> 中声明的方法，在 <strong>ThreadPoolExecutor</strong> 进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
<li><code>submit()</code> 这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code> 方法不同，它能够返回任务执行的结果，去看 <code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了 <strong>Future</strong> 来获取任务执行结果。</li>
<li><code>shutdown()</code>和<code>shutdownNow()</code>是用来关闭线程池的。</li>
</ul>
<h2 id="4-4-ThreadPoolExecutor类实现原理"><a href="#4-4-ThreadPoolExecutor类实现原理" class="headerlink" title="4.4 ThreadPoolExecutor类实现原理"></a>4.4 ThreadPoolExecutor类实现原理</h2><h3 id="4-4-1-线程池的处理流程"><a href="#4-4-1-线程池的处理流程" class="headerlink" title="4.4.1 线程池的处理流程"></a>4.4.1 线程池的处理流程</h3><p><strong>流程图描述</strong>：</p>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt></p>
<p><strong>文字描述</strong>：</p>
<ol>
<li><p>首先线程池判断 <strong>核心线程池</strong> 是否已满（&lt; corePoolSize）？没满：创建一个工作线程来执行任务；满了:  则进入下个流程。</p>
</li>
<li><p>其次线程池判断 <strong>工作队列</strong> 是否已满？没满：则将新提交的任务存储在工作队列里；满了：则进入下个流程。</p>
</li>
<li><p>最后线程池判断 <strong>整个线程池</strong> 是否已满（&lt; maximumPoolSize）？没满：则创建一个新的工作线程来执行任务；满了：则交给饱和策略来处理这个任务。</p>
</li>
</ol>
<h3 id="4-4-2-线程池状态"><a href="#4-4-2-线程池状态" class="headerlink" title="4.4.2 线程池状态"></a>4.4.2 线程池状态</h3><p>在ThreadPoolExecutor中定义了一个<code>volatile</code>变量 :<code>runState</code>，另外定义了几个static final变量表示线程池的各个状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState; <span class="comment">// 保证线程之间的可见性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">0</span>; <span class="comment">// 当创建线程池后，初始时</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   = <span class="number">1</span>; <span class="comment">// 调用了shutdown()方法，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       = <span class="number">2</span>; <span class="comment">// 调用了shutdownNow()方法，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span>; <span class="comment">// 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-3-线程池的任务提交方式："><a href="#4-4-3-线程池的任务提交方式：" class="headerlink" title="4.4.3 线程池的任务提交方式："></a>4.4.3 线程池的任务提交方式：</h3><ul>
<li><code>execute()</code>：没有返回值，也就不能判断任务是否被线程池执行成功</li>
<li><code>submit()</code>：会返回一个<strong>Future</strong>对象，通过<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞住直到任务完成，而使用<code>get(long timeout, TimeUnit unit)</code>方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</li>
</ul>
<h3 id="4-4-4-线程池的关闭"><a href="#4-4-4-线程池的关闭" class="headerlink" title="4.4.4 线程池的关闭"></a>4.4.4 线程池的关闭</h3><ul>
<li><strong>shutdown()：</strong>不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li><strong>shutdownNow()：</strong>立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
<h3 id="4-4-5-添加任务处理流程"><a href="#4-4-5-添加任务处理流程" class="headerlink" title="4.4.5 添加任务处理流程"></a>4.4.5 添加任务处理流程</h3><p>当一个任务通过 <code>execute(Runnable)</code> 方法欲添加到线程池时：</p>
<ul>
<li><p>如果当前线程池中的数量 <code>小于corePoolSize</code>，并线程池处于<code>Running状态</code>，创建并添加的任务。</p>
</li>
<li><p>如果当前线程池中的数量 <code>等于corePoolSize</code>，并线程池处于<code>Running状态</code>，缓冲队列 <code>workQueue未满</code>，那么任务被放入缓冲队列、等待任务调度执行。</p>
</li>
<li><p>如果当前线程池中的数量 <code>大于corePoolSize</code>，缓冲队列<code>workQueue已满</code>，并且线程池中的数量 <code>小于maximumPoolSize</code>，新提交任务会创建新线程执行任务。</p>
</li>
<li><p>如果当前线程池中的数量 <code>大于corePoolSize</code>，缓冲队列<code>workQueue已满</code>，并且线程池中的数量 <code>等于maximumPoolSize</code>，新提交任务由Handler处理。</p>
</li>
<li><p>当线程池中的线程 <code>大于corePoolSize</code> 时，多余线程空闲时间 <code>超过keepAliveTime</code> 时，会关闭这部分线程。</p>
</li>
</ul>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>在 <strong>ThreadPoolExecutor类</strong> 中，最核心的任务提交方法是 <code>execute()</code> 方法。<strong><code>execute()</code></strong> 方法的实现原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.如果运行的线程数小于corePoolSize，尝试创建一个新线程（Worker），并执行它的第一个任务command</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 如果task成功插入等待队列，我们仍需要进行双重校验是否可以成功添加一个线程</span></span><br><span class="line"><span class="comment">　　　　　　（因为有的线程可能在我们上次检查以后已经死掉了）或者在我们进入这个方法后线程池已经关闭了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. 如果等待队列已满，我们尝试新创建一个线程。如果创建失败，我们知道线程已关闭或者已饱和，因此我们拒绝改任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//工作线程小于核心线程数，创建新的线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//创建新的worker立即执行command，并且轮训workQueue处理task</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程池在运行状态且可以将task插入队列</span></span><br><span class="line">　　 <span class="comment">//第一次校验线程池在运行状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//第二次校验，防止在第一次校验通过后线程池关闭。如果线程池关闭，在队列中删除task并拒绝task</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果线程数=0（线程都死掉了，比如：corePoolSize=0），新建线程且未指定firstTask，仅仅去轮训workQueue</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程队列已满，尝试创建新线程执行task，创建失败后拒绝task</span></span><br><span class="line">    <span class="comment">//创建失败原因：1.线程池关闭；2.线程数已经达到maxPoolSize</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上方法主要是通过 <code>线程数</code> 和 <code>addWorker()</code> 来执行的判断操作，其中<strong><code>addWorker()</code></strong> 方法源码:</p>
<p>参数：</p>
<ul>
<li><p><code>firstTask</code>：    </p>
<p>worker线程的初始任务，可以为空。</p>
</li>
<li><p><code>core</code>：           </p>
<ul>
<li>true：将corePoolSize作为上限</li>
<li>false：将maximumPoolSize作为上限</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 外层循环判断线程池的状态</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  线程池状态:RUNNING = -1、SHUTDOWN = 0、STOP = 1、TIDYING = 2、TERMINATED = 3　</span></span><br><span class="line">        <span class="comment">// 线程池至少是shutdown状态</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            <span class="comment">//除了线程池正在关闭（shutdown），队列里还有未处理的task的情况，其他都不能添加</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">	   <span class="comment">//内层循环判断是否到达容量上限，worker+1</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">//worker数量</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">             <span class="comment">//worker大于Integer最大上限或到达边界上限</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">//CAS worker+1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">//成功了跳出循环</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果线程池状态发生变化，重试外层循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在获取住锁定时重新检查。</span></span><br><span class="line">                <span class="comment">//退出ThreadFactory失败或者如果</span></span><br><span class="line">                <span class="comment">//在获得锁定之前关闭。</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// workers是HashSet&lt;Worker&gt;</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// 设置最大线程池大小</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法中调用的 <code>compareAndIncrementWorkerCount(int expect)</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法中 <code>compareAndSet(expect, expect + 1);</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapInt(<span class="keyword">this</span>, VALUE, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <strong><code>execute()</code></strong> 方法中，共用到了3次参数不同的  <strong><code>addWorker()</code></strong> :</p>
<ul>
<li><code>addWorker(command, true)</code></li>
<li><code>addWorker(null, false)</code></li>
<li><code>addWorker(command, false)</code></li>
</ul>
<p>这个 <strong><code>addWorker()</code></strong>方法虽然行数多，但是实际上只做了2个操作：</p>
<ul>
<li>在无限 <code>for()</code> 循环中，对 <code>线程状态</code>和 <code>线程数量</code>做判断是否要通过 <code>AtomicInteger</code> 的 <code>compareAndSet(int expect, int update)</code> 来更改线程数。</li>
<li>在加锁后，对线程的状态做检测，然后进行<code>Worker</code>的添加处理。</li>
</ul>
<p>在看到 <strong><code>addWork()</code></strong> 方法中的如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br><span class="line">workerStarted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>我们就应该意识到，线程开始运行了，注意这里的 <code>run()</code>，这个方法时 <strong>Worker类</strong> 中的 <code>run()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <strong><code>runWorker(this)</code></strong> 方法则是 <strong>ThreadPoolExecutor类</strong> 中的方法，源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">           <span class="comment">//如果线程池正在停止，请确保线程被中断;</span></span><br><span class="line">		   <span class="comment">//如果线程池没有被停止，请确保线程不被中断。</span></span><br><span class="line">		   <span class="comment">//这需要在第二种情况下重新检查以在清除中断时处理shutdownNow竞争</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//执行完毕后task重置，completedTasks计数器++，解锁。</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <strong><code>runWorker()</code></strong> 这个方法中，在 <code>while(){}</code> 循环中获取 <code>task</code>，当前 <code>task</code> 不为<code>null</code>或者从队列中取的任务不为<code>null</code>时，<code>worker</code>线程就一直去执行任务，处理完之后进行释放。其涉及到了如下几个方法：</p>
<ul>
<li><code>getTask()</code>：不断的从阻塞队列中取任务交给线程执行。</li>
<li><code>runStateAtLeast(ctl.get(), STOP)</code>：</li>
<li><code>beforeExecute(wt, task)</code> ：</li>
<li><code>afterExecute(task, thrown)</code>：</li>
<li><code>processWorkerExit(w, completedAbruptly)</code>：</li>
</ul>
<p><strong><code>getTask</code></strong> 是 <strong>ThreadPoolExecutor类</strong> 中的方法，并不是Worker类中的方法，下面是<code>getTask()</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//1：如果线程池处于shutdown状态，并且 队列为空 或者 线程池为空，则线程池数量-1，返回null，回收线程</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标识当前线程：是否设置允许超时 或者 线程数大于核心线程数</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">	    <span class="comment">// 2：判断线程数 或者时间</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/u011637069/article/details/79593114" target="_blank" rel="noopener">https://blog.csdn.net/u011637069/article/details/79593114</a></p>
</blockquote>
<h3 id="4-4-6-任务拒绝策略"><a href="#4-4-6-任务拒绝策略" class="headerlink" title="4.4.6  任务拒绝策略"></a>4.4.6  任务拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor类-原生使用-示例"><a href="#ThreadPoolExecutor类-原生使用-示例" class="headerlink" title="ThreadPoolExecutor类 原生使用 示例"></a>ThreadPoolExecutor类 原生使用 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">            poolExecutor.execute(myTask);</span><br><span class="line">            System.out.println(<span class="string">"第 "</span> + i + <span class="string">"个 —— 线程池中线程数目："</span> + poolExecutor.getPoolSize() + <span class="string">"，队列中等待执行的任务数目："</span> + poolExecutor.getQueue().size() + <span class="string">"，已执行玩别的任务数目："</span> + poolExecutor.getCompletedTaskCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        poolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.taskNum = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"正在执行task "</span> + taskNum);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"task "</span> + taskNum + <span class="string">"执行完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     当 i &lt; 5 时：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     正在执行task 0</span></span><br><span class="line"><span class="comment">     第 0个 —— 线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     第 1个 —— 线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     正在执行task 1</span></span><br><span class="line"><span class="comment">     第 2个 —— 线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     正在执行task 2</span></span><br><span class="line"><span class="comment">     第 3个 —— 线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     正在执行task 3</span></span><br><span class="line"><span class="comment">     第 4个 —— 线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     正在执行task 4</span></span><br><span class="line"><span class="comment">     task 1执行完毕</span></span><br><span class="line"><span class="comment">     task 2执行完毕</span></span><br><span class="line"><span class="comment">     task 3执行完毕</span></span><br><span class="line"><span class="comment">     task 0执行完毕</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - - -  - - - - - -  - -</span></span><br><span class="line"><span class="comment">     当 i &lt; 10 时：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     正在执行task 0</span></span><br><span class="line"><span class="comment">     第 0个 —— 线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     第 1个 —— 线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     正在执行task 1</span></span><br><span class="line"><span class="comment">     第 2个 —— 线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     正在执行task 2</span></span><br><span class="line"><span class="comment">     第 3个 —— 线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     正在执行task 3</span></span><br><span class="line"><span class="comment">     第 4个 —— 线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     第 5个 —— 线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     第 6个 —— 线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     正在执行task 4</span></span><br><span class="line"><span class="comment">     第 7个 —— 线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     第 8个 —— 线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     第 9个 —— 线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0</span></span><br><span class="line"><span class="comment">     task 0执行完毕</span></span><br><span class="line"><span class="comment">     task 1执行完毕</span></span><br><span class="line"><span class="comment">     task 3执行完毕</span></span><br><span class="line"><span class="comment">     正在执行task 7</span></span><br><span class="line"><span class="comment">     task 2执行完毕</span></span><br><span class="line"><span class="comment">     正在执行task 8</span></span><br><span class="line"><span class="comment">     正在执行task 5</span></span><br><span class="line"><span class="comment">     正在执行task 6</span></span><br><span class="line"><span class="comment">     task 4执行完毕</span></span><br><span class="line"><span class="comment">     正在执行task 9</span></span><br><span class="line"><span class="comment">     task 7执行完毕</span></span><br><span class="line"><span class="comment">     task 6执行完毕</span></span><br><span class="line"><span class="comment">     task 9执行完毕</span></span><br><span class="line"><span class="comment">     task 5执行完毕</span></span><br><span class="line"><span class="comment">     task 8执行完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程对于-成员变量-与-局部变量-的影响"><a href="#多线程对于-成员变量-与-局部变量-的影响" class="headerlink" title="多线程对于 成员变量 与 局部变量 的影响"></a>多线程对于 成员变量 与 局部变量 的影响</h2><ul>
<li><p>如果一个变量是 <strong>成员变量</strong>，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是 <strong>彼此影响</strong>的，也就是说一个线程对成员变量的改变会影响到另一个线程。</p>
</li>
<li><p>如果一个变量是 <strong>局部变量</strong>，那么 <strong>每个线程</strong> 都会有一个 <strong>该局部变量的拷贝</strong>（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</p>
</li>
</ul>

      
    </div>
    
    
    

    

    


    <footer class="post-footer">
      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Java基本数据类型/" rel="next" title="Java基本数据类型">
                <i class="fa fa-chevron-left"></i> Java基本数据类型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/线程池-相关类/" rel="prev" title="线程池-相关类">
                线程池-相关类 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://oy991qm3u.bkt.clouddn.com/%E6%A2%B5%E9%AB%98.gif" alt="YannisCheng">
            
              <p class="site-author-name" itemprop="name">YannisCheng</p>
              <p class="site-description motion-element" itemprop="description">不必一味的讨好别人，每个人都有自己的活法。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">164</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/YannisCheng" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:cwj1714@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Executor-接口"><span class="nav-number">1.</span> <span class="nav-text">1. Executor 接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-ExecutorService-接口"><span class="nav-number">2.</span> <span class="nav-text">2. ExecutorService 接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Executors-使用"><span class="nav-number">3.</span> <span class="nav-text">3. Executors 使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-线程池"><span class="nav-number">4.</span> <span class="nav-text">4. 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-ThreadPoolExecutor类继承关系"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 ThreadPoolExecutor类继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-构造函数中的各个参数含义："><span class="nav-number">4.2.</span> <span class="nav-text">4.2 构造函数中的各个参数含义：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-int-corePoolSize："><span class="nav-number">4.2.0.1.</span> <span class="nav-text">1. int corePoolSize：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-int-maximumPoolSize："><span class="nav-number">4.2.0.2.</span> <span class="nav-text">2. int maximumPoolSize：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-long-keepAliveTime："><span class="nav-number">4.2.0.3.</span> <span class="nav-text">3. long keepAliveTime：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-TimeUnit-unit："><span class="nav-number">4.2.0.4.</span> <span class="nav-text">4. TimeUnit  unit：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-BlockingQueue-workQueue："><span class="nav-number">4.2.0.5.</span> <span class="nav-text">5. BlockingQueue workQueue：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-ThreadFactory-threadFactory："><span class="nav-number">4.2.0.6.</span> <span class="nav-text">6. ThreadFactory threadFactory：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-RejectedExecutionHandler-handler："><span class="nav-number">4.2.0.7.</span> <span class="nav-text">7. RejectedExecutionHandler handler：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#allowCoreThreadTimeOut-boolean-value-参数设置"><span class="nav-number">4.2.0.8.</span> <span class="nav-text">allowCoreThreadTimeOut(boolean value)参数设置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-主要方法："><span class="nav-number">4.3.</span> <span class="nav-text">4.3 主要方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-ThreadPoolExecutor类实现原理"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 ThreadPoolExecutor类实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-线程池的处理流程"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1 线程池的处理流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-线程池状态"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2 线程池状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-线程池的任务提交方式："><span class="nav-number">4.4.3.</span> <span class="nav-text">4.4.3 线程池的任务提交方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-4-线程池的关闭"><span class="nav-number">4.4.4.</span> <span class="nav-text">4.4.4 线程池的关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-5-添加任务处理流程"><span class="nav-number">4.4.5.</span> <span class="nav-text">4.4.5 添加任务处理流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行过程"><span class="nav-number">4.4.6.</span> <span class="nav-text">执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-6-任务拒绝策略"><span class="nav-number">4.4.7.</span> <span class="nav-text">4.4.6  任务拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor类-原生使用-示例"><span class="nav-number">4.5.</span> <span class="nav-text">ThreadPoolExecutor类 原生使用 示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程对于-成员变量-与-局部变量-的影响"><span class="nav-number">4.6.</span> <span class="nav-text">多线程对于 成员变量 与 局部变量 的影响</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YannisCheng</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">388.4k</span>
  
</div>













        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.3"></script>


  


<script type="text/javascript" color="18,146,19" opacity="0.7" zindex="-1" count="0" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>

</body>
</html>
