<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Java,JVM,">










<meta name="description" content="JVM理解 —— 源码的编译、执行">
<meta name="keywords" content="Java,JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM理解-编译、加载">
<meta property="og:url" content="http://yannischeng.com/JVM理解-编译、加载/index.html">
<meta property="og:site_name" content="YannisCheng&#39;s Technology Blogs">
<meta property="og:description" content="JVM理解 —— 源码的编译、执行">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88.jpg">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2008.46.46.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2009.07.11.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/Java%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B-2.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2008.51.40111.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/2018-08-07%2011.17.50.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2015.15.17.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2022.17.23.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2022.17.59.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%2000.12.46.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%2000.10.48.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%2000.07.44.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/713721-20160602152821617-738821208.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/08-08%2000.55.32.png">
<meta property="og:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/20170603184309287.png">
<meta property="og:updated_time" content="2019-02-10T10:53:54.534Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM理解-编译、加载">
<meta name="twitter:description" content="JVM理解 —— 源码的编译、执行">
<meta name="twitter:image" content="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yannischeng.com/JVM理解-编译、加载/">





  <title>JVM理解-编译、加载 | YannisCheng's Technology Blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YannisCheng's Technology Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不必一味的讨好别人，每个人都有自己的活法。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yannischeng.com/JVM理解-编译、加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YannisCheng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://oy991qm3u.bkt.clouddn.com/%E6%A2%B5%E9%AB%98.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YannisCheng's Technology Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JVM理解-编译、加载</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-29T23:35:15+08:00">
                2018-06-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-02-10T18:53:54+08:00">
                2019-02-10
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,171 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    

    
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

    
    
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    YannisCheng
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yannischeng.com/JVM理解-编译、加载/" title="JVM理解-编译、加载">http://yannischeng.com/JVM理解-编译、加载/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    尊重个人劳动成果，转载请注明出处。 ─=≡Σ(((つ•̀ω•́)つ))
  </li>
</ul>

      </div>
    



    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>JVM理解 —— 源码的编译、执行</p>
<a id="more"></a>
<p>Android 的 <strong>Dalvik VM</strong> 是Android平台的核心组件平台之一，其并不是一个 <strong>Java虚拟机</strong>：</p>
<ul>
<li><strong>没有遵循Java虚拟机规范</strong>；</li>
<li><strong>不能直接执行Java的Class文件</strong>；</li>
<li>使用的是 <strong>寄存器架构</strong> 而不是JVM中常见的 <strong>栈架构</strong>；</li>
</ul>
<p>Android与Java联系：</p>
<ul>
<li>执行的 <strong>dex（Dalvik Executable）文件</strong> 是通过 <strong>Class文件</strong> 转化而来；</li>
<li>使用Java语法编写应用程序，可直接使用大部分Java API。</li>
</ul>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88.jpg" alt></p>
<p><strong>JDK 与 JRE</strong></p>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2008.46.46.png" alt></p>
<hr>
<p><strong>Java源码编译实质</strong></p>
<p><code>.java文件</code> -&gt; <code>.class文件</code>，使用 <code>Javac</code> 编译器。</p>
<h1 id="Java源码编译过程"><a href="#Java源码编译过程" class="headerlink" title="Java源码编译过程"></a>Java源码编译过程</h1><p><strong>3个步骤</strong></p>
<ul>
<li><strong>解析与填充符号表</strong></li>
<li><strong>注解处理</strong></li>
<li><strong>分析与字节码生成</strong></li>
</ul>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2009.07.11.png" alt></p>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/Java%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B-2.png" alt></p>
<p><strong>编译过程的方法(这张图太经典了，高频出现)</strong></p>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2008.51.40111.png" alt></p>
<h2 id="1-解析与填充符号表"><a href="#1-解析与填充符号表" class="headerlink" title="1. 解析与填充符号表"></a>1. 解析与填充符号表</h2><h3 id="1-1-解析（parseFiles-）"><a href="#1-1-解析（parseFiles-）" class="headerlink" title="1.1 解析（parseFiles()）"></a>1.1 解析（parseFiles()）</h3><ul>
<li><p><strong>词法</strong>：</p>
<ul>
<li>将 <code>源代码</code> 的 <code>字节流</code> 转换为 <code>标记（Token）集合</code>。</li>
<li><code>单个字符</code> 是程序编写过程中的最小元素，而 <code>标记</code> 则是编译过程中的最小元素。</li>
<li>使用 <code>com.sun.tools.javac.parser.Scanner</code> 类实现。</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<ul>
<li>是根据 <code>标记序列</code> 构造<code>抽象语法树</code> 的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式。</li>
<li>使用  <code>com.sun.tools.javac.parser.Parser</code> 类实现。</li>
</ul>
<p><strong>注意：生成抽象语法树后，后续的操作均是基于 <code>抽象语法树</code> 的操作。</strong></p>
</li>
</ul>
<h3 id="1-2-填充符号表（enterTrees-）"><a href="#1-2-填充符号表（enterTrees-）" class="headerlink" title="1.2 填充符号表（enterTrees()）"></a>1.2 填充符号表（enterTrees()）</h3><ul>
<li><strong><code>符号表</code></strong> 是由一组 <code>符号地址</code>+<code>符号信息</code> 构成的表格。</li>
<li><strong><code>符号表</code></strong> 中所登记的信息在 <strong><code>编译</code></strong> 的不同阶段都要使用到。</li>
<li>使用  <code>com.sun.tools.javac.comp.Enter</code> 类实现。</li>
<li><strong><code>默认实例构造器</code></strong> 在此过程中被添加。</li>
</ul>
<h2 id="2-注解处理（processAnnotations-）"><a href="#2-注解处理（processAnnotations-）" class="headerlink" title="2. 注解处理（processAnnotations()）"></a>2. 注解处理（processAnnotations()）</h2><ul>
<li>JDK 1.5 后，新增功能。</li>
<li>作用时间：运行期</li>
<li>作用：类似一组编译器插件，通过插件可以：读取、修改、添加 <strong><code>抽象语法树</code></strong> 中的任意元素。</li>
<li>只要修改了 <strong><code>抽象语法树</code></strong> 后，编译器就要从 <strong><code>解析与填充符号表</code></strong> 重新开始。</li>
</ul>
<h2 id="3-语义分析和生成class文件（Analyse-and-Generate）"><a href="#3-语义分析和生成class文件（Analyse-and-Generate）" class="headerlink" title="3. 语义分析和生成class文件（Analyse and Generate）"></a>3. 语义分析和生成class文件（Analyse and Generate）</h2><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p> 因为抽象语法树 <strong>仅能保证</strong> 源程序的 <strong>结构正确</strong> ，<strong>不能保证</strong> 源程序的语句 <strong>符合逻辑</strong>。</p>
<h4 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h4><ul>
<li>变量相关检查</li>
<li>常量折叠</li>
</ul>
<h4 id="数据、控制流分析"><a href="#数据、控制流分析" class="headerlink" title="数据、控制流分析"></a>数据、控制流分析</h4><ul>
<li>对程序的上下文进行进一步验证</li>
</ul>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><ul>
<li>语法糖：也叫糖衣语法。指在计算机语言中添加某种语法，对语言功能本身没有影响，为的是方便程序员使用</li>
<li>意义：增加程序可读性，降低程序的出错可能性。</li>
<li>解语法糖：虚拟机在执行时不支持处理语法糖语句，所以需要在编译阶段将其还原回最基础的语法结构。</li>
</ul>
<h3 id="生成字节码文件"><a href="#生成字节码文件" class="headerlink" title="生成字节码文件"></a>生成字节码文件</h3><p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/2018-08-07%2011.17.50.png" alt></p>
<hr>
<h1 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h1><h2 id="类型1：泛型与类型擦除"><a href="#类型1：泛型与类型擦除" class="headerlink" title="类型1：泛型与类型擦除"></a>类型1：泛型与类型擦除</h2><p>泛型（JDK 1.5 新增）其本质是 <strong><code>参数化类型</code></strong>的应用，操作的数据被指定为一个参数。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><p>Java中的泛型，<strong>只在源码中存在</strong>，在编译后的 <strong>字节码文件中</strong> ，已经替换为原来的原生类型，并且在相应的位置插入强制转型代码。</p>
<p>例如：对于运行期的 <code>ArrayList&lt;int&gt;</code> 与 <code>ArrayList&lt;String&gt;</code> 是同一个类 <code>List&lt;E&gt;</code></p>
</li>
<li><p>Java中的泛型实现方法为 <strong>类型擦除</strong>。</p>
</li>
<li>当泛型作为 <strong>重载方法</strong> 的参数时，是无法被编译通过的，若是在方法中使用不同的返回值，则编译通过。</li>
</ul>
<h2 id="类型2：自动装箱、拆箱、遍历循环"><a href="#类型2：自动装箱、拆箱、遍历循环" class="headerlink" title="类型2：自动装箱、拆箱、遍历循环"></a>类型2：自动装箱、拆箱、遍历循环</h2><p>List<iinteger></iinteger></p>
<h2 id="类型3：条件编译"><a href="#类型3：条件编译" class="headerlink" title="类型3：条件编译"></a>类型3：条件编译</h2><p>在Java中通过使用条件为 <code>常量</code> if语句，即可实现条件编译。<br>条件为 <code>常量</code> 的if语句不同于其他Java代码，他在编译阶段就会被 <strong><code>运行</code></strong>。仅运行条件成立下的语句，而条件不成立的代码块将会被消除，这个过程是在 <strong><code>分析与生成class文件</code></strong> 阶段完成的。</p>
<hr>
<h1 id="class文件"><a href="#class文件" class="headerlink" title="class文件"></a>class文件</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul>
<li><p>《Java虚拟机规范》：在未来，我们会对Java虚拟机做适当的扩展，以便更好的支持其他语言运行在JVM上（JDK1.7-1.8通过）。</p>
</li>
<li><p><strong><code>字节码（*.class文件）</code></strong> 是构成 <strong><code>平台无关性</code></strong> + <strong><code>语言无关性</code></strong> 的基石。</p>
</li>
<li><p>正因为 <strong><code>字节码</code></strong> 是现实 <strong><code>语言无关性</code></strong> 的基石，所以 <strong><code>字节码</code></strong> 命令提供的语义描述能力、范围要大于Java语言本身。</p>
</li>
</ul>
<h2 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h2><ul>
<li>class文件是一组以 <strong>8位字节为基础单位</strong> 的 <strong>二进制流</strong>，各个数据项目严格按照 <strong>顺序紧凑</strong> 的排列在 class文件 之中，中间没有添加任何 <strong>分隔符</strong>。</li>
<li>若遇到占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。</li>
<li>class文件一般采用类似于 C 语言结构体系的 <strong>伪结构</strong> 来存储数据，伪结构只有2种数据类型：<ul>
<li><strong>无符号数：</strong> 其属于基本的数据类型，可以用来描述数字、索引引用、数量值或其他。</li>
<li><strong>表：</strong> 是由多个 <code>无符号数</code> 或者 <code>其他表</code> 作为数据项构成 <strong><code>复合的数据</code></strong>。所有表都以习惯性的 <code>_info</code> 结尾。<em><code>表</code><strong> 用于描述 </strong>有层次关系<strong> 的 </strong>复合结构*</em> 的数据。</li>
<li>无论是 <strong>无符号数</strong> 还是 <strong>表</strong>，当需要描述同一类型但数量不定的多个数据时，经常使用一个前置的 <strong>容量计数器</strong> + 若干个连续的数据项的形式，这样的形式称为 <strong>某一类型的集合</strong>。</li>
</ul>
</li>
</ul>
<h3 id="魔数-确定class文件版本"><a href="#魔数-确定class文件版本" class="headerlink" title="魔数- 确定class文件版本"></a>魔数- 确定class文件版本</h3><p><code>magic</code> 的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件。</p>
<p>紧接着就是 <code>minor_version</code>(此版本号)、 <code>major_version</code>（主版本号）</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul>
<li><strong>常量池</strong> 可以理解为 class文件的资源仓库。</li>
<li>是与其他项目 <strong>关联最多</strong> 的数据类型，也是class文件中占用空间最大的数据项目之一。同时是class文件中第一个出现<code>表类型</code>的数据项目。</li>
<li>常量池每一个常量都是一个表</li>
<li>存放2大类常量：<ul>
<li><strong>字面量</strong></li>
<li><strong>符号引用</strong></li>
</ul>
</li>
</ul>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2015.15.17.png" alt></p>
<h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p> 接近于Java语言中的 <strong><code>常量</code></strong> 概念。</p>
<h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4><p>属于编译原理方面的概念，包括以下3类：</p>
<ul>
<li><strong>类和接口的全限定名</strong>：路径</li>
<li><strong>字段的名称和描述符</strong>：字段<ul>
<li>描述符用来描述：字段的 <strong>数据类型、修饰符</strong></li>
</ul>
</li>
<li><p><strong>方法的名称和描述符</strong>：</p>
<ul>
<li>描述符是用来描述：方法的 <strong>参数列表（数量、类型、顺序）和返回值</strong></li>
</ul>
<p><strong>注意：要区分 字节码中的描述规则 与 Java代码中的声明规则不同。</strong></p>
</li>
</ul>
<h3 id="访问标志-确定类定义信息"><a href="#访问标志-确定类定义信息" class="headerlink" title="访问标志 - 确定类定义信息"></a>访问标志 - 确定类定义信息</h3><p><strong>访问标志（access_flags）</strong>，作用：识别一些类或者接口层次的 <strong>访问信息</strong>。</p>
<p>通俗的说就是和 <strong>类定义相关</strong> 的描述，例如：是类还是接口、是否为<code>public</code>、是否为 <code>abstract</code>等。</p>
<h3 id="类索引、父类索引与接口索引集合-确定类继承关系"><a href="#类索引、父类索引与接口索引集合-确定类继承关系" class="headerlink" title="类索引、父类索引与接口索引集合 - 确定类继承关系"></a>类索引、父类索引与接口索引集合 - 确定类继承关系</h3><ul>
<li>类索引、父类索引是一个u2类型的数据，而接口索引集合是一组 u2类型的数据的集合（Java不支持多继承，但是支持多实现）。</li>
<li>class文件中由这3项数据来确定这个类的继承关系</li>
</ul>
<h3 id="字段表集合-确定变量"><a href="#字段表集合-确定变量" class="headerlink" title="字段表集合 - 确定变量"></a>字段表集合 - 确定变量</h3><ul>
<li>用于描述接口或者类中声明的变量。</li>
<li>包含 <strong>类级变量</strong> 以及 <strong>实例级变量</strong>。</li>
<li>不包含在 <strong>方法内部声明的局部变量</strong></li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul>
<li>方法中的 Java代码 在经过编译之后，存放在方法属性表集合中一个名为 <strong><code>Code</code></strong> 的属性中。</li>
<li>在 Java语言中，要重载一个方法，除了要与原方法具有相同的名称之外，还要求必须拥有一个与原方法不同的 <strong><code>特征签名</code></strong>。</li>
<li><strong><code>特征签名</code></strong>：就是一个方法中 <strong>各个参数</strong> 在 <strong>常量池</strong> 中的 <strong>字段符号引用</strong> 的 <strong>集合</strong>，因为 <strong><code>返回值</code></strong> 不会包括在 <strong><code>特征签名</code></strong> 中，因此Java语言中无法根据返回对方法进行重载。</li>
<li><strong>区别：</strong>因为 class文件中特征签名范围更广，只要描述符不一致，即可以重载。</li>
</ul>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>Java虚拟机的解释器使用以下最为基本的伪模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	自动计算 PC寄存器值 +1；</span><br><span class="line">	根据 PC寄存器指示的位置，从字节码流中取出操作码；</span><br><span class="line">	if(字节码存在操作数) 从字节码中取出操作数；</span><br><span class="line">	执行操作码定义的操作；</span><br><span class="line">&#125;while(字节码流 &gt; 0)</span><br></pre></td></tr></table></figure>
<h1 id="JVM执行类加载过程"><a href="#JVM执行类加载过程" class="headerlink" title="JVM执行类加载过程"></a>JVM执行类加载过程</h1><p>一个类的加载过程概括性的可分为 <strong>3个阶段</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载、连接、初始化</span><br></pre></td></tr></table></figure>
<p>如果具体细分则为 <strong>7个过程</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载、验证、准备、解析、初始化、使用、卸载</span><br></pre></td></tr></table></figure>
<p><strong>类的生命周期图</strong>，</p>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2022.17.23.png" alt></p>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-07%2022.17.59.png" alt></p>
<p>其中，有 <strong>5个阶段</strong> 是 <strong>必须要按顺序</strong> 执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载 、验证、准备、初始化、卸载</span><br></pre></td></tr></table></figure>
<h2 id="加载-开发人员可介入（类加载器）"><a href="#加载-开发人员可介入（类加载器）" class="headerlink" title="加载 - 开发人员可介入（类加载器）"></a>加载 - 开发人员可介入（类加载器）</h2><h3 id="虚拟机的非数组类加载操作"><a href="#虚拟机的非数组类加载操作" class="headerlink" title="虚拟机的非数组类加载操作"></a>虚拟机的非数组类加载操作</h3><ul>
<li>通过一个类的 <strong>全限定名</strong> 来获取定义此类的<strong> 二进制字节流</strong>。</li>
<li>将这个字节流所代表的 <strong>静态存储结构</strong> 转换为 <strong>方法区</strong> 的<strong>运行时数据结构</strong>。</li>
<li>在内存区生成一个 <strong>代表这个类的对象</strong>，作为方法区这个类的各种数据的 <strong>访问入口</strong>。</li>
</ul>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%2000.12.46.png" alt></p>
<h3 id="二进制字节流的获取途径"><a href="#二进制字节流的获取途径" class="headerlink" title="二进制字节流的获取途径"></a>二进制字节流的获取途径</h3><ul>
<li><ol>
<li>zip包中，例如 jar。</li>
</ol>
</li>
<li><ol>
<li>从网络中获取</li>
</ol>
</li>
<li><ol>
<li>运行时动态生成，反射。</li>
</ol>
</li>
<li><ol>
<li>有其他文件生成，例如 jsp</li>
</ol>
</li>
<li><ol>
<li>从数据库中读取。</li>
</ol>
</li>
</ul>
<h3 id="虚拟机对于数组的创建"><a href="#虚拟机对于数组的创建" class="headerlink" title="虚拟机对于数组的创建"></a>虚拟机对于数组的创建</h3><ul>
<li><ol>
<li>如果数组的组件类型是 <strong><code>引用类型</code></strong> （例如Personp[]），那么递归采用定义的加载过程去加载，数组将在 <strong>加载该组件的类加载器</strong> 的 <strong>类名空间上被标示</strong>。</li>
</ol>
</li>
<li><ol>
<li>如果数组的组件类型不是引用类型（例如int[]）, Java虚拟机将会把数组标记为与 <strong><code>引导类加载器</code></strong> 关联。</li>
</ol>
</li>
<li><ol>
<li>数组可见性与其组件可见性一致，且数组组件不是引用类型，那么数据可见性默认为 <code>public</code>。</li>
</ol>
</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是 <strong><code>连接</code></strong> 的第一个阶段。<br><strong>验证目的</strong>：是为了确保 class文件 的字节流中 <strong>符合 class文件格式约束</strong> 且 <strong>包含的信息是符合当前虚拟机的要求</strong> 的，并且不会危害到虚拟机的自身安全。</p>
<h3 id="验证过程分为4个阶段"><a href="#验证过程分为4个阶段" class="headerlink" title="验证过程分为4个阶段:"></a>验证过程分为4个阶段:</h3><ul>
<li><p><strong>文件格式验证</strong></p>
<p>该阶段的主要目的是：保证输入的字节流 <strong>能正确的解析并存储于方法区之中</strong>。</p>
<p>此阶段的验证是基于 <strong><code>二进制字节流</code></strong> 的，只有通过此阶段的验证，字节流才会进入内存的方法区进行存储。</p>
<p>因此，后面3个阶段的验证都是基于 <strong><code>方法区的存储结构</code></strong> 进行验证的。</p>
</li>
<li><p><strong>元数据验证</strong></p>
<p>对字节码描述的信息进行 <strong>语义分析、校验</strong>，保证其描述的信息 <strong>符合Java语言规范的要求</strong>。</p>
<p>此阶段对 <strong>类的元数据信息</strong> 进行校验。</p>
</li>
<li><p><strong>字节码验证</strong></p>
<p>此过程是验证过程最为复杂的阶段，在第二步对类的元数据信息校验结束后，通过 <strong>数据流</strong> 和 <strong>控制流</strong>分析，确定程序 <strong>语义是合法的、是符合逻辑的</strong>。</p>
<p>此阶段对 <strong>类的方法体</strong> 进行校验。</p>
</li>
<li><p><strong>符号引用验证</strong></p>
<p>此阶段是发生在虚拟机将 <strong>符号引用</strong> 转换为 <strong>直接引用</strong> 的时候，这个转换动作是发生在 <strong>解析</strong> 阶段中。</p>
<p><strong>符号引用校验</strong> 是对 <strong>类自身以外</strong>（常量池中的各种符号引用）的信息 <strong>进行匹配校验</strong> 的过程。 </p>
<p>符号引用验证的目的是 <strong>确保解析动作的正常执行</strong></p>
</li>
</ul>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%2000.10.48.png" alt></p>
<h2 id="准备-类变量赋初值"><a href="#准备-类变量赋初值" class="headerlink" title="准备 - 类变量赋初值"></a>准备 - 类变量赋初值</h2><p>此阶段是正式为 <strong>类变量</strong> <strong>分配内存</strong> 并 <strong>设置其初始值（零值）</strong> 的过程。这些变量所使用的内存是在 <strong>方法区的内存</strong> 中分配的。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>是虚拟机将常量池中的 <strong>符号引用</strong> 抓换为 <strong>直接引用</strong> 的过程。</p>
<h3 id="符号引用-与-直接引用区别"><a href="#符号引用-与-直接引用区别" class="headerlink" title="符号引用 与 直接引用区别"></a>符号引用 与 直接引用区别</h3><p><strong>符号引用</strong></p>
<ul>
<li>通过一组符号来描述所引用的目标。</li>
<li>符号引用于 虚拟机实现的内存布局无关</li>
</ul>
<p><strong>直接引用</strong></p>
<ul>
<li>直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。</li>
<li>直接引用与虚拟机实现的内存布局有关。</li>
</ul>
<h3 id="解析动作"><a href="#解析动作" class="headerlink" title="解析动作"></a>解析动作</h3><ul>
<li>类或接口</li>
<li>字段</li>
<li>类方法</li>
<li>接口方法</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li><strong>初始化</strong> 是类加载过程的最后一步，在此阶段才开始执行类中定义的 Java程序代码（字节码）。</li>
<li>此阶段是执行 <strong>类构造器<code>&lt;clinit&gt;()</code></strong> 方法的过程。</li>
</ul>
<h3 id="lt-clinit-gt-解释"><a href="#lt-clinit-gt-解释" class="headerlink" title="&lt;clinit&gt;()解释"></a><code>&lt;clinit&gt;()</code>解释</h3><ul>
<li><strong>方法中的内容来源</strong> — <code>&lt;clinit&gt;()</code> 是由 <strong>编译器</strong> 自动收集类中的 <strong>所有类变量的赋值动作</strong> 和 <strong>静态语句块（static{}）中的语句</strong> <strong>合并</strong>产生的。</li>
<li><strong>父类子类顺序</strong> — <code>&lt;clinit&gt;()</code> 与类的构造函数（或者说是实例构造器<code>&lt;init&gt;()</code>）不同，它不需要显示调用父类构造器，虚拟机会保证在 <strong>子类的<code>&lt;clinit&gt;()</code></strong> 调用之前 <strong>父类<code>&lt;clinit&gt;()</code></strong> 已经执行完毕。</li>
<li><strong>赋值先后顺序</strong> — 由于父类与子类的 <code>&lt;clinit&gt;()</code> 执行顺序，父类中的静态语句块要优于子类变量的赋值。</li>
<li><strong>必要性</strong> — <code>&lt;clinit&gt;()</code> 对于类或接口而言是非必须的。</li>
<li><strong>（父）接口</strong>的<code>&lt;clinit&gt;()</code>— 接口中不能使用静态语句块，但是接口中仍然有变量初始化赋值操作。因此接口与类都具有 <code>&lt;clinit&gt;()</code> 操作。接口与类不同的是：子接口（实现类）的 <code>&lt;clinit&gt;()</code> 不需要实现 父接口 的 <code>&lt;clinit&gt;()</code> ，只有使用到 父接口中定义的变量时，才会执行。</li>
<li><strong>线程！</strong> — 虚拟机能够保证一个类的 <code>&lt;clinit&gt;()</code> 在 <strong>多线程环境中被正确的加锁、同步</strong>。如果多个线程同时去初始化一个类，那么只能有一个线程执行这个操作，其他线程都只能阻塞等待。</li>
</ul>
<h3 id="初始化阶段的触发条件"><a href="#初始化阶段的触发条件" class="headerlink" title="初始化阶段的触发条件"></a>初始化阶段的触发条件</h3><p>Java虚拟机对于什么时间执行第一个阶段：<strong><code>加载</code></strong>，没有明确要求，但是对于 <strong><code>初始化</code></strong> 阶段则是 <strong>有且只有5种</strong> 明确要求：</p>
<ul>
<li><p>1、遇到 </p>
<p><strong><code>new</code></strong>、<strong><code>getstatic</code></strong>、<code>**putstatic</code><strong>、</strong><code>invokestatic</code><strong><br>这4个字节指令时，要先进行初始化。这4个指令对应于Java语言中的场景就是：
</strong><code>new关键字实例化对象</code><strong>、</strong><code>读取一个静态字段</code><strong>、</strong><code>设置一个静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）</code><strong>、</strong><code>调用类的静态方法</code>**</p>
</li>
<li><p>2、进行 <strong>反射调用</strong> 的时候，如果没有进行初始化，则先要进行初始化。</p>
</li>
<li>3、当初始化一个类的时候，若其 <strong>父类</strong> 还未进行初始化，则先要对其父类进行初始化。</li>
<li>4、当虚拟机启动时，用户需要指定一个要 <strong>执行的主类</strong>（包含main()），虚拟机会先初始化这个类。</li>
<li>5、当使用JDK 1.7 的 <strong>动态语言支持</strong> 时，如果一个 <strong><code>MethodHandler</code></strong> 实例最后的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄时，这个方法对应的类要进行初始化。</li>
</ul>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%2000.07.44.png" alt></p>
<hr>
<h1 id="类加载器-—-程序员自己决定如何获取所需类"><a href="#类加载器-—-程序员自己决定如何获取所需类" class="headerlink" title="类加载器 — 程序员自己决定如何获取所需类"></a>类加载器 — 程序员自己决定如何获取所需类</h1><h2 id="类-与-类加载器"><a href="#类-与-类加载器" class="headerlink" title="类 与 类加载器"></a>类 与 类加载器</h2><p><strong>JVM中类的唯一性确立条件：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类本身 + 加载它的类加载器</span><br></pre></td></tr></table></figure>
<p>换一种表述方式即为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比较2个类是否“相等（equals()/isAssignableFrom()/isInstance()/instanceof关键字）”，只有在这2个类是由同一个类加载器加载的前提下才有意义。</span><br><span class="line"></span><br><span class="line">否则，若是同一个 class文件被同一个JVM加载，只要是加载这个类的 类加载器不同，那么这两个类必定不同。</span><br></pre></td></tr></table></figure>
<h2 id="加载器分类："><a href="#加载器分类：" class="headerlink" title="加载器分类："></a>加载器分类：</h2><h3 id="从-JVM角度-来看，只存在-2种-不同的加载器："><a href="#从-JVM角度-来看，只存在-2种-不同的加载器：" class="headerlink" title="从 JVM角度 来看，只存在 2种 不同的加载器："></a>从 <strong>JVM角度</strong> 来看，只存在 <strong>2种</strong> 不同的加载器：</h3><ul>
<li><strong>启动类加载器（Bootstrap CLassLoader）</strong>，由 <code>C++</code> 实现，是虚拟机本身的一部分。</li>
<li><p><strong>所有的其他类加载器</strong>，由 <code>Java</code> 实现，独立于虚拟机外部且全部继承自 <code>java.lang.ClassLoader</code>。</p>
<p>ClassLoader继承关系（图片来自网络）</p>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/713721-20160602152821617-738821208.png" alt></p>
</li>
</ul>
<h3 id="从-开发人员角度-来看，存在-3种-不同的加载器："><a href="#从-开发人员角度-来看，存在-3种-不同的加载器：" class="headerlink" title="从 开发人员角度 来看，存在 3种 不同的加载器："></a>从 <strong>开发人员角度</strong> 来看，存在 <strong>3种</strong> 不同的加载器：</h3><ul>
<li><p><strong>启动类加载器 （Bootstrap ClassLoader）</strong></p>
<p>此类使用 <code>C++</code> 实现，并非<code>CLassLoader</code>的子类，在代码中无法拿到这个对象，没有子类。</p>
<p>JVM启动时， <code>Bootstrap CLassLoader</code> 也会同时跟着启动，完成 <code>$JAVA_HOME/jre/lib/rt.jar</code> 中所有class文件的加载，如java.lang.<em>、 java.uti.</em>等。</p>
<p>负责加载完核心类库后，并构造 <strong><code>Extension ClassLoader</code></strong> 和<strong><code>App ClassLoader</code></strong> 类加载器。</p>
</li>
<li><p><strong>扩展类加载器 （Extension ClassLoader）</strong></p>
<p>开发人员可以直接使用此加载类</p>
<p>加载位于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的扩展jar。</p>
</li>
</ul>
<ul>
<li><p><strong>应用程序加载器（Application ClassLoader）</strong></p>
<p>开发人员可以直接使用此加载类</p>
<p>父类是 <code>Extension ClassLoader</code>，加载 用户类 <code>$CLASSPATH</code>下的<code>目录</code> 和 <code>jar</code>；</p>
<p>它负责加载 <strong>应用程序主函数类</strong>。</p>
<p>若应用程序中没有自定义类加载器，一般情况下这个就是默认的类加载器。</p>
</li>
<li><p><strong>自定义类加载器 （Custom ClassLoader）</strong></p>
<p>要实现自己的类加载器，不管是实现抽象类<code>ClassLoader</code>，还是继承其他的<code>子ClassLoader</code>类，<strong>它的父加载器都是<code>AppClassLoader</code></strong>，因为不管调用哪个父类加载器，<strong>创建的对象都必须最终调用<code>getSystemClassLoader()</code>作为父加载器</strong>，<code>getSystemClassLoader()</code>方法获取到的正是<code>AppClassLoader</code>。</p>
</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/08-08%2000.55.32.png" alt></p>
<p><strong>双亲委派模型</strong> 要求：除了顶层的 <strong>启动类加载器</strong> 外，其余的类加载器都应有自己的父类加载器。</p>
<p>这里类加载器的关系不是 <strong>父子</strong> 而是 <strong>组合</strong> 关系。</p>
<h3 id="双亲委派模型的工作过程为"><a href="#双亲委派模型的工作过程为" class="headerlink" title="双亲委派模型的工作过程为"></a>双亲委派模型的工作过程为</h3><p>：<br> 如果一个类加载器收到了类加载请求，他首先不会自己尝试加载这个类，而是把这个请求委派给自己的父类加载器去完成，每一层的类加载器都是如此。</p>
<p> 因此所有的加载请求最终都应该传递到顶层的 <strong>启动器类加载器</strong> 中。</p>
<p> 只有当父类加载器反馈自身无法完成这个加载请求时，子类加载器才能完成这个加载请求。</p>
<h3 id="双亲委派模型的作用"><a href="#双亲委派模型的作用" class="headerlink" title="双亲委派模型的作用"></a>双亲委派模型的作用</h3><p>对Java程序的稳定运作很重要。使用此模型来组织类加载器之间的关系，有一个显而易见的好处就是 <strong>Java类</strong> 随着 <strong>它的类加载器</strong> 一起具备了一种 <strong>带有优先级的层级关系</strong>。</p>
<p>例如 <code>java.lang.Object</code> 类，这个类无论是被那个类加载器加载，最终都是委派给模型最顶端的 <strong>启动类加载器</strong>，因此Object类在程序的各种类加载环境中 <strong>都是同一个类</strong>。</p>
<hr>
<h2 id="ClassLoader抽象类的几个关键方法"><a href="#ClassLoader抽象类的几个关键方法" class="headerlink" title="ClassLoader抽象类的几个关键方法"></a><code>ClassLoader</code>抽象类的几个关键方法</h2><ul>
<li><p><strong>loadClass：</strong> </p>
<p>此方法是负责加载<strong>指定名字的类</strong>。加载过程为：<br>先从已加载的类中寻找，如果没有再调用<code>parent</code>的<code>loadClass</code>中寻找，如果还是没有，那么从<code>findBootstrapClassOrNull</code>方法中寻找。如果以上都不行，那么执行<code>findClass</code>方法。</p>
<ul>
<li>如果要<strong>改变类的加载顺序</strong>，则可以<strong>覆盖此方法</strong>；</li>
<li>如果<strong>加载顺序相同</strong>，则可通过覆盖<code>findClass</code>方法来 <strong>做特殊处理</strong>。</li>
</ul>
<p>源代码为：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>findLoadedClass</strong></li>
</ul>
<p>此方法负责从当前 <code>ClassLoader</code> 实例对象的缓存中寻找已存在的类。</p>
<ul>
<li><p><strong>findClass</strong></p>
</li>
<li><p><strong>findSystemClass</strong></p>
</li>
<li><p><strong>defineClass</strong></p>
<p>此方法负责将<code>二进制字节码</code> 转换为 <code>class对象</code>，这个方法对自定义加载类非常重要。</p>
<ul>
<li>如果二进制的字节码格式<strong>不符合</strong>JVM Class 文件的格式，抛出<code>ClassFormatError</code>异常</li>
<li>如果生成的类名和二进制字节码中的<strong>不同</strong>，抛出<code>NoClassDefFoundError</code></li>
<li>如果加载的 <code>class</code> 是受保护的、采用不同签名的、或者类名是以 java开头的，抛出 <code>SecurityException</code></li>
<li>如果加载的 <code>class</code> 在此<code>ClassLoader</code>中<strong>已经加载</strong>，那么抛出<code>LinkageError</code></li>
</ul>
</li>
<li><p><strong>resolveClass</strong></p>
<p>此方法完成对<code>Class</code>的链接，如果已经链接过，那么直接返回。</p>
</li>
</ul>
<p>当调用<code>Class.forName</code>来获取一个对应名称的<code>class</code>对象时，<code>JVM</code> 会先从方法栈栈上寻找第一个<code>ClassLoader</code> ，通常也就是执行 <code>Class.forName</code> 所在的类的<code>ClassLoader</code>，来加载此名称的类。</p>
<p><code>JVM</code>为了保护加载、执行类的安全，他不允许<code>ClassLoader</code>直接卸载已加载了的类。只有JVM才能卸载，当<code>CLassLoader</code>对象没有引用时，此 <code>CLassLoader</code> 对象所加载的类才会被卸载。</p>
<hr>
<h2 id="2-编译执行"><a href="#2-编译执行" class="headerlink" title="2. 编译执行"></a>2. 编译执行</h2><p>解释执行效率低，为提升代码的执行性能，JDK提供了将<strong>字节码编译为机器码</strong>的支持。JDK 在执行过程中对<strong>执行效率高的代码</strong>进行编译，对<strong>执行不频繁的代码</strong>则继续使用解释的方式。因此，JDK 又称为：<strong><code>Hotspot VM</code></strong>，在编译上JDK提供了2种模式：</p>
<ul>
<li><p><strong>client compiler（-client）</strong>：轻量级。只做少量性能开销比高的优化，占用内存少，适合于桌面交互式应用。</p>
<p>在内存器分配策略上，采用<code>线性扫描寄存器分配算法</code>。其他的优化有<code>方法内联</code>、<code>去虚拟化‘、</code>冗余消除``</p>
</li>
<li><p><strong>server compiler（-server）</strong>：重量级。采用大量的传统编译优化技巧来进行优化，占用内存多，适合于服务器端使用。与client不同的是：</p>
<ul>
<li>寄存器分配策略：<code>传统的图着色寄存器分配算法</code>。</li>
<li>优化的范围：全局优化，而不仅仅是一个方法块的优化。</li>
</ul>
</li>
</ul>
<h2 id="3-反射执行"><a href="#3-反射执行" class="headerlink" title="3. 反射执行"></a>3. 反射执行</h2><p>基于反射可动态调用某对象实例中对应的方法、访问查看对象的属性等，无需在编写代码时就确定要创建的对象。</p>
<p>反射和直接创建对象实例，调用方法最大的不同在于创建的过程、方法的调用是动态的。<br>如何实现动态调用：<strong>动态生成字节码、并加载到JVM中执行</strong>。</p>
<p><strong>注意：</strong> 使用<code>getMethod()</code> 相对比较耗性能，一方面是权限的校验，另一方面是所有方法的扫描机Method对象的复制。因此，在使用<code>反射</code>调用多的系统中，应缓存<code>getMethod()</code>返回的Method对象。</p>
<h1 id="Java对象"><a href="#Java对象" class="headerlink" title="Java对象"></a>Java对象</h1><h2 id="4种引用"><a href="#4种引用" class="headerlink" title="4种引用"></a>4种引用</h2><p><strong>强引用</strong>：</p>
<p> 普遍存在的，类似”Object obj=new Object()”；<br> 只要强引用还在，GC就永远不会回收被引用的对象，即时抛出OOM；<br> 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p>
<p><strong>软引用（Soft Reference）</strong></p>
<p> 用来描述有用但是非必须的对象；<br> 如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；直到内存空间不够时（抛出OutOfMemoryError之前），才会被垃圾回收；<br> 由 <code>SoftReference类</code> 实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyObject aRef = new  MyObject();  </span><br><span class="line">SoftReference aSoftRef=new SoftReference(aRef);</span><br></pre></td></tr></table></figure>
<p>重新获得对该实例的强引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObject anotherRef=(MyObject)aSoftRef.get();</span><br></pre></td></tr></table></figure>
<p>而回收之后，调用get()方法就只能得到null了。</p>
<p> 软引用可用来实现内存敏感的高速缓存，使用软引用可以可以增强程序的健壮性、能防止内存泄漏。</p>
<p><strong>弱引用（Weak Reference）</strong></p>
<p>用来描述非必须的对象；<br>只能生存到下一次垃圾回收之前，无论内存是否足够；<br>由 <code>WeakReference类</code> 实现；</p>
<p><strong>虚引用（Phantom Reference）</strong></p>
<p> 也称为幽灵引用或幻影引用；<br> 完全不会对其生存时间构成影响；</p>
<h2 id="“-”运算符-和-“equals-”-方法"><a href="#“-”运算符-和-“equals-”-方法" class="headerlink" title="“==”运算符 和 “equals()” 方法"></a>“==”运算符 和 “equals()” 方法</h2><p>实质上这两种方法本质上还是有区别的：</p>
<ul>
<li><p><strong>equals()</strong> 方法是从String类中的方法，它用于比较两个 <strong>对象引用所指的内容</strong> 是否相等；</p>
</li>
<li><p><strong>==</strong> 运算符比较的是两个 <strong>对象引用的地址</strong> 是否相等。</p>
</li>
</ul>
<p><img src="https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/20170603184309287.png" alt></p>
<hr>
<blockquote>
<p>参考：<a href="http://icyfenix.iteye.com/" target="_blank" rel="noopener">http://icyfenix.iteye.com/</a></p>
</blockquote>

      
    </div>
    
    
    

    

    


    <footer class="post-footer">
      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Android线程-AsyncTask/" rel="next" title="Android-AsyncTask">
                <i class="fa fa-chevron-left"></i> Android-AsyncTask
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/JVM理解-内存管理/" rel="prev" title="JVM理解-内存管理">
                JVM理解-内存管理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://oy991qm3u.bkt.clouddn.com/%E6%A2%B5%E9%AB%98.gif" alt="YannisCheng">
            
              <p class="site-author-name" itemprop="name">YannisCheng</p>
              <p class="site-description motion-element" itemprop="description">不必一味的讨好别人，每个人都有自己的活法。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">181</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/YannisCheng" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:cwj1714@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java源码编译过程"><span class="nav-number">1.</span> <span class="nav-text">Java源码编译过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-解析与填充符号表"><span class="nav-number">1.1.</span> <span class="nav-text">1. 解析与填充符号表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-解析（parseFiles-）"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 解析（parseFiles()）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-填充符号表（enterTrees-）"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 填充符号表（enterTrees()）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-注解处理（processAnnotations-）"><span class="nav-number">1.2.</span> <span class="nav-text">2. 注解处理（processAnnotations()）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-语义分析和生成class文件（Analyse-and-Generate）"><span class="nav-number">1.3.</span> <span class="nav-text">3. 语义分析和生成class文件（Analyse and Generate）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语义分析"><span class="nav-number">1.3.1.</span> <span class="nav-text">语义分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标注检查"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">标注检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据、控制流分析"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">数据、控制流分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解语法糖"><span class="nav-number">1.3.2.</span> <span class="nav-text">解语法糖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成字节码文件"><span class="nav-number">1.3.3.</span> <span class="nav-text">生成字节码文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java语法糖"><span class="nav-number">2.</span> <span class="nav-text">Java语法糖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类型1：泛型与类型擦除"><span class="nav-number">2.1.</span> <span class="nav-text">类型1：泛型与类型擦除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型2：自动装箱、拆箱、遍历循环"><span class="nav-number">2.2.</span> <span class="nav-text">类型2：自动装箱、拆箱、遍历循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型3：条件编译"><span class="nav-number">2.3.</span> <span class="nav-text">类型3：条件编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#class文件"><span class="nav-number">3.</span> <span class="nav-text">class文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#描述"><span class="nav-number">3.1.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class文件结构"><span class="nav-number">3.2.</span> <span class="nav-text">class文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#魔数-确定class文件版本"><span class="nav-number">3.2.1.</span> <span class="nav-text">魔数- 确定class文件版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量池"><span class="nav-number">3.2.2.</span> <span class="nav-text">常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字面量"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#符号引用"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">符号引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问标志-确定类定义信息"><span class="nav-number">3.2.3.</span> <span class="nav-text">访问标志 - 确定类定义信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类索引、父类索引与接口索引集合-确定类继承关系"><span class="nav-number">3.2.4.</span> <span class="nav-text">类索引、父类索引与接口索引集合 - 确定类继承关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段表集合-确定变量"><span class="nav-number">3.2.5.</span> <span class="nav-text">字段表集合 - 确定变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法表集合"><span class="nav-number">3.2.6.</span> <span class="nav-text">方法表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性表集合"><span class="nav-number">3.2.7.</span> <span class="nav-text">属性表集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节码指令"><span class="nav-number">3.3.</span> <span class="nav-text">字节码指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM执行类加载过程"><span class="nav-number">4.</span> <span class="nav-text">JVM执行类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加载-开发人员可介入（类加载器）"><span class="nav-number">4.1.</span> <span class="nav-text">加载 - 开发人员可介入（类加载器）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机的非数组类加载操作"><span class="nav-number">4.1.1.</span> <span class="nav-text">虚拟机的非数组类加载操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制字节流的获取途径"><span class="nav-number">4.1.2.</span> <span class="nav-text">二进制字节流的获取途径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机对于数组的创建"><span class="nav-number">4.1.3.</span> <span class="nav-text">虚拟机对于数组的创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#验证"><span class="nav-number">4.2.</span> <span class="nav-text">验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#验证过程分为4个阶段"><span class="nav-number">4.2.1.</span> <span class="nav-text">验证过程分为4个阶段:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准备-类变量赋初值"><span class="nav-number">4.3.</span> <span class="nav-text">准备 - 类变量赋初值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解析"><span class="nav-number">4.4.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#符号引用-与-直接引用区别"><span class="nav-number">4.4.1.</span> <span class="nav-text">符号引用 与 直接引用区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析动作"><span class="nav-number">4.4.2.</span> <span class="nav-text">解析动作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">4.5.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-clinit-gt-解释"><span class="nav-number">4.5.1.</span> <span class="nav-text">&lt;clinit&gt;()解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化阶段的触发条件"><span class="nav-number">4.5.2.</span> <span class="nav-text">初始化阶段的触发条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类加载器-—-程序员自己决定如何获取所需类"><span class="nav-number">5.</span> <span class="nav-text">类加载器 — 程序员自己决定如何获取所需类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类-与-类加载器"><span class="nav-number">5.1.</span> <span class="nav-text">类 与 类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载器分类："><span class="nav-number">5.2.</span> <span class="nav-text">加载器分类：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从-JVM角度-来看，只存在-2种-不同的加载器："><span class="nav-number">5.2.1.</span> <span class="nav-text">从 JVM角度 来看，只存在 2种 不同的加载器：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-开发人员角度-来看，存在-3种-不同的加载器："><span class="nav-number">5.2.2.</span> <span class="nav-text">从 开发人员角度 来看，存在 3种 不同的加载器：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">5.3.</span> <span class="nav-text">双亲委派模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型的工作过程为"><span class="nav-number">5.3.1.</span> <span class="nav-text">双亲委派模型的工作过程为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型的作用"><span class="nav-number">5.3.2.</span> <span class="nav-text">双亲委派模型的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ClassLoader抽象类的几个关键方法"><span class="nav-number">5.4.</span> <span class="nav-text">ClassLoader抽象类的几个关键方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-编译执行"><span class="nav-number">5.5.</span> <span class="nav-text">2. 编译执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-反射执行"><span class="nav-number">5.6.</span> <span class="nav-text">3. 反射执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java对象"><span class="nav-number">6.</span> <span class="nav-text">Java对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4种引用"><span class="nav-number">6.1.</span> <span class="nav-text">4种引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“-”运算符-和-“equals-”-方法"><span class="nav-number">6.2.</span> <span class="nav-text">“==”运算符 和 “equals()” 方法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YannisCheng</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">420.9k</span>
  
</div>













        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.3"></script>


  


<script type="text/javascript" color="18,146,19" opacity="0.7" zindex="-1" count="0" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>

</body>
</html>
