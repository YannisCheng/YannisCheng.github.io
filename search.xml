<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自定义View-8 TypedArray]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View-8%20TypedArray%2F</url>
    <content type="text"><![CDATA[自定义View中的 attrs.xml 文件设置 1. 文件位置： 2. 文件内容（仅供参考）：1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="MyViewGroup"&gt; &lt;attr name="textOneTitle" format="string"/&gt; &lt;attr name="textOneSize" format="integer"/&gt; &lt;attr name="imageSrc" format="reference"/&gt; &lt;attr name="textTwoTitle" format="string"/&gt; &lt;attr name="textTwoSize" format="integer"/&gt; &lt;attr name="textOneVisible" format="boolean"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 3. 属性文件中参数属性的分类： 4. attrs.xml 文件中 format 取值类型1. reference：参考某一资源ID。 属性的定义 1&lt;attr name="imageSrc" format="reference"/&gt; 属性的使用 1cwj:imageSrc="@drawable/maps" 在java中获取数值（2种方式） 12345Drawable imgSrc = array.getDrawable(R.styleable.MyViewGroup_imageSrc);mImageView.setBackground(imgSrc);int imgSrc = array.getResourceId(R.styleable.MyViewGroup_imageSrc,R.drawable.ic_launcher_background);mImageView.setBackgroundResource(imgSrc); 2. color：颜色值。 属性的定义 1&lt;attr name="textOneColor" format="color"/&gt; 属性的使用 1cwj:textOneColor="#ff0000" 在java中获取 123int textOneColor = array.getColor(R.styleable.MyViewGroup_textOneColor, Color.BLACK);mTextView2.setTextColor(textOneColor); 3. boolean：布尔值。 属性的定义 1&lt;attr name="textOneVisible" format="boolean"/&gt; 属性的使用 1cwj:textOneVisible="false" 在java中获取 1234567boolean oneIsShow = array.getBoolean(R.styleable.MyViewGroup_textOneVisible,true);if (oneIsShow) &#123; mTextView1.setVisibility(VISIBLE);&#125; else &#123; mTextView1.setVisibility(INVISIBLE);&#125; 4. dimension：尺寸值。 属性的定义 1&lt;attr name="textOneSize" format="dimension"/&gt; 属性的使用 1cwj:textTwoSize="@dimen/textOneSize2" 在java中获取 123float textOneSize = array.getDimension(R.styleable.MyViewGroup_textOneSize,10);mTextView1.setTextSize(textOneSize); 5. float：浮点值。 属性的定义 1&lt;attr name = "fromAlpha" format = "float" /&gt; 属性的使用 1android:fromAlpha = "1.0" 6. integer：整型值。 属性的定义 1&lt;attr name = "frameDuration" format="integer" /&gt; 属性的使用 1android:frameDuration = "100" 7. string：字符串。 属性的定义 1&lt;attr name="textOneTitle" format="string"/&gt; 属性的使用 1cwj:textOneTitle="大标题" 在java中使用 123String textOneTitle = array.getString(R.styleable.MyViewGroup_textOneTitle);mTextView1.setText(textOneTitle); 8. fraction：百分数。 属性的定义 1&lt;attr name = "pivotY" format = "fraction" /&gt; 属性的使用 1android:pivotY = "300%" 9. enum：枚举值。 属性的定义 1234&lt;attr name="textTwoGravity"&gt; &lt;enum name="top" value="1"/&gt; &lt;enum name="center" value="2"/&gt;&lt;/attr&gt; 属性的使用 1cwj:textTwoGravity="top" 在java中获取 1234567int gracityIndex = array.getInt(R.styleable.MyViewGroup_textTwoGravity, Gravity.CENTER);if (gracityIndex == 1) &#123; mTextView2.setGravity(Gravity.TOP);&#125; else if (gracityIndex == 2) &#123; mTextView2.setGravity(Gravity.CENTER);&#125; 10. flag：位或运算。 属性的定义 123456789101112&lt;attr name="windowSoftInputMode"&gt; &lt;flag name = "stateUnspecified" value = "0" /&gt; &lt;flag name = "stateUnchanged" value = "1" /&gt; &lt;flag name = "stateHidden" value = "2" /&gt; &lt;flag name = "stateAlwaysHidden" value = "3" /&gt; &lt;flag name = "stateVisible" value = "4" /&gt; &lt;flag name = "stateAlwaysVisible" value = "5" /&gt; &lt;flag name = "adjustUnspecified" value = "0x00" /&gt; &lt;flag name = "adjustResize" value = "0x10" /&gt; &lt;flag name = "adjustPan" value = "0x20" /&gt; &lt;flag name = "adjustNothing" value = "0x30" /&gt; &lt;/attr&gt; 属性的使用 1android:windowSoftInputMode = "stateUnspecified | stateUnchanged | stateHidden" 其他 - 组合属性设置： 属性的定义 1&lt;attr name = "background" format = "reference|color" /&gt; 属性的使用 1android:background = "@drawable/图片ID|#00FF00"]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View-7 ViewGroup]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View-7%20ViewGroup%2F</url>
    <content type="text"><![CDATA[这次描述的是自定义ViewGroup，这其中既包括完全自定义ViewGroup和组合ViewGroup。 自定义组合ViewGroup1. 创建一个自定义ViewGroup的xml文件1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.zhy.autolayout.AutoRelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/item_single_view" android:layout_width="match_parent" android:layout_height="210px" android:background="@color/login_txt" android:gravity="center"&gt; &lt;ImageView android:id="@+id/item_single_iv" android:layout_width="50px" android:layout_height="50px" android:layout_centerHorizontal="true" android:layout_marginTop="6px" android:src="@drawable/ic_launcher"/&gt; &lt;TextView android:id="@+id/item_single_tv_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@+id/item_single_iv" android:layout_marginTop="16px" android:gravity="center_horizontal" android:text="信息" android:textColor="@color/button_text_color"/&gt; &lt;TextView android:id="@+id/item_single_tv_val" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/item_single_tv_title" android:layout_marginTop="10px" android:gravity="center_horizontal" android:text="1223" android:textColor="@color/button_text_color"/&gt;&lt;/com.zhy.autolayout.AutoRelativeLayout&gt; 2. 创建一个继承自ViewGroup的自定义类。2.1 一个原始的自定义类：123456789101112131415public class MyViewGroup extends LinearLayout &#123; public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125;&#125; 2.2 对自定义组合控件中的子控件进行属性设置使用到的类： TypedArray 使用的文件： attrs.xml 文件 注意： 属性的初始化应该放在相应的构造函数中，例如本自定义ViewGroup中的构造过程应该写在第二个构造函数中，写在第三个构造函数中在使用时则不会显示。 在获取Layout布局文件时，注意参数的设置： View view = LayoutInflater.from(context).inflate(R.layout.my_view_group_layout,this,true); 有时，此处参数设置出错，自定义view的控件将不会显示。 此步编写的步骤为： 获取Layout布局文件 声明 Layout布局文件中的子控件 通过 TypedArray 获取 子控件 中的属性值 为各个子控件设置参数值 实例为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class MyViewGroup extends LinearLayout &#123; private static final String TAG = "MyViewGroup"; /* 2- 声明 xml文件用到的 控件 */ TextView mTextView1,mTextView2; ImageView mImageView; public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); // 1 - 获取自定义的 xml文件 View view = LayoutInflater.from(context).inflate(R.layout.my_view_group_layout,this,true); // 3 - findViewById mTextView1 = view.findViewById(R.id.one_tv); mTextView2 = view.findViewById(R.id.two_tv); mImageView = view.findViewById(R.id.image); // 4 - 通过 TypedArray 获取 attrs文件中的属性值 @SuppressLint("Recycle") TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.MyViewGroup); if (array != null) &#123; String textOneTitle = array.getString(R.styleable.MyViewGroup_textOneTitle); float textOneSize = array.getDimension(R.styleable.MyViewGroup_textOneSize,10); String textTwoTitle = array.getString(R.styleable.MyViewGroup_textTwoTitle); float textTwoSize = array.getDimension(R.styleable.MyViewGroup_textTwoSize,10); //两种方式均可 Drawable imgSrc = array.getDrawable(R.styleable.MyViewGroup_imageSrc); //int imgSrc = array.getResourceId(R.styleable.MyViewGroup_imageSrc,R.drawable.ic_launcher_background); boolean oneIsShow = array.getBoolean(R.styleable.MyViewGroup_textOneVisible,true); int textOneColor = array.getColor(R.styleable.MyViewGroup_textOneColor, Color.BLACK); int gracityIndex = array.getInt(R.styleable.MyViewGroup_textTwoGravity, Gravity.CENTER); array.recycle(); Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; MyViewGroup textOneTitle : " + textOneTitle + ", textOneSize : "+ textOneSize + ", textTwoTitle : " + textTwoTitle + ", textTwoSize : " + textTwoSize); // 5 - 为控件中的各个控件设置参数值 mTextView1.setText(textOneTitle); mTextView2.setText(textTwoTitle); mTextView1.setTextSize(textOneSize); mTextView2.setTextSize(textTwoSize); mTextView2.setTextColor(textOneColor); //控制子控件的显隐性 if (oneIsShow) &#123; mTextView1.setVisibility(VISIBLE); &#125; else &#123; mTextView1.setVisibility(INVISIBLE); &#125; //设置自定义图片的两种方式 mImageView.setBackground(imgSrc); //mImageView.setBackgroundResource(imgSrc); if (gracityIndex == 1) &#123; mTextView2.setGravity(Gravity.TOP); &#125; else if (gracityIndex == 2) &#123; mTextView2.setGravity(Gravity.CENTER); &#125; &#125; &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public void setImageView(Drawable imageViewId) &#123; mImageView.setBackground(imageViewId); &#125; public void setTextView1(String textView1Title) &#123; mTextView1.setText(textView1Title); &#125; public void setTextView2(String textView2Title) &#123; mTextView2.setText(textView2Title); &#125; public void setTextView1Size(int textView1Val) &#123; mTextView1.setTextSize(textView1Val); &#125; public void setTextView2Size(int textView2Val) &#123; mTextView2.setTextSize(textView2Val); &#125; public void setTextView2Gravity(String gravity) &#123; if ("top".equals(gravity)) &#123; mTextView2.setGravity(Gravity.TOP); &#125; else if ("center".equals(gravity)) &#123; mTextView2.setGravity(Gravity.CENTER); &#125; &#125;&#125; 3.1 在相应的xml文件中调用自定义的ViewGroup类，实现对此类的调用。在这一步中，要想使用自定义view的属性进行数值的设置，首先要声明命名空间： xmlns:cwj=&quot;http://schemas.android.com/apk/res-auto&quot; 实际例子： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:cwj="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.yannischeng.custom_view.view_group.MyViewGroupActivity" android:orientation="vertical"&gt; &lt;com.yannischeng.custom_view.view_group.MyViewGroup cwj:textOneSize="@dimen/textOneSize1" cwj:textOneTitle="大标题" cwj:textTwoSize="@dimen/textOneSize2" cwj:textTwoTitle="具体的详细信息" cwj:imageSrc="@drawable/maps" android:layout_width="match_parent" android:layout_height="56dp"/&gt;&lt;/LinearLayout&gt; 3.2 修改之后布局文件123456789101112&lt;com.yannischeng.custom_view.view_group.MyViewGroup android:id="@+id/my_view_group" cwj:textOneSize="@dimen/textOneSize1" cwj:textOneTitle="大标题" cwj:textTwoSize="@dimen/textOneSize2" cwj:textTwoTitle="具体的详细信息" cwj:imageSrc="@drawable/maps" cwj:textOneVisible="false" cwj:textOneColor="#ff0000" cwj:textTwoGravity="top" android:layout_width="match_parent" android:layout_height="56dp"/&gt; 运行结果为： 4. 在相应的类中像使用其他控件一样使用自定义ViewGroup类的属性。1234567891011121314@BindView(R.id.my_view_group)MyViewGroup mMyViewGroup;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_view_group); ButterKnife.bind(this); mMyViewGroup.setTextView1("标题"); mMyViewGroup.setTextView1Size(14); mMyViewGroup.setTextView2("小标题"); mMyViewGroup.setTextView2Size(10);&#125; 5. 为自定义控件添加响应事件声明一个回调事件接口： 123456public interface ClickListener &#123; void textOneClickListener(View view); void textTwoClickListener(View view);&#125; 在自定义控件中使用： 12345678910111213141516171819202122232425262728293031323334/* 点击事件接口 */ClickListener mClickListener = null;/* 构造方法 */public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); //... mTextView1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mClickListener.textOneClickListener(v); &#125; &#125;); mTextView2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mClickListener.textTwoClickListener(v); &#125; &#125;); &#125;/** * 点击方法声明 */public void setClickListener(ClickListener listener)&#123; mClickListener = listener;&#125; 在Activity中使用 12345678910111213ClickListener mClickListener = null;mMyViewGroup.setClickListener(new ClickListener() &#123; @Override public void textOneClickListener(View view) &#123; Toast.makeText(MyViewGroupActivity.this, "this is textOneClickListener!", Toast.LENGTH_SHORT).show(); &#125; @Override public void textTwoClickListener(View view) &#123; Toast.makeText(MyViewGroupActivity.this, "this is textTwoClickListener!", Toast.LENGTH_SHORT).show(); &#125;&#125;); 点击左侧写有“标题”的按钮：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权限-FileProvider]]></title>
    <url>%2F%E6%9D%83%E9%99%90-FileProvider%2F</url>
    <content type="text"><![CDATA[问题起因：E/FileSource: Failed to open file &apos;/storage/emulated/0/DCIM/Camera/VID_20171121_203344.mp4&apos;. (Permission denied) 这是因为7.0的新的文件权限导致的。文件共享要采用FileProvicer的形式，不能使用之前的file路径来简单表示。 3步解决问题1在res/下创建xml/文件夹，然后创建：file_paths文件。 12345&lt;resources xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-files-path name="root_path" path="."/&gt;&lt;/resources&gt; 注意：&lt;paths&gt;元素可包含多个元素。 具体元素的含义： &lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /data/user/0/com.yannischeng.simplemediaplayer/files Context.getFilesDir() + /path/ &lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /data/user/0/com.yannischeng.simplemediaplayer/cache Context.getCacheDir() + /path/ &lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0 Environment.getExternalStorageDirectory() + /path/ &lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0/Android/data/com.yannischeng.simplemediaplayer/files Context.getExternalFilesDir(String) + /path/ &lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0/Android/data/com.yannischeng.simplemediaplayer/cache Context.getExternalCacheDir() + /path/ &lt;root-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于外置SD卡路径。 // /system Environment.getRootDirectory().getAbsolutePath(); 2 在AndroidManifest.xml里面注册FileProvider123456789101112&lt;application ... &lt;provider android:name="android.support.v4.content.FileProvider" &lt;!-- 共享文件的文件根目录，名字可以自定义 --&gt; android:authorities="media.player" &lt;!-- 自定义的权限 --&gt; android:exported="false" &lt;!-- 是否设置为独立进程 --&gt; android:grantUriPermissions="true"&gt; &lt;!-- 是否拥有共享文件的临时权限 --&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt; &lt;/provider&gt; &lt;/application&gt; 3在java代码中： 1Uri fileURI = FileProvider.getUriForFile(mContext,"media.player",file);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android视频]]></title>
    <url>%2FAndroid%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/10e357946447 Markdown中流程图语法的使用： 123张三-&gt;李四:嘿!Note right of 李四:说：李四--&gt;张三:忙，没有。 1234张三-&gt;李四: 嘿!Note right of 张三:张三心说：嘿个锤子！李四--&gt;张三: 你好!Note right of 李四: 好你个锤子！ 1234张三 -&gt;李四: 嘿!Note right of 张三:张三心说：嘿个锤子！李四--&gt;张三: 你好!Note right of 李四: 好你个锤子！ 1234张三 -&gt;李四: 嘿!Note right of 张三:张三心说：嘿个锤子！李四 --&gt;张三: 你好!Note right of 李四: 好你个锤子！ 1234张三-&gt;李四: 嘿!Note right of 张三:张三心说：嘿个锤子！李四 --&gt;张三: 你好!Note right of 李四: 好你个锤子！ 1234张三-&gt;李四:嘿!Note left of 张三:张三心说：嘿个锤子！李四--&gt;张三: 你好!Note right of 李四: 李四心说：好你个锤子！ 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 自己的是一样的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 注意： 空格！！！ 一、基本概念写在前面：如果在很多专有名字，概念都不熟悉的情况下，想要去阅读播放器源码会是相当困难的事情。 1. Codec编码（encode） 和 解码(decode)。Codec就是一种程序，这种程序可以对视频文件进行编码和解码。 A video codec is an electronic circuit or software that compresses（编码，压缩） or decompresses（解码，解压） digital video. It converts raw (uncompressed) digital video to a compressed format or vice versa. In the context of video compression, “codec” is a concatenation of “encoder” and “decoder”—a device that only compresses is typically called an encoder, and one that only decompresses is a decoder. 视频文件的本质其实就是图片的集合，当一段连续的图片不断的出现在人眼前(一般一个连贯的电影或者动画至少要求一秒24帧，也就是一秒内连续出现24张图片)，肉眼就会“欺骗性”的告诉大脑我们在看一个视频，而不是幻灯片。 图片大小计算：720P 1280 * 720 * 3byte = 2.7M Android在xml中定义颜色格式：#ffffff，三原色：3X4X2 = 24位二进制位 24/8 = 3。 仅仅是60s（1分钟）就有这么大，一部电影岂不……？ 所以通过：Codec程序对这些连续的图片通过一定的算法压缩成体积更小的文件格式 - 编码，压缩。在屏幕上进行播放时，需要显示图片，所以要将图片进行还原 - 解码，解压缩。Codec解码的编解码是分别针对：视频（图片）、音频（声波）。 视频的编解码是一个非常复杂的过程，但是现在有很多的工具及规范： H.265/H.264/H.263 2. Container format file（视频容器文件） - 结构化的文件视频容器文件即：mp4、rmvb、avi。容器：包括了视频(video)数据、(audio)音频数据、文字(Text)数据。结构化：音频、视频、文字数据必须按照一定的规范，放在指定的地方（方便解析）。 元数据 -&gt; Codec程序 -&gt; 视频容器文件 一个典型的“MP4”视频容器文件 Track(轨道)，这是一个专业术语，用来区分不同的音视频/文字数据。最重要的却是这个MetaData（头文件），它包含了很多关于视频的原始数据，比如视频的大小，视频的时长，还有一个索引表，这个索引表包含了不同轨道的起始位置(以字节为单位)，又因为每个轨道会被分成若干块sample(采样，每一块采样都是可以单独被播放器播放的一段数据，以微妙为单位)，metadata也会维护一个细粒度更小的索引表，记录了每一块sample的大小，起始位置，对应视频的时间是多少(以字节为单位)等等的信息。 3. 视频处理流程 原片(Raw Data) -Encode-&gt; 容器文件(container) -process-&gt; 不同分辨率 -服务器-&gt; 客户端使用 二、MP4 解析1. Mp4格式文件的构成MP4是一种格式的规范，是被ISO机构认证的，只要你通过Codec生成了一个mp4文件，那么这个文件的格式必须是按照ISO机构的规矩来。这个规范很好理解，它定义了一个MP4文件里面，哪些数据应该放在什么位置(以字节为单位)，哪些数据的长度是多少。 MP4格式定义：http://xhelmboyx.tripod.com/formats/mp4-layout.txt 任何容器，包括mp4都是类似的结构化文件，只不过不同的格式文件ISO对其有严格的要求，数据的摆放顺序、排列等等不同而已。 2. MP4头文件构成在Meta Data里面，每一个Header，头文件，我们都叫他们Atom Header(不知道咋翻译)。Atom Header分为Leaf Atom 和 Container Atom。前者代表一个连接着字符串信息的头文件，后者是一个包含了若干个子Atom的头文件，他们互相之间是有层级关系的(参考上图)。每次播放器获取了movie atom之后(moov)，会根据层级关系，向下，或者向下读取相关的其他信息。每一个头文件都会对它的子头文件保存位置的引用，所以只要根据mp4文件的规范获取了最顶级的头文件moov,就可以顺势往下读取其他头文件 苹果MP4文档：https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706 mp4的头文件结构： 最重要的信息是采样索引表(Sample Table Atoms).对应图中“stbl ”这个atom header。这个索引表保存了mp4文件所有的采样(sample)与视频时间的对应关系(一般以微秒为单位)，还有包括每个采样的大小，在mp4文件中的起始位置(以自己为单位)。 3. 标准播放器的启动流程3.1 播放器构成： 数据源（source） 读取器（extractor） 加载控制器（load control） 渲染器（trackRenderer） 3.1 播放器播放流程：在播放器可以把数据提交给渲染器之前，播放器需要把必需的头文件全部解析并存入内存，比如之前说的采样索引表。一般播放器在解析完毕后，会构建三个表： 一个存放时间对应采样索引 一个存放采样索引对应在mp4文件中的起始位置(以字节为单位) 一个存放采样索引对应大小(以字节为单位)。 通过表1，我们知道该微秒对应第1个采样（sample），从第一个和第二个表我们知道，第1个采样的数据范围(在mp4文件内)是从第0字节到300（0+300）字节，那么播放器就会去读取这个范围的数据并且放入渲染器中进行渲染。 同时，加载器会基于当前已经缓存的数据，决定是否还需要不停的读取数据进入内存。一般来说每个播放器都有默认的缓存值，也会有一个基准线，只有当缓存足够数据才能放进渲染器进行渲染。 最后同理，当我们拖动滑动控制器(SeekBar)想快进的时候，我们和第一步一样，通过我们想滑动的时间获取采样的索引，再重新开始读取数据。 综上所述，播放器在正式播放视频文件之前，必须要把头文件全部读取并解析(这会是一段非常耗时的程序)，这也是在线视频播放的等待时间的瓶颈。在接下来的章节我会介绍自适应视频播放(Adaptive Streaming)，这个技术的发明使得了分段式mp4文件(Fragmented Mp4)技术得以诞生，大大的减少了在线视频播放的等待时间。 4. 在线视频播放的技术基础(online video streaming)在线视频的播放其实和播放本地视频的区别就是Extractor读取的Source，数据源不一样。 在线播放需要下载数据到内存，再交由Extractor读取分析。但是既然是在线视频播放，我们肯定不能把整个容器文件下载到内存或者硬盘再开始解析播放。我们希望能控制下载的进度，比如我当前在看第10s的视频内容，所以我只想缓存/下载视频内容到第20s的位置。 我们俗称的渐进式下载(Progressive Downloading)就解决了这一难题。 在HTTP请求里面加一个叫RANGE的header，放入起始字节和结束字节，就可以只下载对应部分的数据，这一header的支持也是各种下载软件实现断点下载的基础。每次断网的时候记录下来已经下载的数据的字节数，下次再下载的时候从字节数+1处重新下载并且写入原有文件就可以了。 三、 Android的Media API1. Android平台视频播放历史自带播放器缺点： 很多格式的容器文件不支持，也不支持自适应视频播放(Adaptive Streaming) 应用开发者很难debug播放器，MediaPlayer的代码很多都是Native Method。并不在Java层。 很难做自定义的拓展和设置，比如缓冲的大小，下载进度等等。 安卓4.3之后 release 新的 Media Codec API组，把API组件设计的面向视频播放的更底层概念。 从结构图里看出，原来的MediaPlayer把Extractor，和Codec API全部封锁在了Framework层，应用层完全接触不到。在新的API设计里面，这些都挪到了应用层(其实虽然MediaCodec API，就是编解码API还在Framework，但是应用层可以调用他们) 2. Android Codec API的使用在全新的Media API里面，最最最重要的就是MediaExtractor和MediaCodec这两个类，第一个可以对容器文件进行读取控制，第二个就是对数据进行编解码的API。 MediaExtractor可以从一个URL，获取容器文件的轨道数量、轨道信息(Track)。在确定了轨道信息之后，可以选择想要解码的轨道(只能选择一个，所以音轨和视频轨道需要两个不同MediaExtractor给两个不同MediaCodec解码)，再从该轨道不停的读取数据放入MediaCodec API进行解码。 MediaCodec API则是创建的时候就需要选择Codec的类型。然后编码的时候需要安卓平台显示视频的Surface 一个MediaCodec在创建之后会在内部维护两个对列(Queue),一个是InputQueue，一个是OutputQueue。类似生产者消费者的模式，MediaCodec会不停的从InputQueue获取数据(InputQueue的数据又是又MediaExtractor提供)，解码，再把解码之后的数据放入OutputQueue，再提供给Surface让其视频内容。]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[一、概览： Animator :这是为动画提供基本支持的类的超类，这些动画可以被启动、结束、并添加AnimatorListeners。 Animator的子类 二、动画分类0. 复杂属性动画 使用 PropertyValuesHolder 来对多个属性同时做动画； 使用 AnimatorSet 来同时管理调配多个动画； PropertyValuesHolder 的进阶使用：使用 PropertyValuesHolder.ofKeyframe() 来把一个属性拆分成多段，执行更加精细的属性动画。 1. 最早的两种 逐帧动画(frame-by-frame animation) 补间动画(tweened animation) 2. 属性动画 ：ValueAnimator（Android3.0） - 某一属性（值）动画属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的，即：ValueAnimator只不过是对值进行了一个平滑的动画过渡。 它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等 补间动画是只能对View对象进行动画操作的。而属性动画就不再受这个限制，它可以对任意对象进行动画操作。 这个类提供了一个简单的计时引擎，用于运行计算动画值的动画并将其设置在目标对象上。所有动画都有一个定时脉冲。它在自定义处理程序中运行，以确保在UI线程上发生属性更改。默认情况下，ValueAnimator使用非线性时间插值，通过AccelerateDecelerateInterpolator类来加速和减速动画。这种行为可以通过调用{@link ValueAnimator＃setInterpolator（TimeInterpolator）}来改变。动画师可以从代码或资源文件创建。这里是一个ValueAnimator资源文件的例子： {@sample development / samples / ApiDemos / res / anim / animator.xml ValueAnimatorResources} 也可以使用{@link PropertyValuesHolder}和 {@link Keyframe}资源标签来创建一个多步骤的动画。 请注意，您可以XMind为每个关键帧指定显式小数值（从0到1），以确定动画在整个持续时间内何时到达该值。或者，您可以关闭分数，关键帧将在总时长内平均分配：{@sample development / samples / ApiDemos / res / anim / value_animator_pvh_kf.xml ValueAnimatorKeyframeResources} （1）ObjectAnimator - ValueAnimator 子类ValueAnimator的这个子类ObjectAnimator为动画目标对象上的属性提供了支持。这个类的构造函数使用参数来定义将被动画的目标对象以及将被动画的属性名称。然后在内部确定适当的设置/获取函数，动画将根据需要调用这些函数来动画属性。 简单使用方式: 1234ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(mTextView01,"rotation",0f,360f);mObjectAnimator.setDuration(2000);mObjectAnimator.setInterpolator(mInterpolator);mObjectAnimator.start(); 1.1 基本使用12345ObjectAnimator animator = ObjectAnimator.ofFloat(view,"progress",0,100);// 2. 用 start() 执行动画animator.setDuration(3000);animator.setInterpolator(new LinearOutSlowInInterpolator());animator.start(); 在自定义View中使用objectAnimator的“属性”：添加setter()/getter()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class CameraFlipBoard extends View &#123; Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); Camera mCamera = new Camera(); Bitmap mBitmap; int degree; ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); public CameraFlipBoard(Context context) &#123; super(context); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //设置自定义动画 &#123; mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.maps); mAnimator.setDuration(2000); mAnimator.setInterpolator(new FastOutLinearInInterpolator()); //无限重复 mAnimator.setRepeatCount(ValueAnimator.INFINITE); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start(); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end(); &#125; //unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问 @SuppressWarnings("unused") public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate(); &#125; public int getDegree() &#123; return degree; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float centerX = getWidth() / 2; float centerY = getHeight() / 2; float cbx = centerX - mBitmap.getWidth() / 2; float cby = centerY - mBitmap.getHeight() / 2; /* 本次要实现的是由图片的中间开始，上半部分不动，下半部分由上往下翻180度。 所以，一张图片要被分成2部分： 上半部分绘制完成之后不动 下半部分则是反向转动180度 */ //上半部分 canvas.save(); canvas.clipRect(0,0,getWidth(),centerY); canvas.drawBitmap(mBitmap, cbx,cby, mPaint); canvas.restore(); /* 未经移动的canvas坐标原点即为camera的坐标原点。 移动的距离要看 具体的bitmap所在的具体位置： 若bitmap在view的坐标原点，则移动bitmap的width/2和height/2即可。 若bitmap不在view的坐标原点，则要根据他们的相对位置进行计算后移动。 */ //下半部分 canvas.save(); if (degree &lt; 90) &#123; canvas.clipRect(0,centerY,getWidth(),getHeight()); &#125; else &#123; canvas.clipRect(0,0,getWidth(),centerY); &#125; mCamera.save(); canvas.translate(centerX,centerY); mCamera.rotateX(degree); mCamera.applyToCanvas(canvas); canvas.translate(-centerX,-centerY); mCamera.restore(); canvas.drawBitmap(mBitmap,cbx,cby,mPaint); canvas.restore(); &#125;&#125; 1.2 组合动画（一个接一个的动画）：AnimatorSet实现组合动画功能主要需要借助AnimatorSet这个类，这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法： after(Animator anim) 将现有动画插入到传入的动画之后执行 after(long delay) 将现有动画延迟指定毫秒后执行 before(Animator anim) 将现有动画插入到传入的动画之前执行 with(Animator anim) 将现有动画和传入的动画同时执行 1234567ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f); ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f); ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(rotate).with(fadeInOut).after(moveIn); animSet.setDuration(5000); animSet.start(); 1234567891011121314151617181920ObjectAnimator animator1 = ObjectAnimator.ofFloat(...); animator1.setInterpolator(new LinearInterpolator()); ObjectAnimator animator2 = ObjectAnimator.ofInt(...); animator2.setInterpolator(new DecelerateInterpolator());AnimatorSet animatorSet = new AnimatorSet(); // 两个动画依次执行,使用 playSequentially()，就可以让两个动画依次播放，而不用为它们设置监听器来手动为他们监管协作。animatorSet.playSequentially(animator1, animator2); animatorSet.start(); // 两个动画同时执行animatorSet.playTogether(animator1, animator2); animatorSet.start();// 使用 AnimatorSet.play(animatorA).with/before/after(animatorB)// 的方式来精确配置各个 Animator 之间的关系animatorSet.play(animator1).with(animator2); animatorSet.play(animator1).before(animator2); animatorSet.play(animator1).after(animator2); animatorSet.start(); 1.3 同一个动画中改变多个属性： PropertyValuesHolder12345PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat("scaleX", 1);PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat("scaleY", 1); PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat("alpha", 1);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3) animator.start(); 1.4 把同一个属性拆分：PropertyValuesHolders.ofKeyframe()12345678910// 在 0% 处开始Keyframe keyframe1 = Keyframe.ofFloat(0, 0); // 时间经过 50% 的时候，动画完成度 100%Keyframe keyframe2 = Keyframe.ofFloat(0.5f, 100); // 时间见过 100% 的时候，动画完成度倒退到 80%，即反弹 20%Keyframe keyframe3 = Keyframe.ofFloat(1, 80); PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe("progress", keyframe1, keyframe2, keyframe3);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder); animator.start(); （2）ViewPropertyAnimator（Android3.1） 该类可以在View对象上自动优化动画选择属性。 如果View对象上只有一个或两个属性被设置为动画，推荐使用ObjectAnimator。由ObjectAnimator调用的属性设置器能够正确地设置属性并使视图无效。 但是，如果同时对多个属性进行动画处理，或者只是想要更方便的语法来为特定的属性设置动画，则ViewPropertyAnimator可能更适合执行此任务。 这个类可以为几个同时动画提供更好的性能，因为它将优化无效调用，只发生一次对于多个属性，而不是每个动画属性独立地导致它自己的失效。而且，使用这个类的语法可能更容易使用，因为调用者只需要告诉View对象哪个属性需要动画。 这个类不是由调用者构造的，而是由View的属性来动画的。调用View.animate()将返回对该视图的相应ViewPropertyAnimator对象的引用。 imageView.animate()中的animate(): 1234567891011public ViewPropertyAnimator animate() &#123; if (mAnimator == null) &#123; mAnimator = new ViewPropertyAnimator(this); &#125; return mAnimator;&#125; ViewPropertyAnimator(View view) &#123; mView = view; view.ensureTransformationInfo();&#125; 2.1 基本功能： rotation scale translation alpha 2.2 使用到的其他相关接口： Animator ： 动画提供基本支持的类的超类 Animator.AnimatorListener ：动画侦听器从动画接收通知。 ValueAnimator.AnimatorUpdateListener ： TimeInterpolator ViewPropertyAnimatorRT 2.3 除了动画之外的价格set方法: ViewPropertyAnimator setDuration(long duration) ViewPropertyAnimator setInterpolator(TimeInterpolator interpolator) ViewPropertyAnimator setListener(Animator.AnimatorListener listener) ViewPropertyAnimator setStartDelay(long startDelay) ViewPropertyAnimator setUpdateListener(ValueAnimator.AnimatorUpdateListener listener) 2.4 ViewPropertyAnimator基本使用，（同一个动画中改变多个属性）1234567imageView.animate().translationX(500f). alpha(0.2f). scaleX(1.5f). scaleY(1.5f). rotation(720). setInterpolator(new AnticipateOvershootInterpolator()). setDuration(3000); 三、 Animator监听器给动画设置监听器，可以在关键时刻得到反馈，从而及时做出合适的操作，例如在动画的属性更新时同步更新其他数据，或者在动画结束后回收资源等 ViewPropertyAnimator ObjectAnimator setListener() addListener() setUpdateListener() addUpdateListener() set[Update]Listener() remove[Update]Listener() addPauseListener() removePauseListener() withStartAction()一次性动画 withEndAction() Animator类当中提供了一个addListener()方法，这个方法接收一个AnimatorListener，我们只需要去实现这个AnimatorListener就可以监听动画的各种事件了。 四、 其他组件1. 插值器 - Interpolator1.1 Interpolator的作用内插器定义动画的变化率。 这可以使基本的动画效果（alpha，缩放，平移，旋转）加速，减速，重复等。 1.2 Interpolator的继承关系 1.3 系统自带效果 Interpolator class Resource ID AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator AccelerateInterpolator @android:anim/accelerate_interpolator AnticipateInterpolator @android:anim/anticipate_interpolator AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator BounceInterpolator @android:anim/bounce_interpolator CycleInterpolator @android:anim/cycle_interpolator DecelerateInterpolator @android:anim/decelerate_interpolator LinearInterpolator @android:anim/linear_interpolator OvershootInterpolator @android:anim/overshoot_interpolator Interpolator class decription AccelerateDecelerateInterpolator 开始和结束缓慢，中间加速 AccelerateInterpolator 开始的时候缓慢，之后开始加速 AnticipateInterpolator 开始的时候向后甩一下，然后向前 AnticipateOvershootInterpolator 开始的时候向后甩一下，然后加速向前甩过终点一点后回到原点 BounceInterpolator 动画结束的时候小距离的时候在终点处弹起 CycleInterpolator 将重复周期的指定数目的动画。变化率遵循正弦模式 DecelerateInterpolator 开始的时候快，结束的时候慢 FastOutLinearInInterpolator 加速运动 FastOutSlowInInterpolator 先加速再减速 LinearInterpolator 以常量速率变化 LinearOutSlowInInterpolator 持续减速 OvershootInterpolator 运动到终点后，冲过终点后再回弹 PathInterpolator 自定义动画完成度 / 时间完成度曲线 2. 计算器 - TypeEvaluator 参考：http://hencoder.com/ui-1-7/ 告诉动画系统如何从初始值过度到结束值 用于ValueAnimator.setEvaluator（TypeEvaluator）函数的接口。 评估者允许开发人员通过允许他们为动画系统不能自动理解和使用的类型提供自定义评估器来为任意属性类型创建动画。 12345678910111213141516public interface TypeEvaluator&lt;T&gt; &#123; /** * 该函数返回对开始和结束值进行线性插值的结果 * 表示开始和结束值之间的比例的“分数”。 计算是一个简单的参数计算：result = x0 + t *（x1 - x0） * 其中 x0 是 startValue ，x1 是 endValue ， t 是 分数 。 * * @参数分数从开始到结束值的分数 * @param startValue起始值。 * @param endValue最终值。 * @return给定的开始值和结束值之间的线性插值 * fraction ：参数fraction非常重要，这个参数用于表示动画的完成度的，我们应该根据它来计算当前动画的值应该是多少。 */ public T evaluate(float fraction, T startValue, T endValue);&#125; 2.1 一个IntEvaluator类代码：123456789/** * 此评估程序可用于在 int 值之间执行类型插值。 */public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 2.2 使用自定义一个Evaluator 1234567891011public class AZEvaluator implements TypeEvaluator&lt;Character&gt; &#123; @Override public Character evaluate(float fraction, Character startValue, Character endValue) &#123; int startInt = (int)startValue; int endInt = (int)endValue; int curInt = (int)(startInt + (fraction *(endInt - startInt))); char result = (char)curInt; return result; &#125;&#125; 1234567891011121314ValueAnimator valueAnimator = ValueAnimator.ofObject(new AZEvaluator(),Character.valueOf('A'),Character.valueOf('Z'));valueAnimator.setDuration(3000);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; char currentChar = (char) animation.getAnimatedValue(); Log.e(TAG, "onAnimationUpdate: " + currentChar ); showChar.setText(String.valueOf(currentChar)); &#125;&#125;);//valueAnimator.setInterpolator(new LinearInterpolator());valueAnimator.setRepeatCount(ValueAnimator.INFINITE);valueAnimator.setRepeatMode(ValueAnimator.REVERSE);valueAnimator.start(); 硬件加速 ？！ 参考：http://hencoder.com/ui-1-8/ 硬件加速能够让绘制变快，主要有三个原因 本来由 CPU 自己来做的事，分摊给了 GPU 一部分，自然可以提高效率； 相对于 CPU 来说，GPU 自身的设计本来就对于很多常见类型内容的计算（例如简单的圆形、简单的方形）具有优势； 由于绘制流程的不同，硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免了一些重复操作，从而大幅提升绘制效率。 原理在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。大致就像这样： 而在硬件加速开启时，Canvas 的工作方式改变了：它只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。大致是这样： 限制]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View-5 View的绘制顺序]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View-5%20View%E7%9A%84%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[参考：http://hencoder.com/ui-1-5/ 在各个重写方法中的 前 or 后？绘制在super.XXX()之前，覆盖之后绘制的内容；绘制在super.XXX()之后，则覆盖之前绘制的内容。 小招数Debug 模式下绘制出额外的信息：如： 绘制过程 注意 处于效率问题，ViewGroup默认绕过draw()方法，直接执行dispatchDraw()，以此来简化流程。若继承了ViewGroup要在除dispatchDraw()以外的方法进行内容的绘制，调用View.setWillNotDraw(false)方法可能会有用，因为有些方法已经使用此方法。 如果绘制代码既可以写在onDraw()亦可以写在其他方法里时，写在onDraw()中最合适，因为Android本身对onDraw()有优化，在不需要重绘时自动跳过onDraw()。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View-4 Canvas的辅助绘制]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View-4%20Canvas%E7%9A%84%E8%BE%85%E5%8A%A9%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. Canvas与Camera中不可忽略的两个方法：对同一个图片对象进行处理时，需要时时注意的两个方法。 save() : 保存处理之前的状态 restore() ：恢复 “保存处理之前的状态” 2. 处理的顺序问题：对于一个图片进行多项操作处理时候，实际处理代码的顺序是从下向上的。Canvas的顺序是反着的。 3. 裁剪 ClipCanvas中与Clip有关的方法： 共有2类：Path和Rect 3.1 Rect裁剪canvas.clipRect(left,top,left + 130,top + 150); canvas.drawBitmap(bitmap, left, top, paint); 3.2 Path裁剪//圆形抠图 canvas.save(); canvas.translate(250,500); Path path = new Path(); path.addCircle(100,200,100, Path.Direction.CW); canvas.clipPath(path); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); //心形挖空 canvas.save(); canvas.translate(600,500); Path path1 = new Path(); path1.setFillType(Path.FillType.INVERSE_WINDING); path1.arcTo(50,100,150,200,135,225,false); path1.arcTo(150,100,250,200,180,225,false); path1.lineTo(150,300); path1.close(); canvas.clipPath(path1); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); //心形抠图 canvas.save(); canvas.translate(1000,500); Path path2 = new Path(); path2.setFillType(Path.FillType.EVEN_ODD); path2.arcTo(50,100,150,200,135,225,false); path2.arcTo(150,100,250,200,180,225,false); path2.lineTo(150,300); path2.close(); canvas.clipPath(path2); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); 4. 变换 Canvas，Matrix，Camera4.1 Canvas变换共有4类： scale translate skew rotate 他们的使用方式相同，唯一就是参数类型不同。 skew的使用 123456789101112131415161718192021/** * 斜切 */ canvas.save(); canvas.translate(0,200); /** * @param sx在X中歪斜的数量 * @param sy在Y中倾斜的数量 */ canvas.skew(0f,0.5f); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); canvas.save(); canvas.translate(700,400); /** * @param sx在X中歪斜的数量 * @param sy在Y中倾斜的数量 */ canvas.skew(-0.5f,0f); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 4.2 Matrix变换大致使用 Matrix matrix = new Matrix(); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.save(); matrix.postTranslate(0,300); canvas.concat(matrix); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); canvas.translate(0,-300); canvas.save(); matrix.preTranslate(0,-300); canvas.concat(matrix); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 4.3 Camera变换中的使用Canvas和Matrix仅能对图像实现二维效果的是实现，而Camera所在的是空间三维坐标系，能够实现空间变换效果。 4.3.1 初次实现变换123456789101112131415161718Camera camera = new Camera();canvas.translate(100,200);canvas.save();camera.save();camera.rotateX(30);camera.applyToCanvas(canvas);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore();canvas.translate(100,-200);canvas.save();camera.save();camera.rotateY(30);camera.applyToCanvas(canvas);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 很明显可以看到，在空间坐标系中进行camera变换后，得到的效果已经失真。 * Android的Camera中的轴是一个控件三维轴：X、Y、Z，3个轴，camera所对应的原点并不是图像的原点，而是三维坐标轴的原点。 * * 所以图像如果想在camera下沿各个轴做&quot;平面（不失真）&quot;的旋转，就要以图像的中心为轴心进行旋转，但是camera不支持设置轴心，所以要通过Canvas进行轴心的再设置。 * * 通过Canvas将图像的中心移动到轴的中心。待旋转结束之后再将图形的轴心移动回之前的位置。 * * 所以，在camera下将图像进行旋转实际的操作步骤是： * * 1）将图像中心移动至空间坐标系的轴心 * 2）执行图像的选装 * 3）恢复图像原来的轴心位置。 * * 通过移动图像的坐标原点后，对图像的X、Y、Z轴分别旋转30度后，三个图像是重合在一起的。即： * 他们的轴心是同一个点。 4.3.2 Camera的空间坐标轴注意：和Camera坐标有关的图片均来自“扔物线”的个人视频截图，此处特此声明。 Camera的空间坐标系的旋转方向： 4.3.3 修正之后123456789101112131415161718192021222324252627282930313233343536373839404142//对X轴进行30度旋转//保存变更前的状态camera.save();canvas.save();//通过canva将三维坐标系的轴心移动至图像的原点，恢复到之前的空间状态。canvas.translate(center1X, center1Y);//在camera下将图像沿着x轴旋转30度camera.rotateX(30);//获得在camera下图像的旋转结果，并将结果应用到canvas中.camera.applyToCanvas(canvas);//通过canva将图像的原点移动至三维坐标系的轴心canvas.translate(-center1X, -center1Y);//camera处理结束后，恢复到之前的sava状态camera.restore();//将得到的图像的结果进行绘制。canvas.drawBitmap(bitmap, point1.x, point1.y, paint);//canvas处理结束后，恢复到之前的sava状态canvas.restore();//对Y轴进行30度旋转canvas.translate(400, 0);camera.save();canvas.save();canvas.translate(center1X, center1Y);camera.rotateY(30);camera.applyToCanvas(canvas);canvas.translate(-center1X, -center1Y);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore();//对Z轴进行30度旋转canvas.translate(400, 0);camera.save();canvas.save();canvas.translate(center1X, center1Y);camera.rotateZ(30);camera.applyToCanvas(canvas);canvas.translate(-center1X, -center1Y);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 实际执行过程 在空间坐标轴中的移动过程大致为： 先将图的原点移动到空间坐标系的原点。即代码： canvas.translate(-center1X, -center1Y); 然后执行具体的变换操作，代码：camera.rotateZ(30); 获取变换后的投影 得到投影结果后，再将图像的原点移动到之前的位置。 运行结果 设置虚拟Camera的位置 123DisplayMetrics displayMetrics = getResources().getDisplayMetrics();float newZ = - displayMetrics.density * 6;camera.setLocation(0, 0, newZ); 5. 为自定义中的图像添加 动画5.1 步骤（1）声明ObjectAnimator对象并进行初始化。12int degree;ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); （2）对ObjectAnimator对象进行具体设置123456//设置时长mAnimator.setDuration(2000);//设置插值器mAnimator.setInterpolator(new FastOutLinearInInterpolator());//无限重复mAnimator.setRepeatCount(ValueAnimator.INFINITE); （3）重写相应的方法设置动画的开始和结束1234567891011@Overrideprotected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start();&#125;@Overrideprotected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end();&#125; （4）设置含有degree属性的方法1234567//unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问@SuppressWarnings("unused")public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate();&#125; （5）使用参数1mCamera.rotateX(degree); 5.2 一个完整的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class CameraFlipBoard extends View &#123; Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); Camera mCamera = new Camera(); Bitmap mBitmap; int degree; ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); public CameraFlipBoard(Context context) &#123; super(context); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //设置自定义动画 &#123; mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.maps); mAnimator.setDuration(2000); mAnimator.setInterpolator(new FastOutLinearInInterpolator()); //无限重复 mAnimator.setRepeatCount(ValueAnimator.INFINITE); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start(); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end(); &#125; //unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问 @SuppressWarnings("unused") public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float centerX = getWidth() / 2; float centerY = getHeight() / 2; float cbx = centerX - mBitmap.getWidth() / 2; float cby = centerY - mBitmap.getHeight() / 2; /* 本次要实现的是由图片的中间开始，上半部分不动，下半部分由上往下翻180度。 所以，一张图片要被分成2部分： 上半部分绘制完成之后不动 下半部分则是反向转动180度 */ //上半部分 canvas.save(); canvas.clipRect(0,0,getWidth(),centerY); canvas.drawBitmap(mBitmap, cbx,cby, mPaint); canvas.restore(); /* 未经移动的canvas坐标原点即为camera的坐标原点。 移动的距离要看 具体的bitmap所在的具体位置： 若bitmap在view的坐标原点，则移动bitmap的width/2和height/2即可。 若bitmap不在view的坐标原点，则要根据他们的相对位置进行计算后移动。 */ //下半部分 canvas.save(); if (degree &lt; 90) &#123; canvas.clipRect(0,centerY,getWidth(),getHeight()); &#125; else &#123; canvas.clipRect(0,0,getWidth(),centerY); &#125; mCamera.save(); canvas.translate(centerX,centerY); mCamera.rotateX(degree); mCamera.applyToCanvas(canvas); canvas.translate(-centerX,-centerY); mCamera.restore(); canvas.drawBitmap(mBitmap,cbx,cby,mPaint); canvas.restore(); &#125;&#125;]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android7.0新特性-Shortcuts]]></title>
    <url>%2FAndroid7-0%E6%96%B0%E7%89%B9%E6%80%A7-Shortcuts%2F</url>
    <content type="text"><![CDATA[说明如果你的App targets android7.1（API level25）或者更高，你就可以在你的app中定义快捷方式来支持特殊的actions。这些快捷方式可以显示在启动图标上，快捷方式可以在你的app内让用户快速开始使用命令或者推荐任务。Shortcuts是Android7.0的新特性，它的功能就像是类似iphone的3D Touch，选中其中的一条Shortcut后，点击是打开对应的app界面，长按则是将此条Shortcut添加至桌面。 以网易云音乐为例进行展示。 长按带有shorcuts功能的app时，该有的样式。 单个shortcut固定到桌面时的样式。其中大的背景icon是在shortcuts中自己设置的，右下角小的背景icon是app的icon。 实现你也可以在你的app中发布两个不同类型的快捷方式 静态快捷方式被定义在一个资源文件中。因此，你必须等到直到你的app更新后，才能改变“静态快捷方式”中的详情。 动态快捷方式是通过在运行时使用ShortcutManager API来发布的，在运行时，你的app可以发布、更新、和移除。 在你的app中同一时间至多可以发布5个快捷方式（静态和动态结合）。然而不必显示你所创建的每一个。 动态使用到的类 ShortcutManager，ShortcutInfo。其中，ShortcutManager用于管理ShortcutInfo，而ShortcutInfo则是执行具体的创建。 简单的初级实现：manager = getSystemService(ShortcutManager.class); //第一步：ShortcutInfo 对象 ShortcutInfo info = new ShortcutInfo.Builder(this,&quot;id1&quot;) //此条shortcut的icon .setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). //固定到桌面时显示的文字 setShortLabel(&quot;Trinea&quot;). //按住app的icon后此条shortcut在显示时的位置 setRank(1). //按住app的icon后此条shortcut显示的文字 setLongLabel(&quot;打开Trinea主页&quot;). //此条shortcut执行的功能 setIntents(intents). build(); //ShortcutInfo 对象 ShortcutInfo info2 = new ShortcutInfo.Builder(this,&quot;id2&quot;). setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). setShortLabel(&quot;百度&quot;). setRank(2). setLongLabel(&quot;百度一下&quot;). setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.baidu.com/&quot;))). build(); //ShortcutInfo 对象 ShortcutInfo info3 = new ShortcutInfo.Builder(this,&quot;id0&quot;). setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). setShortLabel(&quot;SecondActivity&quot;). setDisabledMessage(&quot;此快捷方式已经被禁用&quot;). setRank(3). setLongLabel(&quot;打开 SecondActivity&quot;). setIntents(intents2). build(); //第二步：整理shortcut对象 dynamicShortcuts.add(info); dynamicShortcuts.add(info2); dynamicShortcuts.add(info3); //第三步：通过manager设置shortcut //manager.addDynamicShortcuts(Arrays.asList(info)); manager.setDynamicShortcuts(dynamicShortcuts); 静态需要的文件AndroidManifest.xml。 在触发Shortcuts的Activity的activity标签配置中，添加meta-data标签。具体为： &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.shortcuts&quot; android:resource=&quot;@xml/my_shortcut&quot;/&gt; &lt;/activity&gt; 其中android:resource指向定义了 shortcuts 的资源文件。 创建一个资源文件，在res/xml/目录下，文件的名字同meta-data自己编写的my_shortcut： 在这个资源文件中使用shortcuts作为根元素，它包含多个shortcut标签列表，每一个shortcut 就是一个`静态快捷方式`。 一个shortcut的具体为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;shortcut android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:shortcutDisabledMessage=&quot;@string/message&quot; android:shortcutId=&quot;static&quot; android:shortcutLongLabel=&quot;@string/longlaber&quot; android:shortcutShortLabel=&quot;@string/shortlaber&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetClass=&quot;com.example.shortcutsmy.SecondActivity&quot; android:targetPackage=&quot;com.example.shortcutsmy&quot; /&gt; &lt;/shortcut&gt; &lt;/shortcuts&gt; 说明 shortcutId表示 shortcut 唯一标识符，相同的 shortcutId 会被覆盖。必须字段。 shortcutShortLabel为将 shortcut 拖动到桌面时显示的名字，官方建议不超过 10 个字符，必须字段。 shortcutLongLabel为 shortcut 列表中每个 shortcut 的名字，不宜过长，如果过长或未设置默认会显示 ShortLabel，官方建议不超过 25 个字符。可选字段。 icon为 shortcut 的 icon，在列表展示和拖动到桌面时显示需要，可选字段。 enabled表示 shortcut 是否可用，false 表示禁用。xml 中这个属性几乎没有被设置为 false 的实际场景，具体原因可见6.7 如何更好的删除(废弃)老的 Shortcut中介绍。 shortcutDisabledMessage为已固定在桌面的 shortcut 被 Disabled 后点击时的 Toast 提示内容。可选字段。 intent为点击 shortcut 时响应的 intent，必须字段。可以添加多个 intent，但点击时不会启动所有 intent，而是启动最后一个 intent，在这个 intent 回退时会启动它前面一个 intent，相当于自动将所有 intent 添加到了堆栈。 intent可设置属性包括：android:action、android:data、android:mimeType、android:targetClass、android:targetPackage，其中android:action为必须属性。至此，一个静态的Shortcut创建结束了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android7.0新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View-3 Paint详细]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View-3%20Paint%E8%AF%A6%E7%BB%86%2F</url>
    <content type="text"><![CDATA[参考：http://hencoder.com/ui-1-2/ 继续更随着学习，用适合自己的方式将成果进行记录。 Paint类的4个enum 画笔填充样式 Style123456public static enum Style&#123; FILL(), FILL_AND_STROKE(), STROKE();&#125; 画笔线头样式 Cap123456public static enum Cap&#123; BUTT(), ROUND(), SQUARE();&#125; 两条直线相交后的样式 Join123456public static enum Join&#123; BEVEL(), MITER(), ROUND();&#125; 文字对齐方式 Align123456public static enum Align&#123; CENTER(), LEFT(), RIGHT();&#125; Paint的功能 颜色 效果 绘制文本 初始化 1. 颜色1.1 基本颜色绘制 基本颜色绘制表示：基础颜色的设置，分类的标准就是根据不同颜色设置方式。 Paint 设置颜色的方法：Paint.setColor/ARGB 来设置颜色123paint.setColor(Color.parseColor("#009688")); paint.setColor(Color.BLACK);paint.setARGB(100, 255, 0, 0); Shader 来指定着色方案Shader 中文名是“着色器”。 注意：在设置了 Shader 的情况下， Paint.setColor/ARGB 所设置的颜色就不再起作用。 在Android中并不是直接使用“Shader类”，而是使用它的子类： LinearGradient（线性渐变） RadialGradient（辐射渐变） SweepGradient（扫描渐变） BitmapShader（Bitmap着色） ComposeShader（组合着色） 其中前三者：LinearGradient（线性渐变）, RadialGradient（辐射渐变）, SweepGradient（扫描渐变）同xml绘制图形中有形同的样式。Shader作为一个基类，包含有一个enum类： public enum TileMode { /** * 如果着色器在其原始边界之外绘制，则复制边缘颜色 */ CLAMP (0), /** * 重复着色器的图像水平和垂直 */ REPEAT (1), /** * 复着色器的图像水平和垂直，交替镜像 */ MIRROR (2); TileMode(int nativeInt) { this.nativeInt = nativeInt; } final int nativeInt; } 1 LinearGradient 线性渐变使用： Shader shader = new LinearGradient(100, 100, 500, 500, Color.parseColor(&quot;#E91E63&quot;), Color.parseColor(&quot;#2196F3&quot;), Shader.TileMode.CLAMP); paint.setShader(shader); 此类的构造器 /** * Create a shader that draws a linear gradient along a line. * * @param x0 The x-coordinate for the start of the gradient line * @param y0 The y-coordinate for the start of the gradient line * @param x1 The x-coordinate for the end of the gradient line * @param y1 The y-coordinate for the end of the gradient line * @param colors The colors to be distributed along the gradient line * @param positions May be null. The relative positions [0..1] of * each corresponding color in the colors array. If this is null, * the the colors are distributed evenly along the gradient line. * @param tile The Shader tiling mode */ LinearGradient(float x0, float y0, float x1, float y1, @NonNull @ColorInt int colors[], @Nullable float positions[], @NonNull TileMode tile) 参数： x0 y0 x1 y1：渐变的两个端点的位置 color0 color1“ 是端点的颜色 tile：端点范围之外的着色规则，类型是 TileMode 2 RadialGradient 辐射渐变使用： Shader shader = new RadialGradient(300, 300, 200, Color.parseColor(&quot;#E91E63&quot;), Color.parseColor(&quot;#2196F3&quot;), Shader.TileMode.CLAMP); paint.setShader(shader); 构造方法： RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, TileMode tileMode)。 参数： centerX centerY：辐射中心的坐标 radius：辐射半径 centerColor：辐射中心的颜色 edgeColor：辐射边缘的颜色 tileMode：辐射范围之外的着色模式。 3 SweepGradient 扫描渐变使用： Shader shader = new SweepGradient(300, 300, Color.parseColor(&quot;#E91E63&quot;), Color.parseColor(&quot;#2196F3&quot;)); paint.setShader(shader); 构造方法： SweepGradient(float cx, float cy, int color0, int color1) 参数： cx cy ：扫描的中心 color0：扫描的起始颜色 color1：扫描的终止颜色 4 BitmapShader Bitmap 来着色使用： Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.batman); Shader shader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); paint.setShader(shader); 通过使用：drawCircle() + BitmapShader就可以绘制圆形的 Bitmap，不用 drawBitmap() 了（其他形状同理）。 构造方法： BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY) 参数： bitmap：用来做模板的 Bitmap 对象 tileX：横向的 TileMode tileY：纵向的 TileMode。 5 ComposeShader 混合着色器（两个 Shader 一起使用）使用 // 第一个 Shader：头像的 Bitmap Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.batman); Shader shader1 = new BitmapShader(bitmap1, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 第二个 Shader：从上到下的线性渐变（由透明到黑色） Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.batman_logo); Shader shader2 = new BitmapShader(bitmap2, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // ComposeShader：结合两个 Shader Shader shader = new ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER); paint.setShader(shader); ComposeShader() 在硬件加速下是不支持两个相同类型的 Shader 的，所以这里也需要关闭硬件加速才能看到效果。如何 关闭硬件加速 ? 构造方法： ComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode) 参数： shaderA, shaderB：两个相继使用的 Shader mode: 两个 Shader 的叠加模式，即 shaderA 和 shaderB 应该怎样共同绘制。它的类型是 PorterDuff.Mode 。 PorterDuff.Mode 一共有 17 个，可以分为： Alpha 合成 (Alpha Compositing) 混合 (Blending) 具体使用参考：http://hencoder.com/ui-1-2/ 1.2 setColorFilter(ColorFilter colorFilter) 颜色过滤对每个像素的颜色进行过滤 在设置了对象的基础颜色之后，再对颜色进行设置就是针对“基础颜色”进行设置，不再是停留在对“对象颜色的填充”方面。Paint通过setColorFilter(ColorFilter filter) 方法设置 ColorFilter。 但是 ColorFilter 并不直接使用，而是使用它的子类： LightingColorFilter：模拟简单的光照效果 使用 ColorFilter lightingColorFilter = new LightingColorFilter(0x00ffff, 0x000000); paint.setColorFilter(lightingColorFilter); PorterDuffColorFilter ColorMatrixColorFilter 1.3 setXfermode(Xfermode xfermode)指的是你要绘制的内容和 Canvas 的目标位置的内容应该怎样结合计算出最终的颜色，就是要你以绘制的内容作为源图像，以 View 中已有的内容作为目标图像，选取一个 PorterDuff.Mode 作为绘制内容的颜色处理方案。 注意事项 使用离屏缓冲（Off-screen Buffer） 在绘制之前保存，绘制之后恢复： int saved = canvas.saveLayer(null, null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(rectBitmap, 0, 0, paint); // 画方 paint.setXfermode(xfermode); // 设置 Xfermode canvas.drawBitmap(circleBitmap, 0, 0, paint); // 画圆 paint.setXfermode(null); // 用完及时清除 Xfermode canvas.restoreToCount(saved); 控制好透明区域 2. 效果2.1 setAntiAlias (boolean aa) 抗锯齿效果抗锯齿默认是关闭的，如果需要抗锯齿，需要显式地打开。打开抗锯齿还有一个更方便的方式，可以在初始化的时候就开启抗锯齿： Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); 2.2 setStyle(Paint.Style style) 线条填充效果设置图形是线条风格还是填充风格的，也可以二者并用。 2.3 线条样式效果线条形状的一共有 4 个方法： setStrokeWidth(float width) ：设置线条宽度 setStrokeCap(Paint.Cap cap) ：设置线头的形状。 BUTT 平头 ROUND 圆头 SQUARE 方头 默认为 BUTT。 setStrokeJoin(Paint.Join join) : 设置拐角的形状。 MITER 尖角 BEVEL 平角 ROUND 圆角 默认为 MITER setStrokeMiter(float miter) : 是对于 setStrokeJoin() 的补充，设置 MITER 型拐角的延长线的最大值. 2.4 色彩优化效果 setDither(boolean dither) ：设置图像的抖动。 抖动更多的作用是在图像降低色彩深度绘制时，避免出现大片的色带与色块 paint.setDither(true); setFilterBitmap(boolean filter) ：双线性过滤来绘制 Bitmap。图像在放大绘制的时候会出现马赛克现象，如果开启了双线性过滤，就可以让结果图像显得更加平滑 paint.setFilterBitmap(true); 2.5 setPathEffect(PathEffect effect) 设置轮廓效果使用 PathEffect pathEffect = new DashPathEffect(new float[]{10, 5}, 10); paint.setPathEffect(pathEffect); 共有6 种 PathEffect： (1) CornerPathEffect -- 圆角 (2) DashPathEffect -- 虚线效果 (3) DiscretePathEffect -- 离散路径效果 (4) PathDashPathEffect -- 印章路径效果 (5) ComposePathEffect合并两个特效是有先后顺序的，它会先将第二个参数的PathEffect innerpe的特效作用于路径上，然后再在此加了特效的路径上作用第二个特效。 (6) SumPathEffect是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。 分为两类： 单一效果的 1. CornerPathEffect ：把所有拐角变成圆角 PathEffect pathEffect = new CornerPathEffect(20); paint.setPathEffect(pathEffect); 构造方法 CornerPathEffect(float radius) 的参数 radius 是圆角的半径。使用 //第1组 拐角弧度 Path path = new Path(); path.moveTo(100,200); path.lineTo(400,50); path.lineTo(700,200); path.lineTo(1000,70); canvas.drawPath(path,paintStyle(Color.GREEN,0,null,0)); //画布下移 canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.WHITE,50,null,0)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.YELLOW,100,null,0)); canvas.translate(0,200); private Paint paintStyle(int color, int corner, float[] floats, int phase) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); //设置拐角度数 paint.setPathEffect(new CornerPathEffect(corner)); //设置间断线 if (floats != null) { paint.setPathEffect(new DashPathEffect(floats,phase)); } paint.setStyle(Paint.Style.STROKE); return paint; } - **2. DiscretePathEffect** ：离散路径效果 PathEffect pathEffect = new DiscretePathEffect(20, 5); paint.setPathEffect(pathEffect); 构造方法 DiscretePathEffect(float segmentLength, float deviation) 的两个参数中， segmentLength 是用来拼接的每个线段的长度， deviation 是偏离量。 使用 //第3组 离散 canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.GREEN,2,14)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.WHITE,4,8)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.YELLOW,8,4)); private Paint paintStyle(int color,float someLength, float deviation) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); /** * segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为2的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。 deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。 */ paint.setPathEffect(new DiscretePathEffect(someLength,deviation)); paint.setStyle(Paint.Style.STROKE); return paint; } 3. DashPathEffect ：虚线效果 PathEffect pathEffect = new DiscretePathEffect(20, 5); paint.setPathEffect(pathEffect); 使用 //第2组 间隔线 float[] floats = new float[]{30,10}; float[] floats2 = new float[]{100,30}; float[] floats3 = new float[]{10,30,90,20}; /** * 对于intervals[]数组的有两个限定： 长度必须大于等于2；因为必须有一个实线段和一个空线段来组成虚线。 个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。 对于phase：开始绘制的偏移值 */ canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.GREEN,0,floats,0)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.WHITE,50,floats2,50)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.YELLOW,100,floats3,100)); canvas.translate(0,200); private Paint paintStyle(int color, int corner, float[] floats, int phase) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); //设置拐角度数 paint.setPathEffect(new CornerPathEffect(corner)); //设置间断线 if (floats != null) { paint.setPathEffect(new DashPathEffect(floats,phase)); } paint.setStyle(Paint.Style.STROKE); return paint; } - **4. PathDashPathEffect** ：印章路径效果 Path dashPath = ...; // 使用一个三角形来做 dash PathEffect pathEffect = new PathDashPathEffect(dashPath, 40, 0, PathDashPathEffectStyle.TRANSLATE); paint.setPathEffect(pathEffect); 构造方法 PathDashPathEffect(Path shape, float advance, float phase, PathDashPathEffect.Style style) shape ： 参数是用来绘制的 Path ； advance ：是两个相邻的 shape 段之间的间隔，不过注意，这个间隔是两个 shape 段的起点的间隔，而不是前一个的终点和后一个的起点的距离； phase “和 DashPathEffect 中一样，是虚线的偏移； style ：是用来指定拐弯改变的时候 shape 的转换方式。style 的类型为 PathDashPathEffect.Style ，是一个 enum ，具体有三个值： TRANSLATE：位移 ROTATE：旋转 MORPH：变体 使用 Path mPath = new Path(); mPath.moveTo(0,20); mPath.lineTo(10,0); mPath.lineTo(20,20); mPath.close(); /** *向路径添加一个闭圆轮廓 * Direction:方向 cw:顺时针, ccw:逆时针旋转 * @param x要添加到路径的圆的中心的x坐标 * @param y要添加到路径的圆的中心的y坐标 * @param radius要添加到路径的圆的半径 * @param dir滚动圆圈轮廓的方向 */ mPath.addCircle(0,0,3, Path.Direction.CCW); mPath.addCircle(20,0,3, Path.Direction.CW); canvas.translate(0,80);//通过变形印章来过渡转角 canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,30,12,PathDashPathEffect.Style.MORPH)); canvas.translate(0,80);//通过旋转印章来过渡转角 canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,40,12,PathDashPathEffect.Style.ROTATE)); canvas.translate(0,80);//通过位移来过渡转角 canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,80,12,PathDashPathEffect.Style.TRANSLATE)); private Paint paintStylePashDush(int color, Path shape, float advance, float phase, PathDashPathEffect.Style style) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); /** Path shape:表示印章路径，比如我们下面示例中的三角形加右上角一个点； float advance：表示两个印章路径间的距离,很容易理解，印章间距离越大，间距就越大。 float phase：路径绘制偏移距离，与上面DashPathEffect中的float phase参数意义相同 Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE; Style.ROTATE表示通过旋转印章来过渡转角； Style.MORPH表示通过变形印章来过渡转角； Style.TRANSLATE表示通过位移来过渡转角。 */ paint.setPathEffect(new PathDashPathEffect(shape,advance,phase,style)); paint.setStyle(Paint.Style.STROKE); return paint; } ![](http://oy991qm3u.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-15%2010.44.45.png) 组合效果 5. SumPathEffect ：分别按照两种 PathEffect 分别对目标进行绘制。 PathEffect dashEffect = new DashPathEffect(new float[]{20, 10}, 0); PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new SumPathEffect(dashEffect, discreteEffect); 6. ComposePathEffect ：也是一个组合效果类的 PathEffect 先对目标 Path 使用一个 PathEffect，然后再对这个改变后的 Path 使用另一个 PathEffect。 PathEffect dashEffect = new DashPathEffect(new float[]{20, 10}, 0); PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new ComposePathEffect(dashEffect, discreteEffect); 两者曲别： 第 5 种效果是分别将2种效果都绘制出来，2者都可见。第 6 种效果是县绘制第一种效果，然后在第一种效果上再绘制第二种效果，最终呈现的是：在第一种效果上的第二种效果 使用 canvas.translate(0,250); //通过变形印章来过渡转角 PathDashPathEffect dashPathEffect = new PathDashPathEffect(mPath,40,0,PathDashPathEffect.Style.TRANSLATE); DiscretePathEffect discretePathEffect = new DiscretePathEffect(20,2); canvas.drawPath(path,paintStyleEffectCompose(Color.GREEN,discretePathEffect,dashPathEffect)); canvas.translate(0,140); //通过旋转印章来过渡转角 canvas.drawPath(path,paintStyleEffectSum(Color.GREEN,dashPathEffect,discretePathEffect)); //设置合并两个路径特效效果 private Paint paintStyleEffectCompose(int color, PathEffect effect1, PathEffect effect2) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); paint.setPathEffect(new ComposePathEffect(effect1,effect2)); paint.setStyle(Paint.Style.STROKE); return paint; } //设置合并两个路径特效效果 private Paint paintStyleEffectSum(int color, PathEffect effect1, PathEffect effect2) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); paint.setPathEffect(new SumPathEffect(effect1,effect2)); paint.setStyle(Paint.Style.STROKE); return paint; } 注意：PathEffect 在有些情况下不支持硬件加速，需要关闭硬件加速才能正常使用： Canvas.drawLine() 和 Canvas.drawLines() 方法画直线时，setPathEffect() 是不支持硬件加速的； PathDashPathEffect 对硬件加速的支持也有问题，所以当使用 PathDashPathEffect 的时候，最好也把硬件加速关了。 2.6 setShadowLayer(float radius, float dx, float dy, int shadowColor) 在之后的绘制内容下面加一层阴影如果要清除阴影层，使用 clearShadowLayer() 。 注意：在硬件加速开启的情况下， setShadowLayer() 只支持文字的绘制，文字之外的绘制必须关闭硬件加速才能正常绘制阴影。如果 shadowColor 是半透明的，阴影的透明度就使用 shadowColor 自己的透明度；而如果 shadowColor 是不透明的，阴影的透明度就使用 paint 的透明度。 2.7 setMaskFilter(MaskFilter maskfilter)基于整个画面来进行过滤 BlurMaskFilter ：模糊效果 paint.setMaskFilter(new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL)); 构造方法 BlurMaskFilter(float radius, BlurMaskFilter.Blur style) radius： 参数是模糊的范围 style： 是模糊的类型，共有四种： NORMAL: 内外都模糊绘制 SOLID: 内部正常绘制，外部模糊 INNER: 内部模糊，外部不绘制 OUTER: 内部不绘制，外部模糊 EmbossMaskFilter ：浮雕效果 2.8 获取绘制的 Path根据 paint 的设置，计算出绘制 Path 或文字时的 实际 Path。实际 Path ，指的就是 drawPath() 的绘制内容的轮廓，要算上线条宽度和设置的 PathEffect。 getFillPath(src, dst) 会计算出实际 Path，然后把结果保存在 dst 里。 getTextPath(String text, int start, int end, float x, float y, Path path) getTextPath(char[] text, int index, int count, float x, float y, Path path) 文字的绘制虽然使用 Canvas.drawText() 方法，但其实在下层，文字信息全是被转化成图形，对图形进行绘制的。 getTextPath() 方法，获取的就是目标文字所对应的 Path 。这两个方法， getFillPath() 和 getTextPath() ，就是获取绘制的 Path 的方法。之所以把它们归类到「效果」类方法，是因为它们主要是用于图形和文字的装饰效果的位置计算。 3 绘制文本实例公共方法private Paint paintStyle(int color, Paint.Style style){ Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); //设置文字对齐方式，取值：align.CENTER、align.LEFT或align.RIGHT paint.setTextAlign(Paint.Align.LEFT); //设置是否为粗体文字 paint.setFakeBoldText(false); //设置下划线 paint.setUnderlineText(false); //设置字体水平倾斜度，普通斜体字是-0.25 paint.setTextSkewX(/*(float) -0.25*/0f); //设置带有删除线效果 paint.setStrikeThruText(false); //只会将水平方向拉伸，高度不会变 paint.setTextScaleX(0); return paint; } private Paint paintStyleType(int color, Paint.Style style, Typeface typeface){ Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); paint.setTypeface(typeface); return paint; } private Paint paintStyleAlign(int color, Paint.Style style, Paint.Align align){ Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); paint.setTextAlign(align); return paint; } 基础的文字绘制//基线坐标(100,100) //第1个 基线坐标(100,100) canvas.drawText(strs,100,100,paintStyleAlign(Color.BLACK,Paint.Style.FILL, Paint.Align.LEFT)); //绘制基线Y轴 canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); //绘制基线X轴 canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE)); //第2个 canvas.translate(0,150); canvas.drawText(strs,600,100,paintStyleAlign(Color.BLACK,Paint.Style.FILL, Paint.Align.CENTER)); canvas.drawLine(600,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); canvas.drawLine(600,0,600,100,paintStyle(Color.RED,Paint.Style.STROKE)); //第3个 canvas.translate(0,100); canvas.drawText(strs,100,100,paintStyleAlign(Color.BLACK,Paint.Style.STROKE, Paint.Align.LEFT)); canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE)); //第4个 canvas.translate(0,100); canvas.drawText(strs,600,100,paintStyleAlign(Color.BLACK,Paint.Style.STROKE, Paint.Align.RIGHT)); canvas.drawLine(600,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); canvas.drawLine(600,0,600,100,paintStyle(Color.RED,Paint.Style.STROKE)); FontMetrics 字体的各种度量的类/** * 描述给定文本大小字体的各种度量的类。 请记住，Y值增加下降，所以这些值将是正的，测量距离上升的值将是负的 * 注意:在使用FontMetrics时必须为同一个Paint对象,否则,无法获取文字正确的位置关系 */ Paint paint12 = new Paint(); paint12.setAntiAlias(true); paint12.setStrokeWidth(2); paint12.setStyle(Paint.Style.STROKE); paint12.setColor(Color.BLACK); paint12.setTextSize(180); Paint.FontMetrics fontMetrics = paint12.getFontMetrics(); //可绘制的最高高度所在线 float top; //可绘制的最低高度所在线 float bottom; //系统建议的，绘制单个字符时，字符应当的最高高度所在线 float ascent; //系统建议的，绘制单个字符时，字符应当的最低高度所在线 float descent; /** * 建议在文本行之间添加的额外空格。 */ //fontMetrics.leading; top = 100 + fontMetrics.top; bottom = 100 + fontMetrics.bottom; ascent = 100 + fontMetrics.ascent; descent = 100 + fontMetrics.descent; canvas.translate(-90,300); canvas.drawText(strs,100,100,paint12); //绘制的文字基线 paint12.setStrokeWidth(2); canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); //可绘制的最高高度所在线 paint12.setColor(Color.RED); paint12.setStrokeWidth(4); canvas.drawLine(100,top,1080,top,paint12); //可绘制的最低高度所在线 paint12.setColor(Color.GREEN); paint12.setStrokeWidth(4); canvas.drawLine(100,bottom,1080,bottom,paint12); //系统建议的，绘制单个字符时，字符应当的最高高度所在线 paint12.setColor(Color.YELLOW); paint12.setStrokeWidth(2); canvas.drawLine(100,ascent,1080,ascent,paint12); //系统建议的，绘制单个字符时，字符应当的最低高度所在线 paint12.setColor(Color.BLACK); paint12.setStrokeWidth(2); canvas.drawLine(100,descent,1080,descent,paint12); //文字所占宽度 float width = paint12.measureText(strs); //文字所占高度 float height = bottom - top; Log.e(TAG, &quot;onDraw width: &quot; + width + &quot;, height : &quot; + height); //绘制文字所占区域的边框 Path pathRect = new Path(); RectF rectF2 = new RectF(100,top,width+100,bottom); paint12.setColor(Color.BLUE); paint12.setStrokeWidth(1); pathRect.addRect(rectF2, Path.Direction.CW); canvas.drawRect(rectF2,paint12); 根据路径绘制文字PathMeasure measure = new PathMeasure(pathRect,false); int length = (int) measure.getLength(); paint12.setTextSize(40); paint12.setColor(Color.RED); canvas.drawText(String.valueOf(length),width,bottom,paint12); //根据路径绘制文字 paint12.setColor(Color.BLACK); paint12.setTextSize(90); canvas.translate(0,200); Path rectPath = new Path(); RectF rectF = new RectF(400,200,1000,800); //顺时针 rectPath.addRect(rectF, Path.Direction.CW); canvas.drawPath(rectPath,paintStyle(Color.RED,Paint.Style.STROKE)); /** * @param hOffset 要添加到文本开始位置的路径上的距离 * @param vOffset（ - ）或以下的距离（+）定位文本的路径 */ paint12.setStyle(Paint.Style.FILL_AND_STROKE); canvas.drawTextOnPath(strs,rectPath,0,0,paint12); paint12.setStyle(Paint.Style.STROKE); canvas.drawTextOnPath(strs,rectPath,20,20,paint12); paint12.setStyle(Paint.Style.STROKE); paint12.setColor(Color.BLUE); canvas.drawTextOnPath(strs,rectPath,-20,-20,paint12); 顺时针 逆时针 4 初始化类这一类方法是用来初始化 Paint 对象，或者是批量设置 Paint 的多个属性的方法。 4.1 reset()重置 Paint 的所有属性为默认值。相当于重新 new 一个，不过性能当然高一些啦。 4.2 set(Paint src)把 src 的所有属性全部复制过来。相当于调用 src 所有的 get 方法，然后调用这个 Paint 的对应的 set 方法来设置它们。 4.3 setFlags(int flags)批量设置 flags。相当于依次调用它们的 set 方法。例如：  paint.setFlags(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG); 这行代码，和下面这两行是等价的： paint.setAntiAlias(true); paint.setDither(true);]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View-2 绘制图表：直角坐标系+饼状图]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View-2%20%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%EF%BC%9A%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB%2B%E9%A5%BC%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[步骤分析数据的表现形式 坐标系 饼状图 数据准备，获取图表的： 标题 各个数据项的名称 各个数据项的数值 将数据进行封装 在设定item尺寸范围时，需要设定： 规定好起始位置（X轴或Y轴的startValue） 坐标系确定好原点（0，0） 饼状图确定好圆心 各个item之间的间隔（space） 单个item的宽度或高度（比值） 直方图、折线图时平均分配item的高度、宽度； 饼状图时各个数据所占的扇形面积的大小（当前数据所占比例*360）。 有无特殊要求？具体实现标记重点：在自定义图表的实现过程中，尽量使用“对象获取”、“比例化”的数据。 两个图使用的同一个数据类：PhoneData1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class PhoneData &#123; String phoneName; float phoneValue; int phoneColor; public PhoneData(String phoneName, float phoneValue, int phoneColor) &#123; this.phoneName = phoneName; this.phoneValue = phoneValue; this.phoneColor = phoneColor; &#125; public String getPhoneName() &#123; return phoneName; &#125; public void setPhoneName(String phoneName) &#123; this.phoneName = phoneName; &#125; public float getPhoneValue() &#123; return phoneValue; &#125; public void setPhoneValue(float phoneValue) &#123; this.phoneValue = phoneValue; &#125; public int getPhoneColor() &#123; return phoneColor; &#125; public void setPhoneColor(int phoneColor) &#123; this.phoneColor = phoneColor; &#125; @Override public String toString() &#123; return "PhoneData&#123;" + "phoneName='" + phoneName + '\'' + ", phoneValue=" + phoneValue + ", phoneColor=" + phoneColor + '&#125;'; &#125;&#125; 坐标系的实现：一个完整的类，包括注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213/** * 直角坐标系 * * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class Histogram extends View &#123; private static final String TAG = "Histogram"; private String titleName = "直角坐标系"; private List&lt;PhoneData&gt; mPhoneData = null; private float maxVal = 0f; private float totalVal = 0f; private Paint mPaint = null; private DecimalFormat mDecimalFormat; public Histogram(Context context) &#123; super(context); &#125; public Histogram(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public Histogram(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void initData() &#123; mPhoneData = new ArrayList&lt;&gt;(); mPhoneData.add(new PhoneData("HuaWei", 38f, Color.RED)); mPhoneData.add(new PhoneData("Vivo", 23f, Color.BLUE)); mPhoneData.add(new PhoneData("Samsung", 33f, Color.GREEN)); mPhoneData.add(new PhoneData("Oppo", 12f, Color.YELLOW)); mPhoneData.add(new PhoneData("Apple", 41f, Color.MAGENTA)); mPhoneData.add(new PhoneData("XiaoMi", 17f, Color.LTGRAY)); mPhoneData.add(new PhoneData("Pixel2", 6f, Color.DKGRAY)); mPhoneData.add(new PhoneData("HTC", 11f, Color.MAGENTA)); mPhoneData.add(new PhoneData("MOTO", 9f, Color.CYAN)); for (PhoneData item : mPhoneData) &#123; maxVal = Math.max(maxVal, item.getPhoneValue()); totalVal = totalVal + item.getPhoneValue(); &#125; dealMaxVal(maxVal); Log.d(TAG, "(&gt;^ω^&lt;) -&gt; initData maxVal is : " + maxVal + ", totalVal is : " + totalVal); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); mPaint.setColor(Color.BLACK); mDecimalFormat = new DecimalFormat(".00"); &#125; private void dealMaxVal(float maxVal) &#123; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); initData(); mPaint.setStrokeWidth(1); mPaint.setTextSize(56); canvas.drawText(titleName, canvas.getWidth() / 2 - mPaint.measureText(titleName) / 2, canvas.getHeight() * 0.07f, mPaint); mPaint.setColor(Color.BLACK); canvas.translate(canvas.getWidth() * 0.1f, canvas.getHeight() * 0.9f); mPaint.setStrokeWidth(5); //方式：2,两者均可实现绘制 canvas.drawLine(0f, 0f, canvas.getWidth() * 0.8f, 0f, mPaint); canvas.drawLine(0f, 0f, 0f, -canvas.getHeight() * 0.8f, mPaint); //item的宽度和间隔 float itemWidth = canvas.getWidth() * 0.8f / mPhoneData.size() * 0.8f; float itemSpace = canvas.getWidth() * 0.8f / mPhoneData.size() * 0.2f; //绘制直方图 drawRect(canvas, itemSpace, itemWidth, maxVal); //绘制数值文字 drawTextValue(canvas, itemSpace, itemWidth, maxVal); //绘制折线 drawLines(canvas, itemSpace, itemWidth, maxVal); //绘制点 drawPoint(canvas, itemSpace, itemWidth, maxVal); //绘制最高数值参考线 drawKindOfValLine(canvas, itemSpace, itemWidth); &#125; private void drawKindOfValLine(Canvas canvas, float itemSpace, float itemWidth) &#123; int maxValIndex = 0; mPaint.setColor(Color.BLUE); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStrokeWidth(2); float aveVal = totalVal / mPhoneData.size(); for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; if (maxVal == mPhoneData.get(i).getPhoneValue()) &#123; maxValIndex = i; &#125; &#125; //最大值的表示 float valueYMax = -maxVal / maxVal * canvas.getHeight() * 0.7f; String maxStr = mDecimalFormat.format(mPhoneData.get(maxValIndex).getPhoneValue()); canvas.drawLine(0f, valueYMax, maxValIndex * (itemSpace + itemWidth) + (itemSpace + itemWidth / 2), valueYMax, mPaint); canvas.drawText(maxStr, -mPaint.measureText(maxStr) - 10f, valueYMax, mPaint); //平均值的表示 float valueYAve = -aveVal / maxVal * canvas.getHeight() * 0.7f; String aveStr = mDecimalFormat.format(aveVal); canvas.drawLine(0f, valueYAve, canvas.getWidth() * 0.8f, valueYAve, mPaint); canvas.drawText(aveStr, -mPaint.measureText(aveStr) - 10f, valueYAve, mPaint); &#125; private void drawRect(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; float startXY = 0f; mPaint.setTextSize(36); mPaint.setStrokeWidth(1); for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); //绘制X轴文字 - 横向 canvas.drawText(item.getPhoneName(), startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2, 60, mPaint); //绘制X轴文字 - 有一定角度 /* Path path = new Path(); path.moveTo(startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2, 30); path.lineTo(startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2 + 30, 30 + mPaint.measureText(item.getPhoneName())); canvas.drawTextOnPath(item.getPhoneName(),path,0,0,mPaint);*/ //绘制直方图 canvas.drawRect(startXY + itemSpace, -item.getPhoneValue() / maxVal * canvas.getHeight() * 0.7f, startXY + itemSpace + itemWidth, 0, mPaint); //重新绘制item的起始点 startXY += itemSpace + itemWidth; &#125; &#125; private void drawTextValue(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; float startXY = 0f; mPaint.setTextSize(36); mPaint.setStrokeWidth(1); for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); //绘制直方图上方的数值文字 canvas.drawText(String.valueOf(item.getPhoneValue()), startXY + itemSpace + (itemWidth - mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2, -item.getPhoneValue() / maxVal * canvas.getHeight() * 0.7f - 20f, mPaint); //重新绘制item的起始点 startXY += itemSpace + itemWidth; &#125; &#125; private void drawPoint(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(20); mPaint.setStrokeCap(Paint.Cap.ROUND); float startX = itemSpace + itemWidth / 2; float startY = 0f; for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; canvas.drawPoint(startX, startY, mPaint); startX = startX + itemSpace + itemWidth; &#125; &#125; private void drawLines(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(5); float startX = itemSpace + itemWidth / 2; float startY = 0f; float endX = 0f; for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; if (i == 0) &#123; startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; canvas.drawPoint(startX, startY, mPaint); &#125; else &#123; endX = startX + itemSpace + itemWidth; canvas.drawLine(startX, startY, endX, -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f, mPaint); startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; startX = endX; &#125; &#125; &#125;&#125; /* 绘制x，y轴 方式：1 canvas.drawLine(canvas.getWidth() * 0.1f, canvas.getHeight() * 0.9f,canvas.getWidth() * 0.9f,canvas.getHeight() * 0.9f,mPaint); canvas.drawLine(canvas.getWidth() * 0.1f,canvas.getHeight() * 0.9f,canvas.getWidth() * 0.1f,canvas.getHeight() * 0.1f,mPaint); */ 饼状图的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * PieChart 饼状图 * * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class PieChart extends View &#123; private static final String TAG = "PieChart"; private String titleName = "饼状图"; private List&lt;PhoneData&gt; mPhoneData = null; private float maxVal = 0f; private float totalVal = 0f; private Paint mPaint = null; /** * 起始角度 */ private float startAngle; /** * 划过角度 */ private float swepAngle; /** * 划过角度的一半 */ private float halfSwepAngle; /** * 指示文字的标线 X 轴起始点。 */ private float lineStartX; private float lineStartY; private float lineEndX; private float lineEndY; private float radius = 0f; private float divideStart = 90; private float divideEnd = 270; private DecimalFormat decimalFormat; public PieChart(Context context) &#123; super(context); &#125; public PieChart(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public PieChart(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void initData()&#123; mPhoneData = new ArrayList&lt;&gt;(); mPhoneData.add(new PhoneData("HuaWei",38f, Color.RED)); mPhoneData.add(new PhoneData("Vivo",23f,Color.BLUE)); mPhoneData.add(new PhoneData("Samsung",33f,Color.GREEN)); mPhoneData.add(new PhoneData("Oppo",12f,Color.YELLOW)); mPhoneData.add(new PhoneData("Apple",41f,Color.MAGENTA)); mPhoneData.add(new PhoneData("XiaoMi",17f,Color.LTGRAY)); mPhoneData.add(new PhoneData("Pixel2",6f,Color.DKGRAY)); for (PhoneData item : mPhoneData) &#123; maxVal = Math.max(maxVal,item.getPhoneValue()); totalVal = totalVal + item.getPhoneValue(); &#125; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); mPaint.setStrokeWidth(1); mPaint.setColor(Color.BLACK); //构造方法的字符格式这里如果小数不足2位,会以0补足. decimalFormat=new DecimalFormat("######0.00"); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); /* 圆点坐标：(x0,y0) 半径：r 角度：a0 则圆上任一点为：（x1,y1） x1 = x0 + r * cos(ao * 3.14 /180 ) y1 = y0 + r * sin(ao * 3.14 /180 ) */ initData(); mPaint.setTextSize(56); canvas.drawText(titleName,canvas.getWidth()/2 - mPaint.measureText(titleName)/2, canvas.getHeight() * 0.07f,mPaint); //移动画布的原点 canvas.translate(canvas.getWidth() / 2,canvas.getWidth() / 2 - 100f); float length = canvas.getWidth() * 0.25f; RectF rectF = new RectF(-length, -length,length,length); mPaint.setStrokeWidth(5); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStyle(Paint.Style.FILL); mPaint.setTextSize(36); radius = length; for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); swepAngle = item.getPhoneValue() / totalVal * 360f; halfSwepAngle = startAngle + swepAngle / 2; /* * 角度=弧度*180/Math.PI 圆点坐标：(x0,y0) 半径：r 角度：a0 则圆上任一点为：（x1,y1） x1 = x0 + r * cos(ao * 3.14 /180 ) y1 = y0 + r * sin(ao * 3.14 /180 ) */ lineStartX = (float) (radius * Math.cos(halfSwepAngle * Math.PI / 180)); lineStartY = (float) (radius * Math.sin(halfSwepAngle * Math.PI / 180)); lineEndX = (float) ((radius + 50) * Math.cos(halfSwepAngle * Math.PI / 180)); lineEndY = (float) ((radius + 50) * Math.sin(halfSwepAngle * Math.PI / 180)); if (maxVal == item.getPhoneValue()) &#123; //注意先保存当前canvas canvas.save(); canvas.translate(lineStartX * 0.1f, lineStartY * 0.1f); canvas.drawArc(rectF, startAngle, swepAngle - 2f, true, mPaint); canvas.drawLine(lineStartX,lineStartY,lineEndX,lineEndY,mPaint); //绘制各个区域的文字 diffLineLength(canvas, item); //绘制各个区域的数值 diffLineVal(canvas, item); //绘制百分比 //diffPercentage(canvas,item); &#125; else &#123; canvas.drawArc(rectF,startAngle,swepAngle - 2f,true,mPaint); canvas.drawLine(lineStartX,lineStartY,lineEndX,lineEndY,mPaint); diffLineLength(canvas, item); diffLineVal(canvas, item); //diffPercentage(canvas,item); &#125; if (maxVal == item.getPhoneValue()) &#123; // 特殊工作做完之后，再回复之前保存的canvas canvas.restore(); &#125; startAngle += swepAngle; &#125; &#125; private void diffLineLength(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; canvas.drawLine(lineEndX, lineEndY, lineEndX - 100, lineEndY, mPaint); canvas.drawText(item.getPhoneName(), lineEndX - 120 - mPaint.measureText(item.getPhoneName()), lineEndY, mPaint); &#125; else &#123; canvas.drawLine(lineEndX,lineEndY,lineEndX + 100,lineEndY,mPaint); canvas.drawText(item.getPhoneName(),lineEndX + 120,lineEndY,mPaint); &#125; &#125; private void diffLineVal(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; mPaint.setColor(Color.WHITE); canvas.drawText(String.valueOf(item.getPhoneValue()),(lineEndX - (mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2) * 0.5f,(lineEndY) * 0.5f, mPaint); &#125; else &#123; mPaint.setColor(Color.WHITE); canvas.drawText(String.valueOf(item.getPhoneValue()),(lineEndX + (mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2) * 0.5f,(lineEndY) * 0.5f, mPaint); &#125; &#125; private void diffPercentage(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; mPaint.setColor(Color.WHITE); canvas.drawText(decimalFormat.format(item.getPhoneValue() / totalVal *100) + "%",(lineEndX - mPaint.measureText(decimalFormat.format(item.getPhoneValue()))) / 2,(lineEndY) * 0.5f, mPaint); &#125; else &#123; mPaint.setColor(Color.WHITE); canvas.drawText(decimalFormat.format(item.getPhoneValue() / totalVal *100) + "%" ,(lineEndX - mPaint.measureText(decimalFormat.format(item.getPhoneValue()))) / 2,(lineEndY) * 0.5f, mPaint); &#125; &#125;&#125;]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计原则：依赖倒置原则要依赖抽象，不要依赖具体类。 这个原则比起“针对接口编程，不针对实现编程”更加强调的是“抽象”。不让高层组件依赖底层组件，而且不论“高层”还是“底层”，两者都依赖“抽象”。 这个模式的学习，首先通过一个自己以前最常见的编码开始（自己在学校编写小项目时曾经真的这么写过 ，好囧啊 ﾍ(;´Д｀ﾍ) ）。 引出问题 这样看可能并不会特别直观，但是只要转换为图形…… 通过这个图形的，我们已经很直观的能看到问题的所在：有点“牵一发而动全身”的意思。这样的编写违背了面向接口编程的原则，而且耦合程度高：一个类与众多的类之间保持着依赖关系。 进行倒置 依赖倒置原则中的“倒置”究竟“倒”在哪里？“倒置”指的是和一般的OO设计思想方式相反，倒置你针对问题进行设计时的思维方式。 如何避免违反依赖倒置原则： 变量不可以持有具体类的引用。 在此例中，使用工厂方法来避免new 不要让类派生自具体的类。 不要覆盖基类中已实现的方法 抽象工厂模式的定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。抽象工厂的任务是定义创建一组产品的接口，接口内的每个方法负责创建一个具体的产品，同时我们利用实现抽象工厂子类来实现这个创建方法。抽象工厂中利用工厂方法实现生产方法是相当自然的做法。 停止于： 2017-11-08 15:10:25 专向：Android高级进阶]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StarUML的使用]]></title>
    <url>%2FStarUML%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[StarUML使用参考：http://blog.csdn.net/eyckwu/article/details/53871841UML学 : http://www.uml.org.cn/oobject/201104212.asp各种图（流程图，思维导图，UML，拓扑图，ER图）简介 ：http://www.cnblogs.com/jiqing9006/p/3344221.html 文章持续更新中…… 码云拾遗 明星效应。很简单，在一个领域保持顶尖水平，比在一两个领域保持领先水平和五六个领域保持一般水准都要更有价值、并且收益更好。 有悖常识的真相：让未来更开放的方式，正是专注的去做好一件事情。这个世界上最成功的人，他们在某一领域获得成功之后，可通过经营杠杆进入任何他们想要涉足的领域。而这都得依赖于他们曾极致的专注在做好一件事情上。 正文StarUML是一个韩国人用DELPHI写的UML工具，支持UML2.0。 UML分为：1. 静态建模：系统基础和系统固定框架结构，这些图形往往是“静态”的。2. 类图(Class Diagram)：常用来分析业务概念3. 用例图(Use Case Diagram)：由参与者、用例以及它们之间的关系构成的使用参考：https://www.2cto.com/os/201502/377091.html 参与者：是指存在于系统外部并直接与系统交互的人、系统或设备等。 用例：是系统为参与者提供的功能。 用例命名：取一个简单、概括性的名称，一般是带有动作性的名称。 用例表示：用椭圆表示，椭圆下面附有用例的名称、实线箭头，在用例图中用于连接参与者与用例，用例方向指向用例。 用例与用例之间的三种关系： 1. 泛化（generalization）代表一般与特殊的关系 2. 包含（include）关系 3. 扩展（extend）关系 4. 对象图(Object Diagram)5. 构件图(Component Diagram)：表示组件之间的关系6. 部署图(Deployment Diagram)：部署软件应用的物理设备信息2. 动态建模：描述的是某种行为，是“动态”的。 活动图(Activity Diagram)：类似流程图 状态机图(State Machine Diagram) 时序图(Sequence Diagram)：捕捉一段时间范围内多个对象之间的交互信息， 强调信息交互的时间顺序。 通讯图(Communication Diagram) 时间图(Timing Diagram) StarUML使用Mode的选择选择更为具体的图 添加更为丰富的元素 1. 类图的画法概览 如上图是一个类图，下面对每一个图标的内容进行解释（从左到右，从从上到下）。左侧： 标识Class的可见性（默认public） 添加note，进行对类的说明 右侧： 增加类的属性 增加类的行为 添加reception 添加子类 添加父类 添加已有的接口 添加需要的接口 添加关联 添加聚合 添加组合 添加端口 添加组件 具体1. 类图包括：类名 + 属性 + 方法 2. 类图之间的关系1. 泛化（Generalization）： 就是面向对象中的继承，奔驰、宝马、奥迪都继承自汽车类 表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节，直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 2. 实现（interface Realization）：圆圈代表接口 一般接口实现的画法及表示：在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。 3. 依赖（Dependency）： 对象之间最弱的一种关联方式，是临时性的关联，代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。 一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。 在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。 StarUML的使用同下图 4. 关联4.1 一般关联(Association) : 对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。 在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 4.2 聚合关联(Aggregation) : 表示has-a的关系，是一种不稳定的包含关系。 较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。 在类图使用空心的菱形表示，菱形从局部指向整体。 4.3 组合(Composition) : 表示contains-a的关系，是一种强烈的包含关系。 组合类负责被组合类的生命周期，是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。 在类图使用实心的菱形表示，菱形从局部指向整体。 5. 多重性(Multiplicity) :通常在关联、聚合、组合中使用。就是代表有多少个关联对象存在。使用数字..星号（数字）表示。 2. 用例图]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顶级程序员的10条最佳实践]]></title>
    <url>%2F%E9%A1%B6%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8410%E6%9D%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[今天看到了公众号推荐的文章，写的相当的棒，所有连标题都没有修改，直接就搬了过来，供自己勉励。 来源：https://mp.weixin.qq.com/s/LtgV6YNlgtPdRx788plbgg 1. 慎重选择第 1 门语言编程语言各有不同，不过区别不大。 但用语言的人区别就大了。选择了一门语言你就选择了一个群落。 – Sam Kaufman，自由职业者，iOS 开发者，10x management 如果你想快速建立原型（尤其对于希望对产品进行迭代升级的创始人来说），那就用 Ruby 或者 Javascript – Erin Parker，Spitfire Athlete 创始人兼首席开发者 2. 你不是程序猿！伟大的开发者能够建构并开发应用。 惊艳的开发者能够在关注业务的同时做这件事。 业务端的人大都不懂编码，但是肯定能够理解特定功能背后的动机。 别人说什么开发者就做什么，没有去理解为什么要这么做，导致双方均错失了机会，这样的事情太常见了。 – John Coggeshall，自由职业者，web 开发者，10x Management，PHP 核心贡献者 精通编程是一个崇高的职业目标。一旦实现了这个目标，别忘了考虑一下你自己。不要成为任何公司的奴隶或者在毫无价值的东西上浪费你的时间。 — Greg Sadetsky， Python 及 Javascript 专家，10x Managemen；协同办公空间 Abri.co 创始人 要想按期完成，得在开始技术工作之前事先进行项目沟通（哪怕这并非先决条件），因为其他人的响应速度千变万化。 – Andrew Wilcox ，web 应用开发者，Meteor 核心贡献者，10x Management 3. 保持敏捷，不断交付早发布，不断发布，边说唱边发布。 – Max Nanis ，自由职业者，web 开发者，生物信息学专家，10x Management 不断测试。好的测试包如保单和煤矿里的金丝雀之结合。它能帮助你在生产周期中更早地找出错误，而错误越早发现越容易解决。 – Jeremy Green，自由职业者，web 开发者，专长 Ruby on Rails，10x Management 快速失败。编码（及生活）时我希望尽早知道什么地方不能工作，而不是放任不管让它增殖扩散。全面放开，快速失败，修补缺陷，不断继续。 – Stephanie Volftsun，Knotch 联合创始人兼 CTO 为所有代码编写自动测试！尽可能践行测试驱动的开发。 – Zoran Kacic-Alesic，Industrial Light &amp; Magic 研发主管 4. 保持对测试流程的控制许多项目深受多测试周期之苦。这会拖累项目，导致组织整体出现高级别的问题。 程序员应该专注于对自己的代码进行单元测试及半回归测试。 他们比其他任何人更了解代码库，也知道自己会影响到哪些变更。有时此类变更会由于 QA 测试范围有限而缺失，因此导致生产环节出现重大问题。 – Sanjib Sahoo，tradeMONSTER CTO 要想在力所能及的情况下尽快开发出无缺陷代码，永远永远也不要把写测试放到后面。我们更清楚这一点。要检查一下测试的覆盖率，确保 100% 无死角。 – Seth Purcell，Signpost 工程副总裁 5. 如果你是自由职业者，要学会说不，哪怕面对的是金钱要对时间和成本有一个合理的评估，然后把它加倍。如果大家都说 “这应该很简单，” 那就做 – Ryan Waggoner ，自由职业者，web 及移动应用开发者，10x Management 6. 荣誉属于过去，理论是一回事，但实践更重要改进软件开发质量的最好方式就是去开发软件。 许多雄心勃勃的刚入门的工程师花了很多的业务时间去读书，关于最新工具的、关于开放流程的，诸如此类的东西。很多人都是这么消磨自己的闲暇时间的，但这样很容易就把你给耽搁了。 别这样，通过尽可能用脑来强化大脑负责开发软件的那部分。 –James Cropcho，General Assembly 的 Ruby on Rails 专家及讲师 不断探索。 我见过的许多编码者手上都有几个在进行的业务项目。做业务项目迫使你要探索新技术然后学习创建应用的方方面面。 你可能需要做前端的 HTML/CSS，后端的 API 集成，数据库优化，做移动 app，还得设置自己的服务器。 – Andrew Waage，Retention Science CTO 及联合创始人 7. 结对评审是你的秘密武器结对编程非常必要。 两个程序员联合开发同一个模块可以相互审查对方的代码。开发团队每周也要召开代码审查会议，让每一个开发者给其他人的代码提供反馈意见，解释如何更好地改进代码。 这能够形成一种协作文化，把开发者的自负抛开！ – Sanjib Sahoo 8. 像躲瘟疫一样避免过早优化只有在问题和解决方案都出现在你面前时才进行重构！ 过早重构是时间上的巨大浪费。不要投入半年后可能被扔掉的任何东西的完善上。 过早优化是罪恶之源。 –Seth Purcell 不要过早优化！ 我不断看到工程师在用户还没有到 1000 的时候一再对扩充到 100 万的用户规模担心。 – Mariya Yao，Xanadu Mobile 创始人兼创意总监，移动开发者及设计师 9. 你的代码只写一次，可别人会读它千万遍你写的代码机器会解析执行，可其他人却需要读你的代码，理解它，摆弄它。 你必须明白，你的代码会有未来的观众。 代码也是一种书写形式的沟通。 – Tracy Chou，Pinterest 软件工程师 听起来很奇怪，但是你永远都得替自己的未来着想。问问自己：如果你有健忘症的话，你还能不能理解自己写过的代码？ – Wai Ching Jessica Lam，Sugarbox 联合创始人兼 CTO 通读你的文档。 设计改动很多，有时候代码更新的时候注释不一定会跟进。保持文档的更新，未来的人（包括你自己）理解起来就更容易。 我说不清有多少次我看回自己代码时总在想：“我到底在干什么？” 只要我写出了好的注释，未来头疼就少很多。 – Kitt Vanderwater，Google 软件工程师 10. 这是一个崇高的职业，把你的技能用到好的地方。帮助他人是深层次的人类需求。想办法用你的工作来改善人类，你就会有成功的把握。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬虫框架使用]]></title>
    <url>%2FScrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Scrapy框架使用指南：http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.htmlScrapy零基础使用：http://www.jb51.net/article/57183.htm 问：把网站装进爬虫需要几步？答：四步。 1. 新建项目2. 明确目标3. 制作爬虫4. 存储内容 注意：# coding=utf-8 使用Scrapy爬虫框架时应该添加此条语句表明注释是中文注释 1. 新建项目使用命令新建一个scrapy项目 scrapy startproject projectName 建立项目的文件目录 scrapyproject ├── scrapy.cfg └── scrapyproject ├── __init__.py ├── items.py ├── middlewares.py ├── pipelines.py ├── settings.py └── spiders └── __init__.py 2 directories, 7 files 各个文件的作用： scrapy.cfg ：项目的配置文件 scrapyproject/ ：项目的Python模块，将会从这里引用代码 scrapyproject/items.py ：项目的items文件 scrapyproject/pipelines.py ：项目的pipelines文件 scrapyproject/settings.py ：项目的设置文件 scrapyproject/spiders/ ：具体执行爬虫的目录 2. 明确目标在Scrapy中，items是用来管理抓取内容的容器，有点像Python中的Dict，但是提供了一些额外的保护减少错误。 一般来说，item可以用scrapy.item.Item类来创建，并且用scrapy.item.Field对象来定义属性（可以理解成类似于ORM映射关系，类似于java bean）。 编写Item：修改scrapyproject目录下的items.py4文件，在原本的class后面添加我们自己的class。 import scrapy class PyScrapy1601Item(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() pass class DmozItem(scrapy.Item): node = scrapy.Field() 3. 爬虫实现先爬后取 3.1 爬要建立一个Spider，你必须用scrapy.spider.BaseSpider创建一个子类，并确定三个强制属性： name ：爬虫的识别名称，必须是唯一的。 start_urls ：爬取的URL列表。爬虫从这里开始抓取数据。 parse() ：解析的方法，调用的时候传入从每一个URL传回的Response对象作为唯一参数，负责解析并匹配抓取的数据(解析为item)。 allow_domains ：allow_domains是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页。一个模板： from scrapy.spider import Spider from scrapy.selector import Selector from py_scrapy_16_01.py_scrapy_16_01.items import DmozItem class DmozSpider(Spider): name = &quot;dmoz&quot; allowed_domains = [&quot;dmoztools.net&quot;] start_urls = [ &quot;http://dmoztools.net/Computers/Programming/Languages/Python/&quot;, ] def parse(self, response): sel = Selector(response) sites = sel.xpath(&apos;//div[@class=&quot;browse-node&quot;]/text()&apos;) items2 = [] for node in sites: item = DmozItem() item[&apos;href&apos;] = node.extract() items2.append(item) return items2 进入到 /scrapyproject/scrapyproject下 运行 scrapy crawl dmoz 执行了这条命令发生了啥？首先，Scrapy为爬虫的 start_urls 属性中的每个URL创建了一个scrapy.http.Request 对象 ，并将爬虫的parse() 方法指定为回调函数。然后，这些 Request 被调度并执行，之后通过parse()方法返回 scrapy.http.Response 对象，并反馈给爬虫。 3.2 取爬取整个网页完毕，接下来的就是的取过程了。在基础的爬虫里，这一步可以用正则表达式来抓。在Scrapy里，使用一种叫做 XPath selectors的机制，它基于 XPath表达式。 例子：/html/head/title : 选择HTML文档元素下面的&lt;title&gt;标签。/html/head/title/text() : 选择前面提到的&lt;title&gt; 元素下面的文本内容//td: 选择所有 &lt;td&gt; 元素//div[@class=”mine”] : 选择所有包含 class=&quot;mine&quot; 属性的div标签元素 xpath路径表达式： 表达式 描述 / 从根节点选取 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 更多使用参考 W3C-XPath ：http://www.w3school.com.cn/xpath/index.asp 为了方便使用XPaths，Scrapy提供XPathSelector 类，有2种可以选择: HtmlXPathSelector (HTML数据解析) XmlXPathSelector (XML数据解析) 必须通过一个 Response 对象对他们进行实例化操作，如： sel = Selector(response) Selector对象展示了文档的节点结构。因此，第一个实例化的selector必与根节点或者是整个目录有关 。在Scrapy里面，Selectors 有4种基础的方法： xpath() ：返回一系列的selectors，每一个select表示一个xpath参数表达式选择的节点。 css() ：返回一系列的selectors，每一个select表示一个css参数表达式选择的节点。 extract() ：返回一个unicode字符串，即选中的数据。 re() ：返回一串一个unicode字符串，即使用正则表达式抓取出来的内容。 3.3 xpath()测试在终端输入： scrapy shell http://dmoztools.net/Computers/Programming/Languages/Python/ 在没有报错的情况下，输入 response.headers 得到： 在没有报错的情况下，输入 response.body 得到： 4. 存储内容保存信息的最简单的方法是通过Feed exports，主要有4种：JSON，JSON lines，CSV，XML。我们将结果用最常用的JSON导出，命令如下： scrapy crawl dmoz -o items.json -t json 其中，-o 后面是导出文件名，-t 后面是导出类型。 Pycharm中运行爬虫程序错误1. NameError: global name ‘DmozItem’ is not definedFile &quot;/Users/yannischeng/PycharmProjects/First_Python_Project/spiderone/spiderone/spiders/dmoe_spider.py&quot;, line 20, in parse item = DmozItem() NameError: global name &apos;DmozItem&apos; is not defined 解决方案：使用相对导入 from ..items import DmozItem 第一个点(.) 表示当前目录，第二个点表示上一级父目录。这样做还有一个额外的好处就是你可以随意修改你的包的名称，松耦合。 2. Scrapy爬取中文，显示ascii码，如何转变成utf-8正常编码？ 参考：http://www.jianshu.com/p/c03d968ef68b 将爬取到的中文信息存储为json格式的文件时，文字显示就会出现问题，存储为xml时就不会有问题。本要求应该显示的是：摘要，而实际显示的内容为：\&quot;\u6458\u8981 解决方案：使用json包中的json.dumps(dictname,ensure_ascii=False)具体案例使用： item[&apos;node&apos;] = json.dumps(node.extract(), ensure_ascii=False) print(item[&apos;node&apos;]) 摘要: 把系统换到了fedora,记录几个相关的配置 3. scrapy` 的 parse() return 值必须是Request, BaseItem, dict or None，如果返回str报错[scrapy.core.scraper] ERROR: Spider must return Request, BaseItem, dict or None, got &apos;str&apos; in &lt;GET http://www.cnblogs.com/aLittleBitCool/&gt; 4. scrapy爬虫得到的json文件是ascii码问题 参考：http://bbs.fishc.com/thread-85672-1-1.html import json #记得添加这两个库 import codecs class XXXPipeline(object): #XXX就是你建立scrapy工程的名称 def __init__(self): #添加一下初始化方法 self.file = codecs.open(&apos;item.json&apos;, &apos;wb&apos;, encoding=&apos;utf-8&apos;) #item.json指的是你要保存的json格式文件的名称，编码格式一般都是&apos;utf-8&apos; def process_item(self, item, spider): line = json.dumps(dict(item),ensure_ascii=False) + &apos;\n&apos; #这一句会将你每次返回的字典抓取出来,“ensure_ascii=False”这一句话很重要，如果是True的话就是我们保存的\u4e2d\u56fd这种格式了 self.file.write(line) #写入到文件中 return item 将以上内容插入pipelines.py,同时在settings.py中加入 ITEM_PIPELINES = { &apos;panda.pipelines.PandaPipeline&apos;: 300 }]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来自他人的编程技巧总结]]></title>
    <url>%2F%E6%9D%A5%E8%87%AA%E4%BB%96%E4%BA%BA%E7%9A%84%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[函数不要超过 50 行。 不要一次性写太多来不及测的代码，而是要写一段调试一段。 UT 和编码要同步做。 多写注释方便的往往是自己。 碰到一堆问题时，一次只尝试解决一个问题。 没把握一眼看出问题症结的时候，老老实实单步调试。 设计模式是个好东西，但不要强行使用。 没造成可观的损失前不要尝试做性能优化。 没事别重复造轮子。 大多数情况下 Boss 不关心技术含量，而且往往简单的解决方案更快更有效果。 不要害怕接触新知识，因为害怕也没用，不管你愿意不愿意，你现在会的东西 5 年后就会过时。 重构是程序员的主力技能。 工作日志能提升脑容量。 先用 profiler 调查，才有脸谈优化。 漫山遍野的注释实际背景噪音。 普通程序员 + google = 超级程序员。 写单元测试总是合算的。 不要先写框架再写实现。最好反过来，从原型中提炼框架。 代码结构清晰，其它问题都不算事儿。 管理行不行，就看工作流。 编码不要畏惧变化，要拥抱变化。 常充电。程序员只有一种死法：土死的。 相信你的同事的能力，你不能解决的问题，他们说不能就能神奇的解决 不要相信的你的同事，他们能神奇地解决的方式，往往都是新问题的原因 相信你的同事，他能解决这个问题。 不能相信你的同事，他把问题变得更糟糕了。 但是你还是必须相信你的同事，因为有他在，这些问题还是可以解决的 不能相信你的同事，当问题无法解决的时候，他可能就辞职不干了。 要相信自己，一定可以解决同事或者前任遗留下来的任何问题。 要相信新进来了员工，如果有任何自己无法解决的技术问题，相信新员工可以用非常神奇的方法解决 编程之事，隔离是方向，起名是关键，测试是主角，调试是补充，版本控制是后悔药。 一行代码一个兵。形成建制才能有战斗力。单位规模不宜过大，千人班，万人排易成万人坑。 重构 / 优化 / 修复 Bug，同时只能作一件。 简单模块注意封装，复杂模块注意分层。 人脑性能有限，整洁胜于杂乱。读不懂的代码，尝试整理下格式; 不好用的接口，尝试重新封装下。 迭代速度决定工作强度。想多快好省，就从简化开发流程，加快迭代速度开始。 忘掉优化写代码。过早优化等同恶意破坏；忘掉代码作优化。优化要基于性能测试，而不是纠结于字里行间。 最好的工具是纸笔; 其次好的是 markdown。 leader 问任务时间，若答不上来，可能是任务拆分还不够细。 宁可多算一周，不可少估一天。过于 “乐观” 容易让 boss 受惊吓。 最有用的语言是 English。其次的可能是 Python。 百闻不如一见。画出结果，一目了然。调试耗时将大大缩短。 资源、代码应一道受版本管理。资源匹配错误远比代码匹配错误更难排查。 不要基于想象开发， 要基于原型开发。原型的价值是快速验证想法，帮大家节省时间。 序列化首选明文文本 。诸如二进制、混淆、加密、压缩等等有需要时再加。 编译器永远比你懂微观优化。只能向它不擅长的方向努力。 不要定过大、过远、过细的计划。即使定了也没有用。 至少半数时间将花在集成上。时间，时间，时间总是不够。 与主流意见 / 方法 / 风格 / 习惯相悖时，先检讨自己最可靠。 出现 bug 主动查，不管是不是你的。这能让你业务能力猛涨、个人形象飙升; 如果你的 bug 被别人揪出来….. 呵呵，那你会很被动～≧﹏≦ 不知怎么选技术书时就挑薄的。起码不会太贵，且你能看完。 git 是最棒的。简单，可靠，免费。 仅对 “可预测的非理性” 抛断言。 Log 要写时间与分类。并且要能重定向输出。 注释是稍差的文档。更好的是清晰的命名。让代码讲自己的故事。 造轮子是很好的锻炼方法。前提是你见过别的轮子。 code review 最好以小组 / 结对的形式。对业务有一定了解，建议会更有价值（但不绝对）。而且不会成为负担。管理员个人 review 则很容易成 team 的瓶颈。 提问前先做调研。问不到点上既被鄙视，又浪费自己的时间。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境下MySQL的安装与使用]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[平台：Mac环境 mysql操作命令参考：http://www.runoob.com/mysql/mysql-tutorial.html 安装 官网下载地址 https://dev.mysql.com/downloads/file/?id=473576 默认安装目录 /usr/local/ 安装时弹出的默认密码，在第一次登录时需要用到： A temporary password is generated for root@localhost: gkct&gt;2Wajv5W 安装完成 登录mysql （连接远程数据库，默认端口号：3306） 远程连接 mysql -h主机地址 -u用户名 －p用户密码 登录mysql （连接本地数据库） mysql -u root -p 输入密码 登录后，修改密码 SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;新密码&apos;); 开启/关闭 - 手动 系统偏好设置 -&gt; mysql 修改mysql编码 查看编码 默认设置： mysql&gt; show variables like &apos;%char%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.01 sec) 修改 在目录：/usr/local/mysql/support-files下找里面有没有my-default.cnf或my.cnf文件. 如果有则直接打开添加: 在[client]在下面添加 default-character-set=utf8 默认字符集为utf8 在[mysqld] 添加 default-character-set=utf8 默认字符集为utf8 设定连接mysql数据库时使用utf8编码，以让mysql数据库为utf8运行 init_connect=&apos;SET NAMES utf8&apos; 若是没有在/etc下新建my.cnf。执行命令： $ cd /etc $ sudo vim my.cnf 将 本文 附录内容粘贴到文件中后，保存退出即可。注意：修改完编码后要 退出之后再次进入 才能生效修改之后的编码设置 mysql&gt; show variables like &apos;%char%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.00 sec) 卸载MySQLsudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* vim /etc/hostconfig (and removed the line MYSQLCOM=-YES-) rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* MySQL操作命令 命令操作参考：http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html命令操作参考：http://blog.csdn.net/qi49125/article/details/77887100 数据库操作查看版本号select version(); 查询所有数据库show database; 使用数据库use 数据库名称 创建数据库create database 数据库名 删除数据库drop database 数据库名 备份数据库外部数据库 导入登录 mysql -u root -p; 选择数据库 use databaseName; 将外部的.sql文件拖入终端中 source 命令后面，然后回车 source 拖如.sql文件; 内部数据库 导出在终端中，要进入存储文件的目录，然后再执行导出操作 cd 待存文件的目录 导出MySQL中的所有数据库（结构+数据）mysqldump -u root -p --all-databases &gt; dafadf00.sql; 导出MySQL中的单个数据库（结构+数据）mysqldump -u root -p database_name &gt; sql_name.sql 导出单个数据库中的单张表，导出命令中加了一个表名（结构+数据）mysqldump -u root -p database_name table_name &gt; sql_name.sql 导出数据库的结构 （仅结构）mysqldump -u root -p --add-drop-table temp &gt; /Users/yannischeng/Desktop/outfile_name.sql 导出查询数据结果到指定文件 参考：http://blog.csdn.net/u011677147/article/details/64129606 在做mysql导出数据的时候，遇到的问题如下： ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement mysql 默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。解决方法： 查询mysql 的secure_file_priv配置，使用命令行： show global variables like &apos;%secure%&apos;; 查询结果 secure_file_prive=null -- 限制mysqld 不允许导入导出 secure_file_priv=/tmp/ -- 限制mysqld的导入导出只能发生在/tmp/目录下 secure_file_priv=&apos; &apos; -- 不对mysqld 的导入 导出做限制 更改secure_file_pri的值：/usr/local/mysql/support-files中的my-default.cnf配置文件，就把它复制到/private/etc中，重命名为“my.cnf”，并加入secure_file_priv=’’，重启mysql服务器即可。 使用 into outfile 开始导出： select * from table_name into outfile &apos;/Users/yannischeng/Desktop/NewFile.txt&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\n&apos;; 因为导出的数据会出现一些乱码或者特殊字符，所以使用以上关键字进行转义。 出现问题 ERROR 1 (HY000): Can&apos;t create/write to file &apos;/Users/yannischeng/Desktop/NewFile.txt&apos; (Errcode: 13 - Permission denied 表操作use 数据库名; 删除表drop table 表名; 删除表中数据delete from 表名,……，…… where 表达式; 显示当前数据库的表show tables; 显示表的数据结构describe 表名; 或者 desc 表名; 或者 show columns from 表名; 创建表mysql&gt; create table student( -&gt; id int(4) not null primary key auto_increment, -&gt; name char(20) not null, -&gt; age int(4) not null, -&gt; address char(100), -&gt; other varchar(100) default &quot;null&quot;); rename 修改表名alter table 旧表名 rename 新表名; 或者 rename table 原表名 新表名; 修改表结构：增（add）、删（drop）、改（modify）、重命名（change）可通过after 字段名、first精确控制添加的位置。 add 增加字段alter table 表名 add 字段名 字段设置 字段位置; modify 修改字段alter table 表名 modify 字段名 字段设置 字段位置; change 重命名字段alter table 表名 change 旧字段名 新字段名 字段设置; drop 删除字段alter table 表名 drop 字段名; 数据操作增单条数据 insert into student (,&apos;yannis&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;); 多条数据 insert into student values (13,&apos;tom&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;),(21,&apos;jack&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;); 指定字段插入数据 insert into 表名 (字段名) values (&apos;数值&apos;); 删delete from 表名 where 条件; 改update 表名 set name=&apos;marry&apos; where id=13; 查查询数据完整语法 select [distinct][统计函数] 字段名/* from 数据源 [where 条件子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]; distinct ：去重复 统计函数 ： Count()： 统计分组后的记录数，每一相同的组有多少行记录 Max()： 统计每组最大的值 Min()： 统计每组最小的值 Avg()： 统计每组的平均值 Sum()： 统计每组的和 where ：条件 group by 字段 ：分组。根据某个字段进行分组，相同的放一组，不同的分到不同的组。统计的是数据，不是记录。 having 子句 ：与where子句一样进行条件判断，为什么是group by……having…… 而不是group by……where? 因为：进行数据统计时，是数据进入内存之后，会进行分组 -&gt; 统计 -&gt; having条件判断。而where是针对从磁盘读取数据时进行判断，此刻还没分组，进行统计就判断了。所以错误！ order by 子句 ：order by根据某个字段进行升序或降序排序，基本语法： order by 字段名 [asc/desc]; asc升序 可不写 desc降序 limit 子句 ：是一种限制结果的语句。 1）用来限制数量 2) 限制起始位置 limit 起始位置，长度。分页常用。 内连接，外连接，自然连接，交叉连接 内连接：从左表中取出每一条记录，和右表中所有的记录进行匹配，匹配必须是左表中与右表中某个条件相同，最终会保留结果，否则不保留。基本语法： 左表 [inner] join 右表 on 左表.字段 = 右表.字段; select * from my_student inner join my_class on my_student.C_id = mu_class.id; 左外连接：左表为主，然后每条记录与右表进行连接，不管能不能匹配的上，左表都会保留。能匹配，右表某条记录保留，不能匹配，某条记录置为NULL，最终记录数至少不少于左表已有的记录。基本语法： 左表 left join 右表 on 左表.字段 = 右表.字段; 当前时间：select now(); 附录# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the &quot;--help&quot; option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 init_connect=&apos;SET NAMES utf8 port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect=&apos;SET NAMES utf8&apos; # Don&apos;t listen on a TCP/IP port at all. This can be a security enhancement, # if all processes that need to connect to mysqld run on the same host. # All interaction with mysqld must be made via Unix sockets or named pipes. # Note that using this option without enabling named pipes on Windows # (via the &quot;enable-named-pipe&quot; option) will render mysqld useless! # #skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master&apos;s port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST=&apos;125.564.12.1&apos;, MASTER_PORT=3306, # MASTER_USER=&apos;joe&apos;, MASTER_PASSWORD=&apos;secret&apos;; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables&apos; values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 16-安装爬虫工具Scrapy]]></title>
    <url>%2FPython3%20%2016-%E5%AE%89%E8%A3%85%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7Scrapy%2F</url>
    <content type="text"><![CDATA[python的学习在今天又开始了：人生苦短，我用python。 安装Scrapy需要使用到：pip（python2）、pip3（python3），由于之前已经安装，此处忽略。 平台：Macpython2 pippython3 pip3 使用pip进行安装注意：安装过程还是比较曲折的 (〒︿〒) sudo pip install scrapy 错误 - 1 ： Found existing installation: six 1.4.1 DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project. Uninstalling six-1.4.1: ... OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-89wTP6-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info&apos; 根据网上得出的解决方案： 重启电脑，按住 option 键，–&gt; 再按 command + r 进入 Recovery模式 –&gt; 工具选择终端输入： csrutil disable 然后 reboot 再次执行 sudo pip install Scrapy 进行安装，结果依然出错。错误 - 2 ： Found existing installation: six 1.4.1 DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project. Uninstalling six-1.4.1: Successfully uninstalled six-1.4.1 Running setup.py install for PyDispatcher ... done Running setup.py install for Twisted ... done 注意： Running setup.py install for PyDispatcher ... done Running setup.py install for Twisted ... done 因为未安装 以上两个，导致 Scrapy未能安装成功。错误描述为： AttributeError: &apos;module&apos; object has no attribute &apos;OP_NO_TLSv1_1&apos; 安装 twisted $ pip install twisted==15.4.0 仍然报错 - 3 ： AttributeError: &apos;module&apos; object has no attribute &apos;OP_NO_TLSv1_1&apos; 更新pyOpenSSl sudo pip install --upgrade pyOpenSSl 最终出现： Successfully uninstalled pyOpenSSL-0.13.1 Successfully installed asn1crypto-0.23.0 cffi-1.11.2 cryptography-2.1.2 enum34-1.1.6 idna-2.6 ipaddress-1.0.18 pyOpenSSl-17.3.0 pycparser-2.18 然后输入： scrapy version 出现结果： Scrapy 1.4.0 安装成功！ 使用pip3进行安装 参考：http://www.jianshu.com/p/d00a19f6c4ed 提示：在使用 pip3 进行安装时，首先应该执行以下步骤： sudo -s pip3 install --ignore-installed six 否则报错： PermissionError: [Errno 13] Permission denied: &apos;/usr/local/Cellar/python3/3.6.1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/six.py&apos; 然后执行： sudo -s pip3 install scrapy 结果： Installing collected packages: cssselect, queuelib, w3lib, PyDispatcher, lxml, parsel, idna, pycparser, cffi, asn1crypto, cryptography, pyOpenSSL, pyasn1, attrs, pyasn1-modules, service-identity, hyperlink, incremental, zope.interface, Automat, constantly, Twisted, scrapy Successfully installed Automat-0.6.0 PyDispatcher-2.0.5 Twisted-17.9.0 asn1crypto-0.23.0 attrs-17.2.0 cffi-1.11.2 constantly-15.1.0 cryptography-2.1.2 cssselect-1.0.1 hyperlink-17.3.1 idna-2.6 incremental-17.5.0 lxml-4.1.0 parsel-1.2.0 pyOpenSSL-17.3.0 pyasn1-0.3.7 pyasn1-modules-0.1.5 pycparser-2.18 queuelib-1.4.2 scrapy-1.4.0 service-identity-17.0.0 w3lib-1.18.0 zope.interface-4.4.3 验证： YannisCheng:source yannischeng$ python3 Python 3.6.1 (default, Apr 4 2017, 09:40:21) [GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.38)] on darwin Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; import scrapy &gt;&gt;&gt; 安装成功]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 快捷键]]></title>
    <url>%2FAndroid-Studio%E4%BD%BF%E7%94%A8%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A52%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[键盘快捷键 快捷键参考：https://developer.android.google.cn/studio/intro/keyboard-shortcuts.htmlAndroid Studio使用指南：https://developer.android.google.cn/studio/projects/android-library.html 常规 说明 Windows/Linux Mac 全部保存 Control + S Command + S 同步 Control + Alt + Y Command + Option + Y 最大化/最小化编辑器 Control + Shift + F12 Control + Command + F12 添加到收藏夹 Alt + Shift + F Option + Shift + F 使用当前配置文件检查当前文件 Alt + Shift + I Option + Shift + I 快速切换模式 Control + （反引号） Control + `（反引号） 打开设置对话框 Control + Alt + S Command + ,（英文逗号） 打开项目结构对话框 Control + Alt + Shift + S Command + ;（英文分号） 在标签和工具窗口之间切换 Control + Tab Control + Tab 在 Studio 内导航和搜索 说明 Windows/Linux Mac 搜索全部内容（包括代码和菜单） 按两次 Shift 按两次 Shift 查找 Control + F Command + F 查找下一个 F3 Command + G 查找上一个 Shift + F3 Command + Shift + G 替换 Control + R Command + R 查找操作 Control + Shift + A Command + Shift + A 按符号名称搜索 Control + Alt + Shift + N Command + Option + O 查找类 Control + N Command + O 查找文件（而不是类） Control + Shift + N Command + Shift + O 在路径中查找 Control + Shift + F Command + Shift + F 打开文件结构弹出式菜单 Control + F12 Command + F12 在打开的编辑器标签之前导航 Alt + 向右/向左箭头 Control + 向右/向左箭头 跳到源代码 F4 / Control + Enter F4 / Command + 向下箭头 在新窗口中打开当前编辑器标签 Shift + F4 Shift + F4 最近打开的文件弹出式菜单 Control + E Command + E 最近编辑的文件弹出式菜单 Control + Shift + E Command + Shift + E 转到上一个编辑位置 Control + Shift + 退格键 Command + Shift + 退格键 关闭活动编辑器标签 Control + F4 Command + W 从工具窗口返回到编辑器窗口 Esc Esc 隐藏活动或上一个活动工具窗口 Shift + Esc Shift + Esc 转到行 Control + G Command + L 打开类型层次结构 Control + H Control + H 打开方法层次结构 Control + Shift + H Command + Shift + H 打开调用层次结构 Control + Alt + H Control + Option + H s 编写代码 说明 Windows/Linux Mac 生成代码（getter、setter、构造函数、hashCode/equals、toString、新文件、新类） Alt + Insert Command + N 替换方法 Control + O Control + O 实现方法 Control + I Control + I 控制语句 (if…else / try…catch / etc.) Control + Alt + T Command + Option + T 删除插入符处的行 Control + Y Command + 退格键 折叠/展开当前代码块 Control + 减号/加号 Command + 减号/加号 折叠/展开所有代码块 Control + Shift + 减号/加号 Command + Shift + 减号/加号 复制当前行或选择 Control + D Command + D 基本代码自动完成 Control + 空格键 Control + 空格键 智能代码自动完成（按预期类型过滤方法和变量列表） Control + Shift + 空格键 Control + Shift + 空格键 完成语句 Control + Shift + Enter Command + Shift + Enter 快速文档查找 Control + Q Control + J 显示选定方法的参数 Control + P Command + P 转到声明（直接） Control + B 或 Control + 点击 Command + B 或 Command + 点击 转到实现 Control + Alt + B Command + Alt + B 转到超类方法/超类 Control + U Command + U 打开快速定义查找 Control + Shift + I Command + Y 切换项目工具窗口的可见性 Alt + 1 Command + 1 切换书签 F11 F3 通过助记切换书签 Control + F11 Option + F3 通过行注释添加注释/取消注释 Control + / Command + / 通过块注释添加注释/取消注释 Control + Shift + / Command + Shift + / 选择连续增加的代码块 Control + W Option + Up 将当前选择退回到上一个状态 Control + Shift + W Option + Down 移动到代码块起始位置 Control + [ Option + Command + [ 移动到代码块结束位置 Control + ] Option + Command + ] 从当前位置选择到代码块起始位置 Control + Shift + [ Option + Command + Shift + [ 从当前位置选择到代码块结束位置 Control + Shift + ] Option + Command + Shift + ] 从当前位置删除到单词结尾 Control + Delete Option + Delete 从当前位置删除到单词开头 Control + 退格键 Option + 退格键 优化导入 Control + Alt + O Control + Option + O 项目快速修复（显示意图操作和快速修复） Alt + Enter Option + Enter 重新格式化代码 Control + Alt + L Command + Option + L 自动缩进行 Control + Alt + I Control + Option + I 缩进/取消缩进行 Tab/Shift + Tab Tab/Shift + Tab 智能行合并 Control + Shift + J Control + Shift + J 智能行拆分 Control + Enter Command + Enter 开始新行 Shift + Enter Shift + Enter 下一个/上一个突出显示的错误 F2 / Shift + F2 F2 / Shift + F2 构建并运行 说明 Windows/Linux Mac 构建 Control + F9 Command + F9 构建并运行 Shift + F10 Control + R 调试 说明 Windows/Linux Mac 调试 Shift + F9 Control + D 跳过 F8 F8 逐步执行 F7 F7 智能逐步执行 Shift + F7 Shift + F7 跳出 Shift + F8 Shift + F8 运行到光标位置 Alt + F9 Option + F9 评估表达式 Alt + F8 Option + F8 继续运行程序 F9 Command + Option + R 切换断点 Control + F8 Command + F8 查看断点 Control + Shift + F8 Command + Shift + F8 重构 说明 Windows/Linux Mac 复制 F5 F5 移动 F6 F6 安全删除 Alt + Delete Command + Delete 重命名 Shift + F6 Shift + F6 更改签名 Control + F6 Command + F6 内联 Control + Alt + N Command + Option + N 提取方法 Control + Alt + M Command + Option + M 提取变量 Control + Alt + V Command + Option + V 提取字段 Control + Alt + F Command + Option + F 提取常量 Control + Alt + C Command + Option + C 提取参数 Control + Alt + P Command + Option + P 版本控制/本地历史记录 说明 Windows/Linux MacOS 将项目提交到 VCS Control + K Command + K 从 VCS 更新项目 Control + T Command + T 查看最近变更 Alt + Shift + C Option + Shift + C 打开 VCS 弹出式菜单 Alt + `（反引号） Control + V]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android资源文件-color]]></title>
    <url>%2FAndroid%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6-color%2F</url>
    <content type="text"><![CDATA[官方参考：https://material.io/guidelines/style/color.html#color-color-palette 1234&lt;!-- 0 Black 黑色 --&gt;&lt;color name="Black"&gt;#000000&lt;/color&gt;&lt;!-- 0 White 白色 --&gt;&lt;color name="White"&gt;#FFFFFF&lt;/color&gt; 1234567891011&lt;!-- 1 Grey 灰色 --&gt;&lt;color name="Grey_50"&gt;#FAFAFA&lt;/color&gt;&lt;color name="Grey_100"&gt;#F5F5F5&lt;/color&gt;&lt;color name="Grey_200"&gt;#EEEEEE&lt;/color&gt;&lt;color name="Grey_300"&gt;#E0E0E0&lt;/color&gt;&lt;color name="Grey_400"&gt;#BDBDBD&lt;/color&gt;&lt;color name="Grey_500_bar"&gt;#9E9E9E&lt;/color&gt;&lt;color name="Grey_600"&gt;#757575&lt;/color&gt;&lt;color name="Grey_700"&gt;#616161&lt;/color&gt;&lt;color name="Grey_800"&gt;#424242&lt;/color&gt;&lt;color name="Grey_900"&gt;#212121&lt;/color&gt; 1234567891011&lt;!-- 2 Blue Grey 蓝灰色--&gt;&lt;color name="Blue_Grey_50"&gt;#FAFAFA&lt;/color&gt;&lt;color name="Blue_Grey_100"&gt;#CFD8DC&lt;/color&gt;&lt;color name="Blue_Grey_200"&gt;#B0BEC5&lt;/color&gt;&lt;color name="Blue_Grey_300"&gt;#90A4AE&lt;/color&gt;&lt;color name="Blue_Grey_400"&gt;#78909C&lt;/color&gt;&lt;color name="Blue_Grey_500_bar"&gt;#607D8B&lt;/color&gt;&lt;color name="Blue_Grey_600"&gt;#546E7A&lt;/color&gt;&lt;color name="Blue_Grey_700"&gt;#455A64&lt;/color&gt;&lt;color name="Blue_Grey_800"&gt;#37474F&lt;/color&gt;&lt;color name="Blue_Grey_900"&gt;#263238&lt;/color&gt; 123456789101112131415&lt;!-- 3 Red 红色--&gt;&lt;color name="r_50"&gt;#FFEBEE&lt;/color&gt;&lt;color name="r_100"&gt;#FFCDD2&lt;/color&gt;&lt;color name="r_200"&gt;#EF9A9A&lt;/color&gt;&lt;color name="r_300"&gt;#E57373&lt;/color&gt;&lt;color name="r_400"&gt;#EF5350&lt;/color&gt;&lt;color name="r_500_bar"&gt;#F44336&lt;/color&gt;&lt;color name="r_600"&gt;#E53935&lt;/color&gt;&lt;color name="r_700"&gt;#D32F2F&lt;/color&gt;&lt;color name="r_800"&gt;#C62828&lt;/color&gt;&lt;color name="r_900"&gt;#B71C1C&lt;/color&gt;&lt;color name="r_a100"&gt;#FF8A80&lt;/color&gt;&lt;color name="r_a200"&gt;#FF5252&lt;/color&gt;&lt;color name="r_a400"&gt;#FF1744&lt;/color&gt;&lt;color name="r_a700"&gt;#D50000&lt;/color&gt; 123456789101112131415&lt;!-- 4 Pink 粉色--&gt;&lt;color name="p_50"&gt;#FCE4EC&lt;/color&gt;&lt;color name="p_100"&gt;#F8BBD0&lt;/color&gt;&lt;color name="p_200"&gt;#F48FB1&lt;/color&gt;&lt;color name="p_300"&gt;#F06292&lt;/color&gt;&lt;color name="p_400"&gt;#EC407A&lt;/color&gt;&lt;color name="p_500_bar"&gt;#E91E63&lt;/color&gt;&lt;color name="p_600"&gt;#D81B60&lt;/color&gt;&lt;color name="p_700"&gt;#C2185B&lt;/color&gt;&lt;color name="p_800"&gt;#AD1457&lt;/color&gt;&lt;color name="p_900"&gt;#880E4F&lt;/color&gt;&lt;color name="p_a100"&gt;#FF80AB&lt;/color&gt;&lt;color name="p_a200"&gt;#FF4081&lt;/color&gt;&lt;color name="p_a400"&gt;#F50057&lt;/color&gt;&lt;color name="p_a700"&gt;#C51162&lt;/color&gt; 123456789101112131415&lt;!-- 5 Purple 紫色--&gt;&lt;color name="pur_50"&gt;#F3E5F5&lt;/color&gt;&lt;color name="pur_100"&gt;#E1BEE7&lt;/color&gt;&lt;color name="pur_200"&gt;#CE93D8&lt;/color&gt;&lt;color name="pur_300"&gt;#BA68C8&lt;/color&gt;&lt;color name="pur_400"&gt;#AB47BC&lt;/color&gt;&lt;color name="pur_500_bar"&gt;#9C27B0&lt;/color&gt;&lt;color name="pur_600"&gt;#8E24AA&lt;/color&gt;&lt;color name="pur_700"&gt;#7B1FA2&lt;/color&gt;&lt;color name="pur_800"&gt;#6A1B9A&lt;/color&gt;&lt;color name="pur_900"&gt;#4A148C&lt;/color&gt;&lt;color name="pur_a100"&gt;#EA80FC&lt;/color&gt;&lt;color name="pur_a200"&gt;#E040FB&lt;/color&gt;&lt;color name="pur_a400"&gt;#D500F9&lt;/color&gt;&lt;color name="pur_a700"&gt;#AA00FF&lt;/color&gt; 123456789101112131415&lt;!-- 6 Deep Purple 深紫色--&gt;&lt;color name="deep_pur_50"&gt;#EDE7F6&lt;/color&gt;&lt;color name="deep_pur_100"&gt;#D1C4E9&lt;/color&gt;&lt;color name="deep_pur_200"&gt;#B39DDB&lt;/color&gt;&lt;color name="deep_pur_300"&gt;#9575CD&lt;/color&gt;&lt;color name="deep_pur_400"&gt;#7E57C2&lt;/color&gt;&lt;color name="deep_pur_500_bar"&gt;#673AB7&lt;/color&gt;&lt;color name="deep_pur_600"&gt;#5E35B1&lt;/color&gt;&lt;color name="deep_pur_700"&gt;#512DA8&lt;/color&gt;&lt;color name="deep_pur_800"&gt;#4527A0&lt;/color&gt;&lt;color name="deep_pur_900"&gt;#311B92&lt;/color&gt;&lt;color name="deep_pur_a100"&gt;#B388FF&lt;/color&gt;&lt;color name="deep_pur_a200"&gt;#7C4DFF&lt;/color&gt;&lt;color name="deep_pur_a400"&gt;#651FFF&lt;/color&gt;&lt;color name="deep_pur_a700"&gt;#6200EA&lt;/color&gt; 123456789101112131415&lt;!-- 7 Indigo 靛蓝色 --&gt;&lt;color name="Indigo_50"&gt;#E8EAF6&lt;/color&gt;&lt;color name="Indigo_100"&gt;#C5CAE9&lt;/color&gt;&lt;color name="Indigo_200"&gt;#9FA8DA&lt;/color&gt;&lt;color name="Indigo_300"&gt;#7986CB&lt;/color&gt;&lt;color name="Indigo_400"&gt;#5C6BC0&lt;/color&gt;&lt;color name="Indigo_500_bar"&gt;#3F51B5&lt;/color&gt;&lt;color name="Indigo_600"&gt;#3949AB&lt;/color&gt;&lt;color name="Indigo_700"&gt;#303F9F&lt;/color&gt;&lt;color name="Indigo_800"&gt;#283593&lt;/color&gt;&lt;color name="Indigo_900"&gt;#1A237E&lt;/color&gt;&lt;color name="Indigo_a100"&gt;#8C9EFF&lt;/color&gt;&lt;color name="Indigo_a200"&gt;#536DFE&lt;/color&gt;&lt;color name="Indigo_a400"&gt;#3D5AFE&lt;/color&gt;&lt;color name="Indigo_a700"&gt;#304FFE&lt;/color&gt; 123456789101112131415&lt;!-- 8 Blue 蓝色 --&gt;&lt;color name="Blue_50"&gt;#E3F2FD&lt;/color&gt;&lt;color name="Blue_100"&gt;#BBDEFB&lt;/color&gt;&lt;color name="Blue_200"&gt;#90CAF9&lt;/color&gt;&lt;color name="Blue_300"&gt;#64B5F6&lt;/color&gt;&lt;color name="Blue_400"&gt;#42A5F5&lt;/color&gt;&lt;color name="Blue_500_bar"&gt;#2196F3&lt;/color&gt;&lt;color name="Blue_600"&gt;#1E88E5&lt;/color&gt;&lt;color name="Blue_700"&gt;#1976D2&lt;/color&gt;&lt;color name="Blue_800"&gt;#1565C0&lt;/color&gt;&lt;color name="Blue_900"&gt;#0D47A1&lt;/color&gt;&lt;color name="Blue_a100"&gt;#82B1FF&lt;/color&gt;&lt;color name="Blue_a200"&gt;#448AFF&lt;/color&gt;&lt;color name="Blue_a400"&gt;#2979FF&lt;/color&gt;&lt;color name="Blue_a700"&gt;#2962FF&lt;/color&gt; 123456789101112131415&lt;!-- 9 Light Blue 亮蓝色--&gt;&lt;color name="Light_Blue_50"&gt;#E1F5FE&lt;/color&gt;&lt;color name="Light_Blue_100"&gt;#B3E5FC&lt;/color&gt;&lt;color name="Light_Blue_200"&gt;#81D4FA&lt;/color&gt;&lt;color name="Light_Blue_300"&gt;#4FC3F7&lt;/color&gt;&lt;color name="Light_Blue_400"&gt;#29B6F6&lt;/color&gt;&lt;color name="Light_Blue_500_bar"&gt;#03A9F4&lt;/color&gt;&lt;color name="Light_Blue_600"&gt;#039BE5&lt;/color&gt;&lt;color name="Light_Blue_700"&gt;#0288D1&lt;/color&gt;&lt;color name="Light_Blue_800"&gt;#0277BD&lt;/color&gt;&lt;color name="Light_Blue_900"&gt;#01579B&lt;/color&gt;&lt;color name="Light_Blue_a100"&gt;#80D8FF&lt;/color&gt;&lt;color name="Light_Blue_a200"&gt;#40C4FF&lt;/color&gt;&lt;color name="Light_Blue_a400"&gt;#00B0FF&lt;/color&gt;&lt;color name="Light_Blue_a700"&gt;#0091EA&lt;/color&gt; 123456789101112131415&lt;!-- 10 Cyan 青色 --&gt;&lt;color name="Cyan_50"&gt;#E0F7FA&lt;/color&gt;&lt;color name="Cyan_100"&gt;#B2EBF2&lt;/color&gt;&lt;color name="Cyan_200"&gt;#80DEEA&lt;/color&gt;&lt;color name="Cyan_300"&gt;#4DD0E1&lt;/color&gt;&lt;color name="Cyan_400"&gt;#26C6DA&lt;/color&gt;&lt;color name="Cyan_500_bar"&gt;#00BCD4&lt;/color&gt;&lt;color name="Cyan_600"&gt;#00ACC1&lt;/color&gt;&lt;color name="Cyan_700"&gt;#0097A7&lt;/color&gt;&lt;color name="Cyan_800"&gt;#00838F&lt;/color&gt;&lt;color name="Cyan_900"&gt;#006064&lt;/color&gt;&lt;color name="Cyan_a100"&gt;#84FFFF&lt;/color&gt;&lt;color name="Cyan_a200"&gt;#18FFFF&lt;/color&gt;&lt;color name="Cyan_a400"&gt;#00E5FF&lt;/color&gt;&lt;color name="Cyan_a700"&gt;#00B8D4&lt;/color&gt; 123456789101112131415&lt;!-- 11 Teal 蓝绿色 --&gt;&lt;color name="Teal_50"&gt;#E0F2F1&lt;/color&gt;&lt;color name="Teal_100"&gt;#B2DFDB&lt;/color&gt;&lt;color name="Teal_200"&gt;#80CBC4&lt;/color&gt;&lt;color name="Teal_300"&gt;#4DB6AC&lt;/color&gt;&lt;color name="Teal_400"&gt;#26A69A&lt;/color&gt;&lt;color name="Teal_500_bar"&gt;#009688&lt;/color&gt;&lt;color name="Teal_600"&gt;#00897B&lt;/color&gt;&lt;color name="Teal_700"&gt;#00796B&lt;/color&gt;&lt;color name="Teal_800"&gt;#00695C&lt;/color&gt;&lt;color name="Teal_900"&gt;#004D40&lt;/color&gt;&lt;color name="Teal_a100"&gt;#A7FFEB&lt;/color&gt;&lt;color name="Teal_a200"&gt;#64FFDA&lt;/color&gt;&lt;color name="Teal_a400"&gt;#1DE9B6&lt;/color&gt;&lt;color name="Teal_a700"&gt;#00BFA5&lt;/color&gt; 123456789101112131415&lt;!-- 12 Green 绿色 --&gt;&lt;color name="Green_50"&gt;#E8F5E9&lt;/color&gt;&lt;color name="Green_100"&gt;#C8E6C9&lt;/color&gt;&lt;color name="Green_200"&gt;#A5D6A7&lt;/color&gt;&lt;color name="Green_300"&gt;#81C784&lt;/color&gt;&lt;color name="Green_400"&gt;#66BB6A&lt;/color&gt;&lt;color name="Green_500_bar"&gt;#4CAF50&lt;/color&gt;&lt;color name="Green_600"&gt;#43A047&lt;/color&gt;&lt;color name="Green_700"&gt;#388E3C&lt;/color&gt;&lt;color name="Green_800"&gt;#2E7D32&lt;/color&gt;&lt;color name="Green_900"&gt;#1B5E20&lt;/color&gt;&lt;color name="Green_a100"&gt;#B9F6CA&lt;/color&gt;&lt;color name="Green_a200"&gt;#69F0AE&lt;/color&gt;&lt;color name="Green_a400"&gt;#00E676&lt;/color&gt;&lt;color name="Green_a700"&gt;#00C853&lt;/color&gt; 123456789101112131415&lt;!-- 13 Light Green 亮绿色--&gt;&lt;color name="Light_Green_50"&gt;#F1F8E9&lt;/color&gt;&lt;color name="Light_Green_100"&gt;#DCEDC8&lt;/color&gt;&lt;color name="Light_Green_200"&gt;#C5E1A5&lt;/color&gt;&lt;color name="Light_Green_300"&gt;#AED581&lt;/color&gt;&lt;color name="Light_Green_400"&gt;#9CCC65&lt;/color&gt;&lt;color name="Light_Green_500_bar"&gt;#8BC34A&lt;/color&gt;&lt;color name="Light_Green_600"&gt;#7CB342&lt;/color&gt;&lt;color name="Light_Green_700"&gt;#689F38&lt;/color&gt;&lt;color name="Light_Green_800"&gt;#558B2F&lt;/color&gt;&lt;color name="Light_Green_900"&gt;#33691E&lt;/color&gt;&lt;color name="Light_Green_a100"&gt;#CCFF90&lt;/color&gt;&lt;color name="Light_Green_a200"&gt;#B2FF59&lt;/color&gt;&lt;color name="Light_Green_a400"&gt;#76FF03&lt;/color&gt;&lt;color name="Light_Green_a700"&gt;#64DD17&lt;/color&gt; 123456789101112131415&lt;!-- 14 Lime 酸橙汁饮料 --&gt;&lt;color name="Lime_50"&gt;#F9FBE7&lt;/color&gt;&lt;color name="Lime_100"&gt;#F0F4C3&lt;/color&gt;&lt;color name="Lime_200"&gt;#E6EE9C&lt;/color&gt;&lt;color name="Lime_300"&gt;#DCE775&lt;/color&gt;&lt;color name="Lime_400"&gt;#D4E157&lt;/color&gt;&lt;color name="Lime_500_bar"&gt;#CDDC39&lt;/color&gt;&lt;color name="Lime_600"&gt;#C0CA33&lt;/color&gt;&lt;color name="Lime_700"&gt;#AFB42B&lt;/color&gt;&lt;color name="Lime_800"&gt;#9E9D24&lt;/color&gt;&lt;color name="Lime_900"&gt;#827717&lt;/color&gt;&lt;color name="Lime_a100"&gt;#F4FF81&lt;/color&gt;&lt;color name="Lime_a200"&gt;#EEFF41&lt;/color&gt;&lt;color name="Lime_a400"&gt;#C6FF00&lt;/color&gt;&lt;color name="Lime_a700"&gt;#AEEA00&lt;/color&gt; 123456789101112131415 &lt;!-- 15 Yellow 黄色 --&gt;&lt;color name="Yellow_50"&gt;#FFFDE7&lt;/color&gt;&lt;color name="Yellow_100"&gt;#FFF9C4&lt;/color&gt;&lt;color name="Yellow_200"&gt;#FFF59D&lt;/color&gt;&lt;color name="Yellow_300"&gt;#FFF176&lt;/color&gt;&lt;color name="Yellow_400"&gt;#FFEE58&lt;/color&gt;&lt;color name="Yellow_500_bar"&gt;#FFEB3B&lt;/color&gt;&lt;color name="Yellow_600"&gt;#FDD835&lt;/color&gt;&lt;color name="Yellow_700"&gt;#FBC02D&lt;/color&gt;&lt;color name="Yellow_800"&gt;#F9A825&lt;/color&gt;&lt;color name="Yellow_900"&gt;#F57F17&lt;/color&gt;&lt;color name="Yellow_a100"&gt;#FFFF8D&lt;/color&gt;&lt;color name="Yellow_a200"&gt;#FFFF00&lt;/color&gt;&lt;color name="Yellow_a400"&gt;#FFEA00&lt;/color&gt;&lt;color name="Yellow_a700"&gt;#FFD600&lt;/color&gt; 123456789101112131415&lt;!-- 16 Amber 琥珀色--&gt;&lt;color name="Amber_50"&gt;#FFF8E1&lt;/color&gt;&lt;color name="Amber_100"&gt;#FFECB3&lt;/color&gt;&lt;color name="Amber_200"&gt;#FFE082&lt;/color&gt;&lt;color name="Amber_300"&gt;#FFD54F&lt;/color&gt;&lt;color name="Amber_400"&gt;#FFCA28&lt;/color&gt;&lt;color name="Amber500_bar"&gt;#FFC107&lt;/color&gt;&lt;color name="Amber_600"&gt;#FFB300&lt;/color&gt;&lt;color name="Amber_700"&gt;#FFA000&lt;/color&gt;&lt;color name="Amber_800"&gt;#FF8F00&lt;/color&gt;&lt;color name="Amber_900"&gt;#FF6F00&lt;/color&gt;&lt;color name="Amber_a100"&gt;#FFE57F&lt;/color&gt;&lt;color name="Amber_a200"&gt;#FFD740&lt;/color&gt;&lt;color name="Amber_a400"&gt;#FFC400&lt;/color&gt;&lt;color name="Amber_a700"&gt;#FFAB00&lt;/color&gt; 123456789101112131415&lt;!-- 17 Orange 橘黄色--&gt;&lt;color name="Orange_50"&gt;#FFF3E0&lt;/color&gt;&lt;color name="Orange_100"&gt;#FFE0B2&lt;/color&gt;&lt;color name="Orange_200"&gt;#FFCC80&lt;/color&gt;&lt;color name="Orange_300"&gt;#FFB74D&lt;/color&gt;&lt;color name="Orange_400"&gt;#FFA726&lt;/color&gt;&lt;color name="Orange_500_bar"&gt;#FF9800&lt;/color&gt;&lt;color name="Orange_600"&gt;#FB8C00&lt;/color&gt;&lt;color name="Orange_700"&gt;#F57C00&lt;/color&gt;&lt;color name="Orange_800"&gt;#EF6C00&lt;/color&gt;&lt;color name="Orange_900"&gt;#E65100&lt;/color&gt;&lt;color name="Orange_a100"&gt;#FFD180&lt;/color&gt;&lt;color name="Orange_a200"&gt;#FFAB40&lt;/color&gt;&lt;color name="Orange_a400"&gt;#FF9100&lt;/color&gt;&lt;color name="Orange_a700"&gt;#FF6D00&lt;/color&gt; 123456789101112131415&lt;!-- 18 Deep Orange 深橘黄色--&gt;&lt;color name="Deep_Orange_50"&gt;#FBE9E7&lt;/color&gt;&lt;color name="Deep_Orange_100"&gt;#FFCCBC&lt;/color&gt;&lt;color name="Deep_Orange_200"&gt;#FFAB91&lt;/color&gt;&lt;color name="Deep_Orange_300"&gt;#FF8A65&lt;/color&gt;&lt;color name="Deep_Orange_400"&gt;#FF7043&lt;/color&gt;&lt;color name="Deep_Orange_500_bar"&gt;#FF5722&lt;/color&gt;&lt;color name="Deep_Orange_600"&gt;#F4511E&lt;/color&gt;&lt;color name="Deep_Orange_700"&gt;#E64A19&lt;/color&gt;&lt;color name="Deep_Orange_800"&gt;#D84315&lt;/color&gt;&lt;color name="Deep_Orange_900"&gt;#BF360C&lt;/color&gt;&lt;color name="Deep_Orange_a100"&gt;#FF9E80&lt;/color&gt;&lt;color name="Deep_Orange_a200"&gt;#FF6E40&lt;/color&gt;&lt;color name="Deep_Orange_a400"&gt;#FF3D00&lt;/color&gt;&lt;color name="Deep_Orange_a700"&gt;#DD2C00&lt;/color&gt; 1234567891011&lt;!-- 19 Brown 棕色--&gt;&lt;color name="Brown_50"&gt;#EFEBE9&lt;/color&gt;&lt;color name="Brown_100"&gt;#D7CCC8&lt;/color&gt;&lt;color name="Brown_200"&gt;#BCAAA4&lt;/color&gt;&lt;color name="Brown_300"&gt;#A1887F&lt;/color&gt;&lt;color name="Brown_400"&gt;#8D6E63&lt;/color&gt;&lt;color name="Brown_500_bar"&gt;#795548&lt;/color&gt;&lt;color name="Brown_600"&gt;#6D4C41&lt;/color&gt;&lt;color name="Brown_700"&gt;#5D4037&lt;/color&gt;&lt;color name="Brown_800"&gt;#4E342E&lt;/color&gt;&lt;color name="Brown_900"&gt;#3E2723&lt;/color&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>资源文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Sutdio 使用快人一步]]></title>
    <url>%2FAndroid%20Studio%E4%BD%BF%E7%94%A8%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A51%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[今日感悟，写在前面： 放手无关紧要，精于攻坚克难。 一、Android Studio 3.0 - Android Profiler分析器 参考：http://blog.csdn.net/niubitianping/article/details/72617864Android Studio 3.0 新特性：http://blog.csdn.net/niubitianping/article/details/72600923 二、Android Studio 官方用户指南 https://developer.android.google.cn/studio/intro/index.html 三、使用频率最高的3个快捷键： ⌘ + n：各种自动生成。 （control）⌃ + t 各位看官自己瞧瞧： （shift）⇧ + （control）⌃ + （enter） ⏎ 补充快捷键 四、插件插件安装位置：Android Studio -&gt; Preferences -&gt; Plugins。快捷键：⌘ + ,敲出⌘：⌃ + ⌘ + space，之后进行选择 1. 代码规范 - Alibaba Java Coding Guidelines阿里巴巴Java开发规约的插件。安装后在Android Studio显示为：可选择实时监测，也可以关闭检测。 2. 真机无线调试 - Android WiFi ADB通过WIFI连接手机和电脑。数据线插入你的手机，然后点击Connect，显示State = Connect后拔掉数据线即可。 3. 布局文件分组的插件 - folding-plugin图片来自网络 4. View注解绑定 - Android ButterKnife ZeleznyButterKnife是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。快捷键：⌘ + n使用时必须要将光标悬浮于 activity_main之上才能有效。 4.1 控件的点击事件异常时 只是在Java代码中写明了方法，但是并没有在XML代码中使用onClick=&quot;&quot;来描述此方法 在Java代码中只是声明了方法，当时并没有在方法中声明参数：(View view)。如果不写此参数，将会导致在调用方法时，找不到View中的 指定id 值。 4.2 空指针异常： Android Studio3.0之前 在 app模块 的 gradle 编译文件 build.gradle 加入下列代码： apply plugin: &apos;com.neenbedankt.android-apt&apos; 在 app模块 的 gradle 编译文件 build.gradle 中的 dependencies中加入 apt &apos;com.jakewharton:butterknife-compiler:8.0.1&apos; compile &apos;com.jakewharton:butfe:8.0.1&apos; 在 项目 的 gradle 编译文件 build.gradle 文件，在 dependencies 中加入 classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; Android Studio3.0 在 app模块 的 gradle 中的 dependencies中加入 compile &apos;com.jakewharton:butterknife:8.8.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos; 5. 资源文件状态生成 - SelectorChapek for Android通过资源文件命名自动生成Selector文件。 6. ViewHolder代码自动生成 - AndroidCodeGenerator在 res/layout/文件夹下选择你适配器的item layout的布局文件，然后右键，如图所示： 选择其中一项之后，会弹出一个窗口，在这个窗口已经根据item布局文件默认生成了一个适配器类，你所要做的就是根据自己的实际需求进行修改。 7. 自动findViewById() - Prettify据Layout自动生成findViewById。使用方式同ButterKnife快捷键：⌘ + n 后选择 View Variables 或者 View Fields区别： 前者View Variables生成的是私有变量 后者 View Fields生成的是成员变量 8. 自动生成style代码 - Android Styler快捷键：⇧ + ⌘ + d效果如图： 9. 生命周期方法位置排序 - Lifecycle Sorter根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序。快捷键 ⌘ + ⌥ + K 10. Json数据格式化 - GsonFormatGsonFormat是一个快速格式化json数据，自动生成实体类参数的插件。快捷键：⌘ + n 后选择 GsonFormat。 11. Parcelable自动生成 - ParcelableGenerator自动生成Parcelable接口所需的代码。 Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。 而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。 Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。 Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据。 快捷键：⌘ + n 12. Android Material Design 风格图标全集 - Android Material Design Icon Generator通过此库可以获取MD风格的所有图标，更让人惊喜的是：选中的图标会自动生成各种 drawable 文件夹的图标，而且可以自定义颜色，绝对让人惊喜。快捷键：⌥ + ⌘ + m 选择指定图标以及自定义颜色。 五、组合指令1. 自定义组指令快捷键：⌘ + , 后选择 Live TemPlates，如下所示： 单击上图中的+可以添加自定义的组合键选择其中的AndroidLog即可进行自定义设置： 2. 已存在组合指令2.1 Log输出自定义 logt private static final String TAG = &quot;MainActivity &quot;; loge logi logd 2.2 循环 foreach for (: ) { } fori for (int i = 0; i &lt; ; i++) { } itar (array) for (int i = 0; i &lt; array.length; i++) { = array[i]; } iten (enum) while (enumeration.hasMoreElements()) { Object nextElement = enumeration.nextElement(); } itit (iterator) while (iterator.hasNext()) { Object next = iterator.next(); } itli (List) for (int i = 0; i &lt; list.size(); i++) { Object o = list.get(i); } 2.3 判定 ifn if (savedInstanceState == null) { } inn if (savedInstanceState != null) { } lazy if (savedInstanceState == null) { savedInstanceState = new Bundle(); } lnst if (savedInstanceState instanceof Object) { Object instanceState = (Object) savedInstanceState; } 2.4 View相关 gone .setVisibility(View.GONE); visible Toast Toast.makeText(this, &quot;&quot;, Toast.LENGTH_SHORT).show(); fbc () findViewById(R.id.); fixme // FIXME: 2017/10/26 todo lhm lhw 2.5 全局 static final 变量 psf public static final psfi public static final int psfs St]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HHKB 键位组合]]></title>
    <url>%2FHHKB%20%E9%94%AE%E4%BD%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[Mac环境下的键位组合 键位组合 效果 键位组合 效果 Shift + Option + Q Œ Option + Q œ W „ W ∑ E ´ E R ‰ R ® T ˇ T † Y Á Y ¥ U ¨ U I ˆ I O Ø O ø P ∏ P π A Å A å D Î D ∂ F Ï F ƒ G ˝ G © H Ó H ˙ J Ô J ∆ K  K ˚ L Ò L ¬ Z ¸ Z Ω X ˛ X ≈ C Ç C ç V ◊ V √ B ı B ∫ N ˜ N M Â M µ 1 ⁄ 1 ¡ 2 € 2 ™ 3 ‹ 3 £ 4 › 4 ¢ 5 ﬁ 5 ∞ 6 ﬂ 6 § 7 ‡ 7 ¶ 8 ° 8 • 9 · 9 ª 0 ‚ 0 º - — - – = = = ≠ \ » \ « ` ` ` [ ” [ “ ] ’ ] ‘ ; Ú ; … ‘ Æ ‘ æ , ¯ , ≤ . ˘ . ≥ / ¿ / ÷÷]]></content>
      <categories>
        <category>外设</category>
      </categories>
      <tags>
        <tag>外设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境下Hexo-GitHub-MWeb搭建个人博客]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BHexo-GitHub-MWeb%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[需要的工具：Node.js、Git、Hexo、Coding（自选）、MWeb（自选） 安装Git非重点，自行安装 Node.js非重点，自行安装 Hexo按照此命令进行安装Hexo$ sudo npm install -g hexo 初始化Hexo其中Blog_Hexo为自己建立的目标文件夹。只要是建立自己的任意一个博客，都可使用一下步骤。 $ hexo init Blog_Hexo 在“blog”文件夹中安装npm $ npm install 执行一下命令，查看是否安装成功 $ hexo s 在浏览器中打开：http://localhost:4000 能看到“Hexo”页面表示安装成功： 关联GitHub登录你的Github帐号，新建仓库，名为：用户名.github.io ，此为固定写法。创建之后为： 创建的Hexo文件夹为： cd到Blog_Hexo文件夹下，编辑_config.yml。注意：_config.yml 文件中的 ：后面要加一个空格 1）若是只将博客上传至GItHub中，编写 deploy: type: git repository: https://github.com/gonghonglou/gonghonglou.github.io.git branch: master 2）若是将博客同时上传至GItHub和Coding中，编写： deploy: type: git repo: github: git@github.com:YannisCheng/YannisCheng.github.io.git,master coding: git@git.coding.net:yannischeng/blog.git,master 在Blog_Hexo文件夹目录下执行生成静态页面命令： $ hexo g 此时若出现如下报错： ERROR Local hexo not found in ~/blog ERROR Try runing: &apos;npm install hexo --save&apos; 则执行命令： npm install hexo --save 若无报错，自行忽略此步骤。再执行配置命令： $ hexo d 执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命： $ npm install hexo-deployer-git --save 若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即 Username for &apos;https:// .github.com&apos;: Password for &apos;https:// .github.com&apos;: hexo deploy命令执行成功后，浏览器中打开网址http:// .github.io 能看到和打开 http://localhost:4000 时一样的页面。 发布cd到Blog_Hexo中，执行如下命令新建文章 hexo new &quot;hello-world&quot; 新的文件建立之后的位置为 编辑之后，在 Blog_Hexo 文件夹中执行如下命令 hexo generate //生成静态页面 hexo deploy //将文章部署到Github 至此，安装环节结束，可以进行基本的使用了。 安装主题NexT主题在Blog_Hexo目录下执行： git clone https://github.com/iissnan/hexo-theme-next themes/next 安装之后的文件位置为： 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 theme: next 修改主题为主题增加标签：hexo new page tags 为主题修改背景：在 \themes\next\layout\_layout.swig文件的&lt;/body&gt;上面添加 &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/ca 具体详细设置参考：https://github.com/hustcc/canvas-nest.js/blob/master/README-zh.md 问题杂集主题相关hexo next5.0主题不显示副标题打开themes/next/source/css/_schemes/Mist/_logo.styl 你会看见.site-subtitle { display: none; }删去或改成你想要的即可 为主题 添加字数统计、阅读时长、友情链接开启设置NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件Blog\themes\next_config.yml中打开wordcount统计功能即可 # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true 若只是打开开关，部署之后会发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等字样。 参考：http://blog.csdn.net/wangxw725/article/details/71602256?utm_source=itdadao&amp;utm_medium=referral 找到Blog\themes\next\layout\_macro\post.swig 文件注意： 在此文中出现 字数统计的配置英文字样时会报错！ 安装统计插件如果没有安装 hexo-wordcount 插件，先安装该插件： npm i --save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： npm install hexo-wordcount@2 --save 安装完成后，重新执行启动服务预览就可以了。 Hexo相关添加分类、标签云、关于等页面以添加分类页面为例，在站点目录下，打开git bash，输入 hexo new page &quot;categories&quot; 之后在站点目录下的source文件夹下，会新增一个categories的文件夹，里面有一个index.md文件，打开如下 --- title: categories date: 2015-12-04 15:37:22 type: &quot;categories&quot; comments: false --- 其中，comments可以设置为false，含义是打开分类页面、评论插件不显示；如要显示则改为true。tags, about页面的创建类似，输入 hexo new page &quot;tags&quot; hexo new page &quot;about&quot; 标签的使用 + 文章模板--- title: Mac环境下Hexo-GitHub-MWeb搭建个人博客 date: 2017-10-22 23:48:37 tags: [Mac,博客] categories: 博客 --- hexo草稿模式 参考：http://blog.csdn.net/wizardforcel/article/details/40684575 草稿模式中的文件不会公开显示，适用于：有些文档非常重要但是又不想公开、又不想删除，此时使用hexo模式最合适。使用 hexo new draft &quot;Android热修复&quot; 执行此命令之后，会在相应目录下生成相关文件：~/HexoBLog/source/_drafts/Android热修复.md。图示： 强行预览草稿更爱配置文件： render _drafts: true 通过服务预览： hexo server --drafts 将草稿转变为正式文章： hexo publish [layout] &lt;filename&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《代码整洁之道 clean code》笔记 - 1]]></title>
    <url>%2F%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20clean%20code%E3%80%8B%E7%AC%94%E8%AE%B0%20-%201%2F</url>
    <content type="text"><![CDATA[第1章 整洁代码读此书有两种原因：1.你是个程序员 2.你想成为更好的程序员 基础价值谜题：开发期限压力的来源——混乱的代码。 谜题的答案就是：始终尽可能保持代码的整洁。 如何写出整洁的代码：遵循“小技巧” + “代码感” 编程的时间花费：读：写 = 10：1 通过读旧代码 -&gt; 写出新代码 修改代码的原则：“让营地比你来的时候更干净” —— 童子军军规 “整洁代码”的各种定义：（1）C++发明者：优雅+高效 代码逻辑直接了当，使得缺陷难以隐藏； 尽量减少依赖关系，使之便于维护； 依据某种分层战略完善错误处理代码； 性能调制最优，使得他人无法修改； 整洁的代码只做好一件事。 （2）《面向对象分析与设计》作者： 从不隐藏设计者的意图，干净利落的抽象+直截了当的控制语句 （3）Eclipse教父，OTI公司创始人： 小代码块，越小越好 —— “单一职能原则”； 便于他人进行增补和修改； 单元+验收测试； 有意义的命名，见字知意 —— “字面编程”； 只提供一种做一件事的途径+尽量减少依赖关系，明确的定义+提供清晰、尽量少的API （4）《修改代码的艺术》作者： 整洁的代码总是看起来像是某位特别在意他的人写的，几乎没有改进的余地。代码的作者什么都想到了，若是企图改进它，只能是回到原点。 （5）《极限编程实施》作者： 能通过所有测试； 没有重复代码； 体现系统中的全部设计理念； 包括尽量少的实体、比如：类、方法、函数等。 对象功能太多，就要将对象进行细分；方法功能太多，就要进行“方法抽取” （6）WiKi发明者，在意代码者的教父： 若每个代码块都能让你感到深合己意，那就是简洁的代码； 如果代码让编程语言看起来就像是专门为解决那个问题而存在的，那么就可以称之为漂亮的代码。 减少重复的代码 + 提高表达力 + 提早构建简单抽象]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>代码整洁之道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的menu文件]]></title>
    <url>%2FAndroid%E7%9A%84menu%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在Activity中使用menu：/** * toolbar menu 的图标点初始化 * @param menu * @return */ @Override public boolean onCreateOptionsMenu(Menu menu) { super.onCreateOptionsMenu(menu); getMenuInflater().inflate(R.menu.tool_bar, menu); return true; } 一个menu文件示例：包括：单个item menu，组item menu &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;item android:id=&quot;@+id/choose_day&quot; android:icon=&quot;@drawable/date_choose_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;选择时间范围&quot; app:showAsAction=&quot;always&quot;&gt; &lt;!-- item包含menu表示该menu是item下的子菜单 --&gt; &lt;!--&lt;menu&gt; &amp;lt;!&amp;ndash; 将group中的菜单项放于一个组里面 &amp;ndash;&amp;gt; &lt;group android:id=&quot;@+id/group&quot; android:menuCategory=&quot;secondary&quot; android:visible=&quot;true&quot;&gt; &lt;item android:id=&quot;@+id/today&quot; android:icon=&quot;@drawable/menu_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;今天&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/week&quot; android:icon=&quot;@drawable/menu_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;本周&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;/group&gt; &lt;/menu&gt;--&gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/recorder_voice&quot; android:icon=&quot;@drawable/recoder_selector&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;点击录音&quot; app:showAsAction=&quot;always&quot;&gt; &lt;/item&gt; &lt;/menu&gt; 方法的使用在建立actionbar或是toolbar的时候，都会默认的实现两个方法： onCreateOptionsMenu ： 建立菜单，只在页面加载的时候，运行一次，其后就不在运行了，想改变Menu在这里是不可能的。 onOptionsItemSelected ：对选中的菜单进行操作 Android提供了一个方法叫onPrepareOptionsMenu，它的功能是在每次点击一个Menu的时候，它就改变一次，所以你想要改变Menu的值，就得在这里运行。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>menu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML绘制]]></title>
    <url>%2FXML%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android动画参考 ：http://blog.csdn.net/harvic880925/article/details/39996643/各个形状介绍 ：http://blog.csdn.net/yangyahuiguo/article/details/52131658 shape绘制1. oval：椭圆gradient:表示渐变属性 type 表示渐变的样式 123456789101112131415161718&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -》 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;gradient android:angle="180" android:endColor="@color/Amber_900" android:startColor="@color/Orange_100"/&gt; &lt;!-- 当使用此属性时，过度颜色的背景将被遮盖，只显示当前属性的颜色 --&gt; &lt;!--&lt;solid android:color="@color/Deep_Orange_a700"/&gt;--&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; gradientRadius:和镜像属性结合使用，也是必须要设定的属性。表示镜像半径的大小 1234567891011121314151617&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- sweep 属性正常使用，无需其他条件--&gt; &lt;!-- radial 属性使用需要搭配：gradientRadius属性 ： 效果： 由内而外的扩散--&gt; &lt;gradient android:endColor="@color/Amber_900" android:gradientRadius="100px" android:startColor="@color/Orange_100" android:type="radial"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 12345678910111213141516171819&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -》 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;gradient android:angle="180" android:centerColor="@color/white" android:endColor="@color/Amber_900" android:gradientRadius="200px" android:startColor="@color/Orange_100" android:type="radial"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 1234567891011121314151617181920&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -&gt; 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;!-- android:centerY float。渐变中心的相对Y坐标，在0到1.0之间。 --&gt; &lt;!-- x,y 表示开始颜色 开始的位置--&gt; &lt;gradient android:type="radial" android:gradientRadius="100px" android:centerX="0.3" android:centerY="0.3" android:endColor="@color/Amber_900" android:startColor="@color/Orange_100"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 圆环 12345678910111213141516171819&lt;!-- 绘制圆环 --&gt;&lt;!--innerRadius : 内环的半径。一个尺寸值（dip等等）或者一个尺寸资源 --&gt;&lt;!--innerRadiusRatio : Float类型。这个值表示内部环的比例，例如,如果android:innerRadiusRatio = " 5 ",那么内部的半径等于环的宽度除以5。这个值会被android:innerRadius重写。 默认值是9。( innerRaiusRatio=view的宽度/半径) --&gt;&lt;!-- thickness : 环的厚度，是一个尺寸值或尺寸的资源。--&gt;&lt;!-- thicknessRatio : Float类型。厚度的比例。例如,如果android:thicknessRatio= " 2 ",然后厚度等于环的宽度除以2。这个值是被android:innerRadius重写， 默认值是3。(thickenessRatio=View的宽度/环厚度）--&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:innerRadius="120px" android:innerRadiusRatio="9" android:shape="ring" android:thickness="20px" android:thicknessRatio="3" android:useLevel="false"&gt; &lt;gradient android:endColor="#00000000" android:startColor="#ff0000" android:type="sweep"/&gt;&lt;/shape&gt; shape中各个属性的介绍1. 形状分类 矩形rectangle 椭圆形oval 线性形状line 环形ring 水波纹ripple 2. ring专有属性android:innerRadius 尺寸，内环的半径。android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的半径，例如，如果:android:innerRadiusRatio=”5”，表示内环半径等于环的宽度除以5，这个值是可以被覆盖的，默认为9. android:thickness 尺寸，环的厚度android:thicknessRatio浮点型，以环的宽度比率来表示环的厚度，例如，如果android:thicknessRatio=”2”，那么环的厚度就等于环的宽度除以2。这个值是可以被android:thickness覆盖的，默认值是3.android:useLevel boolean值，如果当做是LevelListDrawable使用时值为true，否则为false. 3. 一个xml文件 6个元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!-- 1- 圆角 android:radius 整型 半径 android:topLeftRadius 整型 左上角半径 android:topRightRadius 整型 右上角半径 android:bottomLeftRadius 整型 左下角半径 android:bottomRightRadius 整型 右下角半径 --&gt; &lt;corners android:radius="8dp" android:topLeftRadius="5dp" android:topRightRadius="15dp" android:bottomLeftRadius="20dp" android:bottomRightRadius="25dp" /&gt; &lt;!-- 2- 渐变色 android:startColor 颜色值 起始颜色 android:endColor 颜色值 结束颜色 android:centerColor 整型 渐变中间颜色，即开始颜色与结束颜色之间的颜色 android:angle 整型 渐变角度(PS：当angle=0时，渐变色是从左向右。 然后逆时针方向转，当angle=90时为从下往上。angle必须为45的整数倍) android:type ["linear" | "radial" | "sweep"] 渐变类型(取值：linear、radial、sweep) linear 线性渐变，这是默认设置 radial 放射性渐变，以开始色为中心。 sweep 扫描线式的渐变。 android:useLevel ["true" | "false"] 如果要使用LevelListDrawable对象，就要设置为true。设置为true无渐变。false有渐变色 android:gradientRadius 整型 渐变色半径.当 android:type="radial" 时才使用。单独使用 android:type="radial"会报错。 android:centerX 整型 渐变中心X点坐标的相对位置 android:centerY 整型 渐变中心Y点坐标的相对位置 --&gt; &lt;gradient android:startColor="#FFFF0000" android:endColor="#80FF00FF" android:angle="45" /&gt; &lt;!-- 3- 内”边距"，即内容与边的距离 android:left 整型 左内边距 android:top 整型 上内边距 android:right 整型 右内边距 android:bottom 整型 下内边距 --&gt; &lt;padding android:left="10dp" android:top="10dp" android:right="10dp" android:bottom="10dp" /&gt; &lt;!-- 4- ”大小" android:width 整型 宽度 android:height 整型 高度 --&gt; &lt;size android:width="600dp" /&gt; &lt;!-- 5- ”内部填充" android:color 颜色值 填充颜色 --&gt; &lt;solid android:color="#ffff9d77" /&gt; &lt;!-- 6- ”描边" android:width 整型 描边的宽度 android:color 颜色值 描边的颜色 android:dashWidth 整型 表示描边的样式是虚线的宽度， 值为0时，表示为实线。值大于0则为虚线。 android:dashGap 整型 表示描边为虚线时，虚线之间的间隔 即“ - - - - ” --&gt; &lt;stroke android:width="2dp" android:color="#dcdcdc" /&gt;&lt;/shape&gt; 阴影绘制 参考：http://blog.csdn.net/lihenair/article/details/50111231 绘制原理&lt;layer_list&gt; : 将多个“图片”或 多种效果的shape 按照顺序层叠起来 原理图解 实例 1234567891011121314151617181920212223242526&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;!-- 底层--&gt;&lt;!-- 此处的位置数值表示：相对于顶层的位置偏移--&gt; &lt;item android:top="10px" android:left="10px"&gt; &lt;shape&gt; &lt;solid android:color="#bbb" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width="1px" android:color="#ccc" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 顶层--&gt; &lt;!-- 此处的位置数值表示：相对于底层的位置偏移--&gt; &lt;item android:bottom="10px" android:right="10px"&gt; &lt;shape&gt; &lt;solid android:color="#ffffff" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width="0.3px" android:color="#ddd" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; 实际应用的例子：在我们的例子中，当按钮被按下时，我们取消了阴影来产生反馈效果。 123456789101112131415161718192021222324252627282930313233&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;layer-list&gt; &lt;item android:left="4dp" android:top="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#ff58bb52" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;!-- SHADOW LAYER --&gt; &lt;item android:left="4dp" android:top="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#66000000" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- CONTENT LAYER --&gt; &lt;item android:bottom="4dp" android:right="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#ff58bb52" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt;]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 15-I/O]]></title>
    <url>%2FPython3%20%2015-I%3AO%2F</url>
    <content type="text"><![CDATA[关于Open()源码文档打开文件并返回流。失败时提高IOError。 文件是一个文本或字节串，给出要打开的文件的名称（如果文件不在当前工作目录中的路径）或要包装的文件的整数文件描述符。 （如果给出了一个文件描述符，则当返回的I / O对象关闭时，它将被关闭，除非closefd设置为False。）mode是一个可选字符串，用于指定文件打开的方式。它默认为&apos;r&apos;，这意味着在文本模式下打开阅读。其他常见的值是“w”用于写入（截断文件已存在），“x”用于创建和写入新文件，“a”用于附加（在某些Unix系统上，这意味着所有写入都附加到无论当前查找位置如何，文件的结尾）。在文本模式下，如果未指定编码，则使用的编码与平台相关：调用locale.getpreferredencoding（False）以获取当前语言环境编码。 （用于读取和写入原始字节使用二进制模式并保留编码未指定。）可用的模式有： &apos;r&apos;开放阅读（默认） &apos;w&apos;打开写入，首先截断文件 &apos;x&apos;创建一个新文件并将其打开以进行写入 &apos;a&apos;开放写作，如果文件存在，则附加到文件末尾 &apos;b&apos;二进制模式 &apos;t&apos;文字模式（默认） &apos;+&apos;打开一个磁盘文件进行更新（读写） &apos;U&apos;通用换行模式（弃用） 默认模式为“rt”（打开阅读文本）。对于二进制随机访问，模式&apos;w + b&apos;打开并将文件截断为0字节，而&apos;r + b&apos;打开文件而不截断。如果文件已经存在，&apos;x&apos;模式意味着&apos;w&apos;并引发一个`FileExistsError`。 Python区分以二进制和文本模式打开的文件，即使底层操作系统没有。文件以二进制模式打开（将&apos;b&apos;追加到模式参数）返回内容作为字节对象而不进行任何解码。在文本模式（默认情况下，或在模式参数附加了&apos;t&apos;）时，文件的内容将返回为字符串，首先使用平台相关编码对字节进行了解码，如果给出，则使用指定的编码。 &apos;U&apos;模式已被弃用，并会在将来的Python版本中引发异常。它对Python 3没有影响。使用换行来控制通用换行符模式。缓冲是用于设置缓冲策略的可选整数。通过0以切换缓冲（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），整数&gt; 1表示固定大小的块缓冲区的大小。当没有给出缓冲参数时，默认缓冲策略的工作原理如下： *二进制文件以固定大小的块进行缓冲;使用启发式方法来选择缓冲区的大小，试图确定底层设备的“块大小”并落回到“io.DEFAULT_BUFFER_SIZE”上。在许多系统上，缓冲区通常为4096或8192字节长。 *“交互式”文本文件（其中isatty（）返回True的文件）使用行缓冲。其他文本文件使用上述针对二进制文件的策略。 encoding是用于对文件进行解码或编码的编码名称。这只能在文本模式下使用。默认编码是平台依赖的，但是Python可以支持任何编码。有关支持的编码列表，请参阅编解码器模块。 errors是一个可选的字符串，指定如何处理编码错误 - 此参数不应在二进制模式下使用。如果存在编码错误（默认值为None）具有相同的效果，则通过&apos;strict&apos;来引发ValueError异常，或者通过&apos;ignore&apos;忽略错误。 （请注意，忽略编码错误可能导致数据丢失。）有关编码错误字符串的列表，请参阅codecs.register的文档或运行&apos;help（codecs.Codec）&apos;。 换行符控制通用换行符的工作原理（仅适用于文本模式）。它可以是无，&apos;&apos;，&apos;\ n&apos;，&apos;\ r&apos;和&apos;\ r \ n&apos;。它的工作原理如下： *输入时，如果换行符为None，则启用通用换行符模式。输入中的行可以&apos;\ n&apos;，&apos;\ r&apos;或&apos;\ r \ n&apos;结尾，并将它们转换为&apos;\ n&apos;，然后返回给调用者。如果是&apos;&apos;，则启用通用换行模式，但是行结束将返回给未经翻译的调用者。如果它具有任何其他合法值，则输入行仅由给定终止 2017年07月21日09:44:52 暂停]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 14-调试]]></title>
    <url>%2FPython3%20%2014-%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[方法 .print()打印用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。 assert断言凡是用print()来辅助查看的地方，都可以用断言assert来替代。代码示例： 1234567def foo(s): n = int(s) assert n != 0, 'n is zero!' return 10 / ndef main(): foo('0') 在程序中使用assert和print()相比也好不到哪去。但是：启动Python解释器时可以用-O参数来关闭assert 1$ python3 -O err.py 关闭后，你可以把所有的assert语句当成pass来看。 logging日志把print()替换为logging是第3种方式，和assert比，logging不但会抛出错误，而且可以输出到文件。注意：导入logging包之后，应在添加配置语句logging.basicConfig(level=logging.INFO)代码示例 1234567891011121314151617181920212223242526272829303132333435363738import logging# logging.basicConfig(level=logging.INFO)# 配置日志信息logging.basicConfig(level=logging.DEBUG, format='%(asctime)-8s %(name)-8s %(levelname)-8s %(message)s - [%(filename)s:%(lineno)s]', datefmt='%Y-%m-%d %H:%M:%S', filename='myapp.log', filemode='w')# 定义一个Handler打印INFO及以上级别的日志到sys.stderrconsole = logging.StreamHandler()console.setLevel(logging.DEBUG)# 设置控制台日志打印格式formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')console.setFormatter(formatter)# 将定义好的console日志handler添加到root loggerlogging.getLogger('').addHandler(console)"""测试logging"""s = '0'n = int(s)logging.info('n = %d' % n)print(10 / n)'''结果输出INFO:root:n = 0Traceback (most recent call last): File "/Users/yannischeng/PycharmProjects/First_Python_Project/py_obj_end_12/TestObj.py", line 69, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero''''''输出到文件中的信息：2017-07-20 09:57:51 root INFO n = 0 - [LogSet.py:27]''' 优点 允许你指定记录信息的级别，有debug，info，warning，error等几个级别。 通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。 参考 logging的配置参考：http://blog.csdn.net/naiveloafer/article/details/7630903 Format编写 Format Description %(name)s Name of the logger (logging channel). %(levelno)s |Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).%(levelname)s |Text logging level for the message (‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’).%(pathname)s |Full pathname of the source file where the logging call was issued (if available).%(filename)s | Filename portion of pathname.%(module)s | Module (name portion of filename).%(funcName)s | Name of function containing the logging call.%(lineno)d | Source line number where the logging call was issued (if available).%(created)f | Time when the LogRecord was created (as returned by time.time()).%(relativeCreated)d | Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.%(asctime)s |Human-readable time when the LogRecord was created. By default this is of the form “2003-07-08 16:49:45,896” (the numbers after the comma are millisecond portion of the time).%(msecs)d | Millisecond portion of the time when the LogRecord was created.%(thread)d | Thread ID (if available).%(threadName)s | Thread name (if available).%(process)d | Process ID (if available).%(message)s | The logged message, computed as msg % args. basicConfig()编写 对日志记录系统进行基本配置： 如果根记录器已经具有处理程序，则此函数不起作用配置。这是一个方便的方法，供简单的脚本使用做一次性配置的日志记录包。 默认行为是创建一个写入的StreamHandler sys.stderr，使用BASIC_FORMAT格式字符串设置格式化程序，和将处理程序添加到根记录器。 可以指定一些可选的关键字参数，这可以改变默认行为。 Optional Keyword Description filename 指定使用指定的FileHandler进行创建文件名，而不是一个StreamHandler。 filemode | 指定打开文件的方式，如果指定了filename（如果filemode未指定，则默认为&apos;a&apos;）。 format | 为处理程序使用指定的格式字符串。 datefmt | 使用指定的日期/时间格式。 style | 如果指定了格式字符串，请使用此字符串指定格式字符串的类型（可能的值&apos;％&apos;，&apos;{&apos;，&apos;$&apos;，for ％-formatting，：meth：`str.format`和：class：`string.Template` - 默认为&apos;％&apos;）。 level | 将根记录器级别设置为指定级别。 stream | 使用指定的流来初始化StreamHandler。注意该参数与“filename”不兼容 - 如果同时使用存在，“流”被忽略。 handlers | 如果指定，这应该是已经创建的迭代处理程序，将被添加到根处理程序。任何处理程序在没有格式化程序分配的列表中分配在此函数中创建的格式化程序。 请注意： 可以指定使用open（filename，mode）创建的流而不是传递文件名和模式。但是应该记住StreamHandler并不关闭它的流（因为它可能使用sys.stdout或sys.stderr），而FileHandler关闭其流当处理程序关闭时。 .调试器pdb – 有了PyCharm目前不考虑此种方式启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 14-单元测试]]></title>
    <url>%2FPython3%20%2014-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[“测试驱动开发”（TDD：Test-Driven Development）– 单元测试 是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 在pycharm中创建单元测试 创建参考：http://blog.csdn.net/u013088062/article/details/50183789一个案例：http://www.cnblogs.com/iamjqy/p/7155315.html 具体创建过程参考python文件夹的.png图片。 选中待要编写测试代码的类名 –&gt; 右键 选择 Go To –&gt; Test Object 单元测试实现待测试类代码12345678910111213141516class MyDict(dict): def __init__(self, **kwargs): super().__init__(**kwargs) def __getattr__(self, item): try: return self[item] except KeyError: raise AttributeError(r"'MyDict' object has no attribute '%s'" % item) def __setattr__(self, key, value): self[key] = value def add(self, m, n): print("%d + %d = %d" % (m, n, (m+n))) 单元测试类代码123456789101112131415161718192021222324from unittest import TestCasefrom py_unittext_14.MyDict import MyDictclass TestMyDict(TestCase): # setUp与tearDown # 这两个方法会分别在每调用一个测试方法的前后分别被执行。 # setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码 def setUp(self): print('setUp...') def tearDown(self): print('tearDown...') def test_add(self): d = MyDict(name='程文佳', age='24', city='Tianjin') self.assertEqual(d.name, '程文佳') self.assertEqual(d['name'], '程文佳') print(d.name) def test_add2(self): d = MyDict(name='程文佳', age='24', city='Tianjin') d.add(3, 4) 测试结果1234567891011setUp...程文佳tearDown...setUp...3 + 4 = 7tearDown...Ran 2 tests in 0.002sOK 小结 单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。 单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。 单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。 单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 13-错误+测试+调试]]></title>
    <url>%2FPython3%20%2013-%E9%94%99%E8%AF%AF%2B%E6%B5%8B%E8%AF%95%2B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[错误12345678try: """ 可能出错的代码块 """except ZeroDivisionError as e: print('except:', e)finally: print('finally...') 错误特点 Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。 使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，即：不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。比如函数main()调用foo()，foo()调用bar()，结果bar()出错了。这时，只要main()捕获到了就可以处理bar()中的错误。 记录错误 捕获错误，把错误堆栈打印出来，分析错误原因，同时，让程序继续执行下去而不是使得程序被结束。 使用方法 12345678import logging# 同样是出错，但程序打印完错误信息后会继续执行，并正常退出.# 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。try: bar('0')except Exception as e: logging.exception(e) 抛出错误 因为错误是class。捕获一个错误就是捕获到该class的一个实例。 既可以使用python的内置函数抛出错误，也可以自己编写函数抛出错误。 使用关键字raise抛出一个错误实例 代码示例 1234567891011121314151617181920# 编写自定义异常类class FooError(ValueError): passdef foo(s): n = int(s) if n==0: raise FooError('invalid value: %s' % s) return 10 / n# 调用自定义的异常类foo('0')# 报的错误Traceback (most recent call last): File "err_throw.py", line 11, in &lt;module&gt; foo('0') File "err_throw.py", line 8, in foo raise FooError('invalid value: %s' % s)__main__.FooError: invalid value: 0]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 11-面向对象+枚举]]></title>
    <url>%2FPython3%20%2011-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[Python中Enum枚举的实现：http://www.cnblogs.com/codingmylife/archive/2013/05/31/3110656.html 定义常量的一般方法：定义变量推荐的方法为：将枚举类型定义一个class类型。每个常量都是class的唯一实例python提供了Enum来实现枚举功能 12345678910111213141516171819202122232425262728293031323334353637# 实现方式1from enum import EnumWeek = Enum('WeekInfo', ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'))# 实现方式2from enum import Enum, unique# @unique装饰器检查保证没有重复值@uniqueclass MyEnum02(Enum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sta = 6# 遍历Enumfor name, value in Week.__members__.items(): print(name, value, m.value)print(Week.Mon.value) # 1"""Mon WeekInfo.Mon 1Tue WeekInfo.Tue 2Wed WeekInfo.Wed 3Thu WeekInfo.Thu 4Fri WeekInfo.Fri 5Sat WeekInfo.Sat 6Sun WeekInfo.Sun 7"""# 使用MyEnum02print(MyEnum02(1)) # MyEnum02.Mon]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 12-面向对象+元类]]></title>
    <url>%2FPython3%20%2012-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[静态语言和动态语言最大的不同，就是函数和类的定义。不是编译时定义的，而是运行时动态编译的。 关键字：type(), metaclass 一般的class创建123456789101112131415class Hello(object): def hello(self): print('Hello World !')from py_obj_end_12.Hello import Hello"""导入Hello类后的测试"""h = Hello()print(h.hello()) # Hello World !# 查看实例h所属的类型，是class Helloprint(type(h)) # &lt;class 'py_obj_end_12.Hello.Hello'&gt;# 查看Hello所属的类型，是 type 类型print(type(Hello)) # &lt;class 'type'&gt; 使用type()来动态创建类type 是什么？为什么 Hello 会是 type 类型的？ 因为Python是动态语言，所以class的定义是运行时动态创建的，而创建class使用的就是type()函数 type()函数既可以返回一个对象的类型，又可以创建出新的类型。 通过type()创建class和直接写class是完全一样的。 因为python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 正常情况下，我们使用class Xxx创建一个类。但是，因为type()函数允许我们动态的将类创建出来。 动态语言本身支持处于运行期的程序动态创建一个类。这和Java的静态语言不同。 type()使用：http://www.cnblogs.com/ccorz/p/6120783.html type(name, bases, dict) 返回一个新的type对象. 基本上是 class 语句的动态形式. 参数: name , 字符串, 制定要构造类的名字, 赋给新对象的 __name__ 属性; bases，一个tuple，指定新类型的所有基类，赋给新对象的__bases__ 属性; dict， 字典类型，作为新类的名字空间，赋给新对象的__dict__ 属性 12345678910111213141516171819# 用type()函数创建Hello类# 1.定义一个函数。即：类的方法def say(self): print('Hello, World 2!')# 2.创建一个class Hello2。type()函数中传入的参数：# 1）class类名，2）继承的父类集合，3）class的方法名与函数的绑定，此处即：将函数say()绑定至方法名hello上# 其实class定义一个类主要也是这3个主要组成部分：类名、继承类、方法# Hello2是一个以名为"Hello22"的类的引用。这个名为"Hello22"的类以object为基类,类中有一个say()函数Hello2 = type('Hello22', (object,), dict(say=say))# 3.为类绑定一个变量Hello2.name = 'cwj'# 测试h2 = Hello2()print(h2.say()) # Hello, World 2!print(h2.name) # cwj metaclass使用metaclass来控制类的创建行为]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 10-面向对象+定制对象]]></title>
    <url>%2FPython3%20%2010-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E5%AE%9A%E5%88%B6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在编写一个基础类的基础上，为其重写某些魔法方法。 python其他内置魔法方法： https://docs.python.org/3/reference/datamodel.html#special-method-nameshttp://www.cnblogs.com/simayixin/archive/2011/05/04/2036295.htmlpython常用魔法方法的实现：http://www.cnblogs.com/scolia/p/5690210.html 魔法方法有：-1.__new__()：对象的创建，是一个静态方法，第一个参数是cls。(不可能是self，因为对象还没创建，哪来的self)—提示单例模式与此有关。0.__init__()：对象的初始化， 是一个实例方法，第一个参数是self。1.__slots__()：约束要绑定的临时变量2.__len__()：让类作用于len()3.__str__()：类似于java中的toString()，返回用户看到的字符串4.__repe__()：返回开发者看到的字符串5.__iter__()：将一个类被用于for...in循环中，返回一个迭代对象6.__getitem__()：像list那样按照下标取出元素，要在其中处理slice切片、step步长7.__getattr__()：当调用不存在的属性时，Python解释器会试图调用__getattr__(self, &#39;attr&#39;)来尝试获得属性。只有在没有找到属性的情况下，才调用__getattr__，已有的属性将不会在__getattr__中查找。而且，实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。8.__call__() __iter__() 配合 __next__()使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person(object): # 构造方法 def __init__(self, name): self._name = name self.a, self.sum = 1, 0 # 使本类可以迭代 def __iter__(self): return self # 具体的迭代方法，此方法的实现是关键 def __next__(self): self.sum = self.sum + self.a if self.sum &gt; 10: raise StopIteration return self.sum # 重写 toString()方法 def __str__(self): return 'Person name is ' + self._name __repr__ = __str__ '''测试'''person = Person("cwj")# 重写 __str__() 之后的效果print(Person("cwj")) # Person name is cwjprint(person) # Person name is cwjprint(isinstance(person, Iterator)) # Trueprint(isinstance(person, Iterable)) # Truel = []# 遍历Person序列，此时Person是一个Iteratorfor n in person: l.append(n) print(n)# 将一个类遍历后得到的结果赋值给l序列print(l) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'''12345678910''' __getitme__()配合__setitme__()使用12345678910111213141516171819class DictDemo(object): def __init__(self): self.dict = &#123;&#125; def __getitem__(self, item): if item in self.dict: return self.dict[item] else: return '不存在' def __setitem__(self, key, value): self.dict[key] = value '''测试'''dictD = DictDemo()dictD['1'] = 'cwj'dictD.__setitem__('1','234')print(dictD.__getitem__('1')) # 234print(dictD['2']) # 不存在 一个实现迭代、容器的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112'''Animal类 自定义魔法函数'''from pip._vendor.requests.packages.urllib3.connectionpool import xrange'''创建一个模拟字典的类，这个类的内部维护了两个列表，key 负责储存键，value 负责储存值，两个列表通过索引的一一对应，从而达到模拟字典的目的'''class Animal(object): def __init__(self, key, value): self.key = [] self.value = [] self.key.append(key) self.value.append(value) self.__index = 0 # __len__方法，按照协议，这个方法应该返回容器的长度 def __len__(self): return len(self.key) # __getitem__方法。这个方法会在a['scolia']时，调用a.__getitem__('scolia')。 # 也就是说这个方法定义了元素的获取. # 先找到 key 列表中建的索引，然后用索引去 value 列表中找对应的元素，然后将其返回 def __getitem__(self, item): if item in self.key: return self.value[self.key.index(item)] else: return '不存在' # __setitem__(self, key, value)方法定义了 a['scolia'] = 'good' 这种操作时的行为， # 此时将会调用a.__setitem__('scolia', 'good') 因为是绑定方法，所以self是自动传递的 def __setitem__(self, key, value): if key not in self.key: self.key.append(key) self.value.append(value) else: __index = self.key.index(key) self.value[__index] = value # __delitem__(self, key)方法定义了del a['scolia'] 这类操作时候的行为， # 里面的‘scolia’就作为参数传进去 def __delitem__(self, key): if key in self.key: __index = self.key.index(key) del self.key[__index] del self.value[__index] else: return "key值不存在" '''只有实现里以上四个方法，就可以当做可变容器来使用了。''' # __str__ 是对应于 str() 函数，在类的表示中会继续讨论，这里是为了 print 语句好看才加进去的， # 因为print语句默认就是调用str()函数 def __str__(self): l = [] for index in xrange(len(self.key)): __key = self.key[index] __value = self.value[index] result = __key,__value l.append(result) return str(l) # 实现一个__iter__方法，这个方法负责返回一个迭代器 def __iter__(self): return self # 内部实现了next（python3.x为__next__）方法，真正负责迭代的实现。 # 当迭代器内的元素用尽之后，任何的进一步调用都之后触发 StopIteration 异常 # 一般会在一个类里同时实现这两种方法（即是可迭代对象又是迭代器），此时__iter__方法只要返回self就足够的了 def __next__(self): if self.__index == len(self.key): self.__index = 0 raise StopIteration() else: __key = self.key[self.__index] __value = self.value[self.__index] result = __key, __value self.__index += 1 return result # __contains__实现了成员判断，这里我们更关心value列表中的数据，所以判断的是value列表。 # 该方法要求返回布尔值。 def __contains__(self, item): if item in self.value: return True else: return False # __reversed__(self)方法返回一个倒序后的副本，这里体现了有序性 def __reversed__(self): __result = self.value __result.reverse() return __result'''实际测试'''m = Animal('1', 'cwj')print(m) # [('1', 'cwj')]print(m.__len__()) # 1m['2'] = 'ddd'm['3'] = 'qwe'm['2'] = 'lkj'print(m) # [('1', 'cwj'), ('2', 'lkj'), ('3', 'qwe')]print(m.__len__()) # 3del m['3']print(m) # [('1', 'cwj'), ('2', 'lkj')]print(m.__len__()) # 2print(reversed(m)) # ['lkj', 'cwj']print('cwj' in m) # True 类的切片操作 参考：http://www.cnblogs.com/scolia/p/5690210.html 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Slices(object): def __init__(self, x): self._x = x self._index = -1 ''' # __getitem__()实现支持for循环 def __getitem__(self, item): if isinstance(self._x, list): self._index += 1 return self._x[self._index] else: raise '参数类型错误' ''' def __getitem__(self, item): # print(item.start, item.stop, item.step) # 1 2 1 # return item # slice(1, 2, 1) if isinstance(item, slice): return self._x[item.start:item.stop:item.step]'''测试Slices类''''''s = Slices([1, 2, 3, 4])for n in s: print(n)'''1234'''s2 = Slices('1234')for n in s2: print(n)'''s3 = Slices([1, 2, 3, 4, 5])# 当直接返回item参数时的结果# print(s3[1:4:1]) # slice(1, 2, 1)print(s3[1:4:1]) # [2, 3, 4]print(s3[-4:-2]) # [2, 3]print(s3[-3:-1]) # [3, 4]print(s3[-5:]) # [1, 2, 3, 4, 5]print(s3[:]) # [1, 2, 3, 4, 5]print(s3[-1::-1]) # [5, 4, 3, 2, 1]print(s3[-1:]) # [5]``` ## `__getattr__()`正常情况下，当我们调用类的`方法`或`属性`时，如果不存在，就会报错。如：```pythonAttributeError: 'Student' object has no attribute 'score' 要避免这个错误，Python有一个机制：写一个__getattr__()方法，动态返回一个属性。当调用不存在的属性时，比如color，Python解释器会试图调用__getattr__(self, &#39;color&#39;)来尝试获得属性，这样我们就有机会返回color的值 123456789101112131415# 返回不存在的属性与函数# 作用：可以针对完全动态的情况作调用def __getattr__(self, item): # 返回未定义的属性 if item == 'color': return '您真是 666 啊 ~ 这个属性都鞥猜到' elif item == 'address': return '哈哈哈' # 返回未定义的函数 elif item == 'add': return lambda: 100 else: # 注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None # 要让class只响应特定的几个属性,要按照约定，抛出AttributeError错误 raise AttributeError('\'Student\' object has no attribute \'%s\'' % item) __call__()与__getattr__()组合实现URL中的链式(chain)调用在python中，函数其实是一个对象。如： 12345&gt;&gt;&gt; f = abs&gt;&gt;&gt; f.__name__'abs'&gt;&gt;&gt; f(-123)123 由于 f 可以被调用，所以，f 被称为可调用对象。所有的函数都是可调用对象。一个类的实例对象想要变成一个可调用的对象，只需要实现一个魔法方法__call__()。 可调用对象与一般对象 可调用对象：obj.name(‘source’).age。即：既可以使用.调用属性或方法，也可以使用obj()以一种函数样式使用此对象。此时调用obj(arg1,arg2,....)就等价于obj.__call__(self,arg1,arg2,...) 一般对象：obj.name。即：只能使用.调用属性或方法。 因为__call__()魔法方法的加入，因此python的函数与对象之间的概念被模糊了 URL中的链式调用，这样无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变，代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344'''URLChain类'''class URLChain(object): def __init__(self, path = ''): self.__path = path def __getattr__(self, item): # 实现参考：https://zhidao.baidu.com/question/1865282935722979707.html # 返回一个 URLChain 对象，这个时候里面的path就是''+'/'+'api'='/api'，此时self = /api print('\'self.__path is\' :' + self.__path + ' , \'item is\' : ' + item + ' ， 之前self为：', self) # 即：上一个 '%s/%s' 的数值代替：构造函数中 path = ''中 '' 的具体数值，相当于重新构造了一个对象， # 在即将的调用的返回值中表示参数self.__path的值, 新传入的参数赋值给item return URLChain('%s/%s' % (self.__path, item)) def __str__(self): return self.__path __repr__ = __str__ # 将此类的实例对象变成一个可调用的对象 def __call__(self, path): print('__call__ 之前self is : ', self) print('__call__ path is : ' + path) return URLChain('%s/%s' % (self.__path, path))'''调用URLChian类'''chain = URLChain()print(chain.api.server.user.friends)''''self.__path is' : , 'item is' : api ， 之前self为： 'self.__path is' :/api , 'item is' : server ， 之前self为： /api'self.__path is' :/api/server , 'item is' : user ， 之前self为： /api/server'self.__path is' :/api/server/user , 'item is' : friends ， 之前self为： /api/server/user/api/server/user/friends'''# 当执行 ('cwj') 这一个参数时调用的是 URLChian的 __call__()print(chain.api.server('cwj').friends)''''self.__path is' : , 'item is' : api ， 之前self为： 'self.__path is' :/api , 'item is' : server ， 之前self为： /api__call__ 之前self is : /api/server__call__ path is : cwj'self.__path is' :/api/server/cwj , 'item is' : friends ， 之前self为： /api/server/cwj/api/server/cwj/friends''' callable()的使用：判断一个变量是函数还是对象代码示例 1234# 判断一个对象是否能被调用，能被调用的对象就是一个Callable对象,函数和自定义的带有__call__()的类实例对象返回值是True：print(callable(chain)) # True URLChian实现了__call__()魔法方法print(callable(dictD)) # Falseprint(callable(abs)) # True]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 09-面向对象]]></title>
    <url>%2FPython3%20%2009-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类的模板 123456789101112131415161718192021222324252627'''类模板'''class Student(object): def __init__(self, name, age, city): self.name = name self.age = age self.__city = city def print_info(self): print('self is : ', self) # self is : &lt;py_class.Student.Student object at 0x10c92c400&gt; # print(student) 得到的结果为：&lt;py_class.Student.Student object at 0x10c92c400&gt; print('class is : ', self.__class__) # class is : &lt;class 'py_class.Student.Student'&gt; print('%s, %d, %s' % (self.name, self.age, self.__city)) def get_age(self): if self.age == 20: print('age is ', self.age) elif self.age &gt; 20: print('too old') else: print('too young') def get_city(self): return self.__city def set_city(self, city): self.__city = city 属性 1.类属性：像是Student类中的name就是类属性 2.实例属性：像是下文中的student.__city就是实例属性 类中变量及函数的命名规范 以__开始，并以__ 双下划线 结束的是python中的特殊变量，特殊变量是可以直接访问的，不是private变量 class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的.通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类 __init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去 在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。 self指向的类的实力对象。由： 12print('self is : ', self) # self is : &lt;py_class.Student.Student object at 0x10c92c400&gt;print(student) # &lt;py_class.Student.Student object at 0x10c92c400&gt; 可以看出，self和student的 内存地址 是一样的。代码示例 123456789'''调用'''# 创建实例对象student = Student('cwj',24, 'tianjin')student.print_info() # cwj, 24, tianjinstudent.get_age() # too old# 访问属性student.age = 19student.name = 'ddd' 访问限制虽然有访问限制的命名方式，但是Python本身没有任何机制阻止你干坏事，一切全靠自觉。 两个下划线开头的变量，声明为类内部的私有变量，不能在类的外部直接使用或访问：在变量前面添加__，即：__name。在类内部的方法中使用时 self.__private_attrs。 两个下划线开头的方法，声明为类内部的私有方法。不能在类地外部调用，在类的内部调用 self.__private_methods. 单下划线开头表示的protected类型的变量，只允许本身及其子类进行访问。 类的方法在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数代码示例: 123456789101112131415161718192021 # 此行代码貌似修改了 Student 类中的 __city 属性,实际这是为student添加了一个属性。 student.__city = 'beijing' # 而且输出结果也显示；__city 属性 的值也变成了：beijing print(student.__city) # beijing # 但是，当我们通过类自身的get()获取属性值时，发现还是之前初始化时的属性值。即：tianjin print(student.get_city()) # tianjin print(hasattr(student, 'name')) # True # 删除临时添加的 __city 属性 # del student.__city# print(student.__city) # AttributeError: 'Student' object has no attribute '__city' # 当我们通过类自身的set()方法修改 __city 属性值时，通过get()得到的属性值是修改之后的。 student.set_city('hk') print(student.get_city()) # hk # 由此可以得出：此时的 student.__city 与 student.set_city() 中的 __city 并不是同一个属性 # student.__city 中的 __city 是student的一个新的同名属性 student.print_info() # ddd, 19, hk Python内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串，即：注释 __name__: 类名 __module__: 类定义所在的模块（类的全名是__main__.className，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 代码示例 123456789101112131415# 由 类 进行调用 __dict__print(Student.__dict__) # &#123;'__module__': 'py_class.Student', '__init__': &lt;function Student.__init__ at 0x100ccf8c8&gt;, 'print_info': &lt;function Student.print_info at 0x100ccf950&gt;, 'get_age': &lt;function Student.get_age at 0x100ccf9d8&gt;, 'get_city': &lt;function Student.get_city at 0x100ccfa60&gt;, 'set_city': &lt;function Student.set_city at 0x100ccfae8&gt;, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None&#125;# 由 对象 调用 __dict__ 方法类似于：java中的toString()print(student.__dict__) # &#123;'name': 'ddd', 'age': 19, '_Student__city': 'hk', '__city': 'beijing'&#125;print(student.__doc__) # None# 由 类 进行调用print(Student.__name__) # Studentprint(student.__module__) # py_class.Student# 由 类 进行调用print(Student.__bases__) # (&lt;class 'object'&gt;,) python对象的销毁垃圾回收 —— 引用计数 + 循环引用 引用计数法。当跟踪变量对象的引用计数变为0时，它将会被回收。但不是立即被回收，而是由‘解释器’在适当的时机将其回收。 循环引用。当两个对象相互引用，但是没有其他的变量引用他们。此时循环垃圾回收器将会工作。 代码示例 1del student.__city 继承支持多继承父类的构造器（__init__(self)）不会被自动调用，需要在子类中亲自专门调用python总是先在本类中查找调用的方法，找不到才会去父类中继续寻找 几个基础的重载方法 1.__init__(self,[]) 构造方法 2.__del__(self) 删除一个对象，dell obj 3.__repr__(self) 转化为供解释器读取的形式 4.__str__(self) 将值转化为始于人阅读的形式 5.__cmp__(self,x) 对象比较 代码示例 父类 123456789101112131415161718192021222324252627'''父类 1 ''' class Animal(object): def __init__(self, name, age): self.__name = name self.__age = age def get_name(self): return self.__name def get_age(self): return self.__age def set_name(self, name): self.__name = name def set_age(self, age): self.__age = age def run(self): print('Animal is running') '''父类 2''' class Pet(object): def play(self): print(self.__name + " is very good !") 子类 1234567891011121314151617181920212223242526272829303132333435363738from py_class.Animal import Animalfrom py_class.Pet import Pet# 多继承class Pig(Animal, Pet): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print('pig is running very slowly...')from py_class.Animal import Animal# 单继承class Dog(Animal): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print(self.__name + ' is running')from py_class.Animal import Animal# 单继承class Cat(Animal): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print(self.__name + 'is running') 测试类 123456789101112131415161718from py_class.Animal import Animalfrom py_class.Dog import Dogfrom py_class.Cat import Catfrom py_class.PIg import Pigdog = Dog('wangwang', 1)dog.run()cat = Cat('miaomiao', 1)cat.run()pig = Pig('big pig', 100)pig.run() # pig is running very slowly...# pig.play() # big pig is very good !print(isinstance(cat, Animal)) # Trueprint(isinstance(cat, Cat)) # True'''由此可见，cat变量既是Cat类型，也是Animal类型''' 多态代码示例 1234567891011121314151617181920212223242526''' 多态的实现方式 1 类似于java这种静态语言的实现，必须传入Animal类型或其子类 # 多态的使用 将 父类 作为参数def run_test(animal): animal.run()'''''' 多态的实现方式 2 属于python的动态语言实现' 这种方式实现的结果与 方式 1 完全一样 原理： 不一定要传入Animal类型，只要保证传入的对象一个run()方法就可以了. 例如：传递的对象为ints，这不是Animal的任何一个子类，只要将赋予run()方法就足以。 动态语言的'鸭子类型'： 它并不要求严格的继承体系，一个对象只要"看起来像鸭子，走起路来像鸭子"，那么它就是鸭子。'''def run_test(ints): ints.run()# 多态的使用 实际参数为具体的子类，得到的结果为各个子类的具体表现run_test(Animal('Animal', 1)) # Animal is runningrun_test(Dog('Dog', 1)) # Dog is runningrun_test(Cat('Cat', 1)) # Catis runningrun_test(Pig('Cat', 1)) # pig is running very slowly... 获取对象信息 getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 12345678910111213141516171819202122232425262728'''isinstance() 查看一个变量的继承关系'''print(isinstance(cat, Animal)) # Trueprint(isinstance(cat, Cat)) # Trueprint(isinstance(pig, Animal)) # Trueprint(isinstance(pig, Pet)) # Trueprint(isinstance(pig, Pig)) # True''' type() 当使用继承关系时，使用type()不能一直向上得到他们的父类， 因此，对于有 继承关系 的类来说不合适'''print(type(123)) # &lt;class 'int'&gt;print(type(dog)) # &lt;class 'py_class.Dog.Dog'&gt;def compare(obj1, obj2): if type(obj1) == type(obj2): print(type(obj1) == type(obj2)) print(str(obj1) + '==' + str(obj2)) else: print(type(obj1) == type(obj2)) # False print(str(obj1) + '!=' + str(obj2))compare(dog, cat)'''获取一个对象所有的属性和方法'''print(dir(dog))# ['_Dog__age', '_Dog__name', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'get_age', 'get_name', 'run', 'set_age', 'set_name']]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 09-面向对象+临时变量、方法+@property+多继承]]></title>
    <url>%2FPython3%20%2009-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%2B%40property%2B%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[绑定临时变量和临时函数 – 不限定参数使用python语言`动态语言`这一特性。 绑定临时变量 为实例对象绑定临时变量 123456# 动态的将 new_name 属性绑定至 实例 中dog.new_name = 'new cwj'print(dog.new_name) # new cwj# 删除临时添加的 new_name 属性del dog.new_name 为类绑定临时变量 123456789# 动态的将 new_name_2 属性绑定至 Dog类 中Dog.new_name_2 = 'new cwj 2'print(dog.new_name_2) # new cwj 2dog2 = Dog('wangwang', 1)print(dog2.new_name_2) # new cwj 2'''可以看到 dog 与 dog2 两个实例都具有 new_name_2 属性，由此可见 new_name_2 属性已经动态的添加至Dog类中''' 绑定临时函数 为实例对象绑定临时函数 12345678910111213141516171819202122232425from types import MethodTypedef set_color(self, color): self.color = color# 给实例绑定一个方法dog.set_color = MethodType(set_color, dog)# 通过这个方法为临时的color赋值dog.set_color('red')# set_color()这个方法是临时赋给dog变量的，而不是赋给dog2的# dog2.set_color('green') # AttributeError: 'Dog' object has no attribute 'set_color'# 输出临时参数color的值print(dog.color) # red# 删除临时方法，删除此方法的同时，也删除了此方法内的历史变量del dog.set_color# 删除临时参数# del dog.color# 当删除临时方法后，此方法将不再能使用# dog.set_color('green') # AttributeError: 'Dog' object has no attribute 'set_color' 为类绑定临时函数 1234567891011121314151617# 定义一个临时的方法def set_color2(self, color): self.color = color# 将临时定义的方法绑定给 Dog这个类Dog.set_color2 = set_color2# Dog类的两个变量dog和dog2分别调用set_color2()dog.set_color2('blue')dog2.set_color2('black')# 测试临时函数是否对临时变量赋值成功print(dog2.color) # blackprint(dog.color) # blue# 删除临时的方法del Dog.set_color2 绑定临时变量和临时函数 – 限定参数 __slots__变量`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的. 除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__` 代码示例 12345678910111213141516171819202122'''声明Pet类'''class Pet(object): ''' 使用一个特殊的变量 __slots__，这个变量可以限制外部为Pet类添加的属性。 例如此处，只允许外部为Pet类添加 name 和 age 两个属性 ''' __slots__ = ('name2', 'age')'''调用Pet类'''pet = Pet()pet.name2 = 'big pig'pet.age = 2# 通过 __slots__ 变量的声明，color不允许被定义# pet.color = 'yellow' # AttributeError: 'Pet' object has no attribute 'color'# print(Pet.__doc__) # 输出注释print(pet.name2) # big pigprint(pet.age) # 2# pig 实例对象不能调用临时变量 name2，因为 __slots__变量定义的参数名称之能限定在它所在的类中，对子类不起作用# print(pig.name2) # AttributeError: name2 @property的使用既能检查参数，又可以`用类似属性`这样简单的方式来`访问类的变量` 实现 关键字：@property,@参数名.setter 代码示例 - Pet类 12345678910111213141516171819'''Pet类'''class Pet(object): def play(self): print(self.__name + " is very good !") '''@property的使用''' # 此处的 color 为 此类对外界声明的一个变量，即：是一个变量名 # 此方法相当于 get_color() @property def color(self): return self._color # 此方法相当于 set_color(self, color) @color.setter def color(self, color): if not isinstance(color, str): raise ValueError('input a str') self._color = color 代码示例 - 调用 123456# 错误的写法，验证对于参数的检验# pet.color = 123 # ValueError: input a strpet2 = Pet()# 为Pet类的color属性设置具体的参数pet2.color = 'grew'print(pet2.color) # grew 多继承在设计类的继承关系时，通常，主线都是单一继承下来的，如果需要“混入”额外的功能，通过多重继承就可以实现，一个类在继承了一个类的基础上，再次继承另一个类。这种设计通常称之为`MixIn`。 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 如： 12class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 08-模块]]></title>
    <url>%2FPython3%20%2008-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Python所有的内置函数：https://docs.python.org/3/library/functions.html 定义在`python`中一个`.py`文件就是一个模块(Module) 优点 提高代码的可维护性 代码的复用性 避免函数名和变量名的冲突 为避免模块名命名冲突，引入了包(每一个包目录下都有一个文件：__init__.py。这个文件是必须存在的，否则python回将这个目录当成普通的目录，而不是一个python包。这个文件可以是空文件，也可以有代码。因为__init__.py本身就是一个模块(mycompany)) 模板1234567891011121314151617#!/usr/bin/env python3# _*_ coding:utf-8 _*_# 当前模块的文档注释，任何模块代码的第一行字符串都视为该模块文档的注释'A test module'# 使用'__author__'变量将作者的名字写入此模块__author__ = 'Yannis Cheng''''以上为python模块的标准文件模板''''''注意到这两行代码：'''if __name__=='__main__': test()'''当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。''' 安装第三方模块在Python中，安装第三方模块，是通过包管理工具`pip`完成的。 在Mac或者Linux下可能会并存`Python 3.X`和`Python 2.X`，此时的命令应该为`pip3` 函数&amp;变量 作用域 公开public：可以被直接引用，如’abs‘等。类似__name__这样的变量是特殊变量可以被直接引用。自己定义的变量一般不使用这种变量名。 非公开：_abc，__aabc python中并没有一种方法可以完全限制访问private函数访问，但是从编程习惯中不应该引用private函数或变量]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 06-闭包+匿名+装饰器+偏函数]]></title>
    <url>%2FPython3%20%2006-%E9%97%AD%E5%8C%85%2B%E5%8C%BF%E5%90%8D%2B%E8%A3%85%E9%A5%B0%E5%99%A8%2B%E5%81%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[参考：http://www.cnblogs.com/vamei/archive/2012/12/15/2772451.html 闭包闭包是函数式编程的重要语法结构，python是以`函数对象`为基础的，python一切皆对象。函数这一语法结构也是一个对象。 定义解释 在一个内部函数里，对在外部作用域的（非全局）变量进行引用，那么内部函数就认为是闭包closure ‘闭包’是‘词法闭包’的简称，是指应用了自由变量的函数。这个被引用的自由变量的将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 ‘闭包’是由函数和其他相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 ‘python’中的闭包：一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。而这个函数B就叫做闭包，在调用函数A时传递的参数就是自由变量。 闭包实际上就是一个简化的类，它提高了代码的复用性 闭包函数代码示例 123456789101112'''闭包示例代码inner_func就是一个闭包函数，它引用自由变量name。name就是inner_func()的环境变量'''def func01(name): def inner_func(age): print('name: ', name, 'age: ', age) return inner_funcbb = func01('cwj')bb(25) # name: cwj age: 25 关于闭包函数的使用问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152'''错误的闭包函数 1 闭包函数中， 闭包中的变量m不会修改外部函数中m的值。'''def foo(): m = 0 def fool(): m = 11 print(m) print(m) # 0 fool() # 11 print(m) # 0print(foo())'''错误的闭包函数 2 '''def foo2(): a = 1 def fool2(): # a = a +1 # UnboundLocalError: local variable 'a' referenced before assignment return a # 1 return fool2ccc = foo2() # 此时：ccc = fool2，ccc只是获得到了一个对象print(ccc()) # 此时：ccc = fool2(), ccc获取到的是一个实例flist = []for i in range(3): # 编写 1 # def foo3(x): def foo3(x, y = i): # 编写 1 的输出 # print(x + i) print(x + y) flist.append(foo3)for f in flist: f(2)'''编写 1 的运行结果为：444结果是4,4,4。这是因为当把函数加入flist列表里时，python还没有给i赋值，只有当执行时，再去找i的值是什么，这时在第一个for循环结束以后，i的值是2，所以以上代码的执行结果是4,4,4.编写 2 的运行结果为：234在程序里面经常会出现这类的循环语句，Python的问题就在于，当循环结束以后，循环体中的临时变量i不会销毁，而是继续存在于执行环境中。还有一个python的现象是，python的函数只有在执行时，才会去找函数体里的变量的值''' 闭包的作用 参考：http://www.jb51.net/article/54498.htm 闭包主要在函数开发中使用 当闭包函数执行完毕后，仍然能够保持住当前的运行环境 闭包可以根据外部作用域的局部变量来得到不同的结果 引用：闭包与并行运算 闭包有效的减少了函数所需定义的参数数目。这对于并行运算来说有重要的意义。在并行运算的环境下，我们可以让每台电脑负责一个函数，然后将一台电脑的输出和下一台电脑的输入串联起来。最终，我们像流水线一样工作，从串联的电脑集群一端输入数据，从另一端输出数据。这样的情境最适合只有一个参数输入的函数。闭包就可以实现这一目的。 并行运算正称为一个热点。这也是函数式编程又热起来的一个重要原因。函数式编程早在1950年代就已经存在，但应用并不广泛。然而，我们上面描述的流水线式的工作并行集群过程，正适合函数式编程。由于函数式编程这一天然优势，越来越多的语言也开始加入对函数式编程范式的支持。 匿名函数定义 匿名函数由关键字lambda表示。:前面的参数名表示函数的参数，:后面的表达式表示为函数执行具体操作的表达式。 ####特点 python对匿名函数的支持有限，只能在一些简单的情况下使用匿名函数 匿名函数有个数限制，只能有一个表达式，不用写return，返回值就是该表达式的结果。 代码示例 1234'''匿名函数的使用 - 1'''print(list(map(lambda x: x*x, [1, 2, 3, 4]))) # [1, 4, 9, 16]'''匿名函数的使用 - 2''' 装饰器定义在代码运行期间动态增加功能的方式，称之为“装饰器(decorator)” 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192'''原函数def now(): print('2017-07-16')now() # 2017-07-16''''''定义一个 now() 的 装饰器函数 log()'''def log(func_origin): def add_func(*args, **kwargs): print('call %s()' % func_origin.__name__) # 因为log()是一个decorator，所以接受一个函数作为参数，并返回一个函数。 # 返回原函数所具有的功能 return func_origin(*args, **kwargs) return add_func'''使用 装饰器函数 log()'''@log# @log 等价于 now = log(now)def now(): print('2017-07-16')'''调用被装饰器装饰的函数now()'''now()'''运行结果：call now()2017-07-16释义：由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。''''''需要传入参数的decorator, 即：3层嵌套'''def log2(text): def decorator(func): def wrap(*args, **kwargs): print('%s %s()' % (text, func.__name__)) # return func(*args, **kwargs) return func() # 输出结果中有：2017-07-16 # return func # 输出结果中没有：2017-07-16 return wrap return decorator'''3层嵌套的使用'''#@log2('execute')# @log2 等价于 now2 = log2('execute')(now2)def now2(): print('2017-07-16')now2 = log2('execute')(now2)now2()'''运行结果：def now():print('2017-07-16')''''''函数也是对象，它有__name__等属性，但经过decorator装饰之后的函数，它们的__name__已经从原来的'now2'变成了wrap'''print(now2.__name__) # wrapdef log3(text): def decorator3(func3): @functools.wraps(func3) # 词条语句等价于 # wrap3.__name__ = func3.__name__ # 需要把原始函数的__name__等属性复制到wrap3()函数中，否则，有些依赖函数签名的代码执行就会出错。 def wrap3(*args, **kwargs): print('%s %s()' % (text, func3.__name__)) # return func3() func3() return wrap3 return decorator3@log3('execute')def now3(): print('2017-07-16')now3()print('now3 name is : ', now3.__name__)'''运行结果execute now3()2017-07-16now3 name is : now3''' 偏函数定义当函数的参数个数太多，需要简化时，使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 代码示例 12345int2 = functools.partial(int, base=2)#等价于def int2(x, base=2): return int(x, base) functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 05-函数式编程-函数作为返回值]]></title>
    <url>%2FPython3%20%2005-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445'''求和运算'''def add_sum(*args): add = 0 for n in args: add = add + n return addprint(add_sum(1, 2, 3, 4, 5)) # 15'''将函数 -实例- 作为返回值'''def add_sum_func(*args): def my_sum(): add = 0 for n in args: add = add + n return add return my_sum()'''将函数 -对象- 作为返回值'''def add_sum_func_02(*args): def my_sum(): add = 0 for n in args: add = add + n return add return my_sum# 调用 add_sum_func()时，返回的不是函数求和的结果，而是求和函数本身，就是延迟了函数结果的实现print(add_sum_func(1, 2, 3, 4, 5)) # 15new_f = add_sum_func(1, 2, 3, 4, 5)print(new_f) # 15# print(new_f()) # TypeError: 'int' object is not callableprint(add_sum_func_02(1, 2, 3, 4, 5)) # &lt;function add_sum_func_02.&lt;locals&gt;.my_sum at 0x1021ef8c8&gt;new_f = add_sum_func_02(1, 2, 3, 4, 5)print(new_f) # &lt;function add_sum_func_02.&lt;locals&gt;.my_sum at 0x1021ef8c8&gt;print(new_f()) # 15'''释义'''''' 函数add_sum_func()与add_sum_func_02()的区别除了函数名字上有区别，在其函数内部只有一点不同，即返回值： 一个是：return my_sum()。带()表示返回的是 函数的数值，即：结果值。 另一个是：return my_sum。不带()表示返回的是 函数本身，即：函数所在内存的地址。 通过查看输出的结果可以清晰的对比出两者的不同。''']]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 04-迭代器]]></title>
    <url>%2FPython3%20%2004-%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[能够使用for循环的数据类型有以下几种： 集合：list、tuple、set、dict 构建类型generator，带yield的generator function 字符串类型：str 复习：可以使用isinstance()判断一个对象是否是Iterable对象。需要导包：from collections import Iterable 1isinstance)(x, Iterable) 迭代器可以被`next()`函数调用并不断返回下一个值的对象称为——迭代器（`Iterator`） 判断一个对象是否为迭代器 1isinstance(x, Iterator) 代码示例 123456789101112131415'''判断是否 可迭代'''print(isinstance((x for x in range(1, 10)), Iterator)) # 构建类型 Trueprint(isinstance([1, 2], Iterable)) # list类型 Trueprint(isinstance((1, 2), Iterable)) # tuple类型 Trueprint(isinstance(&#123;1, 2&#125;, Iterable)) # set类型 Trueprint(isinstance(&#123;'1': 'A', '2': 'B'&#125;, Iterable)) # dict类型 Trueprint(isinstance('ABC', Iterable)) # str类型 rue'''判断是否为 迭代器 对象'''print(isinstance((x for x in range(1, 10)), Iterator)) # 构建类型 Trueprint(isinstance([1, 2], Iterator)) # list类型 Falseprint(isinstance((1, 2), Iterator)) # tuple类型 Falseprint(isinstance(&#123;1, 2&#125;, Iterator)) # set类型 Falseprint(isinstance(&#123;'1': 'A', '2': 'B'&#125;, Iterator)) # dict类型 Falseprint(isinstance('ABC', Iterator)) # str类型 False]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 05-函数式编程-高阶函数]]></title>
    <url>%2FPython3%20%2005-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ `Python`对函数式编程提供部分支持。由于`Python`允许使用变量，因此，`Python`不是纯函数式编程语言。 函数与变量互指代码示例 12345x = abs # 函数名其实也是一个变量，变量之间是可以互指。print(x(-10)) # 10。此时，x就是一个求'绝对值'的函数abs = 10print(abs) # 10print(abs(10)) # TypeError: 'int' object is not callable。此时的abs已经不是一个函数，而是一个值为10的变量。 高阶函数将函数作为参数传入另一个函数，这样的函数被称为高阶函数。 代码示例 12345def high_func(z, y, f): return f(z) + f(y)# 将函数abs作为一个参数指向变量fprint(high_func(-1, -3, abs)) # 4 高阶函数 - map() map接收两个参数：一个是函数，另一个是Iterable， map函数的意义是：将传入的函数依次作用于每一个序列的每一个元素，并将结果作为新的Iterator返回 1234567891011121314151617181920212223242526272829303132333435363738def func(x): return x * x'''通过一行代码实现：序列中的每一个元素进行取平方运算，将结果作为list序列输出'''print(list(map(func, [1, 2, 3, 4, 5]))) # [1, 4, 9, 16, 25]v = map(func, [1, 2, 3, 4, 5])print(isinstance(v, Iterator)) # Trueprint(isinstance(v, Iterable)) # Trueprint(isinstance('abc', Iterator)) # False'''使用 next() 输出Iterator类型的对象 修改前'''# while True:# print(next(v))'''1StopIteration491625''''''修改后'''while True: try: print(next(v)) except StopIteration: break'''1491625''' 高阶函数 - reduce() 参数：两个参数。函数名，序列 作用：将结果继续和序列的下一元素做函数名指定的运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ls = [1, 2, 3, 4, 5]def fun_add(x, y): return x + yprint(reduce(fun_add, ls)) # 15.# 将序列 ls 中的数变成组合成一个整数def func_int(x, y): return x * 10 + yprint(reduce(func_int, ls)) # 12345def func_str(s): # 将字符串转换为int类型。根据`键`取对应的`值` return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s]# 将str类型变为int类型print(reduce(func_int, list(map(func_str, '1234567')))) # 1234567# 将以上方法编写为一个str类型转int的方法def func_str_to_int(s): def f_int(x, y): return x * 10 + y def f_str(ss): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[ss] return reduce(f_int, map(f_str, s))print(func_str_to_int('11223344')) # 11223344'''测试，将不规则的输入按照指定的要求输出。如：'AsdA' 'asdS' 输出后的结果为：'Asda', 'Asds' '''def func_rule(s): # if isinstance(s, str): if isinstance(s, list): def func_to_up(ss): return ss[0].upper() + ss[1::].lower() return list(map(func_to_up, s)) else: print('输入的参数类型有误！') return '-1'L1 = ['adam', 'LISA', 'barT']print(func_rule(L1)) # ['Adam', 'Lisa', 'Bart']'''求乘积'''ll = [3, 5, 7, 9]def prod(lll): def xx(x, y): return x * y return reduce(xx, lll)print(prod(ll)) # 945 高阶函数 - filter() 作用：过滤函数. True保留序列中的元素，False删除序列中的元素 1234567lf = [1, 2, 3, 4, 5]# 过滤一个序列中的偶数def func_odd(n): return n % 2 == 1print(list(filter(func_odd, lf))) # [1, 3, 5] 高阶函数 - sorted() 排序算法 1234567891011121314151617181920212223# 对list类型的数据排序ls01 = [1, -9, 10, 5, 23, -3]print(sorted(ls01)) # [-9, -3, 1, 5, 10, 23]# 高阶函数使用 按照绝对值进行排序print(sorted(ls01, key = abs)) # [1, -3, 5, -9, 10, 23]ls02 = ['asd', 'ffgd', 'fhfgh', 'werr', 'bnbm']# 高阶函数使用 对 字符串 进行排序 根据小写字母排序print(sorted(ls02, key=str.lower)) # ['asd', 'bnbm', 'ffgd', 'fhfgh', 'werr']# 高阶函数使用 对 字符串 进行排序 根据大写字母排序--实现方式1print(sorted(ls02, key=str.lower, reverse=True)) # ['werr', 'fhfgh', 'ffgd', 'bnbm', 'asd']L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]'''根据学生的名字排序'''print(sorted(L)) # [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]'''根据学生的成绩排序'''print(sorted(L, key=itemgetter(1))) # [('Bart', 66), ('Bob', 75), ('Lisa', 88), ('Adam', 92)] itemgetter()的使用 参考：http://www.cnblogs.com/zhoufankui/p/6274172.html operator.itemgetter函数用于获取对象指定的下标数据。如根据学生成绩排序的方法使用中：获取序列中tuple元素下标为1的数据 operator.itemgetter函数获取的不是数值，而是重新定义了一个函数，通过将该函数作用于对象上才能获取数据，如：将数值赋值给key 特点：itmegetter()中的参数可以不按照数字大小的顺序来填入，可以使用2，1这样的顺序，表示 先获取 下标为2的数据值，再获取下标为1的数据的值。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-数据-序列]]></title>
    <url>%2FPython3%20%2002-%E6%95%B0%E6%8D%AE-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[通过print()结果来区分各种序列类型 []是list ()是tuple {}是set {key:value, ...}是dict 说明：在序列声明时： list使用[] tuple与set使用()。其中声明set值时用到set关键字，以区分tuple dict使用{} set使用set() 关于集合–list和tuple list是python内置的、是有序的、可随时添加、删除其中元素的数据类型。通过[]来包裹内容 tuple是有序、”指向不可变“的另一种集合，称为”元组“。通过()来包裹内容 list使用print()后打印的结果为：`[]`` set使用print()后打印的结果为：{} 序列相加相同数据类型序列之间可以相加，不同数据类型序列不能相加 1.list 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051nameList = ['张三', '李四', '王五']print(nameList) #['张三', '李四', '王五']#增 方式-1：追加,只能添加到集合的末尾nameList.append('赵六')print(nameList) #['张三', '李四', '王五', '赵六']#增 方式-2：插入。参数1，添加的位置；参数2，插入的内容nameList.insert(1,'钱七')print(nameList) #['张三', '钱七', '李四', '王五', '赵六']#删nameList.pop(1)print(nameList) #['张三', '李四', '王五', '赵六']#删，无参数情况下默认删除最后一个元素nameList.pop()print(nameList) #['张三', '李四', '王五']#改 根据指定的下标，替换元素nameList[0] = '孙八'print(nameList) #['孙八', '李四', '王五']#查 输出集合的长度print(len(nameList)) #3#查 输出指定位置的元素 方式-1：从前向后，正序print(nameList[1]) #李四#查 输出指定位置的元素 方式-2：从后向前，倒序print(nameList[-1]) #王五#查 循环遍历，方式-1 forfor nameSingle in nameList: print(nameSingle)'''孙八李四王五'''#查 循环遍历，方式-2 whilecount = len(nameList)while count &gt; 0: print(nameList[(-count)]) count = count-1'''孙八李四王五''' 2.tuple 代码示例 123456789101112131415161718tupleValue = (1,2)#空的tupletupleValue01 = ()#只有1个元素的tuple定义时必须加一个逗号·,·，来消除歧义。若不加，则定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号。tupleValue02 = (1,)#一个“可变的”tuple：变的不是tuple的元素，而是其中的list的元素#tuple一开始指向的list并没有改成别的list，所以所谓的“不变”是说，tuple的每个元素，指向永远不变。# 即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！t = ('a', 'b', ['A', 'B'])print(t[2][0])print(t[2][1])'''AB''' 关于dict和set dict dict在其他语言中称为map，其存储的值是 无序 的，使用的键-值对（key-value）存储,用{}来包裹内容。 dict使用print()后打印的结果为：{‘mac’: 999999, ‘hp’: 777777, ‘ASUS’: 46567} dict默认是去重复的 注意: dict的key必须是不可变对象。 特点：和list相比 1.查询速度快 2.内存占用量大 dict代码示例 1234567891011121314151617181920d = &#123;'mac':999999, 'hp':777777, 'ASUS':46567&#125;#查print(d['mac']) #999999#改d['mac'] = 90000print(d['mac']) #90000#判断dict中是否存在当前的键 方法-1print('mac' in d) #Trueprint('lenvol' in d) #False#判断dict中是否存在当前的键 方法-2print(d.get('mac')) #90000print(d.get('lenvol')) #None#删d.pop('mac')print(d) #&#123;'hp': 777777, 'ASUS': 46567&#125; set set是 list的精简版，去掉其重复的元素，而且只存储key值，不存储value值。即set内部是无重复元素的。 set 不能放入 可变对象.因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素” set使用print()后显示的结果是：{} set中到的参数只能放一个。 注意: dict的key必须是不可变对象。 特点：和list相比 1.查询速度快 2.内存占用量大 set代码示例 12345678910111213141516171819202122l = [1,5,1,1,2,2,3,3,4,5]print(l) #[1, 5, 1, 1, 2, 2, 3, 3, 4, 5]print(len(l)) #10s = set(l)print(s) #&#123;1, 2, 3, 4, 5&#125;print(len(s)) #5s.add(7)print(s) #&#123;1, 2, 3, 4, 5, 7&#125;print(len(s)) #6s.remove(7)print(s) #&#123;1, 2, 3, 4, 5&#125;print(len(s)) #5s2 = set([4,5,6,7,8,9])#交集print((s &amp; s2)) #&#123;4, 5&#125;#并集print((s | s2)) #&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; 解释“不可变对象”代码示例 12345678910111213141516171819a = 'abc'print(a)print(a.replace('a','A'))print(a)'''abcAbcabc'''b = a.replace('a','A')print(b)print(a)print(b)'''AbcabcAbc''' 由上面的代码可以看出：在调用了变量a的replace()之后，立即输出变量a的值，此时变量a的值是修改后的，但是在次输出a的值时，还是原来的内容，即：变量a的内容最终并没有被修改。 那为什么立即输出a修改后的内容时是变化的呢？ 当我们把修改后a的值赋给变量b时，不管输出多少次b变量的值，其内容一直是不变的。也就是说：变量b存储的是一个新的内容，即一个新的str类型的对象。而这个新的str类型的对象是在变量a所指的对象的基础上修改之后的新对象。 结论就是：不可变对象修改后得到的对象是一个新的对象，而原有的对象保持不变 条件判断elif是else if的缩写，完全可以有多个elif 代码示例 1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环 1.for A in AList. 将‘AList集合’中的每一个元素赋值到‘变量A’中2.while n。只要条件’n‘满足，就将‘AList集合’中的每一个元素取出并赋值到变量中 for ... in ... while 遍历主要是使用: for in代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 ls = [1, 2, 3, 4, 5, 6, 7, 8, 9] sum02 = 0 for item in ls: print(item) sum02 = sum02 + item print(sum02) ''' 1 2 3 4 5 6 7 8 9 45 ''' d = &#123;'cwj': 150, 'zh': 145, 'ww': 234, 'cwj': 200&#125; print(d) # &#123;'cwj': 150, 'zh': 145, 'ww': 234&#125; print(len(d)) # 3 print(d.keys()) # dict_keys(['cwj', 'zh', 'ww']) dlk = list(d.keys()) print(dlk) # ['cwj', 'zh', 'ww'] dlks = set(dlk) print(dlks) # &#123;'zh', 'ww', 'cwj'&#125; dtk = tuple(d.keys()) print(dtk) # ('cwj', 'zh', 'ww') '''遍历方式 1''' for (key, value) in d.items(): print(key, value) ''' cwj 200 zh 145 ww 234 ''' '''遍历方式 2''' for key in d: print('dict[%s]\'s value is : ' % key, d[key]) ''' dict[cwj]'s value is : 200 dict[zh]'s value is : 145 dict[ww]'s value is : 234 ''' '''遍历方式 3 ，遍历到指定的key时，修改其元素''' for key in d.keys(): print(key) print(d[key]) if key == 'cwj': d[key] = 500 print('ok cwj,your grade has changed!') print(d) ''' cwj 200 ok cwj,your grade has changed! zh 145 ww 234 &#123;'cwj': 500, 'zh': 145, 'ww': 234&#125;''' 几个内置函数代码示例 1234567891011121314151617ll = [1, 2, 3, 4]ll2 = [5, 6, 7, 8]ll3 = [1, 2, 3, 4, 5, 6, 7, 8]ll4 = [2, 7, 4, 5, 0, 1, 9, 1]print(ll * 2) # [1, 2, 3, 4, 1, 2, 3, 4]print(ll + ll2) # [1, 2, 3, 4, 5, 6, 7, 8]# 不能相减# print(ll3 - ll2)# 成员资格# 检测 1 是否在 ll2序列 中， 使用 in 关键字返回值# 为：True or Falseprint(1 in ll2) # False# 获得序列中的最大值print(max(ll3)) # 8print(min(ll4)) # 0]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-返回值]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在python交互环境中，使用本地文件自己定义的函数进入到文件所在的目录下后，将HelloWorld文件中的my_abs方法导入到交互环境中： from HelloWorld import my_abs Hello World 输出的是中文my_abs(-12)12 为系统函数建立别名12a = absprint(a(-90)) #90 空函数 - passpass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码 能运行起来。这样的函数适用于在上下文中，保持 整体逻辑思路 的通畅。 代码示例 12def nop(): pass 除了在函数体内使用之外，在其他语句中也可以使用：代码示例 12if age &gt;= 18: pass 函数参数检查 - isinstance()当我们自定义的函数传入了不恰当的参数时，python的函数能够检测出错误的参数，而我们自定义的函数则不能。当报错时，提示的错误信息和系统内置的函数提示的错误信息也不一样。我们应该完善我们自己定义的函数，使用isinstance()方法 代码示例 1234567891011def my_abs_good(x): # if not isinstance(x,(int, float)): raise TypeError('输入的参数类型异常') if x &gt; 0: return x else: return -xprint(my_abs_good(-2)) #2print(my_abs_good('a')) #TypeError: 输入的参数类型异常 判断一个数据类型是否为可迭代对象代码示例 123s = 'ABC'print(isinstance(s, Iterable)) # Trueprint(isinstance(123, Iterable)) # False 自定义函数的返回值 多个返回值 的本质是一个：tuple对象。只有一个返回值时，默认不显示() 多返回值 代码示例 123456789101112131415161718192021222324252627282930313233def getXY(x, y, step, angle = 0): nx = x + step * math.cos(angle) ny = y - step * math.cos(angle) #返回两个值 return nx, ny# 1x, y = getXY(10,20,100)print(x, y) #110.0 -80.0# 2x, y = (110.0, -80.0)print(x, y) #110.0 -80.0# 3z = getXY(10,20,100)print(z) #(110.0, -80.0)# 4z2 = (10)print(z2) #10'''比较 #1，#2，#3, #4 可以得出，函数的返回值其实是一个tuple对象,当返回值只有1个时，回省略掉()'''print(getXY(10,20,100)) #(110.0, -80.0)x, y, z = (10, 20, 100)print(x, y, z) #10 20 100print(x) #10'''在声明多个变量的同时，也将tuple对象的值对应的赋值给变量，很神奇！''' 没有返回值 return None 代码示例 12def noRetuen(): print('aaaa') 返回值小结 定义函数时，需要确定 函数名 和 参数个数； 如果有必要，可以先对参数的 数据类型 做检查； 函数体内部可以用 return 随时返回函数结果； 函数执行完毕也 没有return语句 时，自动 return None。 函数可以同时返回 多个值，但其实就是一个 tuple。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-参数类型]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[默认参数必须指向 不可变对象。 因为不变对象一旦创建，对象内部的数据就 不能修改，这样就减少了由于修改数据导致的错误。 此外，由于对象不变，多任务环境下同时读取对象 不需要加锁，同时读一点问题都没有。 函数参数的5种类型 1.必选参数2.默认参数3.可变参数4.关键字参数5.命名关键字参数组合参数注意： 函数参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 必选参数代码示例 1234def fun(num): print(num*num)fun(10) #100 默认参数代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041##默认参数示例 1: tag = 2,为默认参数def fun2(num, tag = 2): s = 1 while tag &gt; 0: tag = tag - 1 s = s * num return sprint(fun2(5)) #25print(fun2(5,3)) #125#默认参数示例 2def fun3(name, age = 6, city = 'beijing'): print("name is %s" % name) print("age is %d" % age) print("city is %s" % city)fun3('cwj')'''name is cwjage is 6city is beijing '''#默认参数在赋值时要注明： 参数名称fun3('cwj', age = 9)'''name is cwjage is 9city is beijing'''fun3('cwj', city='tinajin')'''name is cwjage is 6city is tinajin''' 可变参数可变参数（个数可变），其本质是 `tuple`集合，由函数返回的结果可以看出 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个`tuple` 代码示例 12345678910111213141516171819202122def fun4(*numbers): sum = 0 for num in numbers: sum = sum + num * num print(sum)fun4(2,3,4) #29'''*l表示把l这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见'''l = [2,3,4]fun4(*l) #29'''*t表示把t这个tuple的所有元素作为可变参数传进去。这种写法相当有用，而且很常见'''t = (2,3,4)fun4(*t) #29e#可变参数个数为0fun4() #0 关键字参数关键字参数本质 dict（实际参数为 键值对 即可） 而关键字参数允许你传入0个或任意个含 参数名的参数 ，这些关键字参数在函数 内部 自动组装为一个 dict。 12345678910111213141516171819202122232425262728293031323334353637383940414243def fun5(name, age, **keyWord): print('fun5-----') print("name is : ", name) print("age is : %d" % age) print("address is : ", keyWord)#传入1个关键字参数fun5('cwj', 24, address='tianjin')'''name is : cwjage is : 24address is : &#123;'address': 'tianjin'&#125;'''#传入多个关键字参数fun5('cwj', 24, address='beijing', weather='hot')'''name is : cwjage is : 24address is : &#123;'address': 'beijing', 'weather': 'hot'&#125;'''#传入0个参数fun5('cwj', 24)'''name is : cwjage is : 24address is : &#123;&#125;'''#在有现成dict类型的情况下#此处是将d这个dict类型对象的所有 key-value 用关键字参数导入到函数的**keyWord参数中，keyWord获得的是d的一份拷贝，对keyWord的改变将不会影响到函数外的d本身。d = &#123;'address': 'beijing', 'wether':'hot'&#125;fun5('cwj', 24,**d)name is : cwjage is : 24address is : &#123;'address': 'beijing', 'wether': 'hot'&#125; 命名关键字此种参数是用来 限制关键字参数 的名字，就是仅接受 已经命名的形参 的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455'''表示方法1：*，参数名1，参数名2'''def fun6(name, age, *, address, wethear): print('fun6-----') print("name is : ", name) print('age is : %d' % age) print('address is : %s' % address) print('wether is : ', wethear)fun6('cwj', 26, address='tianjin', wethear='hot')'''name is : cwjage is : 26address is : tianjinwether is : hot''''''表示方法2，若函数中已经含有一个'可变参数'，则之后的参数不需要在添加 * 符号'''def fun7(name, age, *keyWord, city, wether): print('fun7-----') print('name is : ', name) print('age is : ', age) print('keuWord is : ', keyWord) print('city is : ', city) print('wether is : ', wether)fun7('cwj', 24, 'xian', city='tianjin', wether='windy')'''name is : cwjage is : 24keuWord is : ('xian',)city is : tianjinwether is : windy''''''表示方法3：设置有默认值的命名关键字参数'''def fun8(name, *, city='beijng',wether): print(name, city, wether)fun8('cwj',wether='hot')'''cwj beijng hot'''def fun9(name): passfun9('cwj') 组合参数代码示例 12345678910111213141516171819202122232425262728293031# 参数 必须参数，可选参数，可变参数，关键字参数def fun10(name, age=19, *key_word, **city): print(name, age, key_word, city)# 参数 必须参数，可选参数，可变参数，命名关键字参数def fun11(name, age=19, *key_word, city, weather): print(name, age, *key_word, city, weather)# 参数 必须参数，可选参数，命名关键字参数def fun12(name, age=8, *, city, weather): print(name, age, city, weather)# 参数 可选参数，可变参数，命名关键字参数def fun13(age=23, *l_num, **key_word): print(age, l_num, key_word)l = [1, 2, 3]fun10('cwj', 24, *l) # cwj 24 (1, 2, 3) &#123;&#125;fun10('cwj', 24, *l, city='beijing') # cwj 24 (1, 2, 3) &#123;'city': 'beijing'&#125;fun11('cwj', 24, *l, city='tianjin', weather='hot') # cwj 24 1 2 3 tianjin hotfun12('cwj', age=24, city='xian', weather='very hot') # cwj 24 xian very hotfun12('cwj', 0, city='beijing', weather='windy') # cwj 0 beijing windyfun13(24, *l, fa='sss') # 24 (1, 2, 3) &#123;'fa': 'sss'&#125;]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-生成器+切片]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E7%94%9F%E6%88%90%E5%99%A8%2B%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[高级特性——(slice)切片，表示为[::] 切片语法：[1:4:2] 数字’1’ 表示开始的索引位置 数字’4’ 表示结束的索引位置 数字’2’ 表示间隔的索引数 补充于：2017年07月18日16:29:53 Python序列切片操作：http://developer.51cto.com/art/201304/389771.htm 切片的方向与位置 对于序列结构数据来说，索引和步长都具有正负两个值任意一个序列结构数据的索引范围为: -len(consequence) 到 len(consequence)-1 范围内的连续整数。step 步长：默认为1，步长值不能为0。切片过程:从第1个想要的对象开始，到第1个不想要的对象结束 说明 正索引默认位置 负索引默认位置 序列方向说明 左 –&gt; 右 左 &lt;– 右 序列第一个元素位置 0 -len(consequence) 序列末元素位置 len(consequence)－1 -1 切片方向代码示例 12345678s3 = [1,2,3,4,5]print(s3[1:4:1]) # [2, 3, 4]print(s3[-4:-2]) # [2, 3]print(s3[-3:-1]) # [3, 4]print(s3[-5:]) # [1, 2, 3, 4, 5]print(s3[:]) # [1, 2, 3, 4, 5]print(s3[-1::-1]) # [5, 4, 3, 2, 1]print(s3[-1:]) # [5] range语法range(start, stop, step) 参考：http://www.nowamagic.net/academy/detail/1302446 根据start和stop确定范围，根据step设定步长 range与xrange 两者都能用于for循环中range 与 xrange 用法上完全相同，不同点是，产生的结果类型不同 range 产生的结果是 list xrange 产生的结果是 生成器 代码示例 123456789101112'''这两个输出的结果都是一样的，实际上有很多不同，''''''range会直接生成一个list对象'''&gt;&gt;&gt; range(5)[0, 1, 2, 3, 4]'''而xrange则不会直接生成一个list，而是每次调用返回其中的一个值'''&gt;&gt;&gt; xrange(5)xrange(5)&gt;&gt;&gt; list(xrange(5))[0, 1, 2, 3, 4]'''要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。''' 函数range的使用12345678910111213141516'''表示从1开始，到10之前（不包括10'''l = range(1, 10)'''从0开始（0可以省略），生成10个数'''ll = range(10)'''从0开始，生成10个数，公差为2（相邻的数之间间隔为2）'''lll = range(0, 10, 2)'''根据range的规则，生成指定的序列'''print(l) # range(1, 10)print(ll) # range(0, 10)print(list(l)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]print(list(ll)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]print(list(lll)) # [0, 2, 4, 6, 8]'''从缩影0开始，去之后索引+2对应的具体数值'''print(list(lll)[::2]) # [0, 4, 8] 使用range进行求和 123456sum = 0numbers = range(1, 10)for i in numbers: sum += iprint(sum)'''45''' 对list使用切片1234567891011l = ['cwj', 'serr', 'bob', 'jack']'''取3个元素 使用方法 切片（slice）,是指：取出一个范围内的元素''''''从索引0开始，直到3为止，但是不包括索引3，实际的取得索引为0，1，2 如果索引是从0开始的，0可以省略'''print(l[0:3]) # ['cwj', 'serr', 'bob']print(l[:3]) # ['cwj', 'serr', 'bob']'''倒着取出元素'''print(l[-3:]) # ['serr', 'bob', 'jack']print(l[0:-3]) # ['cwj'] 对str使用切片1234s = 'cwj, cwj, cwj, cwj'sp = s[::]print(sp) # cwj, cwj, cwj, cwjprint(sp[0:4:2]) # cj 对dict使用切片 – dict不适用与切片123print("对dict使用切片")d = &#123;'cwj': 150, 'zh': 145, 'ww': 234, 'cwj': 200&#125;# print(d[1:3]) # TypeError: unhashable type: 'slice' 对tuple使用切片1234567891011121314print(range(8)) # range(0, 8)ll5 = range(8) # range(0, 8)print(ll5)t = tuple(ll5)print(t) # (0, 1, 2, 3, 4, 5, 6, 7)lls = t[::]print('将 t序列 复制后的结果为：')print(lls)'''将 t序列 复制后的结果为：(0, 1, 2, 3, 4, 5, 6, 7)注意： tuple执行切片以后仍是一个tuple''' 对set使用切片1234s = set(lls)print(s) # &#123;0, 1, 2, 3, 4, 5, 6, 7&#125; 是set类型的数据spl = t[::]print(spl) # (0, 1, 2, 3, 4, 5, 6, 7) 使用range后是tuple类型的数据 迭代器 for 的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768s = 'ABC'for c in s: print(c)'''使用下标循环'''l = [1, 2, 3, 4]for i, value in enumerate(l): print(i, value)'''0 11 22 33 4'''for i, ch in enumerate(s): print(i, ch)'''0 A1 B2 C'''d = &#123;'A': 123, 'B': 456&#125;print(d) # &#123;'A': 123, 'B': 456&#125;for i, dict0 in enumerate(d): print(i, d.items())'''0 A1 B'''ls = [(1, 1), (2, 2), (3, 3)]for x, y in ls: print(x, y)'''1 12 23 3''''''列表生成器'''for x in range(1, 10): print(x * x)'''149162536496481''''''生成的序列后，进行计算'''print([x * x for x in range(1, 9)]) # [1, 4, 9, 16, 25, 36, 49, 64]'''生成序列后，新进行取余数预算，然后进行相乘运算'''print([x*x for x in range(1, 10) if x % 2 == 0]) # [4, 16, 36, 64]'''遍历两个字符串进行 排列组合'''print([m + n for m in 'ABC' for n in '123']) # ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']'''将dict类型的数据转换为 序列'''d = &#123;'A': 1, 'B': 2, 'C': 3&#125;print([k + ' = ' + str(v) for k, v in d.items()]) # 'A = 1', 'B = 2', 'C = 3'] yield关键字 定义generator函数的另一中方式： 当一个函数中含有关键字 yield时，这个函数就不在是一个普通的函数，而是一个generator函数 带有yield关键字的generator函数，执行流程与普通函数不同： - 普通函数：执行到return或者函数的最后一句时，退出函数。 - 带有yield关键字的generator函数，调用next()函数时执行操作，遇到yield()函数时，退出返回。当 再次执行此函数时从上次返回yield语句处继续执行 运行含有yield关键字的函数 123456789101112131415161718192021222324252627282930313233343536def p_yield(): print('step_01') yield 1 print('step_02') yield 2 print('step_03') yield 3# 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：o = p_yield()next(o) # step_01next(o) # step_02next(o) # step_03# next(o) # StopIterationdef fib(max): n, a, b = 0, 0, 1 #l = [] while n &lt; max: '''方法1 返回值：1 \n 2 \n 3 \n 4 \n 5''' # print(b) ''' 方法2 返回值：[1, 1, 2, 3, 5] 函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List来保存中间结果，而是通过 iterable 对象来迭代。 ''' #l.append(b) '''方法3 返回值：1 \n 1 \n 2 \n 3 \n 5. 使用yield关键字，使得生成的值为一个generator对象,而不是使用list占用大量的内存''' yield b a, b = b, a + b n = n + 1 #return l# print(fib(5)) yield关键字的使用 参考：https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/ yield关键字 使得一个普通的函数变成一个generator函数。Python解释器会将其视为一个generator，当for循环fib（5）函数的返回值时，实际调用的是iterable对象。 一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用， 但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。 虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值， 不仅代码简洁，而且执行流程异常清晰 12for n in fib(5): print(n) 区分：fib与fib(5) fib：是一个generator function 好比于：类的定义 fib(5)：是调用 fib 后返回的一个generator对象 好比于：类的实例化]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 01-基础-基本数据类型]]></title>
    <url>%2FPython3%20%2001-%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python是一种计算机编程语言，使用Unicode编码，支持多语言(动态语言，因为变量本身不固定)。 是一种解释性语言在运行 .py 文件时需要通过 解释器 进行解释然后显示呢结果。 区分大小写 参考网站：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 Python代码创建方式 1.在 终端环境 中编写 2.在 文件 中编写 方式 1：在终端环境下 输入 python 进入python交互模式，在&gt;&gt;&gt;后名编写代码： 12300 + 100400 输入 exit() 退出python模式。 方式 2：在文件中 直接在文件中编写代码，然后打开终端进入文件所在目录，运行： 1python 文件名.py 语法1、采用缩进方式（4个空格） 2、大小写敏感，例如：`True`, `False`, `None` 注释 # coding=utf-8 使用Scrapy爬虫框架时应该添加此条语句表明注释是中文注释 # 单行注释 &#39;&#39;&#39; &#39;&#39;&#39;多行注释 符号 ：作用 :结尾表示时，缩进的语句视为代码块,如： 1234if ooo: XXXelse: XXX 字符串编码 参考：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000 ASCII、Unicode和UTF-8的关系在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。所以你看到很多网页的源码上会有类似的信息，表示该网页正是用的UTF-8编码 Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言 数据类型和变量 整数 浮点型 字符串 布尔值 空值 变量 常量 列表 字典 自定义数据类型 整数1，-1，0x123。 整数的除法在Python中有两种：/和//。 其中/表示除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数 1print(13/5) #2.6 另一种除法//称为地板除，两个整数的除法仍然是整数: 1print(13//5) #2 浮点型1.2， 1.23e9, 12.3e8， 1.23e-8 字符串（！此处划重点！） 字符串类型是str。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示。 使用 &#39; &#39; 或者 &quot; &quot; 表示的任意字符。其中包括 “‘”的用法 &quot;I&apos;m OK&quot; 既有&#39;又有&quot;的表示方法 I’m “OK”的用法： &apos;I \&apos;m \&quot;OK\&quot;&apos; 即：需要显示的特殊字符或者需要转义的字符用 \ 表示。 如果不需要转义当前字符，则可以使用 r&#39;&#39; 表示 &#39;&#39;内部不需要转义的字符，例如： 1print(r'"I\'m \"OK\""') 结果为： &quot;I\&apos;m \&quot;OK\&quot;&quot; 在&#39;&#39;&#39; &#39;&#39;&#39; 内可以不使用\n换行符而直接表示多行内容 123print('''line1line2line3''') 结果为： 123line1line2line3 布尔值 注意True和False的大小写，而且布尔值可以用and、or和not运算 测试代码： 123456789101112131415161718print(3 &gt; 2) #Trueprint(3 &lt; 2) #Falseif 3 &gt; 2 and 4 &lt; 5: print("3 &gt; 2")else: print("3 &lt; 2") #3 &gt; 2if 3 &gt; 2 or 4 &gt; 5: print("3 &gt; 2")else: print("3 &lt; 2") #3 &gt; 2if not 4 &lt; 5: print("3 &gt; 2")else: print((not 4 &lt; 5)) #False print("3 &lt; 2") #3 &lt; 2 空值 空值是用None表示的（注意大小写），但是None不能理解为0。 变量 Python与其他不同的是它的变量的类型是通过被赋予的值得类型决定的，即： 后者决定前者的类型。 Python的变量只是一个名字而已，数值内容及其类型才是重点，决定了变量名的实际意义。 变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错,例如Java是静态语言. 12345678a = 123print(a) #123a = "a是个变量名"print(a) #a是个变量名a = Trueprint(a) #Trueb = aprint(b) #True 常量 在Python中，通常用全部大写的变量名表示常量，全部大写的变量名表示常量只是一个习惯上的用法。 格式化输出 格式化输出字符串 – 同C语言，格式化与实际数据之间通过%连接 使用%，%运算符就是用来格式化字符串的，其中 %s 表示替换字符串，%d 表示替换整数，%f 表示替换浮点型%x 表示16进制 代码示例 12345678910name = input('请输入你的名字：') #请输入你的名字：yannisprint('Hello, %s ,你好啊~' % name) #Hello, yannis ,你好啊~age = input("请输入你的年龄： ")print("你的年龄为 %d，确认：%d" % (12,12)) #你的年龄为 12，确认：12#在不确定使用何种类型的数据时，用%s即可print('age is : %s; Gener: %s' % (32,False)) #age is : 32; Gener: False#字符串里面的%是一个普通字符时,需要转义，用%%来表示一个%print('增长率为：%d%%' % 7) #增长率为：7% 一个计算成绩比率的小代码 12345678910111213141516grade1 = input("请输入去年的成绩：")grade2 = input("请输入今年的成绩："#此处将str类型的grade1转换为int的10进制类型，参数：grade1表示待转换的数据，参数：10，表示进制num = int(grade1,10) - int(grade2,10)#此处将int类型的num转换为str类型print('num is : ' + str(num))print('abs is : %d' % abs(num))#将结果转换为float类型mPercent = float(((abs(num))/int(grade1,10))*100)print('mPercent is : ' + str(mPercent))#格式化输出结果print('成绩变化率为：%.2f%%' % mPercent)]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux/Unix系统文件结构]]></title>
    <url>%2FLinux%3AUnix%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[/bin系统有很多放置执行档的目录，但/bin比较特殊。 因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 /etc系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop /etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。 /etc/X11/ ：与XWindow有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 /lib系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /mediamedia是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 /opt这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 /root系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 /sbinLinux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srvsrv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 /tmp这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下： /lost+found这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 根目录下与开机过程有关的目录1234567除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 /usr 的意义与内容：依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。 /usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： /usr/X11R6/为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。/usr/bin/绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var 的意义与内容：如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。 /var/cache/应用程序本身运作过程中会产生的一些暂存档 /var/lib/程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。四. 目录树(directory tree) :在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View-1 三剑客：Canvas + Paint + Path 初步概览]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View-1%20%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%9ACanvas%20%2B%20Paint%20%2B%20Path%20%E5%88%9D%E6%AD%A5%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/d2c7a837265e关于Paint资料非常丰富：http://www.jianshu.com/p/420da0f6e279非常系统的知识：http://hencoder.com/ui-1-1/ 前言 自己一直在学习许多技术大牛的技术博客，看他们是如何学习Android源码，看他们是如何分析当下流行、火热的技术以及框架的使用，可以说是他们的无私奉献、共享精神一直在支持着像我这样渴望学到更多，渴望技术升级的初学者。正所谓“穷则独善其身，达则兼济天下”。一直想着，如果自己有一天能够达到让自己满意的高度，也会将这样的方式继续传递，技术因为通过共享、传递才能得以实现其对社会的价值。 之前自己也学习过自定义View，也写过示例，在项目中也应用过，可都是写较为简单的。而自己写的随手笔记因为条理性、技术点太低（所以不敢称为技术博客），总是使自己不满意，也没有很好的传承下来。最近换了工作而且手头也比较闲，也是一个新的开始。所以秉着好记性不如烂笔头、博客记录成长的信条，将自己的所学、所悟记录下来。 基本自定义View的3个关键点 布局 绘制 触摸反馈 Android坐标系图片来自网络，忘记出处，如有侵权请联系我。 4个级别 Canvas Canvas.drawXXX()是自定义绘制的基本操作。可以绘制几何图形、文字、图片，在+Paint的常用方法。 裁剪范围（很酷的效果） 几何变换（很酷的效果） Paint ：Paint的使用 Path ：轮廓,路径 Canvas的使用 Canvas是“画布”的意思，拥有“绘制”的功能。 1. Canvas的使用需要4个基本元素： 一个Bitmap用于保存像素 一个Canvas来承载绘图调用（写入到位图） 一个绘图的基本元素（例如Rect，Path，文本，位图） 一支Paint（描述颜色和样式） 2. Canvas有两个构造方法： Canvas()：创建一个空的Canvas对象 Canvas(Bitmap bitmap)：用指定的位图构造一个Canvas对象 3. 常用绘制方法：translate()：画布移动drawARGB()：用指定ARGB颜色填充画布上面的位图drawRGB()：用指定RGB颜色填充画布上面的位图drawColor()：用指定颜色填充画布上面的位图drawArc()：画圆弧startAngle：表示开始的角度sweepAngle：表示角度范围useCenter：表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。 1234567891011RectF rectF = new RectF(DensityUtil.dip2px(context, 100), DensityUtil.dip2px(context, 100), DensityUtil.dip2px(context, 220), DensityUtil.dip2px(context, 180));paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF, 0, 80, false, paint);paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF, -10, -80, true, paint);paint.setStyle(Paint.Style.FILL);canvas.drawArc(rectF, -100, -80, true, paint);paint.setStyle(Paint.Style.FILL);canvas.drawArc(rectF, -190, -80,false,paint); drawBitmap()：画位图drawPicture()drawCircle() ：画圆drawLine()：画直线drawLines()：折线drawOval()：画椭圆drawRect()：画矩形drawRoundRect()：画圆角矩形drawPoint()：画点drawPoints()：画一组点pts : 这个数组是点的坐标，每两个成一对offset : 表示跳过数组的前几个数再开始记坐标count : 表示一共要绘制几个点 1234567891011121314151617181920//圆点和方点的切换使用 paint.setStrokeCap(cap)：`ROUND` 是圆点，`BUTT` 或 `SQUARE` 是方点this.paint.setStrokeCap(Paint.Cap.ROUND);this.paint.setAntiAlias(true);this.paint.setStyle(Paint.Style.FILL);this.paint.setStrokeWidth(50);this.paint.setStrokeCap(Paint.Cap.ROUND);canvas.drawPoint(canvas.getWidth() / 2 - 200, canvas.getHeight() / 2, paint);paint.setStrokeCap(Paint.Cap.SQUARE);canvas.drawPoint(canvas.getWidth() / 2 + 200, canvas.getHeight() / 2, paint);paint.setStrokeCap(Paint.Cap.ROUND);this.paint.setStrokeWidth(10);float[] points = &#123;20,20, 50,50, 80,80,100,100,130,130,170,170,210,210,240,240,&#125;;canvas.translate(100,100);canvas.drawPoints(points,paint);canvas.translate(0,300);canvas.drawPoints(points,3,10,paint); drawPath()：画路径组合。这个方法是通过描述路径的方式来绘制图形的，它的 path 参数就是用来描述图形路径的对象 12345path.arcTo(canvas.getWidth() / 2 - 200, 380, canvas.getWidth() / 2, 580, 135, 225, false);path.arcTo(canvas.getWidth() / 2, 380, canvas.getWidth() / 2 + 200, 580, 180, 225, false);path.lineTo(canvas.getWidth() / 2, 720);path.close();canvas.drawPath(path, paint); 角度和划过度数 1234567RectF rectF1 = new RectF(200,100,300,200);paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF1, 135, 225, true, paint);paint.setStyle(Paint.Style.STROKE);canvas.translate(100,0);canvas.drawArc(rectF1, 180, 225, true, paint); drawText()：画文本drawTextOnPath()：根据路径画文本drawPosText()：指定单个文字位置arcTo(): 将指定的弧添加到路径作为新的轮廓。 Paint的使用画笔 1. Paint有3个构造方法：1.Paint():用默认设置创建一个Paint对象2.Paint(int flags):用特殊标记创建一个Paint对象3.Paint(Paint paint):用指定Paint对象的参数初始化一个新的Paint对象 ##2. 常用方法 reset() 清空path的所有数据，但是不会清空FillType rewind() 清除FillType及数据等，但会保留数据结构。这样可以快速重用，提高一定的性能 setARGB(int a, int r, int g, int b) 画笔颜色 setColor(int color) 画笔颜色 setAntiAlias(boolean aa) 是否抗锯齿 setAlpha(int a) 设置画笔透明度 setStrokeWidth(float width) 画笔的粗细(线条的宽度) setXfermode(Xfermode xfermode) 设置图像重叠时的处理方式 - 16种 setFillType() 2个图形重合的模式.类似前面讲解的xfermode,只有4个值：WINDING//默认值，取两个图形相交；EVEN_ODD//取不相交的部分；INVERSE_WINDING//反转相交；INVERSE_EVEN_ODD//反转不相交部分 setShader(Shader shader) 设置着色器 setPathEffect(PathEffect effect) 设置或者清除路径效果 - 6种 setShader(Shader shader) 设置图像效果，可以绘制出各种渐变效果 setShadowLayer(float radius ,float dx,float dy,int color) 在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 setStrokeCap(Paint.Cap cap) 设置线冒样式(线头的装饰画法)，取值有: Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) setStrokeJoin(Paint.Join join) 设置线段连接处样式(折线的拐角装饰画法)，取值有：Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线) setStyle(Paint.Style style) 设置画笔样式”，画笔样式有三种: (1)Paint.Style.FILL：默认值，用这种风格绘制的几何图与文本将被填充，它画出来的是实心图 (2)Paint.Style.STROKE：用这种风格绘制的几何图与文本将被画出外边框，它画出来的是空心图 (3)Paint.Style.FILL_AND_STROKE：用这种风格绘制的几何图与文本将被填充并被画出外边框 3.设置“文字/字体“外观setTextSize(float textSize) 设置文字大小” setFakeBoldText(boolean fakeBoldText) 设置是否为粗体文字 setStrikeThruText(boolean strikeThruText) 设置带有删除线效果 setUnderlineText(boolean underlineText) 设置下划线 setTextAlign(Paint.Align align) 设置开始绘图点位置,文本对齐方式 setTextScaleX(float scaleX) 水平拉伸设置 setTextSkewX(float skewX) 设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 setTypeface() 设置字体样式:Typeface.NORMAL - 正常体;Typeface.BOLD - 粗体;Typeface.ITALIC - 斜体;Typeface.BOLD_ITALIC - 粗斜体 4.字体样式(Typeface)create(String familyName, int style) 直接通过指定字体名来加载系统中自带的文字样式 create(Typeface family, int style) 通过其它Typeface变量来构建文字样式 createFromAsset(AssetManager mgr, String path) 通过从Asset中获取外部字体来显示字体样式 createFromFile(String path) 直接从路径创建 createFromFile(File path) 从外部路径来创建字体样式 defaultFromStyle(int style) 创建默认字体 5. 字体设置 在assets目录下新建fonts目录，把ttf字体文件放到这。 程序中调用： 123456//得到AssetManagerAssetManager mgr=getAssets();//根据路径得到Typeface，注意"ttf文件命名不能使用中文,否则可能无法加载。Typeface tf=Typeface.createFromAsset(mgr, "fonts/ttf.ttf");//设置字体样式tv.setTypeface(tf); 6.文字所占的区域（范围）的设定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 注意:在使用FontMetrics时必须为同一个Paint对象,否则,无法获取文字正确的位置关系 */Paint paint12 = new Paint();paint12.setAntiAlias(true);paint12.setStrokeWidth(1);paint12.setStyle(Paint.Style.STROKE);paint12.setColor(Color.BLACK);paint12.setTextSize(100);Paint.FontMetrics fontMetrics = paint12.getFontMetrics();//可绘制的最高高度所在线float top;//可绘制的最低高度所在线float bottom;//系统建议的，绘制单个字符时，字符应当的最高高度所在线float ascent;//系统建议的，绘制单个字符时，字符应当的最低高度所在线float descent;/** * 建议在文本行之间添加的额外空格。 *///fontMetrics.leadingtop = 100 + fontMetrics.top;bottom = 100 + fontMetrics.bottom;ascent = 100 + fontMetrics.ascent;descent = 100 + fontMetrics.descent;//绘制文字canvas.drawText(strs,100,100,paint12);//------------------------令人惊喜的分割线---------------------canvas.translate(0,200);canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE));canvas.drawLine(100,top,1080,top,paint12);//可绘制的最高高度所在线canvas.drawLine(100,bottom,1080,bottom,paint12);//可绘制的最低高度所在线canvas.drawLine(100,ascent,1080,ascent,paint12);//系统建议的，绘制单个字符时，字符应当的最高高度所在线canvas.drawLine(100,descent,1080,descent,paint12);//系统建议的，绘制单个字符时，字符应当的最低高度所在线canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE));float width = paint12.measureText(strs);//获取文字所占宽度float height = bottom - top;//获取文字所占高度Log.e(TAG, "onDraw width: " + width + ", height : " + height);//绘制文字所占区域的边框Path rectPath = new Path();RectF rectF2 = new RectF(100,top,width+100,bottom);//绘制文字paint12.setColor(Color.GREEN);canvas.drawRect(rectF2,paint12); Path1. 常用方法moveTo() ：设定起始点lineTo() ：画条直线(连续使用此方法,将会画出连续的线)close() ：封闭图形addRect() ：矩形路径（使用此方法时首先绘制一个矩形,后续addXXX()使用类似）addRoundRect() ：绘制圆角矩形路径addCircle() ：绘制原型路径addCircle() ：绘制椭圆路径addArc() ：绘制一段弧形路径quadTo() ：绘制”贝塞尔曲线” 有4个方法参数说明 Path.Direction有两个值： Path.Direction.CCW：是counter-clockwise缩写，指创建”逆时针”方向的矩形路径； Path.Direction.CW：是clockwise的缩写，指创建”顺时针”方向的矩形路径； 2. PathMeasure类的使用 参考:http://blog.csdn.net/cquwentao/article/details/51436852 (1) 123//path：需要测量的path//forceClosed：是否关闭pathpublic PathMeasure(Path path, boolean forceClosed) (2) 12//这里就是指定需要测量的path，同上。public void setPath(Path path, boolean forceClosed) (3) 123//返回当前path的"总"长度。PathMeasure pathMeasure = new PathMeasure(path, false);float length = pathMeasure.getLength(); (4) 123456public boolean getPosTan(float distance, float pos[], float tan[])//返回值是boolean，如过path为空，则返回false传入参数有三个： distance：传入距离起点的距离。 pos[]:意思是position，分别对应点的x，y坐标 tan[]：这个值比较难以理解。我们下面讲解下这个值的意义。 Path 有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算。直接描述路径。1. 添加子图形 ：addXxx()添加的完整封闭图形（除了 addPath() ） 2. 画线（直线或曲线）：xxxTo() lineTo(float x, float y) / rLineTo(float x, float y) ：画直线 lineTo(x, y) 的参数是绝对坐标，而 rLineTo(x, y) 的参数是相对当前位置的相对坐标 （前缀 r 指的就是 relatively 「相对地」)。 所谓当前位置，即最后一次调用画 Path 的方法的终点位置。初始值为原点 (0, 0)。 quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2) ：画二次贝塞尔曲线 cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) ：画三次贝塞尔曲线 moveTo(float x, float y) / rMoveTo(float x, float y) ：移动到目标位置 设置图形起点。 1234paint.setStyle(Style.STROKE); path.lineTo(50, 50); // 斜线 path.moveTo(150, 50); // 移动 path.lineTo(150, 0); // 竖线 画弧形 arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(RectF oval, float startAngle, float sweepAngle) orceMoveTo ：绘制是要 抬一下笔移动过去，还是 直接拖着笔过去，区别在于是否留下移动的痕迹。 1234path.moveTo(100,0);path.lineTo(100,100);path.arcTo(100,100,300,300,-90,90,true);canvas.drawPath(path,paint); 1234path.moveTo(100,0);path.lineTo(100,100);path.arcTo(100,100,300,300,-90,90,false);canvas.drawPath(path,paint); addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) addArc(RectF oval, float startAngle, float sweepAngle) addArc() 只是一个直接使用了 forceMoveTo = true 的简化版 arcTo() 。 close() ：封闭当前子图形 当需要填充图形时（即 Paint.Style 为 FILL 或 FILL_AND_STROKE），Path 会自动封闭子图形。 辅助的设置或计算Path.setFillType(Path.FillType ft) 设置填充方式。 使用参考：http://hencoder.com/ui-1-1/ 3. 获取随机Path方法12345678910private Path getPath()&#123; Path path = new Path(); // 定义路径的起点 path.moveTo(0, 0); // 定义路径的各个点 for (int i = 0; i &lt;= 40; i++) &#123; path.lineTo(i*35, (float) (Math.random() * 150)); &#125; return path; &#125; Color：Android系统中颜色的常用表示方法有以下3种： int color = Color.BLUE; int color = Color.argb(150,200,0,100); 在xml文件中定义颜色； 2. 常用颜色： 方法 描述 Color.BLACK 黑色 Color.GREEN 绿色 Color.BLUE 蓝色 Color.LTGRAY 浅灰色 Color.CYAN 青绿色 Color.MAGENTA 红紫色 Color.DKGRAY 灰黑色 Color.RED 红色 Color.YELLOW 黄色 Color.TRANSPARENT 透明 Color.GRAY 灰色 Color.WHITE 白色 3. ColorFilter类的使用” 参考:http://blog.csdn.net/cquwentao/article/details/51396466 ColorFilter主要用来处理颜色有3个子类: ColorMatrixColorFilter：颜色矩阵 LightingColorFilter：亮度 PorterDuffColorFilter：颜色的混合模式 1. ColorMatrixColorFilter这个类主要是使用matrix对颜色做运算，矩阵的形态如下： &quot;R&quot; &quot;G&quot; &quot;B&quot; &quot;A&quot; &quot;Red通道&quot; a[0] a[1] a[2] a[3] a[4] &quot;Green通道&quot; a[5] a[6] a[7] a[8] a[9] &quot;Blue通道&quot; a[10] a[11] a[12] a[13] a[14] &quot;Alpha通道&quot; a[15] a[16] a[17] a[18] a[19] RGB色彩和Alpha的终值计算方法如下： “Red通道” 终值 = a[0] srcR + a[1] srcG + a[2] srcB + a[3] srcA + a[4] “Green通道”终值 = a[5] srcR + a[6] srcG + a[7] srcB + a[8] srcA + a[9] “Blue通道” 终值 = a[10] srcR + a[11] srcG + a[12] srcB + a[13] srcA + a[14] “Alpha通道”终值 = a[15] srcR + a[16] srcG + a[17] srcB + a[18] srcA + a[19] “备注” srcR为原图Red通道值，srcG为原图Green通道值，srcB为原图Blue通道值，srcA为原图Alpha通道值。每个通道的源值和终值都在0到255的范围内。即使计算结果大于255或小于0，值都将被限制在0到255的范围内。 使用示例1234567private final static float[] MATRIX = new float[] &#123; 0.5f, 0, 0, 0, 0, 0, 0.5f, 0, 0, 0, 0, 0, 0.5f, 0, 0, 0, 0, 0, 1, 0 &#125;; 2. LightingColorFilterLightingColorFilter是上面ColorMatrixColorFilter的一个简化版本，构造函数也比较简单构造函数 123public LightingColorFilter(int mul, int add) //mul代表multiply,也就是乘法 //add代表加法，也就是颜色偏移量 使用示例 12345Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(), R.drawable.home);canvas.drawBitmap(bitmap, 100, 0, paint);LightingColorFilter filter = new LightingColorFilter(0x888888, 0x000000);paint.setColorFilter(filter);canvas.drawBitmap(bitmap, 100, 500, paint); 计算方法 color = color mul／２５５+ add (计算结果大于等于255都指定为255)其中”color”可以为RGB三种通道中的”一种”，mul和add分别为通道对应的值。假设R通道的值就为R=R0x88/0xff+0 0x88/0xff肯定是小于1的，所以颜色变暗了。add的值越”大”,画面越”亮”. 3. PorterDuffColorFilter构造函数 123public PorterDuffColorFilter(int srcColor, PorterDuff.Mode mode) //srcColor源颜色， //mode是色彩的混合模式. 重绘方法1234567891011121314151617/*** 重绘方法* 在某个时候调用 onDraw（android.graphics.Canvas)* 这必须从UI线程调用。 要从非UI线程调用则调用 postInvalidate()*/public void invalidate() &#123; invalidate(true);&#125;/** *这是invalidate（）工作实际发生的地方。 一个完整的invalidate（）会导致绘图缓存无效，但是可以使用invalidateCache设置为false来调用此函数，以便在不需要该过程的情况下跳过该无效步骤。 * * @param invalidateCache此视图的绘图缓存是否也应该被无效。对于完全无效，这通常是正确的，但如果视图的内容或维度未更改，则可能会设置为false。 */void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/self_study/article/details/51628486 说明创建一个抽象类方法，里面写有代理与主题共同的方法。 public abstract class MyObject { //代理与实际主题的共同方法 public abstract void operate(); } 真实主题 public class RealObject extends MyObject { @Override public void operate() { System.out.println(&quot;这是来自RealObject的方法处理&quot;); } } 代理主题 public class ProxyObject extends MyObject { private RealObject realObject; //在此类中调用真实的主题，因为是代理主题“代理”真实主题中的方法，需要用到真实主题的引用 public ProxyObject(RealObject realObject) { this.realObject = realObject; } @Override public void operate() { System.out.println(&quot;在处理“RealObject”之前，处理代理模式中自己的方法处理&quot;); //在此处调用真实主题中的同名方法。 realObject.operate(); System.out.println(&quot;在处理“RealObject”之后，处理代理模式中自己的方法处理&quot;); } } 测试 public class Proxy_DesignPattern { public static void main(String[] args){ ProxyObject proxyObject = new ProxyObject(new RealObject()); proxyObject.operate(); } } /** * 输出结果： * 在处理“RealObject”之前，处理代理模式中自己的方法处理 这是来自RealObject的方法处理 在处理“RealObject”之后，处理代理模式中自己的方法处理 */ 代理模式的角色：Subject：抽象主题类 该类的主要职责是声明真实主题与代理的共同接口方法，该类既可以是一个抽象类，也可以是一个接口； RealSubjct：真实主题类 该类也称为被委托类或被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户端则通过代理类间接地调用真实主题类中定义的方法； ProxySubject：代理类 该类也称为委托类或代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中对应的接口方法，以此起到代理的作用； Client：客户类 即使用代理类的部分。 代理模式根据实际使用的场景也可以分为以下几种：远程代理（Remote Proxy） 为某个在不同的内存地址空间的对象提供局部代理，使系统可以将 Server 部分的实现隐藏，以便 Client 可以不必考虑 Server 的存在，类似于 C/S 模式（主要拦截并控制远程方法的调用，做代理防火墙之类的）； 虚拟代理（Virtual Proxy） 使用一个代理对象标识一个十分耗资源的对象，并在真正需要时才创建，实现一个延迟加载的机制； 保护代理（Protection Proxy） 使用代理控制对原始对象的访问，该类型的代理通常被用于原始对象有不同访问权限的情况； 智能引用（Smart Proxy） 在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数； 写时拷贝（克隆）代理（Copy-on-write Proxy） 其实是虚拟代理的一个分支，提供了拷贝大对象的时候只有在对象真正变化后才会进行拷贝（克隆）的操作，即延迟拷贝。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html 设计原则：封装变化多用组合，少用继承对扩展开发，对修改关闭 定义：装饰模式又名包装(Wrapper)模式。装饰者模式动态地将责任添加到对象上，是继承关系的一个替代方案。 描述： 装饰着可以在所委托装饰着的行为之前或者之后添加自己的行为，已达到特定的目的。 通过使用不同的具体装饰类以及这些装饰类的组合，可以创造出很多不同行为的组合。 装饰着与组件组合时，就是在加入新的行为，新的行为是由组合对象得来的。 如何封装的更好：装饰着模式（Decorator） + 工厂模式（Factory） + 生成器模式（Builder） 装饰模式中的角色有： 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 抽象装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为。行为来自装饰着和基础组件，或与其他装饰着之间的组合关系。 实际应用：java的I/O流 装饰者模式的缺点 ： 产生大量的类。 类型问题。某一个对象依赖特定类型的类型。 采用装饰着实例化组件时，将会增加代码复杂度，不但需要实例化组件，还有把组件包装进装饰者中。 示例：组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 饮料抽象类 */public abstract class Drink &#123; String describtion = "Drink"; int price = 0; /** * 打印 描述 */ public String getDescribtion()&#123; return describtion; &#125; /** * 行为：输出价格 */ public abstract int printPrice();&#125;/** * 具体牛奶饮料类 */public class MilkDrink extends Drink &#123; public MilkDrink()&#123; price = 11; describtion = "MilkDrink " + String.valueOf(price); &#125; @Override public int printPrice() &#123; return price; &#125;&#125;/** * 具体茶饮料类 */public class TeaDrink extends Drink &#123; public TeaDrink()&#123; price = 12; describtion = "TeaDrink " + String.valueOf(price); &#125; @Override public int printPrice() &#123; return price; &#125;&#125; 装饰者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 抽象 装饰者 */public abstract class CondimentDecorator extends Drink&#123; int condimentPrice= 0; public abstract int printPrice();&#125;/** * 抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为 */public class HoneyDecorator extends CondimentDecorator &#123; Drink mDrink; public HoneyDecorator(Drink drink)&#123; this.mDrink = drink; condimentPrice = 10; &#125; @Override public String getDescribtion() &#123; return "HoneyDecorator " + String.valueOf(condimentPrice) + " " + mDrink.getDescribtion(); &#125; @Override public int printPrice() &#123; return condimentPrice + mDrink.printPrice(); &#125;&#125;public class MochaDecorator extends CondimentDecorator &#123; Drink mDrink; /** * 使用抽象基类，践行 "开闭原则"：对扩展开放，对修改关闭 * @param drink 基类 */ public MochaDecorator(Drink drink)&#123; this.mDrink = drink; condimentPrice = 5; &#125; /** * 输出当前组合 */ public String getDescribtion()&#123; return "MochaDecorator " + String.valueOf(condimentPrice) + " " + mDrink.getDescribtion(); &#125; /** * 组合得到新的行为 * @return 当前组合价格 */ @Override public int printPrice() &#123; return condimentPrice + mDrink.printPrice(); &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132public class DecoratorMain &#123; public static void main(String[] args)&#123; //只有一个底料的茶饮料 Drink teaDrink = new TeaDrink(); System.out.println(teaDrink.getDescribtion()); System.out.println(teaDrink.printPrice()); /** * TeaDrink 12 * 12 */ //茶饮料 + 蜂蜜 //抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为 Drink honeyDecorator = new HoneyDecorator(teaDrink); System.out.println(honeyDecorator.getDescribtion()); System.out.println(honeyDecorator.printPrice()); /** * HoneyDecorator 10 + TeaDrink 12 * 22 */ //茶饮料 + 蜂蜜 + 摩卡 Drink mochaDecorator = new MochaDecorator(honeyDecorator); System.out.println(mochaDecorator.getDescribtion()); System.out.println(mochaDecorator.printPrice()); /** * MochaDecorator 5 + HoneyDecorator 10 + TeaDrink 12 * 27 */ &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/sbsujjbcy/article/details/49302717 定义：用原型模式的实例创建对象的实例，同过拷贝这些原型模式的实例创建新的对象。 优点及适用场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 注意事项： 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。 深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝例如： prototype.list = (ArrayList) this.list.clone(); 示例//实现“原型模式”第一步：实现Cloneable接口 public class Person implements Cloneable{ private String name; private String address; private int age; private int height; private ArrayList&lt;String&gt; hobbies; public Person(String name, String address, int age, int height, ArrayList&lt;String&gt; hobbies) { this.name = name; this.address = address; this.age = age; this.height = height; this.hobbies = hobbies; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public ArrayList&lt;String&gt; getHobbies() { return hobbies; } public void setHobbies(ArrayList&lt;String&gt; hobbies) { this.hobbies = hobbies; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, height=&quot; + height + &quot;, hobbies=&quot; + hobbies + &apos;}&apos;; } //实现“原型模式”第二步：重写clone（） @Override protected Object clone() throws CloneNotSupportedException { Person person = (Person) super.clone(); person.name = this.name; person.address = this.address; person.age = this.age; person.height = this.height; //person.hobbies = this.hobbies; //此处使用使用深拷贝 person.hobbies = (ArrayList&lt;String&gt;) this.hobbies.clone(); return person; } } 使用 public class Prototype_DesignPattern { public static void main(String[] args){ ArrayList&lt;String&gt; hobbies = new ArrayList&lt;String&gt;(); hobbies.add(&quot;游泳&quot;); hobbies.add(&quot;足球&quot;); hobbies.add(&quot;自行车&quot;); Person person0 = new Person(&quot;张三&quot;,&quot;北京&quot;,24,177,hobbies); System.out.println(&quot;person0 is &quot; + person0.toString()); //原型模式的使用 try { Person person1 = (Person) person0.clone(); person1.setName(&quot;王哇&quot;); hobbies.remove(&quot;足球&quot;); person1.setHobbies(hobbies); System.out.println(&quot;person1 is &quot; + person1.toString()); Person person2 = (Person) person0.clone(); person2.setAge(44); System.out.println(&quot;person2 is &quot; + person2.toString()); } catch (CloneNotSupportedException e) { e.printStackTrace(); } System.out.println(&quot;person0 is &quot; + person0.toString()); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Builder模式]]></title>
    <url>%2FBuilder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[builder实例 public class Person { private String name; private String address; private int age; private int height; private int weight; //外部类提供一个私有构造函数供内部类调用，在该构造函数中完成成员变量的赋值， //取值为Builder对象中对应的值 private Person(Builder builder){ this.name = builder.name; this.address = builder.address; this.age = builder.age; this.height = builder.height; this.weight = builder.weight; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, height=&quot; + height + &quot;, weight=&quot; + weight + &apos;}&apos;; } //定义一个静态内部类Builder，内部的成员变量和外部类一样 public static class Builder{ private String name; private String address; private int age; private int height; private int weight; //Builder类通过一系列的方法用于成员变量的赋值，并返回当前对象本身（this） public Builder name(String name){ this.name = name; return this; } public Builder address(String address){ this.address = address; return this; } public Builder age(int age){ this.age = age; return this; } public Builder height(int height){ this.height = height; return this; } public Builder weight(int weight){ this.weight = weight; return this; } //Builder类提供一个build方法或者create方法用于创建对应的外部类， //该方法内部调用了外部类的一个私有构造函数，该构造函数的参数就是内部类Builder public Person build(){ return new Person(this); } } } 使用实例 public class MainActivity extends AppCompatActivity { private static final String TAG = &quot;MainActivity&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Person person1 = new Person.Builder(). name(&quot;张三&quot;). address(&quot;河北&quot;). age(24). height(177). build(); Log.e(TAG, person1.toString()); Person person2 = new Person.Builder(). name(&quot;刻有&quot;). address(&quot;拉萨&quot;). height(159). weight(65). build(); Log.e(TAG, person2.toString() ); Person person3 = new Person.Builder(). name(&quot;利盟&quot;). address(&quot;陕西&quot;). age(24). height(188). weight(65). build(); Log.e(TAG, person3.toString() ); Person person4 = new Person.Builder(). name(&quot;由张&quot;). address(&quot;广西&quot;). age(34). height(177). weight(55). build(); Log.e(TAG, person4.toString() ); } } 描述：在Builder类里定义了一份与Person类一模一样的变量，通过一系列的成员函数进行设置属性值， 但是返回值都是this，也就是都是Builder对象，最后提供了一个build函数用于创建Person对象， 返回的是Person对象，对应的构造函数在Person类中进行定义，也就是构造函数的入参是Builder对象， 然后依次对自己的成员变量进行赋值，对应的值都是Builder对象中的值。 特点：创建过程变得清晰，对应的值属性一目了然，可读性大大增强。 总结：定义一个静态内部类Builder，内部的成员变量和外部类一样 Builder类通过一系列的方法用于成员变量的赋值，并返回当前对象本身（this） Builder类提供一个build方法或者create方法用于创建对应的外部类，该方法内部调用了外部类的一个私有构造函数，该构造函数的参数就是内部类Builder 外部类提供一个私有构造函数供内部类调用，在该构造函数中完成成员变量的赋值，取值为Builder对象中对应的值]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[OO基础 ：抽象OO原则 ：封装变化、针对接口编程、松耦合（多用组合，少用继承）观察者模式 ：在对象之间定义一对多的依赖，当一个对象的状态改变，其他对象都会收到通知并自动改变。 被观察者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public interface WeatherSet &#123; void register(WeatherOberver oberver); void unRegister(WeatherOberver oberver); void upData(WeatherData weatherData);&#125;/** * 主题（被观察者） */public class WeatherSetI implements WeatherSet&#123; List&lt;WeatherOberver&gt; oberverList; /** * 初始化存储观察者的集合 * 模块间的依赖应该是通过 抽象来实现的 */ public WeatherSetI() &#123; this.oberverList = new ArrayList&lt;WeatherOberver&gt;(); &#125; /** * 注册 * @param oberver 观察者 */ public void register(WeatherOberver oberver)&#123; if (oberverList.contains(oberver)) &#123; System.out.println("注意 : " + oberver.getClass().getName() + " 当前订阅者已经存在，无需订阅"); &#125; else &#123; oberverList.add(oberver); &#125; &#125; /** * 取消注册 * @param oberver 观察者 */ public void unRegister(WeatherOberver oberver)&#123; System.out.println("注意：" + oberver.getClass().getName() + " 已经不再订阅该消息，bye~bye~"); oberverList.remove(oberver); &#125; /** * 数据更新 * @param weatherData 数据Bean类 * * 设计原则：被打电话给我，我打电话给你（上层调用下层，下层不调用上层） */ public void upData(WeatherData weatherData)&#123; System.out.println("注意：当前有 " + oberverList.size() + " 位订阅了该消息！"); for (WeatherOberver item : oberverList) &#123; item.getData(weatherData); &#125; &#125;&#125;/*** 数据Bean类*/public class WeatherData &#123; int temp; int pressure; public WeatherData(int temp, int pressure) &#123; this.temp = temp; this.pressure = pressure; &#125; public int getTemp() &#123; return temp; &#125; public void setTemp(int temp) &#123; this.temp = temp; &#125; public int getPressure() &#123; return pressure; &#125; public void setPressure(int pressure) &#123; this.pressure = pressure; &#125; @Override public String toString() &#123; return "WeatherData&#123;" + "temp=" + temp + ", pressure=" + pressure + '&#125;'; &#125;&#125; 观察者 123456789101112131415161718192021222324252627282930313233/** * 观察者 接口 */public interface WeatherOberver &#123; /** * 数据更新行为 * @param weatherData 数据Bean类 */ void getData(WeatherData weatherData);&#125; public class WangObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("WangObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125;public class ZhangObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("ZhangObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125;public class LiObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("LiObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125; 应用 public class OberverMain { public static void main(String[] args){ WeatherOberver oberverWang = new WangObserver(); WeatherOberver oberverLi = new LiObserver(); WeatherOberver oberverZhang = new ZhangObserver(); WeatherSetI set = new WeatherSetI(); set.register(oberverWang); set.register(oberverLi); set.register(oberverZhang); set.upData(new WeatherData(12, 45)); /** * 注意：当前有 3 位订阅了该消息！ WangObserver get data temp is : 12, pressure is : 45 LiObserver get data temp is : 12, pressure is : 45 ZhangObserver get data temp is : 12, pressure is : 45 */ System.out.println(); set.unRegister(oberverLi); set.upData(new WeatherData(32, 100)); /** * 注意：observer.LiObserver 已经不再订阅该消息，bye~bye~ 注意：当前有 2 位订阅了该消息！ WangObserver get data temp is : 32, pressure is : 100 ZhangObserver get data temp is : 32, pressure is : 100 */ System.out.println(); set.register(oberverZhang); set.upData(new WeatherData(33, 97)); /** * 注意 : observer.ZhangObserver 当前订阅者已经存在，无需订阅 注意：当前有 2 位订阅了该消息！ WangObserver get data temp is : 33, pressure is : 97 ZhangObserver get data temp is : 33, pressure is : 97 */ } } 实例： Android的广播机制。 我们平时使用本地广播主要就是下面四个方法: LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this); localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter); localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver); localBroadcastManager.sendBroadcast(Intent intent) 调用registerReceiver方法注册广播，调用unregisterReceiver方法取消注册，之后直接使用sendBroadcast发送广播，发送广播之后，注册的广播会收到对应的广播信息，这就是典型的观察者模式 EventBus。 观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件： EventBus.getDefault().register(Object subscriber); EventBus.getDefault().unregister(Object subscriber); EventBus.getDefault().post(Object event); RxJava。 创建一个被观察者： Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; sub) { sub.onNext(&quot;Hello, world!&quot;); sub.onCompleted(); } } ); 创建一个观察者，也就是订阅者： Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() { @Override public void onNext(String s) { System.out.println(s); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { } }; 观察者进行事件的订阅 myObservable.subscribe(mySubscriber);]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式与原则]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/self_study/article/details/51234377 Patterns：模式PrinciPle：原则 设计模式不会直接进入你的“代码”中，而是先进入你的“大脑”中。 在设计模式中，所谓的“实现一个接口”并“不一定”表示“写一个类，并利用implement关键词实现某个java接口”。而是泛指“实现某个超类型（可以是接口或是类）的某个方法”。 设计模式的出现：设计模式是历经验证的OO设计经验，而模式不是被发明的，是被发现的。设计是一门艺术，总是有许多可取舍的地方。如果找不到合适的设计模式，采用一些设计原则也是相当不错的。好的OO系统设计必须是：可维护、可扩充、可复用的。 设计原则（６大）：1. OCP - 开闭原则：what 编写代码应该：面向扩展开放，对修改关闭。 尽量不要通过修改现有代码来满足需求。How 要利用扩展来适应变更。 接口 优于 抽象，抽象 优于 具体类。 针对接口编程，而不是针对实现。 多用组合，少用继承。 2. SRP - 单一职责原则：what 一个类、一个方法只做一件事。how 一个类应该只有一个引起变化的原因。避免潜在错误。 3. LSP - 里氏替换原则：what 所有引用基类的地方都能透明的使用子类的对象。how 子类必须完全实现父类的方法。 子类可以拥有自己的属性和方法。 子类覆盖或实现父类方法时参数范围可以扩大。 子类覆盖或实现父类方法时返回值范围可以缩小。 4. DIP - 依赖倒置原则：what 模块间的依赖应该通过抽象发生，具体类之间不应该有依赖关系。 接口或者抽象不依赖于实现类，否则就失去了抽象接口的意义。 实现 依赖于 接口或者抽象即：底层依赖于高层。how 针对接口编程，而不是针对实现。 别打电话给我，我打电话给你。 5. ISP - 接口隔离原则：what 使用接口时应该建立单一的接口，不应该建立过于臃肿的接口。 接口应该 “专” 而非 “多”即：提供独立单一的接口。 6. LKP - 最少知识原则：what 一个对象应该对 “其他对象”有最少的了解。how 一个类对于另一个类而言，尽量减少“public”，对外只提供一个简洁的访问 自己的方法。 设计模式1. 观察者模式 （有趣的事情发生了，可千万别错过！）定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 2. 装饰者模式 动态的将责任附加到对象上，若要扩展功能，装饰者模式提供了比“继承”更有弹性的替代方案。 3. 简单工厂模式 不是一个真正的模式，但是同“抽象工厂模式”和“工厂方法模式”一样，被用于封装创建对象的代码。 4. 抽象工厂模式 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 5. 工厂方法模式 定义了一个创建对象的接口，但由子类决定实例化的类是哪一个。工厂方法模式让类把实例化推迟到子类。 6. 单例模式 确保一个类只有一个实例，并提供一个全局的访问点。 7. 命令模式 将“请求”封装成对象，以便使用不同的请求、队列、或者日志来参数化其他对象。命令模式也支持可撤销的操作。 8. 适配器模式 将一个类的接口转换为期望的另一个接口，让原本接口不兼容的类可以兼容。 9. 模板模式 定义一个算法的骨架，将算法中的某些步骤延迟到子类中具体实现。使得子类在不改变算法结构的情况下，重新定义算法中的某些步骤。 10. 代理模式 - 保护 为另一个对象提供一个替身或占位符以访问这个对象，是基于访问权控制对对象的访问。 11. 代理模式 - 虚拟 作为创建开销大的对象的代表，虚拟代理经常是直到我们真正需要一个对象时才创建真正的对象。当对象在创建前和创建中时，由虚拟代理来扮演真正对象的替身，待真正对象创建后，虚拟代理就会将请求直接给真正的对象。 12. 代理模式 - 远程 好比远程对象的本地代表。 13. 迭代器模式 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露器内部的表示。 14. 组合模式 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合模式能让客户以一致的方式处理个别对象及组合对象。 15. 外观模式 提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。外观模式不仅简化一个接口，而且将客户以组件的一个子系统中解耦。 16. 策略模式 定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 17. 状态模式 允许对象在内部状态改变时改变它的行为，使对象看起来好像修改了它的类。 使用设计模式的好处 使用模式名称和其他人员进行开发或者开发团队沟通时，彼此之间交流的不只是模式名称，而是一整套模式背后所象征的质量、特性、约束。 思路清晰：他人能更清晰的了解你对设计的想法，团队之间对于设计的看法不会轻易产生误解。 宏观：使用设计模式谈论软件系统，能让你保持在“设计层次”，不会被纠缠于“对象”与“类”这种琐碎的实现细节上。 大家对设计模式都有深入的了解，更易提升自身水平。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/tanyujing/article/details/14160941 http://blog.csdn.net/sbsujjbcy/article/details/49147839 是在内存中维护唯一对象，优点如下： 1.对于那些比较耗内存的类，只实例化一次可以大大提高性能，尤其是在移动开发中。 2.保持程序运行的时候该中始终只有一个实例存在内存中 示例public class Singleton{ private static volatile Singleton instance == null; private Singleton(){ } public static Singleton getInstance(){ if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance == new Singleton(); } } } return instance; } } 关于volatile 参考：http://www.ibm.com/developerworks/cn/java/j-jtp06197.html 概述： Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”； 与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少， 但是它所能实现的功能也仅是 synchronized 的一部分。 单例模式使用： 必须防止外部可以调用构造函数进行实例化，因此构造函数必须私有化。 必须定义一个静态函数获得该单例 单例使用volatile修饰 使用synchronized 进行同步处理，并且双重判断是否为null，在synchronized (Singleton.class)里面又进行了是否为null的判断，这是因为一个线程进入了该代码，如果另一个线程在等待，这时候前一个线程创建了一个实例出来完毕后，另一个线程获得锁进入该同步代码，实例已经存在，没必要再次创建，因此这个判断是否是null还是必须的。 单例的并发测试：见参考。实际应用public class ActivityManager { private static volatile ActivityManager instance; private Stack&lt;Activity&gt; mActivityStack = new Stack&lt;Activity&gt;(); private ActivityManager(){ } public static ActivityManager getInstance(){ if (instance == null) { synchronized (ActivityManager.class) { if (instance == null) { instance = new ActivityManager(); } } return instance; } public void addActicity(Activity act){ mActivityStack.push(act); } public void removeActivity(Activity act){ mActivityStack.remove(act); } public void killMyProcess(){ int nCount = mActivityStack.size(); for (int i = nCount - 1; i &gt;= 0; i--) { Activity activity = mActivityStack.get(i); activity.finish(); } mActivityStack.clear(); android.os.Process.killProcess(android.os.Process.myPid()); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 桌面使用命令]]></title>
    <url>%2FUbuntu%20%E6%A1%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[桌面环境：super ： 长按显示启动器快捷信息 super + 数字 ： 启动指定的应用 super + D ： 显示桌面 super + w : 所有窗口平铺 super + s : 显示所有的工作区 super + t : 打开回收站 alt + prt ： 对窗口截图 ctrl + h ： 显示隐藏文件.h开头 shift + prt ： 选取截图 shift + ctrl + T : 桌面打开终端（在同一窗口下，新的标签页） ctrl + w : 关闭应用 super + c : 搜索图片 super + v : 搜索视屏 super + a : 搜索应用 super + f : 搜索文件和文件夹 super + m : 搜索音乐 终端运行命令(简洁版) 2016年12月19日10:40:37 软件更新 apt-get update 安装 apt-get install 软件名称 卸载 apt-get remove 软件名称 其他清屏 clear vim编辑 vim（vim filename） 组添加组 groupadd 组名 删除组 groupdel 组名 更改组信息 groupmod 组名 显示当前用户所属组 groups 用户查询历史登录 last [用户名] 切换用户 su 用户名 退出切换的用户 exit 相关文件 etc/group, etc/passwd, etc/shadow 查看当前用户 w/who 添加用户 useradd 用户名 删除用户 suerdel 用户名 更改用户信息 usermod 添加用户到组中 useradd -G 组名 用户名 （G:附加组，用户将创建一个与自己同名的组） useradd -g 组名 用户名 （g：表示用户所加入的主组） 用户修改密码 passwd 用户名 查询id值 id 将用户添加至已存在的组中 usermod -a -G 组名 用户名 更改用户主要所在组 usermod -g 组名 用户名 文件pwd 查看当前目录 cat （从第一行开始显示）查看文件内容 cat [-nTAEv] tac （从最后一行开始显示） nl （显示时输出行号） nl [-b{ a, t}n{ln,rn,rz}w ] more （分页显示） space 向下翻一页 enter 向下翻一行 q 立即退出 :f 立刻显示当前文件名及当前行数 /字符串 在当前显示内容中，向下查询【字符串】 less（同more，可以向前翻页） /字符串 向上查询 ？字符串 向下查询 n 重复前一个查询 N 反向重复前一个查询 q 离开 pagedown 向下翻页 pageuP 向上翻页 head （仅显示头几行） head [-n number] 文件 tail（仅显示尾几行） tail [-n number] 文件 od （以2进制的方式读取档案） 目录与文件查看 ls [-aAdfFhilrRSt] 目录名 （可以使用×作为匹配符）ls [--color={none,auto,always}] 目录名 ls [--full-time{mtime,ctime,atime}] 目录名 ll == ls -l ls -a （显示隐藏文件及目录） pwd -P （返回真实目录，非连接目录） 路径切换 cd 文件路径cd - (返回上一个工作目录) cd ~ （home目录） cd .. (返回上层文件) cd ../目录 （同一层目录中前往其他目录） cd ~用户名 （进入此用户的home目录） 创建文件vim 文件名 （方式1） touch 文件名(空) （方式2） echo “输入内容” &gt; 文件名.后缀 （方式3） 修改文件时间+创建文件touch(空) 时间分类mtime:内容变更时间； ctime：状态时间； atime：接收时间 touch [-mcadt] 创建目录 mkdirmkdir [-mp] 目录名 （m：权限，p：自动建立多层目录） 删除目录 rmdirrmdir [-p] 目录名 （p：当前目录包含多个目录，删除时连同自身删除）仅能删除空目录 rm -rf 目录名 （删除非空目录） 慎用 更改组 chgrpchgrp [-R] 组名 文件 （R：文件夹递归） 更改拥有者 chownchown [-R] 用户名 文件 chown [-R] 用户名：组名 文件 获取文件名 basename 目录获取目录 dirname 目录文件预设权限 umaskumask [-S] (查看权限预设) 022:表示被‘拿掉的权限’,即：u,g-w,o-w umask 002 （设置权限） 权限的分类基本属性 + 隐藏属性 + 特别S属性 更改权限属性 chmodchmod [-R] 777 文件名 chmod [-R] u=(+/-)rwx,g=(+/-)rwx,o=(+/-)rwx 文件名 设定隐藏属性 chattrchattr [+-=][ASacdistu] 文件或目录名 (最常用a，i) chattr +a：表示在原有参数的基础上，追加参数-append，表示只能向文件中添加数据，不能删除,多用于日志。 chattr +i：表示文件不能被删除，改名，设定链接关系，同时不能写入，追加内容。 显示隐藏属性 lsattrlsattr [-aR] 文件或目录名 SUID,SGID,SBIT 设定4：SUID（使用在非目录上） 2：SGID（目录与文件均可） 1：SBIT（使用在非文件上） e.g. chmod 4755 文件名 结果为：-rwsr-xr-x 文件的类型 filefile 文件路径 文件查询whereis/locate（通过数据库查询,所以在查询前最好更新数据书库，updatedb文件） which find不推荐使用（伤硬盘：原理是在硬盘上查找，耗时）使用×匹配文件 which [-a] 文件 whereis [-bmsu] 文件或目录 locate 文件名 复制cp 源文件路径 新文件路径 （复制，建立快捷方式，新旧比对，复制目录） cp [-adfilprsu] cp 源1，源2…… 目录 移动mv （移动，更名 ） mv [-fiu] mv 原文件名 新文件名 mv 文件1，文件2 目录名 删除 rmrm [-rfi] 目录或文件 (若文件名中含有-，则用‘./’或者‘空格--空格’) 更新 2017年02月04日 星期六 18时34分42秒 查看磁盘空间大小命令 主要命令：df 详细命令：df -hl : 查看磁盘剩余空间（效果同 df -H） df -h : 查看每个根路径的分区大小 du -sh : [目录名] 返回该目录的大小 du -sm : [文件夹] 返回该文件夹总M数 fdisk -l : 查看硬盘分区 查看ip地址ifconfig 查看端口号主要命令 ： netstat 查看所有的服务端口: netstat -a 查看所有的服务端口，显示pid号 netstat -ap 查看某一（**）端口，则可以结合grep命令： netstat -ap | grep ** 如查看**端口，： lsof -i:** 若要停止使用这个端口的程序，使用kill +对应的pid kill pid 还有一个比较好用的命令，查看**端口： netstat -lnp | grep ** 查看端口号和运行程序： netstat -atunp | more 查看进程所用端口： netstat -tlnp|grep ** 卸载已经安装的软件命令： dpkg -l | grep appName apt-get remove appName 更新grep命令 参考：http://www.lai18.com/content/24612942.html 命令： 是linux中的搜索工具。可以用在搜索条件“过滤”。 用法： grep [选项] PATTERN 参数说明： [options] -c：只输出匹配行的计数。 -i：不区分大 小写(只适用于单字符)。 -h：查询多文件时不显示文件名。 -l：查询多文件时只输出包含匹配字符的文件名。 -n：显示匹配行及行号。 -s：不显示不存在或无匹配文本的错误信息。 -v：排除，不显示过滤的字符串的行；显示不包含匹配文本的所有行。 -E ：过滤多个字符串。 -o ：输出精确匹配的字符而不是默认的整行。 -f ：指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 Context control： -B 除了显示匹配的一行之外，并显示该行之前的num行 -A 除了显示匹配的一行之外，并显示该行之后的num行 -C 除了显示匹配的一行之外，并显示该行之前后各num行 grep &quot;String&quot; -B 10 test.txt #显示匹配的String行和String的前10行。 pattern正则表达式主要参数： \：忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 $: 匹配正则表达式的结束行。 \&lt;：从匹配正则表达 式的行开始。 \&gt;：到匹配正则表达式的行结束。 [ ]：单个字符，如 [Gg]rep 匹配Grep和grep。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求。 [^]：匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。 x\{m\}：重复字符x，m次，如：&apos;0\{5\}&apos;匹配包含5个0的行。 x\{m,\}：重复字符x,至少m次，如：&apos;0\{5,\}&apos;匹配至少有5个0的行。 x\{m,n\}：重复字符x，至少m次，不多于n次，如：&apos;0\{5,10\}&apos;匹配5 -- 10个0的行。 .：所有的单个字符。 *：有字符，长度可以为0。]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux vim 命令]]></title>
    <url>%2FLinux%20vim%20%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vim命令vi有3个模式：插入模式、命令模式、低行模式。插入模式：在此模式下可以输入字符，按ESC将回到命令模式。 命令模式：可以移动光标、删除字符等。 低行模式：可以保存文件、退出vi、设置vi、查找等功能(低行模式也可以看作是命令模式里的)。 打开文件、保存、关闭文件(vi命令模式下使用)vi filename //打开filename文件,文件名称可以不存在 :w //保存文件 :w filename //保存至filename文件 :q //退出编辑器，如果文件已修改请使用下面的命令 :q! //退出编辑器，且不保存 :wq //退出编辑器，且保存文件 :wq! //强制保存内容退出 3.插入文本或行(vi命令模式下使用，执行下面命令后将进入插入模式，按ESC键可退出插入模式)a //在当前光标位置的右边添加文本 A //在当前行的末尾位置添加文本 i //在当前光标位置的左边添加文本 I //在当前行的开始处添加文本(非空字符的行首) O //在当前行的上面新建一行 o //在当前行的下面新建一行 R //替换(覆盖)当前光标位置及后面的若干文本 J //合并光标所在行及下一行为一行(依然在命令模式) 移动光标(vi命令模式下使用)&lt;1&gt;、使用上下左右方向键 &lt;2&gt;、命令模式下： h 向左、l 向右、j 向下 、k 向上。 Backspace 向左、空格键 向右、Enter 移动到下一行首、- 移动到上一行首。 &lt;3&gt; $ 跳至行末，0 跳至行首 删除、恢复字符或行(vi命令模式下使用)x //删除当前字符 nx //删除从光标开始的n个字符 dd //删除当前行 ndd //向下删除当前行在内的n行 d&lt;enter&gt; //删除光标所在行及下一行(共计删除2行) u //撤销上一步操作 U //撤销对当前行的所有操作 搜索(vi命令模式下使用)/vpser //向光标下搜索vpser字符串 ?vpser //向光标上搜索vpser字符串 n //向下搜索前一个搜素动作 N //向上搜索前一个搜索动作 跳至指定行(vi命令模式下使用)n //跳n行 n+ //向下跳n行 n- //向上跳n行 G //跳至文件的底部 gg //跳至文件顶部 设置行号(vi命令模式下使用):set nu //显示行号 :set nonu //取消显示行号 复制、粘贴(vi命令模式下使用)yy //将当前行复制到缓存区，也可以用 &quot;ayy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。 nyy //将当前行向下n行复制到缓冲区，也可以用 &quot;anyy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。 yw //复制从光标开始到词尾的字符。 nyw //复制从光标开始的n个单词。 y^ //复制从光标到行首的内容。 y$ //复制从光标到行尾的内容。 p //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用&quot;ap 进行粘贴。 P //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用&quot;aP 进行粘贴。 替换(vi命令模式下使用):s/old/new //用new替换行中首次出现的old :s/old/new/g //用new替换行中所有的old :n,m s/old/new/g //用new替换从n到m行里所有的old :%s/old/new/g //用new替换当前文件里所有的old 编辑其他文件:e otherfilename //编辑文件名为otherfilename的文件。 修改文件格式:set fileformat=unix //将文件修改为unix格式，如win下面的文本文件在linux下会出现^M。 总结：当如果不知道自己处在什么模式时可以按: 2次Esc键 即可回到命令模式，会有最后提醒一点： 注意大小写！！！ Linux中vim编辑注意事项 2016年12月17日21:47:04 Ctrl s： 暂停该终端 Ctrl q： 让终端继续运行 Ctrl c： 中止当前正在执行的程序。 Ctrl d： 相当于exit命令，退出当前会话。 Ctrl z： 将当前运行的程序放到后台运行。与运行时加&amp;类似。 Tab键自动补全命令。 Linux中Terminal快捷键的使用 2017年 01月 09日 星期一 22:21:36 CST 文件：shift + ctrl + T： 新标签页打开新的终端 shift + ctrl + N： 新的窗口打开新的终端 alt + w : 关闭终端 alt + Q : 关闭全部终端 编辑：ctrl + C ： 复制 ctrl + V ： 粘贴 查看：F11 ： 全屏 ctrl + = : 放大 ctrl + - ： 缩小 ctrl + 0 ： 正常大小 查找：ctrl + F ： 查找 ctrl + G ： 查找下一个 ctrl + H ： 查找上一个 ctrl + J ： 清除高亮查找 标签页：ctrl + pgup : 向上翻页 ctrl + pgdn : 向下翻页 shift + ctrl + pgup ： 标签内容移动之左侧标签 shift + ctrl + pgdn ： 标签内容移动之右侧标签 alt +数字 ： 切换至指定的标签页]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装记录]]></title>
    <url>%2FUbuntu16.04%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[以下省略“sudo”命令表示是在root权限下运行的 ubuntu16.04使用参考网址 Linux使用设置 &gt;&gt;网页 http://m.blog.csdn.net/article/details?id=51049513Linux命令大全 &gt;&gt;网页 http://www.runoob.com/linux/linux-command-manual.htmlLinux命令大全–支持在线搜寻 http://man.linuxde.net/文档手册中心 –ChinaUnix &gt;&gt;网页 http://man.chinaunix.net/Linux Kernel –ChinaUnix &gt;&gt;网页 http://man.chinaunix.net/tech/lyceum/linuxK/tlk.htmlLinux Git使用 &gt;&gt;网页 http://v.youku.com/v_show/id_XNzgwOTk0NDQw.html?f=22842023&amp;spm=a2hzp.8244740.0.0&amp;from=y1.7-1.1以下省略“sudo”命令表示是在root权限下运行的 root登录 先设定一个root的密码： sudo passwd root root 登陆： su root cp -p /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak vi /etc/lightdm/lightdm.conf 在lightdm.conf最后增加一行： greeter-show-manual-login=true 重启后，即可用root登入。 系统没有声音Ubuntu在root用户下，为了安全考虑默认关闭系统的声音。 将root加到pulse和pulse-access组： usermod -a -G pulse-access root gpasswd -a root pulse gpasswd -a root pulse-access 编辑/etc/default/pulseaudio文件 cp -p /etc/default/pulseaudio/etc/default/pulseaudio.bak vim /etc/default/pulseaudio 修改以下两处 PULSEAUDIO_SYSTEM_START=1 DISALLOW_MODULE_LOADING=0 改为1和0，表示允许运行在system环境，允许动态加载模块。 重启计算机 有声音但在“系统设置”中无法调节声音： 运行： gedit /root/.profile 在文件的最后添加： pulseaudio --start --log-target=syslog 当在“系统设置”中出现“伪声音”时，且无法实际调节声音时： apt install pavucontrol pavucontrol 系统正常耳机没有声音 参考网址：http://www.linuxdiyf.com/linux/25529.html 终端运行 alsamixer 按M键把关闭的都大开（关闭的都显示的是MM），然后调节到合适的位置，白色为宜 最后一项Independ显示为ON表示耳机和音箱只能有一个有声音，按M键关闭则表示耳机和音箱可以同时有声音 （–未进行测试–） 若耳机还是没声音，可是试着运行 gedit /etc/modprobe.d/alsa-base.conf 在最后一行加入 #enable headphoneoptions snd-hda-intel power_save=10 power_save_controller=N model=6stack-dig 然后运行 apt-get remove alsa-base 然后重启 shutdown -r now 重启后运行 apt-get install alsa-base ubuntu16.04系统字体变成方框问题进入到字体的目录下/usr/share/fonts/，输入下面的命令： cd /usr/share/fonts/ 制作ubuntu16.04app启动图标 2016年12月15日15:40:42 在文件所在目录下新建一个Studio.desktop文件,并用gedit打开,然后将下面的内容复制进去并修改. [Desktop Entry] Name=应用的名称 Type=Application（不改） Icon=你的AndroidStudio解压目录的绝对路径/android-studio/bin/studio.png Exec=sh 你的AndroidStudio解压目录的绝对路径/android-studio/bin/studio.sh 保存退出(注意：每一行后面都不能有空格,否则失败) 右键该文件–&gt;属性–&gt;权限–&gt;选择“允许作为程序执行文件”,此时发现图标变了,双击打开App 安装ADB 2017年01月30日 星期一 15时57分56秒 参考： http://www.itdadao.com/articles/c15a299707p0.html http://www.jianshu.com/p/8768e5bccfa8 若apt-get install 失败： sudo add-apt-repository ppa:phablet-team/tools (原始ppa更好) sudo apt-get update sudo apt-get install android-tools-adb 出现异常： E: 无法获得锁 /var/lib/dpkg/lock – open (11: 资源临时不可用) E: 无法对管理目录(/var/lib/dpkg/)加锁，是不是另一个包管理程序在使用它？ 解决办法： 删除有问题的文件 安装 JDK + Eclipse + Apache Tomcat 2016年12月14日15:32:34以下省略“sudo”命令表示是在root权限下运行的 JDK8 （下载地址） http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz 在所在的文件夹目录下，可以直接打开terminal，跳过以下两句操作，直接进行环境配置 cd /Downloads tar -zxvf jdk-8u101-linux-x64.tar.gz 3.配置环境变量 gedit /etc/profile 在文件末尾添加以下内容： export JAVA_HOME=/home/lt/Java/jdk1.8.0_101(你的Jdk目录) export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 更新文件（必须执行） source /etc/profile notice！若在终端中出现:程序 ‘javac’ 已包含在下列软件包中： update-alternatives --install /usr/bin/javac javac /root/文档/jdk1.8.0_112/bin/javac 300 update-alternatives --install /usr/bin/java java /root/文档/jdk1.8.0_112/bin/java 300 Eclipse（eclipse安装工具） （下载地址） https://www.eclipse.org/downloads/download.php?file=/oomph/epp/neon/R/eclipse-inst-linux64.tar.gz 解压 tar -zxcf eclipse-inst-linux64.tar.gz 进入解后目录下,双击eclipse.inst运行安装程序 若有安装错误执行 mkdir jre cd jre ln -s （你的JDK目录/bin bin） Tomcat9 （下载地址） http://tomcat.apache.org/download-90.cgi 在所在的文件夹目录下，可以直接打开terminal，跳过以下两句操作，直接进行环境配置 cd Downloads/ unzip apache-tomcat-9.0.0.M9.zip 配置环境变量： export CATLINA_HOME=/home/lt/Java/apache-tomcat-9.0.0.M9（文件所在路径） sourse /etc/profile 安装MySQL+WorkBrench 2016年12月15日15:54:09 以下省略“sudo”命令表示是在root权限下运行的 ubuntu16.04安装mysql5.7未用sudo apt-get update未用sudo apt-get upgrade apt-get install mysql-server mysql-client apt-get install libmysqlclient-dev 自动安装会装上5.7的client端，中间会弹出提示框输入root的密码 安装完成之后检查是否成功。socket处于 listen 状态则表示安装成功 netstat -tap | grep mysql 未用sudo groupadd mysql未用sudo useradd -r -g mysql mysql 修改密码 未用sudo /usr/bin/mysqladmin -u root password 登陆mysql数据库可以通过如下命令： mysql -u root -p -u 用户名， -p 用户密码，输入后提示输入密码，此时输入密码就可以登录到mysql 安装客户端apt-get install mysql-workbench 安装RabbitVCS 2017年02月06日 星期一 14时04分24秒参考：http://blog.csdn.net/catshitone/article/details/48022315 注： 安装完毕后，注销LogOut，重新登录，在文件夹和文件夹内点击鼠标右键就用RabbitVCS操作工具了。 如果不能正常运行则输入： sudo apt-get install python-nautilus python-configobj python-gtk2 python-glade2 python-svn python-dbus python-dulwich subversion meld 再次更新软件包库： sudo apt-get update 注销LogOut，重新登录即可。 安装Terminator 2017年02月06日 星期一 15时53分34秒参考： http://www.jianshu.com/p/cee2de32ca28 安装： apt-get install terminator 卸载： apt-get remove terminator 快捷键(自定义之后的): 水平分割终端 : Ctrl+O 垂直分割终端 : Ctrl+E 搜索 : Ctrl+F 复制 : Ctrl+C 粘贴 : Ctrl+V clear屏幕 : Ctrl+G 关闭当前终端 : Ctrl+W 退出当前窗口 : Ctrl+Q 变化当前窗口位置 ：super+R 全屏状态 : F11 在垂直分割的终端中将分割条向右移动 :Ctrl+Right 在垂直分割的终端中将分割条向左移动 :Ctrl+Left 隐藏/显示滚动条 :Ctrl+Shift+S 配置文件（可参考）： [global_config] handle_size = -3 enabled_plugins = CustomCommandsMenu, LaunchpadCodeURLHandler, APTURLHandler, LaunchpadBugURLHandler title_transmit_fg_color = &quot;#000000&quot; suppress_multiple_term_dialog = True title_transmit_bg_color = &quot;#3e3838&quot; inactive_color_offset = 1.0 [keybindings] [profiles] [[default]] palette = &quot;#000000:#5a8e1c:#2d5f5f:#cdcd00:#1e90ff:#cd00cd:#00cdcd:#e5e5e5:#4c4c4c:#868e09:#00ff00:#ffff00:#4682b4:#ff00ff:#00ffff:#ffffff&quot; background_image = &quot;&quot; background_darkness = 0.68 scrollback_lines = 3000 background_type = transparent use_system_font = scroll_background = False show_titlebar = False cursor_shape = ibeam font = Liberation Mono 12 background_color = &quot;#0e2424&quot; foreground_color = &quot;#e8e8e8&quot; [layouts] [[default]] [[[child1]]] type = Terminal parent = window0 profile = default [[[window0]]] type = Window parent = &quot;&quot; size = 925, 570 [plugins] ubuntu安装Wine 参考：http://www.ubuntukylin.com/ukylin/forum.php?mod=viewthread&amp;tid=27068 安装源 sudo add-apt-repository ppa:wine/wine-builds sudo apt-get update 安装wine apt-get install wine1.8 卸载wine 1).卸载wine主程序，在终端里输入： sudo apt-get remove --purge wine 2).然后删除wine的目录文件： rm -r ~/.wine 3).卸载残留不用的软件包： sudo apt-get autoremove 终端中输入wine，检测是否安装完成 ubuntu安装WebStorm 2017年02月16日 星期四 12时31分00秒 参考：https://quanru.github.io/2016/04/17/%E4%BD%BF%E7%94%A8%20Linux%20%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91Web%E5%89%8D%E7%AB%AF/webstorm使用快捷键参考： http://blog.csdn.net/zghekuiwu/article/details/54382145 https://github.com/damao/Intellij-IDEA-F2E#%E6%B3%A8%E5%86%8C 下载： http://www.jetbrains.com/webstorm/index.html 解压下载的 gz 包，在bin/下运行： ./webstorm.sh WebStorm 默认情况下是需要收费的，可以申请为开源项目的贡献者来获得 licenses。 安装完成后，在 File - Settings - Plugins，选择需要安装的插件，例如 AngularJS、Markdown 等。 在 File - Settings - Directories 下，通过 Add content Root 来设置我们的项目路径 在 File - Settings - JavaScript - Libraries 下，勾选想要支持的库，建议全部勾上（如 NodeJS）。 在 File - Settings - Editor - Colors &amp; Fonts - Font 下，选择自己想要的主题， 然后 Save as… 保存自己想要的主题名称，设置字体为Ubuntu Mono， 字体设置为 16（貌似有点小，相当于 Eclipse 下的 12） 在 File - Settings - Appearance 下，勾选 Show line numbers 选项。 破解方式：选择line server 方式，输入： http://idea.iteblog.com/key.php 安装ubuntu主题 2016年12月15日14:54:25 安装主题管理工具： apt-get install unity-tweak-tool 安装主题 apt-add-repository ppa:numix/ppa apt-get update apt-get install numix-icon-theme-circle //安装图标 apt-get install numix-gtk-theme //安装主题 安装docky（Mac桌面下方的启动器） 参考网址：http://www.aichengxu.com/view/992905参考网址：http://www.noobslab.com/2014/11/mbuntu-macbuntu-1410-transformation.html install docky add-apt-repository ppa:docky-core/ppa apt-get update apt-get install docky apt-get remove docky docky 安装XX-Net 2017年02月04日 星期六 17时17分36秒 安装xx-net 安装firefox或者chrome 设置： 系统设置 --&gt; 网络 --&gt; 网络代理 --&gt; 方法：自动 配置：http://127.0.0.1:8086/proxy.pac 全局配置 重点： 此项目来自GitHub，可以直接clone到本地 需要使用到Google AppID，以此进行服务器部署，以达到真正上网的目的 使用host科学上网 2016年12月15日16:04:07使用host文件进行翻墙参考链接：https://laod.cn/hosts/2016-google-hosts.html 安装sbulime text3 2017年 01月 28日 星期六 15:05:31 CST安装参考： http://www.cnblogs.com/unflynaomi/p/5704293.html 汉化，中文输入问题参考： http://blog.csdn.net/u013453604/article/details/48002127 汉化，无法输入中文资源： http://download.csdn.net/detail/u013453604/9049633 不能输入中文问题参考： http://www.cnblogs.com/mo-wang/p/5120484.html（步骤不全，修改的内容全面） http://www.liuqianfei.com/article/3e51f07d254b464995b0f4c94cc1d69c（步骤全面） 配置java，python，markdown： http://www.jianshu.com/p/58bf9e4d5b32 安装步骤： sudo add-apt-repository ppa:webupd8team/sublime-text-3 sudo apt-get update sudo apt-get install sublime-text-installer 安装：python3 apt install python3-pip 卸载 sublime text 命令： sudo apt-get remove sublime-text-installer 启动sublime text3 在terminal终端中输入：subl 打开指定的文件： subl 文件名 解决sublime无法输入中文的问题在进行所有操作时首先进行依赖包的安装：代码依赖于 gtk 2.0，编译 c 需要安装 build-essential。 sudo apt-get install build-essential libgtk2.0-dev 如果路径中含有空格，你必须使用双引号将路径括起来： $ subl &amp;quot;~/Documents/test/my test file.txt&amp;quot; 解决无法输入中文问题 - 2017年03月12日 星期日 15时17分24秒 参考：http://www.jianshu.com/p/03a9092c73e2亲测有效！ 解决事件输入问题 参考：https://my.oschina.net/antsky/blog/491146 WPS字体缺失 下载缺失的字体文件，然后复制到Linux系统中的/usr/share/fonts文件夹中。 国外下载地址：https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip 国内下载地址：https://pan.baidu.com/s/1eS6xIzosudo cp * /usr/share/fonts 执行以下命令,生成字体的索引信息： sudo mkfontscale sudo mkfontdir 运行fc-cache命令更新字体缓存。 sudo fc-cache 重启wps即可，字体缺失的提示不再出现。 WPS不能输入中文问题 参考:http://forum.ubuntu.org.cn/viewtopic.php?f=48&amp;t=476937原因：环境变量未正确设置，以上可以直接针对wps设置。 解决办法,终端输入: gedit /usr/bin/wps 在此文件中输入一下内容,#!/bin/bash之后: export XMODIFIERS=&quot;@im=fcitx&quot; export QT_IM_MODULE=&quot;fcitx&quot; 安装WeChat 2016年12月13日22:43:53 安装linux微信： 下载地址:https://github.com/geeeeeeeeek/electronic-wechat/releases apt-get install git git clone https://github.com/geeeeeeeeek/electronic-wechat.git cd electronic-wechat apt-get install npm apt-get install nodejs-legacy npm install &amp;&amp; npm start 官方推荐的安装方法： To clone and run this repository you’ll need Git and Node.js (which comes with npm) installed on your computer. From your command line: Clone this repository git clone https://github.com/geeeeeeeeek/electronic-wechat.git# Go into the repositorycd electronic-wechat# Install dependencies and run the app npm install &amp;&amp; npm start To pack into an app, simply type one of these: npm run build:osx npm run build:linux]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alias 的使用]]></title>
    <url>%2FAlias%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[所有命令均在ubuntu16.04环境下完成，在不同环境下可能会有差异 alias介绍alias用于自定义快捷命令，避免总是使用相同的，重复的，冗长的命令来执行操作 alias的用法1.添加新的自定义快捷方式 alias 自定义新名字=&quot;操作命令&quot; 示例：将进入文档目录的命令定义为 cdd 新命令 alias cdd=&quot;cd /root/文档/&quot; 2.删除自定义的快捷方式： unalias 自定义新名字 示例：删除 cdd 新命令 unalias cdd 3.查询自定义快捷方式： alias alias的存储注： 若不保存在文件中，则只能在当前的`terminal`中使用,只有保存到文件中后才能供以后继续使用 来自～/.bashrc文档的介绍 Alias definitions.You may want to put all your additions into a separate file like ~/.bash_aliases, instead of adding them here directly. See /usr/share/doc/bash-doc/examples in the bash-doc package. 使用以下方式，将自定义的快捷键存入系统已有文件中。此文件位于/root/下: vim ~/.bashrc 使用以下方式，将自定义的快捷键存入”指定”的新文件中。此文件位于/root/下: vim ~/.bash_aliases 注： 对于以上两中方式，必须使用： source ~/.bash_aliases 命令更新文件，否则自定义快捷键将不会被找到，无法起作用。 个人快捷命令组合： ls 查询字段释义：http://blog.csdn.net/sjzs5590/article/details/8254527更多详细使用参考：用户目录下的 .bash_profile # Alias alias ll=&apos;ls -lh -G&apos; alias la=&quot;ls -lah -G&quot; # 显示size alias lls=&apos;ls -lSGh&apos; alias las=&quot;ls -laSGh&quot; # 显示行号 alias lln=&apos;ls -lh | nl&apos; alias lan=&quot;ls -lah | nl&quot; alias llns=&apos;ls -lSh | nl&apos; alias lans=&quot;ls -laSh | nl&quot; alias grep=&apos;grep --color&apos; # Hexo alias ohb=&apos;open &quot;/Users/yannischeng/Documents/HexoBLog&quot;&apos; alias ohbs=&apos;open &quot;/Users/yannischeng/Documents/HexoBLog/source/_posts&quot;&apos; alias chbl=&apos;cd &quot;/Users/yannischeng/Documents/HexoBLog&quot;&apos; alias chbsl=&apos;cd &quot;/Users/yannischeng/Documents/HexoBLog/source/_posts&quot;&apos; # python project alias opp=&apos;open /Users/yannischeng/PycharmProjects/First_Python_Project&apos; alias cppl=&apos;cd /Users/yannischeng/PycharmProjects/First_Python_Project&apos; # .bash_profile alias sup=&apos;source .bash_profile&apos; alias oup=&apos;open /Users/yannischeng/.bash_profile&apos; alias cupl=&apos;cd /Users/yannischeng/&apos; # open app alias om=&apos;open /Applications/MWeb.app&apos; alias oas=&apos;open /Applications/&quot;Android Studio&quot;.app&apos; alias osb=&apos;open /Applications/&quot;Sublime Text&quot;.app&apos; alias ogc=&apos;open /Applications/&quot;Google Chrome&quot;.app&apos; alias opc=&apos;open /Applications/PyCharm.app&apos; alias owc=&apos;open /Applications/WeChat.app&apos; alias od=&apos;open /Applications/Dictionary.app&apos; alias owm=&apos;open /Applications/NeteaseMusic.app&apos; # login mysql alias lms=&apos;mysql -u root -p&apos; # mytree alias mtree=&quot;find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos;&quot;]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略者模式]]></title>
    <url>%2F%E7%AD%96%E7%95%A5%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[仅仅知道抽象、继承、多态、封装并不会马上让你变成好的面向对象设计者。设计大师关注的是弹性、可维护、可应付改变的设计。 软件开发的一个不变真理：CHANGE。 策略模式（Strategy Pattern）定义：定义算法族（一组行为），分别封装起来（定义成为不同的接口），让他们之间可以互相替换。 此模式让算法（行为类）之间的变化独立于算法的使用者（调用类）。 OO设置原则： 封装变化: a)找出应用中可能需要变化之处，把他们独立出来——封装，不要和固定的代码混在一起。 b)把会变化的部分取出并封装起来，以后便可以轻易的改动活着扩充此部分，而不影响不需要变化的部分（每个设计模式背后的精神所在）。 针对接口编程（针对超类型编程），而不是针对实现编程： a)针对接口编程：关键是利用多态（运行时动态的改变行为）。 b)针对超类型编程：变量的声明类型应该是超类型（一个抽象类或一个接口） 多用组合，少用继承： “有一个”可能比“是一个”好。 实践书中“鸭子”的实现： 将“飞行”、“鸣叫”这些行为（鸭子的自身属性）抽象成“飞行接口”、“鸣叫接口”，之后再将“行为接口”具体实现，组合至具体的“鸭子类“中。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
</search>
