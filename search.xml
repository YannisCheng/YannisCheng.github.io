<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[App性能优化-2]]></title>
    <url>%2FApp%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-2%2F</url>
    <content type="text"><![CDATA[App优化的本质 - 知识体系结构够丰富、知识点理解够透彻、代码够规范，则不存在优化。 一张图表述 App 性能优化切入点： 本文内容将会根据此图进行说明，分为以下模块点： 布局 绘制 内存 启动速度 包体 耗电 RecyclerView自带优化、Bitmap 响应速度-线程 布局优化屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。 通过颜色我们可以知道应用是否有多余层次的绘制，如果一路飘红，那么我们就要相应的处理了。 优化 Version 1.0 ：颜色设置、include + merge、ViewStub颜色设置 如果父控件有颜色，也是自己需要的颜色，那么就不必在子控件加背景颜色 如果每个子控件的颜色不太一样，而且可以完全覆盖父控件，那么就不需要再父控件上加背景颜色 嵌套include + merge 参考：https://blog.csdn.net/a740169405/article/details/50473909 特点： 使用include标签可以增加布局的 复用性，提高效率。 使用merge标签可以 减少 视图树中的 节点个数，加快视图的绘制，提高UI性能。 &lt;merge/&gt; 标签的使用，看上去一次只减少一个节点，但是当一个布局嵌套很复杂的时候，节点的个数可能达到几百个，这个时候，如果每个地方都多一个节点，视图的绘制时间相应的也就变长了很多。 使用 &lt;merge/&gt; 注意： 1.&lt;merge/&gt; 必须放在布局文件的根节点上。 2.&lt;merge/&gt; 不是一个ViewGroup，也不是一个View，它相当于声明了一些视图，等待被添加。 3.&lt;merge/&gt; 标签被添加到A容器下，那么 &lt;merge/&gt; 下的所有视图将被添加到A容器下。 4.因为 &lt;merge/&gt; 并不是View，所以在通过 LayoutInflate.inflate 方法渲染的时候， 第二个参数必须指定一个 父容器，且第三个参数必须为 true，也就是必须为 &lt;merge/&gt; 下的视图指定一个父亲节点。 5.如果Activity的布局文件根节点是FrameLayout，可以替换为 &lt;merge/&gt;，这样，执行setContentView之后，会减少一层FrameLayout节点。 6.自定义View如果继承LinearLayout，建议让自定义View的布局文件根节点设置成 &lt;merge/&gt;，这样能少一层结点。 7.因为 &lt;merge/&gt; 不是View，所以对 &lt;merge/&gt;标签设置的所有属性都是无效的。 ViewStub 参考：https://blog.csdn.net/a740169405/article/details/50351013 &lt;ViewStub/&gt; 产生效果的本质是：==懒加载==、==弱引用==。通过一个在视图中已存在的 &lt;ViewStub/&gt; 来临时代替 正式布局，直到真正需要加载 正式布局 时，将 &lt;ViewStub/&gt; 替换掉。 inflate() 方法只能调用一次，不建议通过 setVisibility() 加载视图 使用 要实现的操作：在一个 Activity 上放置了一个按钮，点击后加载懒加载的视图。 1、 Activity布局文件定义 my_sub_activity.xml： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:onClick=&quot;onClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;加载视图&quot;/&gt; &lt;ViewStub android:id=&quot;@+id/stub&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/my_sub_tree&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt; android:inflatedId 指定了懒加载视图跟节点的 ID，android:layout 指定了懒加载的视图。android:layout_width、android:layout_height 分别指定了懒加载视图的宽和高。 2、 懒加载布局文件 my_sub_tree.xml： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffffff&quot; android:gravity=&quot;center&quot; android:padding=&quot;10dip&quot; android:text=&quot;懒加载视图&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;22sp&quot;&gt;&lt;/TextView&gt; 3、 在 Activity 中调用的代码，点击后查到ViewStub对象，并加载视图 1234567@Overridepublic void onClick(View v) &#123; // 这里调用的是inflate方法，当然，也可以调用setVisibility方法（但是不建议这么做） // 只能点击一次加载视图按钮，因为inflate只能被调用一次 // 如果再次点击按钮，会抛出异常&quot;ViewStub must have a non-null ViewGroup viewParent&quot; ((ViewStub) findViewById(R.id.stub)).inflate();&#125; 效果图： &lt;ViewStub/&gt; 在VIew树中加载的前后对比： 加载前： 加载后： 优化 Version 1.1 ：ConstraintLayout（约束布局）复杂界面可选择ConstraintLayout，可有效减少层级。 绘制优化 - 渲染性能：onDraw()Android渲染机制：Android系统 每隔16s 发出 VSYNC 信号，触发UI渲染： 渲染成功：界面流畅； 渲染失败：时间延误或者直接跳过，反应到手机屏幕就是：卡、跳帧。 Android渲染机制的最后一步是 onDraw()，在前面的介绍中已经处理了测量、布局过程，此时，解决办法，根本做法是 减轻onDraw()的负担。 onDraw() 处理方法： 不要做耗时的任务，也 不做过多的循环操作，特别是 嵌套循环，虽然每次循环耗时很小，但是大量的循环势必 霸占CPU的时间片，从而造成View的绘制过程不流畅。 不要创建新的局部对象，因为 onDraw() 方法一般都会 频繁大量调用，就意味着会 产生大量的临时对象，不仅 占用过的内存，而且会导致系统更加 频繁的GC，大大降低程序的执行速度和效率。 优化 Version 2.0 ：onDrow() onDraw中不要创建新的局部对象 onDraw方法中不要做耗时的任务 内存优化内存泄漏内存泄漏 指的是 那些程序不再使用的对象无法被GC识别，这样就 导致这个对象一直留在内存当中，占用了没来就不多的内存空间。 内存泄漏是一个 缓慢积累 的过程，温水煮青蛙一般，往往很难直观的看到，只能最后内存不够用了，程序崩溃。 因为有 内存泄漏，所以 内存被占用越来越多，那么 GC会更容易被触发，GC会 越来越频发，但是当GC的时候 所有的线程都是暂停状态的，需要处理的 对象数量越多耗时越长，所以这也会造成 卡顿。 发生泄漏的4大类情况 集合类 单例/静态变量 匿名内部类/非静态内部类 资源未关闭 集合类泄漏集合类添加元素后，仍引用着集合元素对象，导致该集合中的元素对象无法被回收，从而导致内存泄露。合适的做法为： 123456789static List&lt;Object&gt; mList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 100; i++) &#123; Object obj = new Object(); mList.add(obj); obj = null;&#125;mList.clear();mList = null; 单例/静态变量单例模式具有其 静态 特性， 其生命周期 = 应用程序生命周期，正是因为这一点，往往很容易造成内存泄漏。 一个示例： 12345678910111213141516public class SingleInstance &#123; private static SingleInstance mInstance; private Context mContext; private SingleInstance(Context context)&#123; this.mContext = context; &#125; public static SingleInstance newInstance(Context context)&#123; if(mInstance == null)&#123; mInstance = new SingleInstance(context); &#125; return sInstance; &#125;&#125; 在此单例模式中，当我们将 Activity 作为 context 参数进行传递时，这个单例就拥有了 Activity 的引用。当此 Activity 没有用、要被销毁时，此单例仍然持有 此Activity的引用。所以 GC 无法回收，结果就是造成了内存泄漏。 修改之后，合理的使用方式为: 12345678910111213141516public class SingleInstance &#123; private static SingleInstance mInstance; private Context mContext; private SingleInstance(Context context)&#123; this.mContext = context.getApplicationContext(); &#125; public static SingleInstance newInstance(Context context)&#123; if(mInstance == null)&#123; mInstance = new SingleInstance(context); &#125; return sInstance; &#125;&#125; 匿名内部类/非静态内部类 两个关键点： 生命周期 对象引用 非静态内部类一个示例：123456789101112131415161718192021public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); new MyAscnyTask().execute(); &#125; class MyAscnyTask extends AsyncTask&lt;Void, Integer, String&gt;&#123; @Override protected String doInBackground(Void... params) &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125; &#125;&#125; 乍一看这一段程序在功能上是没有问题的。但是如果从对象持有、内存状态再来看待这段程序时，MyAscnyTask是一个非静态内部类，如果他处理数据的时间很长，极端点用sleep 100秒，在这期间Activity可能运行5s后就关闭了，原本理想的状态是Activity的内存应该被回收的。但是：我们知道非静态内部类会持有外部类的引用，所以Activity也需要陪着非静态内部类MyAscnyTask一起跑完 100s。好了，内存泄漏就形成了。 如何解决呢？ 这就要回到这一节主题所代表的问题本质：生命周期。 既然 MyAscnyTask 与 Activity 的 生命周期差距如此之大，那么就干脆把 MyAscnyTask 变成 静态内部类，和Application玩去吧，这样做得到的结果就是： 静态内部类与外部类两者之间的 引用、内存 关系也相互独立了。 于是，可以修改该为： 123456789101112131415161718192021public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); new MyAscnyTask().execute(); &#125; //改了这里 注意一下 static static class MyAscnyTask extends AsyncTask&lt;Void, Integer, String&gt;&#123; @Override protected String doInBackground(Void... params) &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125; &#125;&#125; 匿名态内部类一个示例：12345678910111213141516171819202122232425262728293031public class TestActivity extends Activity &#123;private TextView mText; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg);//do somethingmText.setText(&quot; do someThing&quot;); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); mText = findVIewById(R.id.mText); // 匿名线程持有 Activity 的引用，进行耗时操作 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); mHandler. sendEmptyMessageDelayed(0, 100000); &#125;&#125; 在本小结的一开始列出了2个关键点：生命周期 已经在第一种问题中得到了应用。 那么接下来通过 对象引用 这个出发点来解决这个问题。 引用分为：强、软、弱、虚引用，而且 引用强度依次递减。 强引用： 平时用的最多、不做处理的一般都是强引用，如果一个对象具有的是强引用，那么GC即使发生OOM也不会回收它。 软引用（SoftReference）： 如果内存空间足够，GC则不会回收它，如果内存空间不足，那么GC则回收它。 弱引用（WeakReference）： GC的时候无论内存是否够用，都要回收它。 虚引用： 不常用。 那么此 匿名态内部类示例 的内存问题解决方式就变成了： static化 - 对内外类之间的联系进行分离 引用强度下降，使用弱引用 - 保证生命周期短的类及时销毁 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestActivity extends Activity &#123; private TextView mText; private MyHandler myHandler = new MyHandler(TestActivity.this); private MyThread myThread = new MyThread(); private static class MyHandler extends Handler &#123; WeakReference&lt;TestActivity&gt; weakReference; MyHandler(TestActivity testActivity) &#123; this.weakReference = new WeakReference&lt;TestActivity&gt;(testActivity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); weakReference.get().mText.setText(&quot;do someThing&quot;); &#125; &#125; private static class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); mText = findViewById(R.id.mText); myHandler.sendEmptyMessageDelayed(0, 100000); myThread.start(); &#125; //最后清空这些回调 @Override protected void onDestroy() &#123; super.onDestroy(); myHandler.removeCallbacksAndMessages(null); &#125;&#125; 资源未关闭可能出现问题的方面有： 流 未关闭 注册后未进行解绑 start() 后没有 stop() 分析工具： leakcanary，漏洞直接显示 Android Lint，帮助发现代码构成/质量问题。内存泄漏时会有发黄。 Android Profiler，自带，好好琢磨。 启动速度优化启动速度分为： 冷启动（Cold Start） 热启动（Hot Start） 温启动（Warm Start）冷启动 冷启动是指应用程序从头开始：系统的进程在此开始之前没有创建应用程序。 在冷启动开始时，系统有三个任务。这些任务是：1、加载并启动应用程序2、启动后立即显示应用程序的空白启动窗口3、创建应用程序进程 当系统为我们创建了应用进程之后，开始创建 应用程序对象。 1、启动主线程2、创建主Activity3、加载布局4、屏幕布局5、执行初始绘制 应用程序进程完成第一次绘制后，系统进程会交换当前显示的背景窗口，将其替换为主活动。此时，用户可以开始使用该应用程序。至此启动完成。 Application创建当Application启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成绘制应用程序。此时，系统进程会交换应用程序的启动窗口，允许用户开始与应用程序进行交互。这就是为什么我们的程序启动时会先出现一段时间的 黑屏(白屏)。如果我们有自己的Application，系统会onCreate()在我们的Application对象上调用该方法。之后，应用程序会生成主线程（也称为UI线程），并通过创建主要活动来执行任务。从这一点开始，App就按照他的 应用程序生命周期阶段进行。 Activity创建应用程序进程创建活动后，活动将执行以下操作： 初始化值。 调用构造函数。 调用回调方法，例如 Activity.onCreate()，对应Activity的当前生命周期状态。 通常，该 onCreate()方法对加载时间的影响最大，因为它以最高的开销执行工作：加载和膨胀视图，以及初始化活动运行所需的对象。 热启动（Hot start）应用程序的热启动比冷启动要简单得多，开销也更低。在一个热启动中，系统都会把你的Activity带到前台。如果应用程序的Activity仍然驻留在内存中，那么应用程序可以避免重复对象初始化、布局加载和渲染。 热启动显示与冷启动方案相同的屏幕行为：系统进程显示空白屏幕，直到应用程序完成呈现活动。 温启动（Warm start）温启动包含了冷启动时发生的一些操作，与此同时，它表示的开销比热启动少，有许多潜在的状态可以被认为是温暖的开始。 场景： 用户退出您的应用，但随后重新启动它。该过程可能已继续运行，但应用程序必须通过调用从头开始重新创建Activity 的onCreate()。 系统将您的应用程序从内存中逐出，然后用户重新启动它。需要重新启动进程和活动，但是在调用onCreate()的时候可以从Bundle（savedInstanceState）获取数据。 谷歌官方给的建议是：1、利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；2、避免在启动时做密集沉重的初始化（Heavy app initialization）；3、避免I/O操作、反序列化、网络操作、布局嵌套等。 这里是慢的定义： 冷启动需要5秒或更长时间。 温启动需要2秒或更长时间。 热启动需要1.5秒或更长时间。 无论何种启动，我们的优化点都是：Application、Activity创建以及回调等过程 包体优化APK的文件构成。 assets文件夹 存放一些配置文件、资源文件，assets不会自动生成对应的 ID，而是通过 AssetManager 类的接口获取。 res目录 res 是 resource 的缩写，这个目录存放资源文件，会自动生成对应的 ID 并映射到 .R 文件中，访问直接使用资源 ID。 META-INF 保存应用的签名信息，签名信息可以验证 APK 文件的完整性。 AndroidManifest.xml 这个文件用来描述 Android 应用的配置信息，一些组件的注册信息、可使用权限等。 classes.dex Dalvik 字节码程序，让 Dalvik 虚拟机可执行，一般情况下，Android 应用在打包时通过 Android SDK 中的 dx 工具将 Java 字节码转换为 Dalvik 字节码。 resources.arsc 记录着资源文件和资源 ID 之间的映射关系，用来根据资源 ID 寻找资源。 问题解决方案：减小 代码和资源 1、首先使用lint工具，同时开启资源压缩,自动删除无用的资源 1234567891011android &#123; ... buildTypes &#123; release &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125; 2、我们可以使用可绘制对象，某些图像不需要静态图像资源; 框架可以在运行时动态绘制图像。Drawable对象（以XML格式）可以占用APK中的少量空间。此外，XML Drawable对象产生符合材料设计准则的单色图像。 3、重用资源，比如一个三角按钮，点击前三角朝上代表收起的意思，点击后三角朝下，代表展开，我们会用两张图来切换，其实我们完全可以用旋转的形式去改变。一般比如同一图像的着色不同，我们可以用android:tint和tintMode属性 4、压缩PNG和JPEG文件您可以减少PNG文件的大小，而不会丢失使用工具如图像质量 pngcrush，pngquant，或zopflipng。所有这些工具都可以减少PNG文件的大小，同时保持感知的图像质量。 5、使用WebP文件格式可以使用图像的WebP文件格式，而不是使用PNG或JPEG文件。WebP格式提供有损压缩（如JPEG）以及透明度（如PNG），但可以提供比JPEG或PNG更好的压缩。 7、代码混淆使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能。这个大家太熟悉了。不多说了。 8、插件化。比如功能模块放在服务器上，按需下载，可以减少安装包大小。 耗电使用JobScheduler使用JobScheduler，来调整任务优先级等策略来达到降低损耗的目的。 具体功能：1、可以推迟的非面向用户的任务(如定期数据库数据更新)；2、当充电时才希望执行的工作(如备份数据)；3、需要访问网络或 Wi-Fi 连接的任务(如向服务器拉取配置数据)；4、零散任务合并到一个批次去定期运行；5、当设备空闲时启动某些任务；6、只有当条件得到满足, 系统才会启动计划中的任务（充电、WIFI…）。 懒惰第一的法则减少你的应用程序可以删除冗余操作吗？例如，它是否可以缓存下载的数据而不是重复唤醒无线电以重新下载数据？ 推迟应用是否需要立即执行操作？例如，它可以等到设备充电才能将数据备份到云端吗？ 合并可以批处理工作，而不是多次将设备置于活动状态吗？例如，几十个应用程序是否真的有必要在不同时间打开收音机发送邮件？在一次唤醒收音机期间，是否可以传输消息？ RecyclerView自带优化、BitmapBitmap的优化套路很简单、粗暴，就是：压缩。三种压缩方式：1.对图片质量进行压缩2.对图片尺寸进行压缩3.使用libjpeg.so库进行压缩 响应速度-线程优化影响响应速度的主要因素是主线程有耗时操作，影响了响应速度。所以响应速度优化的核心思想是避免在主线程中做耗时操作，把耗时操作异步处理。 线程优化的思想是采用线程池，避免在程序中存在大量的Thread。线程池可以重用内部的线程，从而避免了现场的创建和销毁所带来的性能开销，同时线程池还能有效地控制线程池的最大并发数，避免大量的线程因互相抢占系统资源从而导致阻塞现象发生。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化-关键字、内部类]]></title>
    <url>%2FApp%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB-1%2F</url>
    <content type="text"><![CDATA[总结 Java static 关键字 参考：http://www.importnew.com/20579.html参考：https://www.cnblogs.com/dotgua/p/6354151.html?utm_source=itdadao&amp;utm_medium=referral 特点被static关键字修饰的变量、方法、代码块是独立于该类的、被该类的所有实例共享，任何一个实例对其修改后都会导致其他实例的变化。 修饰1、成员变量static 修饰的变量我们称之为 静态变量，没有用static修饰的变量称之为 实例变量，他们两者的区别是： 静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。 但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。 一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。static修饰的类成员，在程序运行过程中，只需要初始化一次即可，不会进行多次的初始化。 2、方法过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。 static修饰方法的最大的作用，就是可以使用”类名.方法名”的方式操作方法，避免了先要new出对象的繁琐和资源消耗。 3、代码块当我们new一个类的对象时，static修饰的成员变量首先被初始化（如果有多个static修饰的成员，那么会按照他们的先后位置进行初始化），随后是普通成员，最后调用类的构造方法完成初始化。 静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该类的任何地方。 Java final 关键字final 指的是：这是不可变的。 1、修饰数据final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。更重要的是，final会告诉编译器：这个数据是不会修改的。那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。 在针对 基本类型 和 引用类型 时，final关键字的效果存在细微差别： final修饰数据：在被赋值后是无法在对其进行值修改的； final修饰的数据的值是不可改变的，所以必须确保在使用前就已经对成员变量赋值了。我们有且只有两个地方可以给它赋值： 声明该成员时赋值 在构造方法中赋值 final修饰引用变量：只是限定了引用变量的引用不可改变，即不能将已经修饰过的引用再次去引用另一个对象（引用变量的值实际上是它所引用的对象的地址，也就是说该地址的值是不可改变的），但是引用的对象的值是可以改变的。 同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。 2、修饰方法参数 ？在参数前面添加final关键字，它表示在整个方法中：我们不会（实际上是不能）改变参数的值 123456public void finalFunc(final int i, final Value value) &#123; // i = 5; 不能改变i的值 // v = new Value(); 不能改变v的值 // 可以改变引用对象的值 value.v = 5; &#125; 疑问： java参数传递采用的是值传递，对于基本类型的变量，相当于直接将变量进行了拷贝。所以即使没有final修饰的情况下，在方法内部改变了变量i的值也不会影响方法外的i。 3、修饰方法用final关键字修饰方法，它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。 4、修饰类final修饰的类是无法被继承的。 上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。 Java 内部类 参考：http://www.cnblogs.com/dolphin0520/p/3811445.html 将一个类定义在另一个 类里面 或者一个 方法里面，这样的类称为内部类。 内部类分类 成员内部类 局部内部类 匿名内部类 静态内部类 成员内部类是最普通的内部类，它定义在另一个类的内部。成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法创建成员内部类的对象了。 12345678910111213141516171819202122public class InnerClassEg &#123; private int age = 12; public InnerClassEg(int age) &#123; this.age = age; &#125; public void innerInfo()&#123; System.out.println(&quot;InnerClassEg innerInfo()!age is : &quot; + age); &#125; class Apple&#123; public Apple() &#123; System.out.println(&quot;this is a apple !&quot;); &#125; public void printHelper()&#123; System.out.println(&quot;apple printHelper()!&quot;); &#125; &#125;&#125; 类 Apple 像是类 InnerClassEg 一个成员变量（可以像类的成员一样拥有多种权限修饰），所以被称为 成员内部类。成员内部类 Apple 可以访问 外部宿主类 InnerClassEg 中的各种成员变量。 12345678910111213141516171819202122public class InnerClassEg &#123; private int age = 12; private static String name = &quot;class&quot;; public InnerClassEg(int age) &#123; this.age = age; &#125; public void innerInfo()&#123; System.out.println(&quot;InnerClassEg innerInfo()!age is : &quot; + age); &#125; class Apple&#123; public Apple() &#123; &#125; public void printHelper()&#123; System.out.println(&quot;apple printHelper()!age is : &quot; + age + &quot;, name is : &quot; + name); &#125; &#125;&#125; 注意： 当成员内部类 Apple 的变量和宿主类 InnerClassEg 的成员变量名相同时，使用的是 成员内部类的变量（就近）。 12345678910111213141516171819public class InnerClassEg &#123; private int age = 12; private static String name = &quot;class - InnerClassEg&quot;; private String example = &quot;Example - InnerClassEg&quot;; // ... class Apple&#123; private String example = &quot;Example - Apple&quot;; public Apple() &#123;&#125; public void printHelper()&#123; System.out.println(&quot;apple printHelper()!age is : &quot; + age + &quot;, name is : &quot; + name + &quot;, example : &quot; + example); &#125; &#125;&#125; 运行结果： 12InnerClassEg innerInfo()!age is : 23apple printHelper()!age is : 23, name is : class - InnerClassEg, example : Example - Apple 当修改为一下形式时： 12345678910class Apple&#123; private String example = &quot;Example - Apple&quot;; public Apple() &#123;&#125; public void printHelper()&#123; System.out.println(&quot;apple printHelper()!age is : &quot; + age + &quot;, name is : &quot; + name + &quot;, example : &quot; + example); System.out.println(&quot;apple printHelper()! example is : &quot; + InnerClassEg.this.example ); &#125;&#125; 运行结果为： 123InnerClassEg innerInfo()!age is : 23apple printHelper()!age is : 23, name is : class - InnerClassEg, example : Example - Appleapple printHelper()! example is : Example - InnerClassEg 关于成员内部类的继承问题。 一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点： 1）成员内部类的引用方式必须为 Outter.Inner. 2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。 1234567891011121314class WithInner &#123; class Inner&#123;&#125;&#125;class InheritInner extends WithInner.Inner &#123; // InheritInner() 是不能通过编译的，一定要加上形参 InheritInner(WithInner wi) &#123; wi.super(); //必须有这句调用 &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner obj = new InheritInner(wi); &#125;&#125; 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 123456789101112131415class People&#123; public People() &#123;&#125;&#125; class Man&#123; public Man()&#123;&#125; public People getWoman()&#123; //局部内部类 class Woman extends People&#123; int age =0; &#125; return new Woman(); &#125;&#125; 注意：局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类 匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 在Android中编写事件监听的代码时，使用匿名内部类不但方便，而且使代码更加容易维护。 1234567history_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;); 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static（加有static关键字的成员内部类）。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，因为在没有外部类的对象的情况下，静态变量、静态内部类可以进行创建，普通成员变量则不能创建。 1234567class Outter &#123; public Outter() &#123;&#125; static class Inner &#123; public Inner() &#123;&#125; &#125;&#125; 内部类的初始化123456789101112131415161718192021222324252627282930public class Test&#123; public static void main(String[] args)&#123; // 初始化Bean1 Test test = new Test(); Test.Bean1 bean1 = test.new Bean1(); bean1.I++; // 初始化Bean2 Test.Bean2 bean2 = new Test.Bean2(); bean2.J++; //初始化Bean3 Bean bean = new Bean(); Bean.Bean3 = bean.new Bean3(); bean3.k++; &#125; class Bean1&#123; public int I = 0; &#125; static class Bean2&#123; public int J = 0; &#125;&#125; class Bean&#123; class Bean3&#123; public int k = 0; &#125;&#125; 内部类问题为什么成员内部类可以无条件访问外部类的成员？事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件。在内部类中会有一个指向外部类的对象的指针，也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用。 为什么局部内部类和匿名内部类只能访问局部final变量？匿名内部类的变量根本就不是外部类方法中的局部变量。 如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对 拷贝进行初始化赋值。 这样一来就解决了 变量生命周期不一致的问题。但是新的问题又来了，既然在匿名内部类的方法中访问的变量和外部类方法中的变量不是同一个变量，当在匿名内部类的方法中改变变量的值的话，会出现什么情况？ 对！会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将外部类方法中的变量限制为final变量，不允许对变量进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。 到这里，就清楚为何方法中的局部变量和形参都必须用final进行限定了。 静态内部类有特殊的地方吗？ 静态内部类是不依赖于外部类的：可以在不创建外部类对象的情况下创建内部类的对象。 静态内部类是不持有指向外部类对象的引用的。 内部类的使用场景和好处 内部类使得多继承的解决方案变得完整：每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。 方便编写事件驱动程序 方便编写线程代码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-字符串]]></title>
    <url>%2FJava-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[String、StringBuffer、StringBuilder String、StringBuffer、StringBuilder区别一张图描述3者之间的关系 String类象操作本质String类： 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence String类中的每一个方法在对 原有的 String对象 作出修改时，实际上都是 创建了一个全新的对象，已包含修改后的字符串内容，而最初的对象没有发生改变。 如：substring()： 12345678910public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125; 最终的在方法结束 return 时，返回的是：new String(value, beginIndex, subLen); 当一个String对象传递给另一个方法或者进行其他操作时，实际传递的是一个 引用的拷贝。被传入的 拷贝引用 其实只是在方法运行时存在，方法结束后拷贝引用消失，同时返回一个 新创建的对象。 如测试例子： 12345678String str1 = &quot;Java is good !&quot;;System.out.println(&quot;str1 is : &quot;+str1+&quot;, heshCode is: &quot; + str1.hashCode());str1 = str1 + &quot;Oh! Yes!&quot;;System.out.println(&quot;str1 is : &quot;+str1+&quot;, heshCode is: &quot; + str1.hashCode());str1 = str1.concat(&quot; No! php is the best!&quot;);System.out.println(&quot;str1 is : &quot;+str1+&quot;, heshCode is: &quot; + str1.hashCode()); 运行结果为： 123str1 is : Java is good !, heshCode is: -158517034str1 is : Java is good !Oh! Yes!, heshCode is: -917780248str1 is : Java is good !Oh! Yes! No! php is the best!, heshCode is: -1986999688 String类的“+” 与 StringBuilder类的 append()StringBuilder类： 123public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 当 String对象 执行 + 操作时，实际执行的操作是：编译器自动引入 StringBuilder类，然后 自动创建StringBuilder对象，调用其 append()。 那么，我们直接使用 String类 的 + 操作和 StringBuilder类有什么区别呢？ 区别就是中间产生的 StringBuilder类对象。 假如要在 循环中 对 String类的对象 进行操作，则结果是每执行一次 循环操作就创建一个新的 StringBuilder类的对象，而内存是需要为这些对象分配空间的，同时还要在创建对象时消耗时间，即：费时费空间。 如果在执行循环之前，使用已经创建的 StringBuilder类对象，则在执行循环操作时不会再创建额外的对象。 那么，StringBuilder类的 append() 是如何实现的呢？1. StringBuilder类 中的 append() 12345@Overridepublic StringBuilder append(String str) &#123; super.append(str); return this;&#125; 2. AbstractStringBuilder类 中的 append() 1234567891011121314151617public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;&#125;private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125; 3. Arrays类 中的 copyOf() 123456public static char[] copyOf(char[] original, int newLength) &#123; char[] copy = new char[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 4. 最终调用的是System类的 arraycopy() 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 由此调用步骤可见，StringBuilder类 中的 append() 最终调用的是底层的方法。 这就是使用 String类对象 做 + 操作与 StringBuilder类 对象的 append() 操作的区别。 StringBuffer类又是什么呢？StringBuffer类： 123public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence 在 源码的注释文档中，有这么一段话： 12As of release JDK 5, this class has been supplemented with an equivalent class designed for use by a single thread, &#123;@link StringBuilder&#125;. The &#123;@code StringBuilder&#125; class should generally be used in preference to this one, as it supports all of the same operations but it is faster, as it performs no synchronization. 翻译成中文就是： 12从JDK 5发行版开始，这个类已经补充了一个设计用于单个线程StringBuilder的等效类。StringBuilder类通常应优先于此类使用，因为它支持所有相同的操作，但速度更快，因为它不执行同步。 注释中提到的 同步 指的是，在具体的执行方法中，有 synchronized 关键字。 如：同样是 append()， 在 StringBuffer类 中的源代码为： 123456@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 输出格式化默认情况下：数据都是右对齐的，但是使用 - flag 则可以实现左对齐。一般格式化语法的抽象语法描述为： 1%[argument_index$][flags][width][.precision]conversion 格式化输出像是 C语言 中的 printf() 的风格输出就是 格式化输出，在 Java SE5 引进了此种输出方式。 具体使用： 1234int age = 10;float length = 12.3f;System.out.printf(&quot;age is : %3d, length is %4.3f\n&quot;, age,length);System.out.format(&quot;age is : %d, length is %-4.2f\n&quot;, age,length); 输出结果为： 12age is : 10, length is 12.345age is : 10, length is 12.35 即：printf() 与 format() 在格式化输出上具有相同的功能。 格式化说明符Fromatter类 简单示例: 123Formatter formatter = new Formatter(System.out);String forStr = &quot;%-15s %5d %3.3f&quot;;formatter.format(forStr,&quot;total size is &quot;, 123, 222.1234f); 运行结果： 1total size is 123 222.123]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-5]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5%2F</url>
    <content type="text"><![CDATA[内容持续更新中 树树是一种 非线性 数据结构，是n(n≥0)个节点的 有限集。 树的结构定义是一个递归的定义：在树的定义中又用到了树的概念。 树的其他表现形式： 术语： 结点： 包含一个元素及若干个指向其子树的分支。 度： 结点拥有的子树数量称为结点的度。 叶子/终端结点： 度为0。 分支结点/非终端结点：度不为0.。 树的度： 树内各个结点的度的最大值。 孩子： 结点的子树称为该结点的孩子，该结点称为该树的双亲。 兄弟：同一个双亲的孩子 层次：是从根开始的，根为第一层。 深度：树中结点的最大层次称为树的深度。 有序树/无序树： 如果将树中的结点的各个子树看成是从左向右（不能互换）的，则是有序，反之无序。 森林： m(m≥0)颗互不相交的树的集合，对树中每个结点而言，其子树的集合即为森林。 二叉树特点 每个结点 至多只有2棵子树（二叉树中不存在度大于 2 的结点） 二叉树的子树 有左右之分，次序不能任意颠倒 性质 在二叉树的 第 i 层 上至多有 $ 2^{i-1} $ 个结点。 深度为 k 的二叉树至多有 $ 2^{k} - 1$ 个结点。 对于任何一个二叉树T，如果其终端结点数为 n0，度为2的结点数为 n2，则 n0 = n2 + 1。 具有 n 个结点的 完全二叉树 的深度为 $ log2n + 1 $ . 分类 满二叉树：一棵深度为 k 且有 $ 2^{k} - 1$ 个结点的二叉树；每一层上的结点数都是最大结点数。 完全二叉树：一棵深度为 k ，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为k的 满二叉树 中编号从 1至n 的结点一一对应时，称为 完全二叉树； 叶子结点只可能在层次最大的两层上出现。 对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为 l 或者 l+1; 不完全二叉树 存储结构 数组式存储 用一组 地址连续的存储单元 依次的 自上而下、自左至右 的存储 完全二叉树 上的结点元素，即可将完全二叉树上编号为 i 的结点元素存储在如上定义的一维数组中下标为 i-1 的分量中。 一个深度为 k 且只有 k 个结点的单枝树（树中不存在度为2的结点）需要的长度为 $2^k - 1$ 的一维数组。 如：一个 完全二叉树 的树形表示为： 转换为 数组式 存储结构为： 如：一个一般的二叉树的树形表示为： 转换为 数组式存 储结构为： 链式存储 设计 不同的结点结构 可构成 不同形式的链式存储结构 。 二叉链表：由二叉树的定义得知，二叉树的结点由 一个数据元素 和 分别指向其左、右子树的 两个分支 构成，即：二叉树中的 结点 至少包含3个域：数据域 、 左指针域 、右指针域。 三叉链表：有时为了便于找到结点的双亲，还在二叉链表的结点结构中 增加一个指向双亲结点的指针域， 单支树的二叉链表 二叉链表 三叉链表 遍历二叉树按照某条搜索路劲访问树中的每个结点，使得 每个结点均被访问一次，而且仅被访问一次。 遍历二叉树是以 一定的规则 将二叉树的中的 结点排列成一个线性序列，这实质上是 对一个非线性结构进行线性化操作，使得每个结点（除了第一个和最后一个外）在 线性序列 中 有且仅有一个直接前驱和一个直接后继。 二叉树是由 3个 基本单元组成：根节点、左子树、右子树，只要依次遍历这三个部分，便是遍历了整个二叉树。 使用L、D、R分别表示遍历左子树、访问根、遍历右子树，将有 DLR、DRL、LDR、LRD、RLD、RDL6种。但是二叉树的其中一个特点是：左右有序，次序不能任意颠倒，于是只有 3 种： DLR - 先（根）序遍历 LDR - 中（根）序遍历 LRD - 后（根）序遍历 3种遍历算法的不同之处仅在于访问根节点和遍历左、右子树的 先后关系。 线索二叉树当以 二叉链表作为存储结构时 ，只能找到结点的左、右孩子信息，而 不能直接得到 结点在任一序列中的 前驱 和后继 信息，这种信息只能是在 遍历的动态过程中 才能得到。 通过在每个结点上 增加两个指针域 ，分别用来表示结点在任意一次遍历时得到的前驱和后继信息。如： 其中： LTag 0：lchild域指示结点的左孩子 1：lchild域指示结点的前驱 RTag 0：rchild域指示结点的右孩子 1：rchild域指示结点的后继 以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做：线索链表 。 其中，指向结点前驱和后继的指针，叫做 线索 。 加上线索 的 二叉树 称为 线索二叉树。 线索二叉树的表示： 对 二叉树 以某种次序遍历 使其变为线索二叉树的过程 叫做 线索化。 树和森林树的存储结构 双亲表示法 假设以一组连续空间存储树的结点，同时在 每个结点 中 附设一个指示器 指示其双亲结点在链表中的 位置。但是，在这种表示方法中，求结点的孩子时需要遍历整个树。 孩子表示法 描述：由于树中 每个结点 可能有 多棵子树，则可用 多重链表 ，即 每个结点有 多个指针域，每个指针域 指向一棵子树的根结点。 具体表示为：把 每个结点 的 孩子结点排列起来，看成是一个 线性表，且以 单链表作为存储结构，则 n 个结点就有 n 个孩子链表。而 n 个头指针组成一个线性表，为了方便查找，可采用顺序存储结构。 特点：此种实现方式适合于 涉及到孩子的操作，不适合于 原树： 孩子链表 双亲 + 孩子 表示法 孩子兄弟表示法 又称 二叉树表示法 或者 二叉链表表示法，以 二叉链表作为树的存储结构。 特点：通过此存储结构便于实现各种树的操作。 原树： 二叉树表示法： 森林与二叉树的转换树转换为二叉树 加线： 在所有的兄弟结点之间加一条连线. 去线,：对树中每个结点,只保留它与第一个孩子结点的连线,删除它与其它孩子结点之间的连线. 旋转：层次调整,以 树结点为轴心 ,将整个树 顺时针旋转 一定的角度,使之结构层次分明.第一个孩子是二叉树结点的左孩子,兄弟转化过来的孩子是结点的右孩子. 二叉树转换为树是树转二叉树的 逆过程 加线 去线 逆时针旋转，层次调整 森林转换为二叉树 把每个结点转化为二叉树 第一棵二叉树不动，从 第二棵开始 ，依次把 后一棵二叉树的根结点 作为 前一棵二叉树的根结点的 右孩子 ，用线连起来。当所有的二叉树链接起来后，就得到了有森林转换来的二叉树。 二叉树转换为森林 从根结点开始,若右孩子存在,则把 与右孩子的结点的连线删除 ,在查看分离后的二叉树,若右孩子存在,删除….直到所有的右孩子连线都删除为止,得到分离的二叉树 每棵分离后的二叉树转化为树即可. 树和森林的遍历 先序遍历先访问根结点，然后依次先序遍历完每棵子树：ABCDEFGIJHK 后序遍历先依次后序遍历完每棵子树，然后访问根结点:CDBFIJGHEKA 哈夫曼树定义哈夫曼树，又称最优二叉树，是一类带权路径长度最短的树。 路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。路径长度：路径上的分支数目。树的路径长度：从树根到每一个结点的路径长度之和。树的带权路径长度：树种所有叶子结点的带权路径长度之和。哈夫曼树（最优二叉树）：假设有 n 个权值，试构造一棵有 n 个叶子结点的二叉树，每个叶子结点带不同的权，则其中带权路径长度最小的二叉树被称为：哈夫曼树。 如： a的带全路径长度为：7x2+5x2+2x2+4x2=36b的带全路径长度为：7x3+5x3+4x2+2x1=46c的带全路径长度为：7x1+5x2+2x3+4x3=35 则：c树的带权路径长度最小，c树为哈夫曼树。 哈法曼树构造哈法曼树： 对给定的n个权值{W1,W2,W3,…,Wi,…,Wn}构成n棵二叉树的初始集合F={T1,T2,T3,…,Ti,…, Tn}，其中每棵二叉树Ti中 只有一个权值为Wi的根结点，它的左右子树均为空。 在F中选取 两棵 根结点 权值最小 的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值 为其左右子树的根结点的 权值之和。 从F中删除这两棵树，并把这棵 新的二叉树 同样以 升序排列 加入到集合F中。 重复2）和3），直到集合F中只有一棵二叉树为止。 实现图解 前缀编码：若要设计长短不等的编码，则必须是任一个字符的编码都不是另一个字符的编码的前缀。这种编码称为：前缀编码。 哈夫曼编码：由哈夫曼树对应的字符串转换的对应最短二进制码，就是哈夫曼编码。]]></content>
      <categories>
        <category>温故知新</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络篇-基础]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E7%AF%87-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[网络篇 - 基础总结 参考：http://www.cnblogs.com/maybe2030/p/4781555.html参考：https://blog.csdn.net/GitChat/article/details/78546898参考：https://blog.csdn.net/never_cxb/article/details/50420521参考：https://blog.csdn.net/zhangliangzi/article/details/51812415参考：https://blog.csdn.net/cxq2111504104/article/details/73480109参考：https://blog.csdn.net/guoguo527/article/details/52078962 计算机网络学习的 核心内容 就是 网络协议 的学习。网络协议是为计算机网络中进行 数据交换 而建立的 规则、标准或 约定 的集合（就像 普通话 之于全国人民之间的沟通、英语 之于全球人类之间的沟通），如：TCP/IP协议。 为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，于是提出了 网络模型、网络协议 网络模型层次划分 协议： 是控制 两个对等实体 进行通信的规则的集合，协议是 水平的。 服务： 任一层实体需要 使用下层服务，遵循本层协议，实现本层功能， 向上层提供服务，服务是 垂直 的 。 出现的先后顺序： OSI 7层 ：先有模型，后有协议，先有标准，后进行实践； TCP/IP 4层 ：先有协议和应用再提出了模型，且是参照的OSI模型。 实际应用： OSI 是一种理论下的模型 TCP/IP 已被广泛使用，成为网络互联事实上的标准。 7层 -&gt; 5层 -&gt; 4层 网络层次模型变化 7层 与 4层 网络层次模型表格对比 7层参考模型 - OSI/RM开放系统互联参考模型 —— OSI/RM（Open System Interconnection/Reference Model）。 数据在此网络模型中传递数据 物理层（Physical Layer） 该层为上层协议提供了一个 传输数据的可靠的物理媒体，激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。 传输的数据形式是比特流。 2个重要的设备名称：中继器 和 集线器。 数据链路层（Data Link Layer） 为网络层 提供可靠的数据传输；基本数据单位为帧； 主要的协议：以太网协议； 2个重要设备名称：网桥 和 交换机 网络层（Network Layer） 负责对子网间的数据包进行 路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；基本数据单位为IP数据报； 主要协议： IP协议（Internet Protocol，因特网互联协议）、 ICMP协议（Internet Control Message Protocol，因特网控制报文协议）、 ARP协议（Address Resolution Protocol，地址解析协议）、 RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 1个重要设备名称：路由器 传输层（Transport Layer） 负责将上层数据 分段 并提供 端到端的可靠、不可靠的传输 以及端到端的差错控制、流量控制问题； 主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）； 重要设备：网关 会话层（Session Layer） 管理主机之间的 会话进程，即负责建立、管理、终止进程之间的会话。 利用在数据中插入校验点来实现 数据同步。 主要协议：NetBIOS、SAP、SDP、NWLink 表示层（Presentation Layer） 对上层 数据或信息进行变换 以保证一个主机应用层信息可以被另一个主机的应用程序理解，数据转换包括数据的 加密、压缩、格式转换等。 主要协议：ASCII、MPEG、JPEG、MIDI 应用层（Application Layer） 为操作系统或网络应用程序 提供访问网络服务的接口。 主要协议：HTTP、SMTP、FTP、Telnet、DNS、DHCP、SSH TELNET 5层参考模型 物理层 比特传输 数据链路层 以太网（Ethernet）、 802.11 (WiFi)、PPP 网络层 IP协议、路由协议等 传输层 TCP, UDP 应用层 FTP, SMTP, HTTP 4层参考模型数据包传递过程。图片来自网络，十分贴切： HTTP 协议超文本传输协议 —— HTTP（HyperText Transfer Protocol），互联网上应用最为广泛的一种网络协议，是用于从万维网 WWW（:World Wide Web ）服务器 传输超文本到 本地浏览器 的传送协议。 HTTP协议工作于 客户端-服务端 架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 特点 无连接： 限制每次连接只处理 一个请求 。服务器处理完客户的请求，并收到客户的应答后，即断开连接。 无状态： 无状态是指协议 对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 灵活： 允许传输 任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。 简单快速： 客户向服务器请求服务时， 只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 URLURL组成 URI 与 URL2者都是 定位资源位置 的，就像 经纬度 一样可以表示你在世界的哪个角落。 定义： URI（Uniform Resource Identifier）：统一资源 标志符，是一种宽泛的含义、定义更广。 URL（Uniform Resource Locator）：统一资源 定位符，URL则是URI的一个子集。 操作： URI ：在 java.net.URI 只能看到一些属性，只是表示一个位置，但是无法通过 URI 获取到 这个对象的流 URL ：在 java.net.URL 该类提供方法 openConnection()，通过该方法我们可以 通过IO流进行操作。 HTTP - Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式，由4部分组成： 请求行（request line） 请求头部（header） 空行 请求数据 示例：以Post为例 HTTP - ResponseHTTP响应也由4个部分组成： 状态行 消息报头 空行 响应正文 HTTP - 状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 Http 请求方法 GET ： 请求指定的页面信息，并返回实体主体。 POST ： 向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中，可能会导致新的资源的建立和/或已有资源的修改。 HEAD ： 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 PUT ： 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE ： 请求服务器删除指定的页面。 CONNECT ： HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS ： 允许客户端查看服务器的性能。 TRACE ： 回显服务器收到的请求，主要用于测试或诊断。 GET 和 POST请求的区别 形式： GET 提交的数据会放在 URL之后 ，以?分割URL和传输数据，参数之间以&amp;相连。 POST 方法是把提交的数据放在HTTP包的 Body中。 大小： GET 提交的数据 大小有限制（因为浏览器对URL的长度有限制） POST 方法提交的数据 没有限制. 安全性： GET 方式提交数据时，参数 的键和值直接 出现在URL上。 获取值： GET 方式需要使用 Request.QueryString 来取得变量的值 POST 方式通过 Request.Form 来获取变量的值。 TCP 协议TCP 区别 UDP TCP：面向连接、可靠 TCP的三次握手机制很大程度上保证了连接的可靠性，其实网络的不安全不稳定特性，无论多少次握手都不能保证连接的可靠性 。 UDP：无连接、不可靠 UDP传送数据前并 不与对方建立连接，对接收到的数据也 不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发。但是正是因为没有三次握手机制，导致了其达到了TCP无法达到的传输效率。 TCP建立连接 - 3次握手3次握手描述 主机A 发起握手，目的端点是服务端的端点 post_server 生成一个随机数作为它的初始化发送序号 x 发出一个同步报文段，SYN = 1，发送序号 seq = x 发出后进入 SYN_SEND 状态，等待服务器确认 服务端 监听到端口 post_server 上有链接，则响应 生成一个随机数作为它的初始发送序号 seq = y 发出一个同步报文段，并对主机A端口的连接请求进行确认，发送ack = x+1 发送 SYC+ACK 包，此时服务器进入 SYN_RECV 状态 主机A 发出对 服务器端口 post_server 的确认，确认序号 ack = y+1，同时还有 ack = x+1 客户端和服务器端进入 ESTABLISHED 状态，完成三次握手 图形描述-简化 图形描述-详细 为什么是3次握手 第一次：客户端发送，服务端知道 客户端 可以发送数据 第二次：服务端接收、发送，客户端知道 服务端 能收、能发 第三次：客户端接收、发送，服务端知道 客户端 能收、能发 3 次是双向通信的最小值，也就是 SYN, SYN ACK, ACK。如果2次握手的话，客户端有可能因为网络阻塞等原因会发送多个请求报文，这时服务器就会建立连接，浪费掉许多服务器的资源。所以要增加第三次握手。 TCP关闭 - 4次握手4次握手描述 主机A的端口通知主机B的端口 应用程序通知 TCP数据 已经 发送完毕时，关闭连接。 TCP 向主机B 发送一个带 FIN 附加标记的报文段：FIN = 1，seq = x 主机B响应 收到 FIN 报文段后，并没有立刻用 FIN 报文段 回复主机A，而是先向主机A 发送一个确认信号（目的是为了防止这段时间内，主机A重复的发送 FIN 报文段）：ACK = 1，ack=x+1 。 同时，通知自己相应的应用程序：主机A传输已经结束，对方要求关闭连接。 主机B关闭向主机A发送数据的端口 自身的应用程序告诉 TCP：我也要彻底关闭连接。 TCP 收到对最后数据的确认后，向主机A发送一个 FIN 报文段：FIN = 1，seq = y, ACK:ack = x+1; 主机A响应 收到 FIN 这个报文段后，向主机B发送一个 ACK = 1， ack = y+1 表示连接彻底释放。 主机B收到主机A的ACK报文段后，关闭连接。此时，主机A等待2MSL （Maximum Segment Lifetime）后依然没有收到回复，则证明主机 B已正常关闭，那好，主机A也可以关闭连接了。 图形描述-简化 图形描述-详细 为什么是4次握手 参考：https://www.cnblogs.com/zengzy/p/5107516.html TCP是 全双工模式，关闭连接时，当 主机 B收到主机A的FIN报文时，仅仅表示主机 A不再发送数据，但是还能接收数据。 SocketUNIX BSD 发明了socket，其屏蔽了各个协议的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。 Socket 其实是提供了 tcp/ip协议的抽象，对外提供了一套接口，同过这个接口就可以统一、方便的使用tcp/ip协议的功能了。 Socket 在Java 中的实现需要通过 IP地址 + 端口号实现（TCP是两个进程之间的通信，一个客户端有多个进程同时进行通信，使用端口号加以区分）。 Socket 在网络模型中的位置 图片来自网络 套接字（Socket）编程接口是从顶上3层（应用层）进入传输层的接口，因为： 顶上3层处理的是具体的网络应用的所有细节，而对通信细节了解很少；低下4层对具体的网络应用了解不多，却处理所有的通信细节。 顶上3层通常构成所谓的用户进程，低下4层却通常作为操作系统的内核的一个部分提供。 Socket 与 TCP/IP 与 HTTP协议 3者之间的关系应用层的HTTP协议是基于 TCP协议的，传输层的 TCP协议 是基于 网络层的 IP协议的，Socket本身不算是协议，仅仅是提供了一个针对TCP或者UDP编程的接口。 HTTPSHTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）基于安全套接字层的超文本传输协议。HTTPS = HTTP + SSL HTTP与HTTPS的不同点 HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层 HTTP 无需加密，而 HTTPS 对传输的数据进行加密 HTTP 无需证书，而 HTTPS 需要认证证书 什么时候该使用 HTTPS?银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk反编译 - 构建、打包篇]]></title>
    <url>%2FApk%E5%8F%8D%E7%BC%96%E8%AF%91%20-%20%E6%9E%84%E5%BB%BA%E3%80%81%E6%89%93%E5%8C%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Apk反编译 - 构建、打包 之前总是根据用到的、学习到的知识点进行总结，写博客。但是写的多了，写的时间长了，在写到一个具体的知识点的实现过程时，会有意的意识到，这个知识点可以和之前的某个知识点串起来，而那个知识点又可以和另外知识点连接起来，这样我就在无形之中，将自己的知识点串联了起来，形成了属于我自己、适合我自己的知识体系、系统架构。 这一点是我在一开始写博客时，没有想到的。我一开始的想法仅仅是想记录下当前的这个点，方便自己以后日后使用。同样，正是由于这个意外的收获，是我更加坚定了自己写好博客、写有质量的博客、写知识系统性的博客。形成良性循环。 带着问题工作，思考工作中的每一个环节。 关注 各个大厂 的 微信技术公众号，从实际的产品中看热门知识点的应用。 Android构建过程Apk打包本文的分析方式为：反向分析。由结果向后倒推。 了解 Android 的打包流程，有助于我们做一些 针对编译期的优化，包括但不限于提高打包速度，提高 Android 应用的 hack 难度增加安全性，减少 Android 安装包的体积，完成一些自动化的编码，减少编码压力等。 Apk 文件构成 参考：https://mp.weixin.qq.com/s?__biz=MzI0NjIzNDkwOA==&amp;mid=2247483789&amp;idx=1&amp;sn=6aed8c7907d5bd9c8a5e7f2c2dcdac2e&amp;scene=1&amp;srcid=0831CCuRJsbJNuz1WxU6uUsI#wechat_redirect 概览apk 文件本质上其实是一个 zip包。 基本的 Apk包内容： 红色标注部分，这一些文件和文件夹是一个 Android 应用基本都具备的。而其他的一些文件和文件夹则是一些第三方库，或者是其他一些代码生成的。 不同项目的包的内容的差异： 1. AndroidManifest.xml是 Android 应用的全局配置文件 ，它包含了这个应用的很多配置信息，例如包名、版本号、所需权限、注册的服务等。 可以根据这个文件在相当程度上 了解这个应用的一些信息 。该文件在直接解压的状态下是被编译为二进制的 XML 文件，是 无法直接查看 的。 2. assets 文件夹assets 文件 夹用于保存 需要保持原始文件的资源文件夹，开发过程中拖了什么到里面，打包完之后里面还是什么。一般用于存放音频，网页（帮助页面之类的），字体等文件。 主要需要知道的点是它与 res 文件夹的区分 以及如何在应用中访问该文件夹的资源，如它可以有多级目录而 res 则只有两级。 assets 文件 与 res 文件夹 的 区分 子目录不同： res目录中的资源 只能存储在相应的子目录 (如res/layout、res/values等)中 ssets目录中的资源可以 任意存放，也可以建立任意层次的子目录 引用资源的方式 不同： res目录 中的 所有资源 都会在 R类 的相应子类中 生成对应的int类型变量，需要使用这些变量来引用资源。 assets目录中的资源需要 直接使用文件名 来引用，返回与资源文件对应的 InputStream对象，剩下的操作就是普通的Java代码 输入流 操作了。 例如： 12InputStream is1=getResources().getAssets().open(&quot;xyz.xml&quot;);InputStream is2=getResources().getAssets().open(&quot;abc/test.db&quot;); 编译时处理方式不同 res目录中 的资源子目录 除了raw 外，其他资源目录中的资源文件 都会被编译，这也是为什么将APK文件解压后无法直接查看XML格式资源文件内容的原因。 assets与res/raw目录 中的资源文件 不会做任何处理，在调用时通过 流 的方式，所以将APK解压后，这两个目录中的资源文件都会保持原样。 3. dex 文件classes.dex 文件是 Android 系统运行于 Dalvik Virtual Machine 上的 可执行文件，也是Android 应用程序的核心所在。 项目工程中的： Java 源码 通过 javac 生成 class 文件， 再通过 dx 工具 转换为 classes.dex， 注意： 这里有 classes2.dex和 classes3.dex。 1：这是 方法数超过一个 dex 的上限，分 dex 的结果。2：分 dex 在 Android 5.0 之前需要开发者自行完成，5.0 后 dx 自带支持。3：目前一些热补丁有关的技术，主要便是对 dex 做各种处理。 4. lib 文件夹该目录存放着应用需要的 native 库文件：如一些底层实现的图片处理、音视频处理、数据加密的库以 so 库的形式在该文件夹中。 而该文件夹下有时会 多一个层级，这是 根据不同 CPU型号 而划分 的，如 ARM，ARM-v7a，x86等。 5. META-INF 文件夹该目录的主要作用是用于保证 APK 的 完整性 以及 安全性。 主要有三个文件： MANIFEST.MF：保存了整个 apk 文件中 所有文件的文件名 + SHA-1后的 base64 编码值。这也就意味着 MANIFEST.MF 象征着 apk 包的完整性。 CERT.RSA：这个文件保存了 公钥 和 加密方式 的信息。 CERT.SF：这个文件与 MANIFEST.MF 的结构一样，只是其 编码被被私钥加密。 6. res 文件夹放的所有文件都会 被映射到 R 文件 中，生成对应的 资源 ID，便于代码中 通过 ID 直接访问。其中的资源文件包括了动画(anim)，图像(drwable)，布局(layout)，常量值(values)，颜色值(colors)，尺寸值(dimens)，字符串(strings)，自定义样式(styles)、菜单(menu)等。 7. resource.arsc 文件此文件是所有文件中 结构最复杂 的。 string 的信息最多 resource.arsc 是可以包含 多个 package 的资源的。 然后可以看到一个 Resource Types 的列表。这里看到的是 anim 的 type。 右边显示了有多少个 anim 以及多少项 configurations，以及表的具体内容为 ID - Name - 各个维度的值（在这里即是资源的路径），通过这个可以完成通过 id + 对应的 configuration 获取对应资源的操作。 资源混淆的原理，就是修改这里 各个维度的值，并修改 对应 res 里面的文件夹 以及 文件名实 现的。 Android 打包流程 参考：https://www.jianshu.com/p/8d691b6bf8b4参考：https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232113&amp;idx=1&amp;sn=02f413999ab0865e23d272e69b9e6196&amp;scene=1&amp;srcid=0831gT4p6M0NFG5HTTeRHTUC#wechat_redirect Android的是如何构建一个APK的？此图是谷歌官方发布的一张.apk打包流程图。 概述： 流程概述： 资源打包。应用程序的资源文件（res 文件下各个文件），通过AAPT打包成 R.java类（资源索引表）、.arsc文件。 AIDL处理。如果有AIDL，则通过 AIDL工具，打包成 Java接口类。 生成.class文件。R.java 和 aidl.java 通过 Java编译成为目标的 .class文件。 dx处理。第三方jar 或者 lib 通过 .dx工具 打包成 dex文件， .dx工具 的主要作用是将 Java的字节码 转换为 Dalvik的字节码，在此过程中会 压缩常量池，消除一些冗余信息。 apk打包。apkbuilder工具 会将所有 未编译的资源文件、.arsc资源、.DEX文件打包到一个完成的 apk文件 中。 签名。完成的apk将通过配置了签名文件（调试和释放都有）的 jarsigner工具 对其进行签名。得到一个签名后的APK：signed.apk 对齐处理。zipalign工具 对 signed.apk 进行对齐处理，所谓对齐，主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问APK文件时的速度会更快。对齐的作用主要是为了减少运行时内存的使用。 Android 打包后续加固快速多渠道包资源混淆热补丁]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Apk</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk反编译 - 工具篇]]></title>
    <url>%2FApk%E5%8F%8D%E7%BC%96%E8%AF%91%20-%20%E5%B7%A5%E5%85%B7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Apk反编译 - 工具 参考：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/1002/8570.html 工具工具套装-01 ApkTool： 作用：拆包，得到AndroidManifest和res等资源文件下载地址： http://ibotpeaches.github.io/Apktool/install/ dex2jar： 作用：classes.dex转化成jar文件下载地址： https://sourceforge.net/projects/dex2jar/files/ jd-gui： 作用：将jar文件转换成java代码下载地址： http://jd.benow.ca/ 工具套装-02jadx： 一步到位Apk反编译处理、强大的集合工具。 GitHub 项目地址：https://github.com/skylot/jadx zip包下载地址：https://bintray.com/skylot/jadx/releases/v0.7.1#files 工具套装-03 Android Studio 自带的 Apk 分析工具 将一个 Apk 拖进 Android Studio； 或者在执行 Build APK(s) 后，双击 build/output/apks/目录下的apk 即可显示： 通过此工具可以对 Apk 在宏观上有一个系统的认识，是 宏观 性的。 使用工具套装01 - ‘ApkTool + dex2jar + jd-gui’ApkTool拆解Apk文件，反编译 其中的资源文件，将它们反编译为 可阅读 的AndroidManifest.xml文件和res文件。 若是直接把Apk文件当做 zip解压，得到的xml资源文件都是 无法 直接用文本编辑器打开阅读的，因为它们在打包时经过了build-tools的处理。 在终端中执行以下命令： 1java -jar apktool_2.3.3.jar d police.apk 注意： 在执行命令时，一定要将 待处理的Apk文件 放置在 和 apktool_XXX.jar 文件同一文件目录下。 dex2jar在执行此步骤时，需要对 Apk文件进行解压，之后将解压文件夹中的 classes.dex文件 复制到 dex2jar_XX 文件夹中，如下： 然后在 当前目录 dex2jar_XX 下，运行命令： 1sh d2j-dex2jar.sh classes2.dex 若在原有文件的基础上，得到一个新文件 classes2-dex2jar.jar，这就表明处理成功： 注意： 若是在执行命令过程中，遇到了 权限问题，可作出如下修改即可： 1sudo chmod +x d2j_invoke.sh jd-gui到这一步就是 查看java代码 的环节了。点击 jd-gui-osx-1.4.0 目录下的 JD-GUI.app 文件， 会弹出一个UI窗口： 选择刚刚得到的 classes2-dex2jar.jar 文件： 打开后的界面为： 至此，就可以选择具体的包，查看具体的代码了： 工具套装02 - ‘jadx’jadx 的 官方使用参考：https://github.com/skylot/jadx博客参考：https://blog.csdn.net/Fisher_3/article/details/78654450 优点： 图形化的界面。 拖拽式的操作。 反编译输出 Java 代码。 导出 Gradle 工程。 根据自己的路径，进入到 jadx-0.7.1/bin 后，点击 jadx-gui 文件，即可开启UI窗口 然后选择要反编译的 Apk文件 即可： 其中的文件，除了 .java文件 是可读的之外，资源文件也是可直接读的： 区别jd-gui 与 jadx 对比jadx 可直接导出 gradle 项目但是貌似只有 .java文件 导出结果： 对 .java文件 的反编译能力不同，从对比可以看出，对于同一个 加固极好的CM.apk 文件而言，明显 jadx 反编译出的文件要多： 具体反编译的代码对比可以看出 jadx 反编译出的的文件的图标标识更符合 一般情况下对 Java 的认识，更熟悉。 变量：能够发编译出变量名的就显示变量名；对于不能编译出的变量名， jadx 是通过以下： 功能实现 自定义命名变量名 的如： f142g，但是这样的 变量名没有实际意义，仅仅就是一个变量的区分、标识而已。 而且同时不能实现通过 点击 进行变量间的跳转，仅仅是颜色上的区分，如： jd-gui 是通过以下： 功能实现 自定义命名变量名 的如： b，但是这样的 变量名没有实际意义，仅仅就是一个变量的区分、标识而已。 不同点： jd-gui 中的变量通过点击是 可以进行跳转 的，这一点真的是非常有用。 代码格式 jadx： 严格 符合代码格式的，且 代码颜色更为丰富。jd-gui： 不严格 符合代码格式，仅仅是有一个缩进的样子而已，代码颜色较为单一。 代码实现反编译结果 同一个方法内部的 代码实现是不同 的。左侧为： jadx ， 右侧为：jd-gui]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Apk</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器]]></title>
    <url>%2FJava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Java-容器 总结 优化是一个棘手的问题，但最好的策略就是置之不顾，直到你发现需要担心它了。 —— 《Java编程思想》 常用集合之间的继承、实现关系 常用容器类 Java容器类的用途是：保存对象 迭代器： 作用： 是 遍历 并 选择 序列总的对象，客户端程序员无需知道 该序列的底层结构 特点： 一般的只能单向移动（ListIterator 双向，只能适用于各种 List类 的访问） 使用 next() 获取序列中的下一个元素 使用 hasNext() 检查序列中是否还有元素 一个简单迭代器的实现 12345678910111213141516171819202122232425public class DinerMenuIterator implements Iterator &#123; MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if (position &gt;= items.length || items[position] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; MenuItem menuItem = items[position]; position++; return menuItem; &#125;&#125; 一个 display() 123456public static void display(Iterator&lt;String&gt; iterator)&#123; while (iterator.hasNext()) &#123; String item = iterator.next(); System.out.println(item); &#125;&#125; Collection 集合 Collection 继承了 Iterable 接口。 注意：Collections和Collection的区别 Collections包含有 各种有关集合操作 的 静态多态方法 Collection 是接口 List像数组一样，其建立了 数字索引 与 对象 的关联。支持添加重复的对象、有序（按照元素插入的顺序），一种可修改的序列。 ArrayList数据底层结构 是 数组特点：增删快、查询慢 ArrayList 与 Arrays 与 ArrayArray类 ：提供静态方法来动态创建和访问Java数组。Arrays类 ：该类包含用于处理数组的各种方法（如排序和搜索）。 此类还包含一个静态工厂，允许将数组视为列表。 ArrayList本质由源码的 成员变量声明 ： 1234private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData; 以及：构造函数： 12345678910111213141516171819202122232425262728public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125;// - - - -public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;// - - - -public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 来看：ArrayList 本质是：是一个 容量可变 的 Object[] 。 ArrayList的扩容最终调用的扩容方法 123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 通过 Arrays.copyOf(elementData, newCapacity) 方法获取新的 数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 在 Arrays 类中 通过 copyOf() 方法 生成新的 数组。具体实现过程： 先创建新数组 再复制 1234567891011121314151617181920212223242526复制指定的数组，使用空值截断或填充（如有必要），以便副本具有指定的长度。对于在原始数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效但不是原始副本的索引，副本将包含 `null`。当且仅当 **指定的长度大于原始数组的长度** 时，这些指数才会存在。返回的结果是 `newType` 类的数组参数说明： @param &lt;U&gt; 原始数组中对象的类 @param &lt;T&gt; 返回数组中对象的类 @param original 要复制的数组 @param newLength 要返回的副本的长度 @param newType 要返回的副本的类 -&gt; &lt;T&gt; @return 原始数组的副本，用空值截断或填充以获得指定的长度 public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) // 先创建新数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); // 再将源数据复制到新数组 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; Array 类的 newArray() 进行具体数组 类型 的创建，即：Arrays 类中 copyOf() 方法中的 T[] copy 实例 类型。 在具体的创建过程中，有一个方法： isPrimitive() ，其作用是：确定 对象类型 是否为 预定义的9个（ 8种基本类型 和 void） 类型。 123456789101112131415161718192021222324private static Object newArray(Class&lt;?&gt; componentType, int size) throws NegativeArraySizeException &#123; if (!componentType.isPrimitive()) &#123; return createObjectArray(componentType, size); &#125; else if (componentType == char.class) &#123; return new char[size]; &#125; else if (componentType == int.class) &#123; return new int[size]; &#125; else if (componentType == byte.class) &#123; return new byte[size]; &#125; else if (componentType == boolean.class) &#123; return new boolean[size]; &#125; else if (componentType == short.class) &#123; return new short[size]; &#125; else if (componentType == long.class) &#123; return new long[size]; &#125; else if (componentType == float.class) &#123; return new float[size]; &#125; else if (componentType == double.class) &#123; return new double[size]; &#125; else if (componentType == void.class) &#123; throw new IllegalArgumentException(&quot;Can&apos;t allocate an array of void&quot;); &#125; throw new AssertionError();&#125; 当执行 123if (!componentType.isPrimitive()) &#123; return createObjectArray(componentType, size);&#125; 时，调用 Array 类的 private static native Object createObjectArray() 本地方法实现 创建数组副本。调用 System 类的 public static native void arraycopy() 本地方法实现 复制数组副本。 ArrayList 类中，clear() 方法的实现： 1234567public void clear() &#123; modCount++; for (int i = 0; i &lt; size; i++) // 为每一个元素置空，让其被 GC 回收 elementData[i] = null; size = 0;&#125; LinkedList数据底层结构 是 链表 特点：查询快、增删慢 源代码中，节点（Node） 的表示： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 各种Queue以及栈的行为，由 LinkedList 提供支持。 实现： Queue 接口 ：队列 队列 是一种典型的 先进后出 FIFO 的容器，即：从容器的一端放入，从容器的另一端取出，事物放入的顺序和取出的顺序是相同的。 队列 常被当做一种可靠的将对象从程序某的个区域 传输 到另一个区域的 途径，这一点在 并发编程 中特别重要。 实现：Deque接口 ：双端队列 Deque接口 中的每个操作都有 2种 方法，一种在 异常情况 下直接抛出异常奔溃，另一种则 不会抛异常，而是返回特殊的值，比如 false, null 既能作为 队列，实现 先进先出（FIFO）； 添加 元素是添加到 队尾，删除 时删除的是 头部 元素。 对应元素 添加、删除、获取元素 方法为： 也能作为 栈，实现 后进先出（LIFO） 这时 入栈、出栈 元素都是在双端队列的 头部 进行 对应的元素 压栈、出栈、获取元素 方法为： VectorVector是同步的，如果设计涉及到多线程，还是用Vector比较好一些。 SetSet 最常被使用的 测试归属性，可以很容易的查询某个对象是否在 Set 集合中。因此：查找 就成为了 Set 中最为重要的操作。 所有 Set子类 的 相同点： 不支持添加重复对象所有 Set子类 的 不同点： 顺序 HashSet：无序。是 最快的 获取元素方式，使用 散列函数 的存储方式。—— 快 TreeSet ：按照 比较结果的升序 保存元素，使用 红-黑树数据结构。—— 有序 LinkedHashSet：按照 被添加 的顺序保存元素。使用 散列函数 存储。—— 有序 HashSet对速度进行了优化。底层数据结构是 哈希表，覆盖 equals() 的同时 覆盖 hashCode()。 是 最快的 获取元素方式，使用 散列函数 的存储方式。 TreeSet底层数据结构是 二叉树。元素必须实现 Comparable接口。 有序存储： 按照比较结果的 升序 保存元素，使用 红-黑树数据结构。 LinkedHashSet底层数据结构是 链表（维护插入的次序） 和 哈希表，覆盖 equals() 的同时 覆盖 hashCode()。 按照 被添加 的顺序保存元素，使用 散列函数 存储。 Map将 对象 映射 到 其他对象 的能力是一种解决编程问题的杀手锏。 一组 成对 的 键值对 对象，允许使用键来查找值。 各个实现类的特点： HashMap：最快 的查找技术，无明显顺序。—— 快 TreeMap：按照 比较结果的升序 保存键。—— 有序 LinkedHashMap：按照 插入顺序 保存键，同时保留了 HashMap 的查询速度。 —— 有序、快 HashMap 参考:https://www.cnblogs.com/chengxiao/p/6059914.html 最快 的查找技术，无明显顺序。 HashMap的工作原理 参考：http://www.importnew.com/7099.html 原理 HashMap 是基于 散列（hashing） 原理。 通过 put() 和 get() 存储和获取对象。当将 键值对 传递给 put() 方法时，它是调用 键对象 的 hashCode() 方法来计算 hasdCode，然后找到 bucket 位置来存储 键对象 和 值对象。当获取对象时，通过 键对象 的 equals() 找到正确的 键值对，然后返回 值对象。 碰撞问题 当 2个对象的hashCode 相同时，所以他们的 bucket 位置也相同，但是他们可能并不相同，此时碰撞 就会发生。 HashMap 通过使用 链表 来解决 碰撞问题。当发生 碰撞 时，对象会存储在 链表的下一个节点中，在每个 链表节点 中存放的是 键值对对象（包含有键值对的Map.Entry对象）。 如果 2个键对象的hashCode相同，如何获取值对象。（1）调用 get() 方法，HashMap 会使用 键对象 的 hashCode 找到 bucket 位置，然后获取对象；（2）如果有 2个值对象同时存储在1个bucket 中，通过 遍历链表 直到找到值对象：找到 bucket 位置后，回调用 keys.equals() 找到链表中正确的接节点，最终找到要找的值对象。 对象与 hashCode 的关系 如果 两个对象相等(equal)，那么他们 一定有相同的哈希值。 如果 两个对象的哈希值相同 ，但他们 未必相等(equal) —— 碰撞问题。 负载因子（load factor），容量 rehashing过程 ： 默认的负载因子大小为 0.75，当一个 map 填满了 75% 的 bucket 时，和其他集合类（如ArrayList）一样，将会创建原来 HashMap 容量 2倍 的 bucket数组，会重新调整 map大小，并将原对象放入新的 bucket数组 中。 为什么 类似 String、Integer这样的wrapper (final)类适合作为键 因为 String 以及其他的 wrapper 类，是 final 定义的，不可变的，是重写了 equals() 和 hasCode() 方法的。 不可变性 是必要的，因为为了要计算 hashCode() ，就要防止 键值 改变，如果 键值 在放入和获取时不同的话，就不能获取想要的 值对象。 因为 键值 不可变性 的必要，会减小 碰撞的几率 的发生，这样能提高 HashMap 的效率。 满足作为 键 的条件 可以使用任何遵守 equals() 和 hashCode() 的对象作为键。 源码中部分方法的实现 参考：https://blog.csdn.net/ymrfzr/article/details/51244052 具体放入键值对 的 put() 方法 123456/** * 将指定关键字和指定value关联在一起*/public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 计算key.hashCode（）并将散列（XOR）更高的散列位降低。 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; table 变量：表格首次使用时初始化，并根据需要调整大小。 分配时，长度始终是2的幂。 1transient Node&lt;K, V&gt;[] table; 具体执行 put 操作的 putVal() 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果table数组尚未创建（第一次调用put），则新建table数组 if ((tab = table) == null || (n = tab.length) == 0) // resize() 初始化或加倍表格大小。 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // table[i]中没有结点则创建新节点 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果p=table[i]的关键字与给定关键字key相同，则替换旧值 e = p; // 如果结点类型是TreeNode，则向红黑树中插入新节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 遍历链表，查找给定关键字 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 如果没有找到，则创建新节点 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 创建新节点后若超出树形化阈值，则转换为树形存储 treeifyBin(tab, hash); break; &#125; // 如果找到关键字相同的结点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e不为空，即map中存在要添加的关键字 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //修改map结构的操作数加1 ++modCount; if (++size &gt; threshold) //如果超出重构阈值，需要重新分配空间 resize(); afterNodeInsertion(evict); return null;&#125; put() 方法中使用到的 HashMap.Node&lt;K,V&gt;：基本哈希bin节点，用于大多数条目。 它是 Map.Entry&lt;K,V&gt; 接口的实现。Node&lt;K,V&gt; 的子类有：LinkedHashMap.LinkedHashMapEntry&lt;K,V&gt;，(红黑树形容器)TreeNode&lt;K,V&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 不可变的哈希值————由关键字key得来 final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; // 执行 异或运算，得到一个新的 hashCode return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 对象相同或同类型且key-value均相同，则返回true public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; TreeMap按照 比较结果的升序 保存键。 LinkedHashMap按照 插入顺序 保存键，同时保留了 HashMap 的查询速度。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM理解-并发]]></title>
    <url>%2FJVM%E7%90%86%E8%A7%A3-%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[JVM理解 —— 线程资源同步和线程之间的交互机制 Java程序多采用多线程的方式来支撑大量的并发请求处理，程序在多线程方式执行的情况下，复杂程度远高于单线程串行执行的程序。 多线程程序带来的最明显的问题就是 线程之间公共资源的竞争 与 线程之间的交互。 物理计算机的并发 高速缓存(Cache)释义： 由于计算机的存储设备与处理器的 运算速度 有着几个数量级的差距，所以需要加入一层 读写速度尽可能接近处理器运算速度的高速缓存，来作为 内存与操作系统之间的缓冲。 工作过程： 将运算需要的数据复制到缓存中，使得运算快速进行。当运算结束后再从缓存同步回内存中。 缓存一致性高速缓存虽然解决了处理器与内存之间的速度问题，但是也引入了 缓存一致性 的问题。 多处理器系统中，每一个处理器都有自己的高速缓存，但是它们又共享一块主内存，结果就是因为各自缓存的数据不一致，主内存不知该以谁的数据为准。 乱序执行优化除了 高速缓存 之外，为了使得处理器内部的运算单元能尽量被充分的使用，处理器可能会对 输入代码进行 乱序执行优化，。 在执行完计算之后将乱序执行的结果重组，保证 结果 与 代码顺序执行的结果 是 一致 的。但是 不能保证程序中各个语句计算的先后顺序 与 输入代码中的顺序是一致 的。 如果一个计算任务依赖另一个计算任务产生的中间结果，那么其顺序性将不能依靠代码的先后顺序来保证。 Java内存模型Java虚拟机规范中试图通过定义一种 Java内存模型 来 屏蔽 掉各种 硬件 和 操作系统 的 内存访问差异，以实现让 Java程序在各种平台下都能达到一致的运行内存访问结果。 Java内存模型的目标： 1定义程序中各个 变量 的 访问规则。即：在虚拟机中将变量 存储到内存 和 从内存中取出变量 这样的底层实现细节。 此处的 变量 与 Java程序中所指的变量有区别：它包括了 实力字段、静态字段、构成数组对象的元素，不包括局部变量与方法参数（属于线程私有，不会被共享）。 主内存 与 工作内存注意：在此部分中讲到的 主内存、工作内存 与 JVM中内存的划分不在一个层次上，两者基本没有关系。 各个内存中数据的处理主内存Java内存模型规定 所有变量 均存在于 主内存 Main Memory（可类比 物理计算机中的 主内存，但是此处仅是虚拟机内存的一部分） 中。 线程工作内存 每条线程还有自己的 工作内存 Work Memory（可类比物理计算机中的 高速缓存） 。 线程的工作内存中保存了 被该线程使用到的变量在主内存中的拷贝副本。 线程对该变量的所有操作都必须在 工作内存 中进行，而不能直接读写主内存中的变量。 不同的线程也无法 直接访问 其他线程中工作内存的变量。 线程间变量 值的传递 均需要通过 主内存 来完成。 内存间的交互操作8中操作主内存与工作内存间的具体交互，即：一个变量如何从主内存被拷贝到工作内存，又如何从工作内存被同步至主内存，是通过一下 8种 操作来完成的，虚拟机实现时必须保证下面提及的每一种操作都是 原子性、不可再分的。 lock（锁定） 作用于 主内存 中的变量； 把一个变量表示为 线程私有独占状态。 unlock（解锁） 作用于 主内存 中的变量； 把一个处于 锁定 状态的变量释放出来，然后此变量才能被其他线程锁定。 read（读取） 作用于 主内存 中的变量； 把一个 变量的值从主内存传递至线程的工作内存中，方便 load 动作的使用。 load（载入） 作用于 工作内存 中的变量； 把 read 操作中得到的变量值放入到 工作内存 的变量副本中。 use（使用） 作用于 工作内存 中的变量； 把工作内存中得到的变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时，将会执行这个操作。 assign（赋值） 作用于 工作内存 中的变量； 把一个从执行引擎接收到的值赋给工作内存中的变量。每当虚拟机遇到一个给变量赋值的字节码指令时，就执行该操作。 store（存储） 作用于 工作内存 中的变量； 把工作内存中一个变量的值传送到主内存中，以便 write 操作。 write（写入） 作用于 主内存 中的变量； 将从 store 操作中得到的变量的值赋给 主内存中 的变量。 变量的在内存间的移动一个变量从主内存复制到工作内存，需要顺序执行： 1read、load 把变量从工作区同步至主内存，需要顺序执行： 1store、write Volatile型变量的特殊规则1是 Java虚拟机 提供的 轻量级 同步机制 特性当一个变量被定义为 volatile 时，此变量将会具备2种特性： 可见性 禁止 指令重排序优化 Java内存模型中对volatile定义的规则 假定有1个线程：T，2个volatile变量：V、W，那么在进行read、load、use、assign、store、write操作时应满足如下规则： 规则1 - 刷新123只有当线程T对变量V的前一个动作是 `load` 时，线程T才能对变量V执行`use`动作；并且，只有当线程T对变量V执行的后一个动作是 `use` 时，线程T才能对变量V执行 `load` 操作。线程T对变量V的`use` 操作可以认为是和线程T对变量V的`load`与`read`操作相关联，必须连续一起出现。 此规则要求在工作内存中，每次使用变量V前都必须先从主内存刷新变量的最新值，用于保证当前线程能看到其他线程对变量V的值所做的修改 规则2 - 同步123只有当线程T对变量V的前一个动作是 `assign` 时，线程T才能对变量V执行`store`动作；并且，只有当线程T对变量V执行的后一个动作是 `store` 时，线程T才能对变量V执行 `assign` 操作。线程T对变量V的`assign` 操作可以认为是和线程T对变量V的`store`与`write`操作相关联，必须连续一起出现。 此规则要求在工作内存中，每次 修改 变量V的值后都必须立刻同步回主内存中，用于保证其他线程能看到自己对变量V的值所做的修改 规则3 - 禁止指令重排序12345假定动作A是线程T对变量V实施的`use`或`assign`操作，动作F是和动作A相关联的`load`或者`store`操作，动作P是和动作F相关联的`read`或者`write`操作；类似的：假定动作B是线程T对变量W实施的`use`或`assign`操作，动作G是和动作B相关联的`load`或者`store`操作，动作Q是和动作G相关联的`read`或者`write`操作；如果：A先于，那么 P先于Q。 此规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同 volatile - 可见性可见性定义： 当一个线程对一个变量的值进行修改之后，此变量的 新值 对于 其他线程 而言是可以 立即得知 的。 工作内存非一致性volatile变量在各个线程的工作内存中 不存在 一致性的问题。 在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但是由于线程在每次使用变量值的时候 都需要先刷新，因此导致执行引擎看不到不一致的情况。 volatile变量并发安全问题volatile变量时原子性的，但是Java的运算却并非是原子性操作，导致 volatile变量的运算在并发下一样是不安全的。 满足以下2种条件时，可以使用volatile关键字 运算结果不依赖其他其他变量的当前值，或者能够确保只有单一线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束 若是不能满足以上2点，则必须使用 synchronized 关键字来保持 原子性。 volatile - 禁止指令重排序优化Java内存模型3个特征 原子性 可见性 有序性 原子性 由Java的内存模型来直接保证原子性变量的操作包括6种操作。可以大致认为基本数据类型的访问、读写是具备原子性的。 如果 需要有一个范围更大的原子性保证，则可以使用 synchronized 关键字。synchronized 块之间的操作也具备有原子性。 可见性可见性是指： 1当一个线程修改了一个变量的值，那么其他线程能够立即得知这个改变。 Java内存模型是通过在变量的值修改后将新值同步回主内存，在变量读取前，从主内存刷新变量的值。 1本质是通过依赖主内存作为传递媒介来实现可见性的。 synchronized 与 final 关键字也可以实现可见性。 synchronized 关键字是因为规则： 1对一个变量执行 unlock 操作前，必须把此变量先同步回主内存中（执行store、write操作）。 有序性Java语言中天然的有序性可以总结为： 如果在本线程中观察，所有的操作均是有序的（线程内部表现为串行的语义）； 如果在一个线程中观察另个一线程，所有的操作均是无序的（指令重排序+工作内存与主内存同步延迟）。 通过使用 volatile 与 synchronized 关键字实现有序性。 volatile 关键字本身禁止指令重排序优化 synchronized 则是通过规则： 1一个变量在同一时刻只允许一个线程对其进行 `lock` 操作。 先行发生原则 此原则是判断：数据是否存在竞争、线程是否安全 的主要依据。 先行发生指的是：两项操作之间的偏序关系。 Java内存模型中“天然”的 8种先行发生原则 程序次序规则：一个线程内按照 控制流顺序执行 传递性：例如：A先于B，B先于C，则A先于C。 对象终结规则：一个对象的初始化先于它的终结。 volatile变量规则 线程启动规则：Thread 对象的start先行于后面的每一个操作 线程中断规则：对线程 interrupt() 的调用先行发生于 检测方法的调用。 线程终止规则：线程中的所有操作都先行于线程的终结检测。 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作，必须是同一个锁。 线程交互机制线程之间除了会有资源竞争之外，还会有交互的需求。典型例子：生产者 - 消费者 常用方式：wait()、notify()、notifyAll()。 notify() 与 notifyAll() 的区别： notify() 只是随机找 wait() 此Object的一个线程 wait() 方法有可能被 假唤醒，因此通过在 Object.wait 被唤醒后，应该 再次确认 需要等待的 状态是否改变 了。例如： 12345while (!task.isFinished()) &#123; synchronized (task)&#123; task.wait(); &#125;&#125; notifyAll() 是通知 wait() 此Object的所有线程 线程状态及解析描述 线程的状态 是用一个 枚举类型 来描述的，严格来讲一个线程有 6种状态 ，分别是 6个枚举值： NEW： 尚未开始的线程处于此状态 RUNNABLE：在Java虚拟机中 执行的线程 处于此状态 BLOCKED：` 等待监视器锁定的 阻塞 线程状态 TIMED_WAITING： 正在等待另一个线程执行某个动作达到 指定等待时间 的线程处于此状态 WAITING： 无限期 等待另一个线程执行特定操作的线程处于此状态 TERMINATED： 已 退出 的线程处于此状态 只不过人们平时理解的时候经常会增加阻塞状态，可运行状态，还有挂起状态。 参考：https://www.cnblogs.com/kevin-yuan/p/4112434.htmlhttps://www.cnblogs.com/trust-freedom/p/6606594.htmlhttp://www.cnblogs.com/ELMND/p/4737580.html 虚拟机在并发运行时数据区域的情况（图片来自网络）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM理解-内存管理]]></title>
    <url>%2FJVM%E7%90%86%E8%A7%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[JVM理解 —— 内存管理 Java不是由开发人员来显示分配内存和回收内存，而是由JVM来 自动管理内存的分配和回收（又称为：垃圾回收、Garbage Collection：GC）。这降低了开发的难度，但是实际使用中遇到的问题就是由于不清楚JVM的 内存分配 和 回收机制，造成内存泄漏，最终导致JVM内存不够用。 内存空间JDK遵照 JVM规范进行内存区域的划分，如下： 程序计数器 Java虚拟机栈 本地方法栈 方法区 堆 程序计数器数据活动范围： 当前线程私有 说明： 占用一块较小的内存空间。 可以看做是当前线程所执行的字节码的行号指示器。 抛出异常： 无 Java虚拟机栈数据活动范围： 当前线程私有；生命周期与线程相同 说明： Java方法执行的内存模型：每个方法在执行的同时创建一个栈帧（Stack Frame），用以存储： 局部变量表 操作数栈 动态连接 返回方法地址 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中执行 入栈 到 出栈 的过程。 抛出异常： 线程请求的栈深度大于虚拟机所允许的深度，抛出：StackOverflowError。 无法申请到足够内存时，抛出：OutOfMemoryError。 本地方法栈数据活动范围： 当前线程私有 说明： 与 虚拟机栈发挥的作用类似，不同点： 虚拟机栈为虚拟机执行Java方法（字节码）服务 本地方法栈为虚拟机执行的 Native方法服务 抛出异常： StackOverflowError。 OutOfMemoryError。 方法区数据活动范围： 所有线程公有 说明： 存储已被 虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。 永久代 运行时常量池，存放编译期生成的各种 字面量 符号引用 直接引用 具有动态性（相对于常量池） 抛出异常： OutOfMemoryError。 堆数据活动范围： 所有线程公有 说明： 是Java虚拟机所管理的内存中最大的一块， 唯一目的：存放所有对象实例、数组 是垃圾收集器管理的主要区域，实行：分代收集算法（JDK 1.2开始）： 新生代：Eden Space，Survivor Space（From Space）+ Survivor Space (To Space)（From:To = 1:1） 旧生代（新:旧 = 1:2） TLAB(Thread Local Allocation Buffer) 线程私有缓冲区 抛出异常： OutOfMemoryError。 新生代（New Generation）新生代内存由： Eden Space 2块相同大小的 Survivor Space 构成，也被称为：From Space 和 To Space。 Eden Space 与 From Space 与 To Space 所占新生代内存空间的比值= 8:1:1 新建对象只会存在于 Eden Space 和 From Space 中， To Space 是空的 —— 此种分配方式与 复制回收算法 有关。 不同的GC方式会以不同的方式来划分或者根据运行状态调整 Eden Space 和 Survivor Space 的大小。 大多数情况下Java程序中所有新建的对象都是从 新生代 的内存中分配的，当 Eden Space 不足时，会把存活对象转移动 Survivor Space 中。 新创建的对象一般情况下都会分配到 Eden Space 中（大对象、大数组分配到 旧生代 中），当对象经过第一次 Minor GC 后（对象年龄+1），如果仍然存活则将存活对象移动至 Survivor Space 中，当对象的年龄达到一定的岁数时，将被移动至 旧生代 中。 为什么 新生代中会有 Survivor Space？ 如果没有 Survivor Space ， Eden Space 中每进行一次 Minor GC后，存活的对象就会被送到 旧生代 中，这样就会导致 旧生代 很快被填满，发生 Major GC或 Full GC。 但由于 旧生代 内存空间远大于 新生代 空间，所以进行一次 Full GC 会消耗大量的时间。而且若是在无 Survivor Space的情况下，旧生代 被填满的速度大大加快，结果就是导致 频繁 的发生 Full GC，这将会影响程序的执行和响应速度，更有甚至会因为 超时 产生其他问题。 在无 Survivor Space 的情况下，如何解决？ |方案 |优点 |缺点||:-:|:-:|:-:|增加老年代空间 |更多存活对象才能填满老年代。降低Full GC频率 |随着老年代空间加大，一旦发生Full GC，执行所需要的时间更长减少老年代空间 |Full GC所需时间减少 |老年代很快被存活对象填满，Full GC频率增加 上述两种解决方案都不能从根本上解决问题。 结论一： Survivor Space 存在的意义就是 减少被移动至 旧生代 中的对象，进而减少 Full GC 发生。 为什么 Survivor Space 会有 From Space 与 To Space 2块空间？由上文已经说明了为什么没有 Survivor Space 不行，这次假设只有 1块 Survivor Space。 当只有 1块 Survivor Space 时，新建对象填满了 Eden Space ，此时就会触发 Minor GC ，然后 Eden Space 中的存活对象被复制至 Survivor Space 中。 这样的操作一直循环下去，虽然存活对象得到了转移，但是这2个区域中对象所占用的内存地址并不是连续的，这就导致了在只有 1块Survivor Space 的条件下产生的问题： 1内存地址碎片化 内存地址碎片化导致的问题就是： 严重影响Java程序的性能，堆空间中被散布的对象占据着不连续的内存，最直接的结果就是：没有足够大的连续空间。 建立 2块Survivor Space 的意义当建立 2块Survivor Space 时： 对已满的 Eden Space 进行 Minor GC 时，存活对象就会被复制至 From Space 中，Eden Space 被清空。 当对已满的 Eden Space 再次进行 Minor GC 时，再次执行 Minor GC，Eden Space 和 From Space 中的存活对象将被复制至 To Space 中（ ==这种 复制算法 保证了 To Space 中来自 Eden 和 From Space 2部分中存活对象所占用的内存空间地址是连续的，避免了碎片化的产生 == ）。 之后对 Eden Space 和 From Space 内存空间进行清空，将 From Space 和 To Space 进行交换即：将 To Space 中存活的对象复制至 From Space 中，保证 To Space 是空的。 所以，建立 2块Survivor Space 的意义就是： 1永远有一个 Survivor Space 是空的，另一个非空的 Survivor Space 无碎片。 参考：https://blog.csdn.net/u012799221/article/details/73180509 旧生代（Old Generation/Tenuring Generation） 是用于存放 新生代 内存中经过多次垃圾回收后仍然存活的对象，例如 缓存对象。 新建的对象也有可能在 旧生代 中直接分配内存。主要由2种情况决定： 新建对象为大对象 新建对象为大数组对象，且数组中无引用外部对象 内存分配1. 堆分配Java对象所占用的内存主要是从 堆 上进行分配，堆 是 所有线程共享 的，因此在堆上分配内存时是 需要加锁 的。这导致了创建对象开销比较大。当 堆 上的内存空间不足时，会触发 GC ，如过 GC 后内存空间仍然不足，则抛出 OOM。 2. TLAB（Thread Local Allocation Buffer）分配 JDK 为了提升内存分配效率，会为 每个新创建的线程 在 新生代的 Eden Space 上分配一块独立空间。这块空间称为 TLAB（Thread Local Allocation Buffer），其大小是由JVM根据运行情况而得出的。 在 TLAB 中分配内存是 不需要加锁 的，因此JVM在给线程中的对象分配内存时会尽量在 TLAB 上分配。如果对象过大或者 TLAB 空间已经用完了，则仍然在 堆 上分配内存 因此在编写Java程序时，通常多个 小的对象比大的对象在内存分配上 更高效。 内存回收JVM 通过 GC 来回收 堆 和 栈 中的内存。 **GC 的基本原理是**： 首先找到程序中不在被使用的对象 然后回收这些对象所占用的内存 GC 分类： Java 中的堆也是 GC 收集垃圾的主要区域。 Minor GC - 新生代 - 复制算法 Full GC（又称 Major GC）- 旧生代 - 标记-清除算法 Minor GC堆 中 新生代 中对象的生命周期（80%）一般为 朝生夕死。所以在 新生代 中使用的垃圾回收算法是 复制算发。 在GC开始前，对象只会存在于 Eden Space 和 From Space 区，此时 To Space 是空的。 当GC运行时，Eden Space 中存活的对象被复制到 To Space 中；同时 From Space 中的对象根据其年龄值（年龄阈值可以通过-XX:MaxTenuringThreshold来设置）来决定去向： 到达一定值，则对象将移动至 旧生代 ； 未达到一定值，则对象被复制到 To Space 中。 之后 Eden Space 和 From Space 区域已经被清空，此时，将 From Space 和 To Space 的角色进行交换（保证命名为 To Space 是空的）。 Minor GC 会一直重复这样的过程，直到 To Space 被填满，将所有对象移动至 旧生代 中。 Major GC Major GC 是发生在 旧生代 的垃圾收集动作，所采用的是 标记-清除 算法。 旧生代 中的对象有部分是从 新生代 中移动过来的。所以不会轻易被回收掉，因此 Major GC 不会像 Minor GC 那样发生的频繁，并且做一次 Major GC 要比 Minor GC 消耗的时间长。 由于使用 标记-清除 算法时，会导致产生内存碎片（即：不连续的内存空间），当此后要为较大的对象分配内存空间且没有较大内存空间时，会提前触发一次GC操作。 回收算法 引用计数 收集器 跟踪 收集器 引用计数 收集器 引用计数 收集器采用的是 分散式 的管理方式，通过 计数器 记录是否对 对象进行引用。当 一个对象的引用计数器为0 时，说明此对象已经不在被使用，于是进行回收。 不足 引用计数器 需要在每次对对象赋值时进行 计数器的增减，它有一定的消耗。 引用计数器 对于 循环引用 的场景是 无法实现回收 的。如：对象B 和 对象C 互相引用时， 对于Java这种面向对象的会形成复杂引用关系的语言而言，引用计数器 是非常不合适的，在 JDK 的 GC 实现中 未采用 此种方式。 跟踪 收集器跟踪收集器采用的是 集中式 管理方式。全局记录 数据的 引用状态。 基于一定条件（定时、空间不足时）的触发 ，使用跟踪收集器，执行时需要从 根集合 来扫描 对象的引用关系 ，这可能会造成 应用程序暂停。 实现算法有3种： 复制（Copying） 标记-删除（Mark-Sweep） 标记-压缩（Mark-Compact） 复制（Copying）复制采用的方式是： 从 根集合 扫描出 存活的对象， 将 找到的存活对象 复制到 一块新的完全未使用的空间中 复制特点： 当要回收的空间中 存活的对象较少时，复制算法会比较高效，但是其带来的成本是：要 增加一块 全新的内存空间 及进行 对象 的 移动 标记-清除（Mark-Sweep）此种方式采用的是方式： 从 根集合 开始扫描， 对 存活对象进行标记 标记完成之后，再次扫描 整个空间中 未标记的对象，并对其进行回收。 标记-清除 特点： 此种方式 不需要进行对象的移动， 仅对 不存活的对象 进行清除。因此在空间中 存活对象较多 的情况下，较为高效。 由于此方式采用的是 直接回收不存活对象所占用的内存空间，因此会造成 内存碎片。 标记-压缩（Mark-Compact） 此种方式采用和 标记-清除 一样的方式对 存活对象进行标记 在 回收不存活对象所占用的内存空间 后，会将 其他所有存活的对象 都往 左端空闲的空间进行移动，并 更新引用其对象的指针。 标记-压缩 特点： 需要 对存活对象进行移动，成本相对较高 不产生碎片]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM理解-编译加载]]></title>
    <url>%2FJVM%E7%90%86%E8%A7%A3-%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[JVM理解 —— Java代码执行 Android 的 Dalvik VM 是Android平台的核心组件平台之一，其并不是一个 Java虚拟机： 没有遵循Java虚拟机规范； 不能直接执行Java的Class文件； 使用的是 寄存器架构 而不是JVM中常见的 栈架构； Android与Java联系： 执行的 dex（Dalvik Executable）文件 是通过 Class文件 转化而来； 使用Java语法编写应用程序，可直接使用大部分Java API。 JDK 与 JRE Java源码编译实质 .java文件 -&gt; .class文件，使用 Javac 编译器。 Java源码编译过程3个步骤 解析与填充符号表 注解处理 分析与字节码生成 编译过程的方法 1. 解析与填充符号表1.1 解析（parseFiles()） 词法： 将 源代码 的 字节流 转换为 标记（Token）集合。 单个字符 是程序编写过程中的最小元素，而 标记 则是编译过程中的最小元素。 使用 com.sun.tools.javac.parser.Scanner 类实现。 语法： 是根据 标记序列 构造抽象语法树 的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式。 使用 com.sun.tools.javac.parser.Parser 类实现。 注意：生成抽象语法树后，后续的操作均是基于 抽象语法树 的操作。 1.2 填充符号表（enterTrees()） 符号表 是由一组 符号地址+符号信息 构成的表格。 符号表 中所登记的信息在 编译 的不同阶段都要使用到。 使用 com.sun.tools.javac.comp.Enter 类实现。 默认实例构造器 在此过程中被添加。 2. 注解处理（processAnnotations()） JDK 1.5 后，新增功能。 作用时间：运行期 作用：类似一组编译器插件，通过插件可以：读取、修改、添加 抽象语法树 中的任意元素。 只要修改了 抽象语法树 后，编译器就要从 解析与填充符号表 重新开始。 3. 语义分析和生成class文件（Analyse and Generate）语义分析 因为抽象语法树 仅能保证 源程序的 结构正确 ，不能保证 源程序的语句 符合逻辑。 标注检查 变量相关检查 常量折叠 数据、控制流分析 对程序的上下文进行进一步验证 解语法糖 语法糖：也叫糖衣语法。指在计算机语言中添加某种语法，对语言功能本身没有影响，为的是方便程序员使用 意义：增加程序可读性，降低程序的出错可能性。 解语法糖：虚拟机在执行时不支持处理语法糖语句，所以需要在编译阶段将其还原回最基础的语法结构。 生成字节码文件 Java语法糖类型1：泛型与类型擦除泛型（JDK 1.5 新增）其本质是 参数化类型的应用，操作的数据被指定为一个参数。 特点： Java中的泛型，只在源码中存在，在编译后的 字节码文件中 ，已经替换为原来的原生类型，并且在相应的位置插入强制转型代码。 例如：对于运行期的 ArrayList&lt;int&gt; 与 ArrayList&lt;String&gt; 是同一个类 List&lt;E&gt; Java中的泛型实现方法为 类型擦除。 当泛型作为 重载方法 的参数时，是无法被编译通过的，若是在方法中使用不同的返回值，则编译通过。 类型2：自动装箱、拆箱、遍历循环List 类型3：条件编译在Java中通过使用条件为 常量 if语句，即可实现条件编译。条件为 常量 的if语句不同于其他Java代码，他在编译阶段就会被 运行。仅运行条件成立下的语句，而条件不成立的代码块将会被消除，这个过程是在 分析与生成class文件 阶段完成的。 class文件描述 《Java虚拟机规范》：在未来，我们会对Java虚拟机做适当的扩展，以便更好的支持其他语言运行在JVM上（JDK1.7-1.8通过）。 字节码（*.class文件） 是构成 平台无关性 + 语言无关性 的基石。 正因为 字节码 是现实 语言无关性 的基石，所以 字节码 命令提供的语义描述能力、范围要大于Java语言本身。 class文件结构 class文件是一组以 8位字节为基础单位 的 二进制流，各个数据项目严格按照 顺序紧凑 的排列在 class文件 之中，中间没有添加任何 分隔符。 若遇到占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。 class文件一般采用类似于 C 语言结构体系的 伪结构 来存储数据，伪结构只有2种数据类型： 无符号数： 其属于基本的数据类型，可以用来描述数字、索引引用、数量值或其他。 表： 是由多个 无符号数 或者 其他表 作为数据项构成 复合的数据。所有表都以习惯性的 _info 结尾。表 用于描述 有层次关系 的 复合结构* 的数据。 无论是 无符号数 还是 表，当需要描述同一类型但数量不定的多个数据时，经常使用一个前置的 容量计数器 + 若干个连续的数据项的形式，这样的形式称为 某一类型的集合。 魔数- 确定class文件版本magic 的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件。 紧接着就是 minor_version(此版本号)、 major_version（主版本号） 常量池 常量池 可以理解为 class文件的资源仓库。 是与其他项目 关联最多 的数据类型，也是class文件中占用空间最大的数据项目之一。同时是class文件中第一个出现表类型的数据项目。 常量池每一个常量都是一个表 存放2大类常量： 字面量 符号引用 字面量 接近于Java语言中的 常量 概念。 符号引用属于编译原理方面的概念，包括以下3类： 类和接口的全限定名：路径 字段的名称和描述符：字段 描述符用来描述：字段的 数据类型、修饰符 方法的名称和描述符： 描述符是用来描述：方法的 参数列表（数量、类型、顺序）和返回值 注意：要区分 字节码中的描述规则 与 Java代码中的声明规则不同。 访问标志 - 确定类定义信息访问标志（access_flags），作用：识别一些类或者接口层次的 访问信息。 通俗的说就是和 类定义相关 的描述，例如：是类还是接口、是否为public、是否为 abstract等。 类索引、父类索引与接口索引集合 - 确定类继承关系 类索引、父类索引是一个u2类型的数据，而接口索引集合是一组 u2类型的数据的集合（Java不支持多继承，但是支持多实现）。 class文件中由这3项数据来确定这个类的继承关系 字段表集合 - 确定变量 用于描述接口或者类中声明的变量。 包含 类级变量 以及 实例级变量。 不包含在 方法内部声明的局部变量 方法表集合 方法中的 Java代码 在经过编译之后，存放在方法属性表集合中一个名为 Code 的属性中。 在 Java语言中，要重载一个方法，除了要与原方法具有相同的名称之外，还要求必须拥有一个与原方法不同的 特征签名。 特征签名：就是一个方法中 各个参数 在 常量池 中的 字段符号引用 的 集合，因为 返回值 不会包括在 特征签名 中，因此Java语言中无法根据返回对方法进行重载。 区别：因为 class文件中特征签名范围更广，只要描述符不一致，即可以重载。 属性表集合字节码指令Java虚拟机的解释器使用以下最为基本的伪模型： 123456do&#123; 自动计算 PC寄存器值 +1； 根据 PC寄存器指示的位置，从字节码流中取出操作码； if(字节码存在操作数) 从字节码中取出操作数； 执行操作码定义的操作；&#125;while(字节码流 &gt; 0) JVM执行类加载过程一个类的加载过程概括性的可分为 3个阶段： 1加载、连接、初始化 如果具体细分则为 7个过程： 1加载、验证、准备、解析、初始化、使用、卸载 类的生命周期图， 其中，有 5个阶段 是 必须要按顺序 执行的： 1加载 、验证、准备、初始化、卸载 加载 - 开发人员可介入（类加载器）虚拟机的非数组类加载操作 通过一个类的 全限定名 来获取定义此类的 二进制字节流。 将这个字节流所代表的 静态存储结构 转换为 方法区 的运行时数据结构。 在内存区生成一个 代表这个类的对象，作为方法区这个类的各种数据的 访问入口。 二进制字节流的获取途径 zip包中，例如 jar。 从网络中获取 运行时动态生成，反射。 有其他文件生成，例如 jsp 从数据库中读取。 虚拟机对于数组的创建 如果数组的组件类型是 引用类型 （例如Personp[]），那么递归采用定义的加载过程去加载，数组将在 加载该组件的类加载器 的 类名空间上被标示。 如果数组的组件类型不是引用类型（例如int[]）, Java虚拟机将会把数组标记为与 引导类加载器 关联。 数组可见性与其组件可见性一致，且数组组件不是引用类型，那么数据可见性默认为 public。 验证验证是 连接 的第一个阶段。验证目的：是为了确保 class文件 的字节流中 符合 class文件格式约束 且 包含的信息是符合当前虚拟机的要求 的，并且不会危害到虚拟机的自身安全。 验证过程分为4个阶段: 文件格式验证 该阶段的主要目的是：保证输入的字节流 能正确的解析并存储于方法区之中。 此阶段的验证是基于 二进制字节流 的，只有通过此阶段的验证，字节流才会进入内存的方法区进行存储。 因此，后面3个阶段的验证都是基于 方法区的存储结构 进行验证的。 元数据验证 对字节码描述的信息进行 语义分析、校验，保证其描述的信息 符合Java语言规范的要求。 此阶段对 类的元数据信息 进行校验。 字节码验证 此过程是验证过程最为复杂的阶段，在第二步对类的元数据信息校验结束后，通过 数据流 和 控制流分析，确定程序 语义是合法的、是符合逻辑的。 此阶段对 类的方法体 进行校验。 符号引用验证 此阶段是发生在虚拟机将 符号引用 转换为 直接引用 的时候，这个转换动作是发生在 解析 阶段中。 符号引用校验 是对 类自身以外（常量池中的各种符号引用）的信息 进行匹配校验 的过程。 符号引用验证的目的是 确保解析动作的正常执行 准备 - 类变量赋初值此阶段是正式为 类变量 分配内存 并 设置其初始值（零值） 的过程。这些变量所使用的内存是在 方法区的内存 中分配的。 解析是虚拟机将常量池中的 符号引用 抓换为 直接引用 的过程。 符号引用 与 直接引用区别符号引用 通过一组符号来描述所引用的目标。 符号引用于 虚拟机实现的内存布局无关 直接引用 直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。 直接引用与虚拟机实现的内存布局有关。 解析动作 类或接口 字段 类方法 接口方法 初始化 初始化 是类加载过程的最后一步，在此阶段才开始执行类中定义的 Java程序代码（字节码）。 此阶段是执行 类构造器&lt;clinit&gt;() 方法的过程。 &lt;clinit&gt;()解释 方法中的内容来源 — &lt;clinit&gt;() 是由 编译器 自动收集类中的 所有类变量的赋值动作 和 静态语句块（static{}）中的语句 合并产生的。 父类子类顺序 — &lt;clinit&gt;() 与类的构造函数（或者说是实例构造器&lt;init&gt;()）不同，它不需要显示调用父类构造器，虚拟机会保证在 子类的&lt;clinit&gt;() 调用之前 父类&lt;clinit&gt;() 已经执行完毕。 赋值先后顺序 — 由于父类与子类的 &lt;clinit&gt;() 执行顺序，父类中的静态语句块要优于子类变量的赋值。 必要性 — &lt;clinit&gt;() 对于类或接口而言是非必须的。 （父）接口的&lt;clinit&gt;()— 接口中不能使用静态语句块，但是接口中仍然有变量初始化赋值操作。因此接口与类都具有 &lt;clinit&gt;() 操作。接口与类不同的是：子接口（实现类）的 &lt;clinit&gt;() 不需要实现 父接口 的 &lt;clinit&gt;() ，只有使用到 父接口中定义的变量时，才会执行。 线程！ — 虚拟机能够保证一个类的 &lt;clinit&gt;() 在 多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只能有一个线程执行这个操作，其他线程都只能阻塞等待。 初始化阶段的触发条件Java虚拟机对于什么时间执行第一个阶段：加载，没有明确要求，但是对于 初始化 阶段则是 有且只有5种 明确要求： 1、遇到 new、getstatic、**putstatic、invokestatic这4个字节指令时，要先进行初始化。这4个指令对应于Java语言中的场景就是： new关键字实例化对象、读取一个静态字段、设置一个静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用类的静态方法** 2、进行 反射调用 的时候，如果没有进行初始化，则先要进行初始化。 3、当初始化一个类的时候，若其 父类 还未进行初始化，则先要对其父类进行初始化。 4、当虚拟机启动时，用户需要指定一个要 执行的主类（包含main()），虚拟机会先初始化这个类。 5、当使用JDK 1.7 的 动态语言支持 时，如果一个 MethodHandler 实例最后的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄时，这个方法对应的类要进行初始化。 类加载器 — 程序员自己决定如何获取所需类类 与 类加载器JVM中类的唯一性确立条件： 1类本身 + 加载它的类加载器 换一种表述方式即为： 123比较2个类是否“相等（equals()/isAssignableFrom()/isInstance()/instanceof关键字）”，只有在这2个类是由同一个类加载器加载的前提下才有意义。否则，若是同一个 class文件被同一个JVM加载，只要是加载这个类的 类加载器不同，那么这两个类必定不同。 加载器分类：从 JVM角度 来看，只存在 2种 不同的加载器： 启动类加载器（Bootstrap CLassLoader），由 C++ 实现，是虚拟机本身的一部分。 所有的其他类加载器，由 Java 实现，独立于虚拟机外部且全部继承自 java.lang.ClassLoader。 ClassLoader继承关系（图片来自网络） 从 开发人员角度 来看，存在 3种 不同的加载器： 启动类加载器 （Bootstrap ClassLoader） 此类使用 C++ 实现，并非CLassLoader的子类，在代码中无法拿到这个对象，没有子类。 JVM启动时， Bootstrap CLassLoader 也会同时跟着启动，完成 $JAVA_HOME/jre/lib/rt.jar 中所有class文件的加载，如java.lang.、 java.uti.等。 负责加载完核心类库后，并构造 Extension ClassLoader 和App ClassLoader 类加载器。 扩展类加载器 （Extension ClassLoader） 开发人员可以直接使用此加载类 加载位于 $JAVA_HOME/jre/lib/ext 目录下的扩展jar。 应用程序加载器（Application ClassLoader） 开发人员可以直接使用此加载类 父类是 Extension ClassLoader，加载 用户类 $CLASSPATH下的目录 和 jar； 它负责加载 应用程序主函数类。 若应用程序中没有自定义类加载器，一般情况下这个就是默认的类加载器。 自定义类加载器 （Custom ClassLoader） 要实现自己的类加载器，不管是实现抽象类ClassLoader，还是继承其他的子ClassLoader类，它的父加载器都是AppClassLoader，因为不管调用哪个父类加载器，创建的对象都必须最终调用getSystemClassLoader()作为父加载器，getSystemClassLoader()方法获取到的正是AppClassLoader。 双亲委派模型 双亲委派模型 要求：除了顶层的 启动类加载器 外，其余的类加载器都应有自己的父类加载器。 这里类加载器的关系不是 父子 而是 组合 关系。 双亲委派模型的工作过程为： 如果一个类加载器收到了类加载请求，他首先不会自己尝试加载这个类，而是把这个请求委派给自己的父类加载器去完成，每一层的类加载器都是如此。 因此所有的加载请求最终都应该传递到顶层的 启动器类加载器 中。 只有当父类加载器反馈自身无法完成这个加载请求时，子类加载器才能完成这个加载请求。 双亲委派模型的作用对Java程序的稳定运作很重要。使用此模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java类 随着 它的类加载器 一起具备了一种 带有优先级的层级关系。 例如 java.lang.Object 类，这个类无论是被那个类加载器加载，最终都是委派给模型最顶端的 启动类加载器，因此Object类在程序的各种类加载环境中 都是同一个类。 ClassLoader抽象类的几个关键方法 loadClass： 此方法是负责加载指定名字的类。加载过程为：先从已加载的类中寻找，如果没有再调用parent的loadClass中寻找，如果还是没有，那么从findBootstrapClassOrNull方法中寻找。如果以上都不行，那么执行findClass方法。 如果要改变类的加载顺序，则可以覆盖此方法； 如果加载顺序相同，则可通过覆盖findClass方法来 做特殊处理。 源代码为： 12345678910111213141516171819202122232425protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; return c;&#125; findLoadedClass 此方法负责从当前 ClassLoader 实例对象的缓存中寻找已存在的类。 findClass findSystemClass defineClass 此方法负责将二进制字节码 转换为 class对象，这个方法对自定义加载类非常重要。 如果二进制的字节码格式不符合JVM Class 文件的格式，抛出ClassFormatError异常 如果生成的类名和二进制字节码中的不同，抛出NoClassDefFoundError 如果加载的 class 是受保护的、采用不同签名的、或者类名是以 java开头的，抛出 SecurityException 如果加载的 class 在此ClassLoader中已经加载，那么抛出LinkageError resolveClass 此方法完成对Class的链接，如果已经链接过，那么直接返回。 当调用Class.forName来获取一个对应名称的class对象时，JVM 会先从方法栈栈上寻找第一个ClassLoader ，通常也就是执行 Class.forName 所在的类的ClassLoader，来加载此名称的类。 JVM为了保护加载、执行类的安全，他不允许ClassLoader直接卸载已加载了的类。只有JVM才能卸载，当CLassLoader对象没有引用时，此 CLassLoader 对象所加载的类才会被卸载。 2. 编译执行解释执行效率低，为提升代码的执行性能，JDK提供了将字节码编译为机器码的支持。JDK 在执行过程中对执行效率高的代码进行编译，对执行不频繁的代码则继续使用解释的方式。因此，JDK 又称为：Hotspot VM，在编译上JDK提供了2种模式： client compiler（-client）：轻量级。只做少量性能开销比高的优化，占用内存少，适合于桌面交互式应用。 在内存器分配策略上，采用线性扫描寄存器分配算法。其他的优化有方法内联、去虚拟化‘、冗余消除`` server compiler（-server）：重量级。采用大量的传统编译优化技巧来进行优化，占用内存多，适合于服务器端使用。与client不同的是： 寄存器分配策略：传统的图着色寄存器分配算法。 优化的范围：全局优化，而不仅仅是一个方法块的优化。 3. 反射执行基于反射可动态调用某对象实例中对应的方法、访问查看对象的属性等，无需在编写代码时就确定要创建的对象。 反射和直接创建对象实例，调用方法最大的不同在于创建的过程、方法的调用是动态的。如何实现动态调用：动态生成字节码、并加载到JVM中执行。 注意： 使用getMethod() 相对比较耗性能，一方面是权限的校验，另一方面是所有方法的扫描机Method对象的复制。因此，在使用反射调用多的系统中，应缓存getMethod()返回的Method对象。 Java对象4种引用强引用： 普遍存在的，类似”Object obj=new Object()”； 只要强引用还在，GC就永远不会回收被引用的对象，即时抛出OOM； 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。 软引用（Soft Reference） 用来描述有用但是非必须的对象； 如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；直到内存空间不够时（抛出OutOfMemoryError之前），才会被垃圾回收； 由 SoftReference类 实现。 12MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 重新获得对该实例的强引用 1MyObject anotherRef=(MyObject)aSoftRef.get(); 而回收之后，调用get()方法就只能得到null了。 软引用可用来实现内存敏感的高速缓存，使用软引用可以可以增强程序的健壮性、能防止内存泄漏。 弱引用（Weak Reference） 用来描述非必须的对象；只能生存到下一次垃圾回收之前，无论内存是否足够；由 WeakReference类 实现； 虚引用（Phantom Reference） 也称为幽灵引用或幻影引用； 完全不会对其生存时间构成影响； “==”运算符 和 “equals()” 方法实质上这两种方法本质上还是有区别的： equals() 方法是从String类中的方法，它用于比较两个 对象引用所指的内容 是否相等； == 运算符比较的是两个 对象引用的地址 是否相等。 参考：http://icyfenix.iteye.com/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程-2 Android]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B-2%20Android%2F</url>
    <content type="text"><![CDATA[线程总结-2 Android Android 线程处理 - AsyncTask描述 AsyncTask 调用、实现了 ThreadPoolExecutor类、Executor接口。并且 子线程 和 UI主线程 之间切换、数据传递还是通过 Handler 和 Message 进行处理的。 AsyncTask支持正确、简单地使用UI线程。这个类允许你在后台执行操作并在UI线程上发布结果，而无需操纵Thread和Handler。 AsyncTask被设计为 Thread 和 Handler 的辅助类，并不构成通用的线程框架。 理想情况下，AsyncTasks应该用于 短操作（最多几秒）。如果需要长时间保持线程稳定，强烈建议使用由 java.util.concurrent提供的各种API，例如 Executor，ThreadPoolExecutor 和 FutureTask。 使用AsyncTask 是一个抽象类，只有被继承之后才能使用。 在 AsyncTask 类的构造方法中，执行了 doInBackground() ，在这个方法中处理传入的参数。将处理后得到的结果传递给 postResult() , 其源代码描述为： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 在这个方法中，通过 getHandler() 获取 Handler 对象，通过 Message 将 当前 AsyncTask 和 result 结果进行封装后发送至 InternalHandler 类中处理。在这个类中，调用了 onProgressUpdate(result.mData) 、 onCancelled(result) 、onPostExecute(result) 异步任务由 3个泛型类型 定义： Params：这是发送给任务的参数的类型 Progress ：后台计算期间发布的进度单位的类型 Result 后台最终计算结果的类型。 如果在实际使用过程中，并没有特定要求3种泛型类型，可以将子类声明为： 1MyTask extends AsyncTask(Void，Void，Void) &#123;...&#125; 执行异步任务时，会经历 4个步骤: onPreExecute()：在任务执行前在UI线程上调用。此步骤通常用于设置任务，例如通过在用户界面中显示进度条。 此方法是在 executeOnExecutor(Executor exec, Params... params) 中被调用的。 doInBackground()：在 onPreExecute() 完成执行后立即在后台线程上调用。此步骤用于执行可能需要很 长时间的后台计算。异步任务的参数 传递给 此步骤。计算结果 必须通过该步骤返回并返回到最后一步。此步骤还可以使用 publishProgress() 发布 一个或多个进度单元。这些值将在UI线程的 onProgressUpdate() 步骤中发布。 此方法是在 AsyncTask 类的构造方法中被调用的。之所用调用 publishProgress() 能够更新 onProgressUpdate() 是因为： 12345protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; onProgressUpdate() ：在调用 publishProgress() 后在 UI线程 上调用。执行的时间是未定义的。此方法用于在后台计算仍在执行时在用户界面中显示任何形式的进度。例如，它可以用来为进度条设置动画效果或在文本字段中显示日志。 onPostExecute()：在后台 计算完成后 在UI线程上调用。后台计算的结果作为参数传递给此步骤。 取消任务 任何时候都可以通过调用 cancel(boolean) 来取消任务。 调用此方法将导致对 isCancelled() 的后续调用返回true。在调用此方法后，将在 doInBackground(Object[]) 返回后调用onCancelled(Object)而不是 onPostExecute(Object)。 为了确保尽快取消任务，如果可能的话（例如在一个循环内部）应该始终从 doInBackground(Object[]) 定期检查 isCancelled()的返回值。 线程规则 AsyncTask类必须在UI线程上加载。 必须在UI线程上创建任务实例。 必须在UI线程上调用. 不要手动调用上面提到的执行任务的4个方法。 任务 只能执行一次（如果尝试执行第二次执行，则会引发异常。 AsyncTask 中2个在类加载时就进行初始化的static对象 Executor THREAD_POOL_EXECUTOR = threadPoolExecutor volatile Executor sDefaultExecutor = SERIAL_EXECUTOR 静态对象1 ：public static final Executor THREAD_POOL_EXECUTOR;此静态对象 THREAD_POOL_EXECUTOR 的实现是通过实现一个 完整的线程池 的来初始化的。 12345678910111213141516171819202122232425262728293031323334// 对线程池进行参数配置private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/** *可用于并行执行任务的 Executor 。 */public static final Executor THREAD_POOL_EXECUTOR;static &#123;// 对线程池进行初始化。 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); // 设置连接超时 threadPoolExecutor.allowCoreThreadTimeOut(true); // 对象指向。 THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 这个 THREAD_POOL_EXECUTOR 对象的执行是在 私有静态内部类SerialExecutor 中的 scheduleNext() 中年被执行的： 12345protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125;&#125; 静态对象2：private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;这个静态对象 sDefaultExecutor 在 AsyncTask 中是实际使用的。而这个静态对象是由 1public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 得到的，对 Executor SERIAL_EXECUTOR 这个对象的注释是： 1一个 Executor 按顺序一次执行一个任务。这种序列化对特定进程是全局的。 而且 Executor SERIAL_EXECUTOR 对象的实现是通过实现 Executor 接口，并重写 execute() 得到的。 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 既然实现 Executor 接口，那么肯定就要重写 void execute(Runnable command) ，在这个方法中声明了一个 ArrayDeque类 对象 mTasks。 ArrayDeque类是一个实现了 Deque接口的可调整大小的数组类。 offer() 其作用是 在此双端队列的末尾插入指定的元素， poll()的作用是：返回由此双端队列表示的队列头部，或者如果此双端队列为空，则返回 null。 这段代码的意思是：将一个新的线程对象添加到 可变数组对象 mTasks 中。如果当前这个 线程能够运行，那么执行 r.run()， 否则执行 scheduleNext()。 其中 ArrayDeque类的结构继承实现结构为： offer() 具体实现为： 1234567891011121314151617181920212223242526272829303132public boolean offer(E e) &#123; return offerLast(e);&#125;public boolean offerLast(E e) &#123; addLast(e); return true;&#125;public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity();&#125;private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(&quot;Sorry, deque too big&quot;); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n;&#125; transient Object[] elements;：存储该双端队列元素的数组。transient int head;：deque头部元素的索引（这是将被remove（）或pop（）移除的元素）; 或者如果该deque是空的，则任意数字等于tail。transient int tail;：下一个元素将添加到deque尾部的索引（通过addLast（E），add（E）或push（E））。 AsyncTask任务中前后台切换的关键：Handler mHandler 的初始化123456public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper);...&#125; 通过三目运算符，判断 mHandler 对象是否为空。 若 callbackLooper 为空，则执行 getMainHandler()； 若不为空，则执行 new Handler(callbackLooper)。 即：这个三目运算符的作用就是 判断callbackLooper参数，以决定以哪种方式对 Handler 对象进行实例化。 其中 getMainHandler()这个方法引出了 AsyncTask类中的一下部分方法 getMainHandler()源代码描述 12345678private static Handler getMainHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(Looper.getMainLooper()); &#125; return sHandler; &#125;&#125; 这段源代码中使用到了 Looper.getMainLooper()与 InternalHandler类。其中 InternalHandler类 的源代码描述： 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 注意：这个static class InternalHandler extends Handler是一个极其关键的一个内部类，因为他实现了 后台任务和UI主线程之间的切换，Internal是内部的意思。 在这个类中，尤其要注意 handleMessage(Message msg) 这个方法的重写。因为通过这个方法，对 msg.what 进行了判断： MESSAGE_POST_RESULT：表示 后台任务执行完毕。AsyncTask类调用 finish(Result result). finish(Result result) 的源代码描述为： 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 在调用这个方法时，通过对 isCancelled() 作出判断，以确定在 UI主线程 调用哪个方法，向 UI主线程 传递什么数据。 MESSAGE_POST_PROGRESS：表示 后台任务正在 持续的发送 更新结果，所以此处调用的 回调方法是：onProgressUpdate()。正是因为实在 handleMessage(Message msg) 回调了此方法，所以在使用 AsyncTask 类，重写 onProgressUpdate() 时返回的结果是直接作用在UI主线程里的。 在这个私有静态内部类 InternalHandler 中，用到了一个对象 result ，这个对象就是 AsyncTaskResult类的实例化，是 AsyncTask 中的另一个私有静态内部类。 AsyncTaskResult；类源代码描述为： 123456789private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 这个私有静态内部类 AsyncTaskResult 的作用就是封装了 AsyncTask 类 和 数据类 Data，对 当前AsyncTask任务和对应的数据进行整体封装。这个封装写的是极好的，好在对此类的对象使用时，仅通过此对象的某个成员变量就可以完成需要零散变量能完成的任务，将需要的需要用到数据做成一个整体性的类，数据从整体中获取，使得在使用中不会感到变量繁多，而是通过一种调用的方式，极好。 InternalHandler类 总结： 至此，通过以上分析可以得出的结论是：这个私有静态内部类主要是回调了 onCancelled(result)、onPostExecute(result)、onProgressUpdate(result.mData) 方法，即：InternalHandler类的作用是 AsyncTask 处理任务的后期结果显示阶段。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git的使用 版本系统的分类： 本地VCS（LVCS） 例如：RCS 优点 （1）适合文本文件（2）适合保存在本地硬盘上 缺点 （1）不支持基于项目的文件（2）不支持网络协作 集中VCS （CVCS） 例如：SVN，CVS 优点： （1）适合多人协作（2）适合代码集中管理 缺点： （1）存在单点故障（2）必须联网，无法脱机本地工作 分散式VCS（DVCS） 例如：Git，Mercurial 特点： 分布式：各个Repo（仓库）都具有完整的镜像 快照：每次记录都是完整的信息 状态区：了解git的状态区是学习git的重要步骤，只有掌握不同状态区的状态才能掌握git的核心思想。 分支：最重要的功能之一 Git介绍： 参考：https://git-scm.com/docs git 中文意思：饭桶。是一个分布式版本控制系统，Git 原本是 linus torvalds 用来管理 Linux 开发版本，而专门开发的一个版本控制工具。 特点： 具有速度快、使用简单、非线性开发模式（分支合并）、分布式、可管理各种规模的项目。项目中所有文件都可以在本地完成。 原理： 采用的“快照”版本控制而非“保存”。 在项目版本发生改变时，发生改变的文件被复制到下一个版本中，未发生改变的文件产生”快照“链接到下一个版本中。 通过SSH协议产生的指纹码，git将项目发送至github仓库。 git提交原理： Working Directory（本地工作库） -&gt; Staying Area（暂存区域） -&gt; Git Directory（版本控制仓库） Git使用 参考：http://marklodato.github.io/visual-git-guide/index-zh-cn.html#commit Github身份认证：本地Git仓库与远程Git仓库是通过 SSH身份认证进行通信的。进入.ssh文件夹下，输入命令： 1ssh-keygen -t rsa -C “邮箱名” 生成两个表明自己身份的文件：id_rsa ：私钥, id_rsa.pub ：公钥将id_rsa.pub中的内容添加至Github中个人设置中的SSH Key中。 Git命令操作：常见Git命令启动一个工作区 clone 将存储库克隆到新目录中 init 创建一个空的Git仓库或重新初始化现有的Git仓库 对当前变化的工作 add 文件内容到索引 mv 移动或重命名文件，目录或符号链接 reset 将当前HEAD复位为指定状态 rm 从工作树和索引中删除文件 检查历史和状态 bisect 使用二进制搜索来查找引入错误的提交 grep 打印匹配图案的行 log 显示提交日志 show 显示各种类型的对象 status 显示工作树状态 分支、合并、差异 branch 列表，创建或删除分支 checkout 切换分支或恢复工作树文件 commit 将更改记录到存储库 diff 显示提交，提交和工作树等之间的更改 merge 合并两个或更多的开发历史 rebase 重新申请在另一个基本提示之上 tag 创建，列出，删除或验证使用GPG签名的标签对象 远程操作 fetch 从另一个存储库下载对象和引用 pull 从另一个存储库或本地分支中拉取并集成 push 推送更新远程参考以及相关对象 查看相关 查看git版本 1git --version 查看当前git配置信息 1git config --list 查看所有项目的配置信息 1git config - -list - -global 查看所有的提交日志。在git仓库下查看提交记录日志 1git log 分组查看信息。根据提交者的名字进行分组显示，显示每个开发者的commit信息 1git shortlog 图形化的log记录 1gitk 指定文件 ：查看指定文件的历史修改记录。在Android Studio中代码行区域中右键选择annotate查看该文件的历史操作人 1git blame 查看代码库状态。每当文件有改动，可使用此命令查看git仓库的状态变化 1git status 查看文件发生的具体变化 1git diff 比较提交节点间的差异，注意：git支持第三方的diff工具进行diff操作 1git diff 不同的HEAD 配置相关12git config --global user.name 你的名字git config --global user.email 邮箱 等价于,配置你的git信息： 1git config --global --add user.name 名字 user.email 邮箱 删除配置: 1git config --global --unset user.name 名字 仓库管理创建 1、创建仓库方式1 - 自己创建一个仓库： 1git init 2、创建仓库方式2 - 将一个远程仓库的clone为本地仓库： 1git clone 项目地址 此时，git自动把本地的master分支与远程的master分支对应了起来，且远程仓库默认名称为：origin。创建单个文件 1git touch 文件名 注意：提交之后使用 git status 查看仓库中文件的状态 内容的 add、commit 添加单个文件 1git add 文件名 添加所有未提交的文件 1git add . 提交注释、说明 1git commit -m 追加修改，将之前的-m信息改为现在的-m信息 1git commit -amend -m 将本地代码仓库添加至远程仓库，其中‘origin’指的是远程仓库的名字，是默认的名字。 1git remote add origin git@…… 注意：提交之后使用 1git log 查看仓库中文件的提交记录 push - 提交提交修改。其中‘-u’表示将本地master分支内容推送到远程master分支上，并且将两者建立连接，此次建立连接后，后面将不再需要使用此参数。 1git push -u origin master pull - 更新1git pull - -rebase(可选) git 回退 - checkout（文件回退） &amp; reset（版本回退）单个文件回退——add之后的。 用版本库中的文件替换工作区的文件，无论是修改还是删除。放弃当前文件所有的内容修改，与上次文件内容相同。 1git checkout 文件名 在 git add 之后，一般先使用如下命令，将一个文件移除暂存区： 1git reset HEAD 文件名 然后再使用上一条命令 版本回退——commit之后的 重新编写注释 1git commit --amend -m &quot;add 1.html file and modify its content 回退至上一个版本。HEAD~100：会推至之前的第100个版本。 1git reset - -hard HEAD^ 删除删除指定的文件。使用此命令后，自动执行 git add 文件名 操作。 1git rm 文件名 暂存 将当前修改暂存起来 1git stash 查看当前暂存的内容 1git stash list 恢复暂存的内容（不会删除记录） 1git stash apply 恢复暂存内容（删除历史记录） 1git stash pop 删除记录 1git stash drop 分支 查看当前所有本地分支，其中*表示当前所在的分支 1git branch 查看所有的远程分支 1git branch -r 查看所有本地和远程的分支 1git branch -a 查看远程分支 1git remote 查看远程分支的详细信息 1git remote -v 创建 12git branch devgit checkout dev 等价于 git checkout -b dev 先创建dev分支，后并自动切换到该分支。注意：使用分支时，先将未提交的文件暂存（stash），然后 git checkout 分支名。 合并 合并 ‘分支名’到master分支中 1git merge 分支名 同上。不同：合并后，连同时间线也会一同合并 1git rebase 分支名 提交，将 ‘分支名‘推送至远程仓库中 1git push origin 分支名 删除 分支名 1git branch -d 分支名 创建Tag 查看tag信息 1git tag 创建普通Tag。这种创建方式的tag默认会在记录的最后提交 1git tag version1 通过commit id指定创建tag的地方 1git tag version1 bs234242（一般6、7位即可）： -a 表示指定tag名；-m 表示指定注释的文字 1git tag -a version1 -m ”“ daf3413144134 删除Tag 删除指定参数的tag 1git tag -d 参数（version1） 删除远程仓库中的tag，应先删除本地的tag 1git push origin :refs/tags/version1 执行上一条语句，然后再执行此条命令 提交 将指定名字的tag推送至远程仓库中 1git push origin tag参数（version1） 将本地所有的tag推送至远程仓库 1git push origin - -tags]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息机制]]></title>
    <url>%2FAndroid%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Handler、Looper、MessageQueue、Thread、ThreadLocal、HandlerThread、IntentService 概述 Android的消息机制主要是指Handler的运行机制，其运行机制包括：MessageQueue和Looper的支撑。 Handler：将一个任务切换至某个执行的线程中执行，系统之所以提供Handler是为了解决在子线程中无法访问UI矛盾。通过Handler更新UI仅仅是其的一个特殊使用场景。 MessageQueue：在机制中扮演：消息存储的角色。其内部是采用单链表的数据结构来存储消息队列，单链表在插入和删除上占有优势。 Looper：在机制中扮演：消息循环的角色。Handler创建时会采用当前线程中的Looper来构建消息循环。 ThreadLocal：ThreadLocal并不是线程，因为ThreadLocal可以在不同的线程中互不干扰的存储并提供数据，Handler通过ThreadLocal可以获取每个线程中的Looper。 UI主线程、子线程Android规定只能在主线程中访问UI，ViewRootImpl的checkThread()对UI操作做了验证. 123if(mThread ！= Thread.currentThread)&#123; 异常&#125; 为什么系统不允许在子线程中访问UI呢？这是因为Android的UI控件不是安全线程。如果在多线程中并发访问UI控件可能会导致不可预期的状态。为什么系统不为UI控件添加锁机制呢？这是因为： 使得UI访问逻辑变得复杂。 会降低UI访问的效率，锁机制本身会阻塞线程的执行。 注意： ==线程默认是没有Looper的，如果需要使用Handler就必须为线程创建Looper== 经常使用的UI主线程就是ActivityThread，其在创建的过程中会初始化Looper，这就是UI主线程中默认可以使用Handler的原因。 HandlerHandlerl类的结构 Handler 创建Handler创建时会采用当前线程的Looper来创建内部的消息循环系统。因此想要在当前单独的Thread中使用Handler，需要为当前的Thread创建Looper即可，具体创建方法（其实此创建方法在HandlerThread 的 run()中就有具体的应用）参考 Looper主题。 待Handler创建结束之后，Looper和MessageQueue就可以和Handler协同工作了。 Handler消息的处理：12345/** * Subclasses must implement this to receive messages. */public void handleMessage(Message msg) &#123;&#125; Handler发送消息： post() send() post()调用方法： Handler -&gt; post() 1234public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; Handler -&gt; sendMessageDelayed() 1234567public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; Handler -&gt; sendMessageAtTime() 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; Handler -&gt; enqueueMessage() -&gt; MessageQueue -&gt; enqueueMessage()：将消息放入到消息对列中 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; MessageQueue -&gt; enqueueMessage()：内部单链表存储消 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; sendMessage()调用方式相同：1234public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125; Handler中的LooperHandler中的Looper获取消息队列Looper在Handler的构造函数中进行初始化处理: Handler -&gt; Handler() 1234567891011121314151617public Handler(Callback callback, boolean async) &#123; ··· mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; ···&#125; Handler中的Looper清空循环中的消息Handler -&gt; dump() -&gt; Looper -&gt; dump() 12345678public final void dump(Printer pw, String prefix) &#123; pw.println(prefix + this + &quot; @ &quot; + SystemClock.uptimeMillis()); if (mLooper == null) &#123; pw.println(prefix + &quot;looper uninitialized&quot;); &#125; else &#123; mLooper.dump(pw, prefix + &quot; &quot;); &#125;&#125; Looper -&gt; dump() -&gt; MessageQueue -&gt; dump() 12345678910/** * Dumps the state of the looper for debugging purposes. * * @param pw A printer to receive the contents of the dump. * @param prefix A prefix to prepend to each line which is printed. */public void dump(@NonNull Printer pw, @NonNull String prefix) &#123; pw.println(prefix + toString()); mQueue.dump(pw, prefix + &quot; &quot;, null);&#125; MessageQueue -&gt; dump() 1234567891011121314void dump(Printer pw, String prefix, Handler h) &#123; synchronized (this) &#123; long now = SystemClock.uptimeMillis(); int n = 0; for (Message msg = mMessages; msg != null; msg = msg.next) &#123; if (h == null || h == msg.target) &#123; pw.println(prefix + &quot;Message &quot; + n + &quot;: &quot; + msg.toString(now)); &#125; n++; &#125; pw.println(prefix + &quot;(Total messages: &quot; + n + &quot;, polling=&quot; + isPollingLocked() + &quot;, quitting=&quot; + mQuitting + &quot;)&quot;); &#125;&#125; Handler中的MessageQueueHandler中的MessageQueue 查询消息对列Handler -&gt; hasMessages() -&gt; MessageQueue -&gt; hasMessages() 1234567/** * Check if there are any pending posts of messages with code &apos;what&apos; in * the message queue. */public final boolean hasMessages(int what) &#123; return mQueue.hasMessages(this, what, null);&#125; MessageQueue -&gt; hasMessages() 12345678910111213141516boolean hasMessages(Handler h, Runnable r, Object object) &#123; if (h == null) &#123; return false; &#125; synchronized (this) &#123; Message p = mMessages; while (p != null) &#123; if (p.target == h &amp;&amp; p.callback == r &amp;&amp; (object == null || p.obj == object)) &#123; return true; &#125; p = p.next; &#125; return false; &#125;&#125; 注意：此处的p.target就是Handler，因为源代码中：Message p = mMessages; 在Message类中： Handler中的MessageQueue 移除消息对列Handler -&gt; removeMessages() -&gt; MessageQueue -&gt; removeMessages() 1234567/** * Remove any pending posts of messages with code &apos;what&apos; that are in the * message queue. */public final void removeMessages(int what) &#123; mQueue.removeMessages(this, what, null);&#125; MessageQueue -&gt; removeMessages() 123456789101112131415161718192021222324252627282930313233void removeMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // Remove all messages at front. while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; p.recycleUnchecked(); p = n; &#125; // Remove all messages after front. while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.what == what &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); p.next = nn; continue; &#125; &#125; p = n; &#125; &#125;&#125; MessageQueue MessageQueue的类结构 MessageQueue主要包含2个操作：插入+读取，读取本身伴随着删除。 插入：参考Handler的MessageQueue 读取（伴随删除）： next() Looper使用Looper谨记一点：当前线程。 Looper的类结构 会以无限循环的方式去查找新消息，是一种阻塞式的执行方式。 从Looper类中的成员变量，可以看出此类的作用： 通过当前线程`Thread`的`ThreadLocal`，操作`MessageQueue`。 构造方法之一：创建一个MessageQueue，保存当前线程的对象。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 为一个线程创建Looper 12345678910111213141516171819* This is a typical example of the implementation of a Looper thread,* using the separation of &#123;@link #prepare&#125; and &#123;@link #loop&#125; to create an* initial Handler to communicate with the Looper.* * class LooperThread extends Thread &#123;* public Handler mHandler;** public void run() &#123;* Looper.prepare();** mHandler = new Handler() &#123;* public void handleMessage(Message msg) &#123;* // process incoming messages here* &#125;* &#125;;** Looper.loop();* &#125;* &#125; 退出： 方式1：直接退出 Looper -&gt; quit() -&gt; MessageQueue -&gt; quit() 123public void quit() &#123; mQueue.quit(false);&#125; MessageQueue -&gt; quit() 123456789101112131415161718192021void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; 方式2：通过设定退出标记，安全退出 Looper -&gt; quitSafely() -&gt; MessageQueue -&gt; quit() 123public void quitSafely() &#123; mQueue.quit(true);&#125; 注意： prepareMainLooper()是给主线程ActivityThread创建Looper使用的，其内部也是调用了prepare()。 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125;&#125; 退出。如果在子线程手动创建了Looper，那么在所有事件结束时，应当调用quit()来终止循环。否则这个子线程会一直处于等待状态。 最重要的方法 myLooper() 返回与当前线程关联的Looper对象。 如果调用线程未与Looper关联，则返回null。 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; myQueue() 返回与当前线程关联的 MessageQueue 对象。 这必须从运行Looper的线程调用，否则将引发NullPointerException。 123public static @NonNull MessageQueue myQueue() &#123; return myLooper().mQueue;&#125; Looper类的重点： loop()只有调用了loop()，消息循环系统才能真正的起作用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot; + Thread.currentThread().getName() + &quot;, h=&quot; + msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 注意： 源代码中的Message msg = queue.next();表示读取MessageQueue中的消息。在此处，MessageQueue与Looper建立联系。 源代码中的msg.target.dispatchMessage(msg);可以写为handler.dispatchMessage(msg);。在此处，Handler与Looper`建立联系。 dispatchMessage(msg)在Handler中是一个重要的方法： 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 因为在此方法中直接调用了handleMessage(msg);，即：将子线程中的消息作用于UI主线程，消息处理的终点。 结论：==在Looper类中，将Handler、MessageQueue、Message统一了起来。== ThreadLocalThreadLocal并不是线程，其作用是在不同的线程中**互不干扰的存储并提供数据**，对于其他线程而言是无法获取数据的。 对于某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，采用ThreadLocal。 对于Handler来说，他需要获取当前线程的Looper，而Looper的作用域就是线程，而且不同的线程具有不同的Looper。此时通过ThreadLocal就可以实现Looper在线程中的存取。 只要线程处于活动状态且可以访问ThreadLocal实例，每个线程就会保留对其线程局部变量副本的隐式引用; 在线程消失后，线程本地实例的所有副本都将进行垃圾回收（除非存在对这些副本的其他引用）。 ThreadLocal的类结构 public方法 使用1ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;Boolean&gt;(); 123456789101112131415161718mBooleanThreadLocal.set(true);new Thread(&quot;a&quot;)&#123; @Override public void run() &#123; super.run(); mBooleanThreadLocal.set(false); Log.e(TAG, &quot;ヽ(｀Д´)ﾉ -&gt; run : &quot; + mBooleanThreadLocal.get()); &#125;&#125;;new Thread(&quot;2&quot;)&#123; @Override public void run() &#123; super.run(); Log.e(TAG, &quot;ヽ(｀Д´)ﾉ -&gt; run : &quot; + mBooleanThreadLocal.get()); &#125;&#125;; 输出结果为： 12306-26 09:24:00.722 27466-27466/com.yannischeng.guard E/MainActivity: ヽ(｀Д´)ﾉ -&gt; onCreate main : true06-26 09:24:00.723 27466-27490/com.yannischeng.guard E/MainActivity: ヽ(｀Д´)ﾉ -&gt; run : a : false06-26 09:24:00.723 27466-27491/com.yannischeng.guard E/MainActivity: ヽ(｀Д´)ﾉ -&gt; run : 2 : null 从结果可以看出，同一个对象在不同的线程中，赋的值不同，输出的值不同。 原理不同的线程访问同一个ThreadLocal对象的get()，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。不同线程中的数组是不同的。 ThreadLocal -&gt; set() 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; ThreadLocal -&gt; ThreadLocalMap -&gt;set() private void set(ThreadLocal&lt;?&gt; key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal&lt;?&gt; k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); } ThreadLocal -&gt; ThreadLocalMap -&gt;Entry 这个哈希映射中的条目扩展了WeakReference，使用它的主要引用字段作为键（它始终是一个ThreadLocal对象）。 请注意，null键（即entry.get（）== null）表示该键不再被引用，因此该条目可以从表中删除。 这些条目在下面的代码中被称为“陈旧条目”。 123456static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 从以上代码可以看出，在调用set()时，先获取当前线程，然后通过当前线程获取该线的ThreadLocal，即： hreadLocal -&gt; getMap() 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 代码中的t.threadLocals就是： 1ThreadLocal.ThreadLocalMap threadLocals = null; 然后调用： 1234if (map != null) map.set(this, value);else createMap(t, value); 将当前线程Thread的ThreadLocal作为key值，将自己设置的value值作为value，存储到ThreadLocalMap的对象map中。 ThreadLocal -&gt; get() 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; get()同set(). MessageMessage的类结构 HandlerThread HandlerThread类结构 HandlerThread继承Thread类调用Looper类，就足以说明这个类的作用。 方便的类，用于启动具有循环的新线程。 然后可以使用循环来创建处理程序类。 请注意，start()仍然必须被调用。 使用过程： 参考：https://blog.csdn.net/javazejian/article/details/52426353 12345678// 创建异步HandlerThreadHandlerThread handlerThread = new HandlerThread(&quot;download&quot;);// 必须先开启线程handlerThread.start();// 子线程HandlerHandler childHandler = new Handler(handlerThread.getLooper(),new ChildCallback()); 根据 HandlerThread 类 用于启动具有循环的新线程，然后可以使用循环来创建处理程序类 的使用场景，对 handlerThread 所在地 Handler 进行调用。 1234for(int i=0;i&lt;7;i++)&#123; //每个1秒去更新图片 childHandler.sendEmptyMessageDelayed(i,1000*i);&#125; 意义：这是 在Thread中手动加入Looper的好示例。这个类很简单，只有165行。源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; private @Nullable Handler mHandler; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; /** * @return a shared &#123;@link Handler&#125; associated with this thread * @hide */ @NonNull public Handler getThreadHandler() &#123; if (mHandler == null) &#123; mHandler = new Handler(getLooper()); &#125; return mHandler; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; /** * Returns the identifier of this thread. See Process.myTid(). */ public int getThreadId() &#123; return mTid; &#125;&#125; 实现：通过源代码可以发现，此类在实现上主要是在Thread类中的run()中对Looper进行了创建和调用。即： 12345678910111213@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 并且着重处理了Looper的退出操作：quitSafely()与quit()。 线程处理：此类在线程处理上使用了wait()和notifyAll()。而且尤其重要的一点是：在使用时要先调用Thread的start()，然后在调用getLooper()。 通过Handler处理当前Thread中的消息，需要对Handler进行初始化操作。初始化时需要传入Looper对象，在HandlerThread类中，Looper对象的获取是在getLooper()之后得到的，但是getLooper()中调用了wait()，只有先调用run()中notifyAll()才能返回已经创建结束的Looper对象。 IntentService IntentService类的结构 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; /** * Unless you provide binding for your service, you don&apos;t need to implement this * method, because the default implementation returns null. * @see android.app.Service#onBind */ @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 基本类描述： 使用参考：https://blog.csdn.net/javazejian/article/details/52426425 IntentService是一个继承Service的抽象类，有一个内部类ServiceHandler继承Handler并实现handleMessage(Message msg)方法，并在方法内调用onHandleIntent(@Nullable Intent intent)抽象方法。抽象方法onHandleIntent(@Nullable Intent intent)是提供给外界调用的处理耗时任务的方法。 内部实现描述IntentService类内部创建并调用了Looper、Handler、HandlerThread。 实际上：IntentService是在Service中对Handler+HandlerThread进行了综合实现。 具体实现： 在onCreate()中 对HandlerThrad和Handler进行实现。 1234567public void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 在onStart()中对消息进行处理，注意 Message对象的赋值。 12345678910111213@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125;@Overridepublic int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125; 根据Service的生命周期： 可知，当执行完毕onCreate()、onStart()、onStartCommand()后，基本上所有的类的对象已经初始化完毕。即：左侧的生命周期。 在实际使用中，onCreate()仅调用1次，onStartCommand()调用多次。为了符合Service的这一运行特性，仅在onCreate()中进行创建、在onStart()中进行数据发送。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程-1 Java]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B-1%20Java%2F</url>
    <content type="text"><![CDATA[线程总结-1 Java 参考：https://www.cnblogs.com/xdp-gacl/p/3633936.html参考：https://www.cnblogs.com/wxd0108/p/5479442.html 名词释义： 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源。 线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如synchronized关键字。 在同一个时间点上，一个CPU只能支持一个线程在执行。因为CPU运行的速度很快，因此我们看起来的感觉就像是多线程一样。 基本线程类：Thread类，Runnable接口。 线程优先级： 优先级范围：1 - 10；1最低，5是正常级 在不指定的情况下，所有线程的优先级是一样的。 线程的优先级应该在start()方法调用之前被设置 线程的状态线程状态转换关于阻塞(Blocked)情况 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断，IO完成都会回到(Runnable)状态，等待JVM的调度。 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）。 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。 Thread类中的yield()可以让一个Running状态的线程转入(Runnable)状态。 在Runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的，有可能刚刚处于Runnable状态的线程，会马上被再次调用。 基本控制方法： 参考：https://blog.csdn.net/maoyeqiu/article/details/50215123 方法 功能 isAlive() 判断线程是否终止 getPriority() 获得线程优先级 setPriority() 设置线程优先级 Thread.sleep() 指定当前线程的睡眠毫秒数 join() thread.join()把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B。 yield() 让出cpu，当前线程进入就绪队列等待调用 wait() 当前线程进入对象的wait pool，让当前线程释放锁，使得其他线程获取锁 notify()/notifyAll() 唤醒对象的wait pool中的一个或者所有等待的线程 sleep() 让当前线程睡眠，持有锁 每个对象都有的方法（机制）synchronized, wait(), notify() 是任何对象都具有的同步工具。 讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait()/notify()必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait()之后，其他线程可以进入同步块执行。 关键字 synchronized一个线程变为一个对象的锁的拥有者是通过下列三种方法： 执行这个对象的 synchronized 方法 执行这个对象的 synchronized 语句块，这个语句块中锁的对象 执行 synchronized 静态方法 synchronized单独使用:直接用于方法:相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。 12345public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125; 代码块：在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 12345678public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;&#125; synchronized 作用于方法1234567891011121314151617181920212223242526272829303132333435class Bank&#123; private int money = 1000; public synchronized int getMoney(int number)&#123; money -= number; System.out.println(&quot;Left Money: &quot; + money); return number; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println(&quot;操作金额：&quot; + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Thread t01 = new MoneyThread(bank);// 从银行取钱 Thread t02 = new MoneyThread(bank);// 从取款机取钱 t01.start(); t02.start(); &#125;&#125; 运行结果： 1234Left Money: 800操作金额：200Left Money: 600操作金额：200 synchronized 作用于代码块 - 同一个类的同一个对象12345678910111213141516171819202122232425262728293031323334353637class Bank&#123; private int money = 1000; public int getMoney(int number)&#123; synchronized (this)&#123; money -= number; System.out.println(&quot;Left Money: &quot; + money); return number; &#125; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println(&quot;操作金额：&quot; + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Thread t01 = new MoneyThread(bank);// 从银行取钱 Thread t02 = new MoneyThread(bank);// 从取款机取钱 t01.start(); t02.start(); &#125;&#125; 运行结果： 1234Left Money: 800操作金额：200Left Money: 600操作金额：200 synchronized 作用于代码块 - 同一个类的不同对象12345678910111213141516171819202122232425262728293031323334353637class Bank&#123; private int money = 1000; public int getMoney(int number)&#123; synchronized (this)&#123; money -= number; System.out.println(&quot;Left Money: &quot; + money); return number; &#125; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println(&quot;操作金额：&quot; + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Bank bank2 = new Bank(); Thread t1 = new MoneyThread(bank);// 从银行取钱 Thread t2 = new MoneyThread(bank2);// 从取款机取钱 t1.start(); t2.start(); &#125;&#125; 运行结果： 1234Left Money: 800Left Money: 800操作金额：200操作金额：200 synchronized 作用于代码块 - 作用域的范围修改前 123456789101112131415161718192021222324252627282930313233343536373839class Bank&#123; private int money = 1000; public int getMoney(int number)&#123; number = number + 12; System.out.println(&quot; Money + 12 is : &quot; + number); synchronized (this)&#123; money -= number; System.out.println(&quot;Left Money: &quot; + money); return number; &#125; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println(&quot;操作金额：&quot; + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Thread t01 = new MoneyThread(bank);// 从银行取钱 Thread t02 = new MoneyThread(bank);// 从取款机取钱 t01.start(); t02.start(); &#125;&#125; 运行结果 123456 Money + 12 is : 212 Money + 12 is : 212Left Money: 788操作金额：212Left Money: 576操作金额：212 修改后 123456789101112131415161718192021222324252627282930313233343536373839class Bank&#123; private int money = 1000; public int getMoney(int number) &#123; synchronized (this)&#123; number = number + 12; System.out.println(&quot; Money + 12 is : &quot; + number); money -= number; System.out.println(&quot;Left Money: &quot; + money); return number; &#125; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println(&quot;操作金额：&quot; + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Thread t01 = new MoneyThread(bank);// 从银行取钱 Thread t02 = new MoneyThread(bank);// 从取款机取钱 t01.start(); t02.start(); &#125;&#125; 运行结果： 123456 Money + 12 is : 212Left Money: 788操作金额：212 Money + 12 is : 212Left Money: 576操作金额：212 由以上示例的运行结果的输出顺序可以看出：在 synchronized 代码块之外的的代码，在进行多线程运行时，是不受 synchronized 关键字控制的。 synchronized 作用于静态方法1234567891011121314151617181920212223242526272829303132333435class BankStatic &#123; private static int money = 1000; public synchronized static int getMoney(int number) &#123; money -= number; System.out.println(&quot;Left Money: &quot; + money); return number; &#125;&#125;class MoneyThreadStatic extends Thread &#123; private Bank bank; @Override public void run() &#123; System.out.println(&quot;操作金额：&quot; + BankStatic.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Thread t3 = new MoneyThreadStatic();// 从银行取钱 Thread t4 = new MoneyThreadStatic();// 从取款机取钱 t3.start(); t4.start(); Thread t5 = new MoneyThreadStatic();// 从银行取钱 Thread t6 = new MoneyThreadStatic();// 从取款机取钱 t5.start(); t6.start(); &#125;&#125; 运行结果 12345678Left Money: 800Left Money: 600操作金额：200操作金额：200Left Money: 400操作金额：200Left Money: 200操作金额：200 synchronized 关键字的组合使用 - 生产者消费者问题synchronized, wait(), notify()结合典型场景。 生产者消费者问题是研究多线程程序时绕不开的经典问题之一，它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。要解决此问题可以通过：同步机制实现的生产者/消费者问题。 同步问题核心在于：如何保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用加锁机制，保证资源在任意时刻至多被一个线程访问。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 仓库类Storage实现缓冲区 */public class Storage &#123; private final int MAX_SIXE = 5; private LinkedList&lt;Object&gt; linkedList = new LinkedList&lt;&gt;(); //生产num个产品 public void produce(int num) &#123; synchronized (linkedList) &#123; // 如果仓库剩余容量不足 while (linkedList.size() + num &gt; MAX_SIXE) &#123; System.out.println(Thread.currentThread().getName() + &quot;, wait:【要生产的产品数量】:&quot; + num + &quot;/t【库存量】:&quot; + linkedList.size() + &quot;/t暂时不能执行生产任务!&quot;); try &#123; linkedList.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 生产条件满足情况下，生产num个产品 for (int i = 0; i &lt; num; i++) &#123; linkedList.add(new Object()); &#125; System.out.println(&quot;【已经生产产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + linkedList.size()); linkedList.notifyAll(); &#125; &#125; public void constume(int num) &#123; synchronized (linkedList) &#123; // 如果仓库存储量不足 while (linkedList.size() &lt; num) &#123; System.out.println(Thread.currentThread().getName() + &quot;, wait:R【要消费的产品数量】:&quot; + num + &quot;/t【库存量】:&quot; + linkedList.size()); // 由于条件不满足，消费阻塞 try &#123; linkedList.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 消费条件满足情况下，消费num个产品 for (int i = 1; i &lt;= num; ++i) &#123; linkedList.remove(); &#125; System.out.println(&quot;【已经消费产品数】:&quot; + num + &quot;/t【现仓储量为】:&quot; + linkedList.size()); linkedList.notifyAll(); &#125; &#125; public LinkedList&lt;Object&gt; getLinkedList() &#123; return linkedList; &#125; public void setLinkedList(LinkedList&lt;Object&gt; linkedList) &#123; this.linkedList = linkedList; &#125; public int getMAX_SIXE() &#123; return MAX_SIXE; &#125;&#125; 123456789101112131415161718192021222324252627/** * 生产者类Producer继承线程类Thread */public class Producer extends Thread &#123; // 每次生产的产品数量 private int num; // 所在放置的仓库 private Storage storage; // 构造函数，设置仓库 public Producer(int num, Storage storage) &#123; this.num = num; this.storage = storage; &#125; // 调用仓库Storage的生产函数 private void produce(int num) &#123; storage.produce(num); &#125; @Override public void run() &#123; produce(num); &#125;&#125; 1234567891011121314151617181920212223242526/** * 消费者类Consumer继承线程类Thread */public class Consumer extends Thread &#123; // 每次消费的产品数量 private int num; // 所在放置的仓库 private Storage storage; public Consumer(int num, Storage storage) &#123; this.num = num; this.storage = storage; &#125; // 调用仓库Storage的生产函数 private void consume(int num) &#123; storage.constume(num); &#125; @Override public void run() &#123; consume(num); &#125;&#125; 12345678910111213141516171819public class TestMain &#123; public static void main(String[] args)&#123; // 仓库对象 Storage storage = new Storage(); // 消费者对象 Consumer c1 = new Consumer(1,storage); Consumer c2 = new Consumer(3,storage); // 生产者对象 Producer p1 = new Producer(2,storage); // 线程开始执行 c1.start(); p1.start(); c2.start(); &#125;&#125; 123456Thread-0, constume wait:R【要消费的产品数量】:1/t【库存量】:0Thread-1, constume wait:R【要消费的产品数量】:3/t【库存量】:0Thread-2, produce【已经生产产品数】:2/t【现仓储量为】:2Thread-1, constume wait:R【要消费的产品数量】:3/t【库存量】:2Thread-0, constume【已经消费产品数】:1/t【现仓储量为】:1Thread-1, constume wait:R【要消费的产品数量】:3/t【库存量】:1 死锁问题产生死锁的原因： 资源不足、分配不当 请求、释放资源的顺序不对。 产生死锁的条件 互斥条件：在一段时间内，资源仅为一个线程所占有。此时，其他线程想要占用只能等待。 请求与保持条件：线程已经保持了一个资源，同时又提出了新的资源请求，此新资源却又被其他线程占用，即：请求被阻塞、自身持有资源又保持不放。 不可剥夺条件：线程中持有的资源为被使用完毕之前，不能别其他线程强行夺走，只能是自己来释放。 循环等待条件：若干线程间形成收尾相连的循环资源等待关系。 Java并发编程：线程池的使用 参考：https://www.cnblogs.com/dolphin0520/p/3932921.html 使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 线程池使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务。 ThreadPoolExecutor类ThreadPoolExecutor继承关系： 构造函数中的各个参数含义： 1. int corePoolSize： 核心池的大小（例如：正式工人。就是线程池大小），这个参数跟后面讲述的线程池的实现原理有非常大的关系。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中； 2. int maximumPoolSize： 线程池最大线程数（例如：正式工人 + 临时工人。任务量突然过大时的一种补救措施），它表示在线程池中最多能创建多少个线程。 3. long keepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； 4. TimeUnit unit： 参数keepAliveTime的时间单位，有7种取值： 1234567TimeUnit.DAYS; //天TimeUnit.HOURS; //小时TimeUnit.MINUTES; //分钟TimeUnit.SECONDS; //秒TimeUnit.MILLISECONDS; //毫秒TimeUnit.MICROSECONDS; //微妙TimeUnit.NANOSECONDS; //纳秒 5. BlockingQueue workQueue： 一个阻塞队列，用来存储等待执行的任务。阻塞队列有以下几种选择，一般使用LinkedBlockingQueue和Synchronous： 123ArrayBlockingQueue;LinkedBlockingQueue;SynchronousQueue; 6. ThreadFactory threadFactory： 线程工厂，主要用来创建线程。 7. RejectedExecutionHandler handler： 表示当拒绝处理任务时的策略，有以下四种取值： 1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 主要方法： execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。 submit()这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。 shutdown()和shutdownNow()是用来关闭线程池的。 ThreadPoolExecutor类实现原理线程池状态在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态： 12345volatile int runState; // 保证线程之间的可见性static final int RUNNING = 0; // 当创建线程池后，初始时static final int SHUTDOWN = 1; // 调用了shutdown()方法，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；static final int STOP = 2; // 调用了shutdownNow()方法，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；static final int TERMINATED = 3; // 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后 任务的执行过程在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法。execute()方法的实现原理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; // 为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施 if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125; else if (!addIfUnderMaximumPoolSize(command)) reject(command); // is shutdown or saturated &#125;&#125;private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123; Thread t = null; // 首先获取到锁，因为这地方涉及到线程池状态的变化 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。 // 判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。 if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING) // 创建线程去执行firstTask任务 t = addThread(firstTask); &#125; finally &#123; mainLock.unlock(); &#125; // 判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING） if (t == null) return false; t.start(); return true;&#125;private Thread addThread(Runnable firstTask) &#123; Worker w = new Worker(firstTask); //创建一个线程，执行任务 Thread t = threadFactory.newThread(w); if (t != null) &#123; //将创建的线程的引用赋值为w的成员变量 w.thread = t; workers.add(w); //当前线程数加1 int nt = ++poolSize; if (nt &gt; largestPoolSize) largestPoolSize = nt; &#125; return t;&#125;// 它实际上实现了Runnable接口private final class Worker implements Runnable &#123; private final ReentrantLock runLock = new ReentrantLock(); private Runnable firstTask; volatile long completedTasks; Thread thread; Worker(Runnable firstTask) &#123; this.firstTask = firstTask; &#125; boolean isActive() &#123; return runLock.isLocked(); &#125; void interruptIfIdle() &#123; final ReentrantLock runLock = this.runLock; /注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的 //如果成功获取了锁，说明当前worker处于空闲状态 if (runLock.tryLock()) &#123; try &#123; if (thread != Thread.currentThread()) thread.interrupt(); &#125; finally &#123; runLock.unlock(); &#125; &#125; &#125; void interruptNow() &#123; thread.interrupt(); &#125; private void runTask(Runnable task) &#123; final ReentrantLock runLock = this.runLock; runLock.lock(); try &#123; if (runState &lt; STOP &amp;&amp; Thread.interrupted() &amp;&amp; runState &gt;= STOP) boolean ran = false; beforeExecute(thread, task); //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据 //自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等 try &#123; task.run(); ran = true; afterExecute(task, null); ++completedTasks; &#125; catch (RuntimeException ex) &#123; if (!ran) afterExecute(task, ex); throw ex; &#125; &#125; finally &#123; runLock.unlock(); &#125; &#125; public void run() &#123; try &#123; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); //当任务队列中没有任务时，进行清理工作 &#125; &#125;&#125; getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Runnable getTask() &#123; for (;;) &#123; try &#123; // 先判断当前线程池状态 int state = runState; // 如果runState大于SHUTDOWN，即为STOP或者TERMINATED if (state &gt; SHUTDOWN) return null; Runnable r; if (state == SHUTDOWN) // Help drain queue //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间， r = workQueue.poll(); else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //则通过poll取任务，若等待一定的时间取不到任务，则返回null r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS); else r = workQueue.take(); if (r != null) return r; //如果没取到任务，即r为null，则判断当前的worker是否可以退出 if (workerCanExit()) &#123; if (runState &gt;= SHUTDOWN) // Wake up others //中断处于空闲状态的worker interruptIdleWorkers(); return null; &#125; // Else retry &#125; catch (InterruptedException ie) &#123; // On interruption, re-check runState &#125; &#125;&#125;private boolean workerCanExit() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); boolean canExit; //如果runState大于等于STOP，或者任务缓存队列为空了 //或者 允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1 try &#123; canExit = runState &gt;= STOP || workQueue.isEmpty() || (allowCoreThreadTimeOut &amp;&amp; poolSize &gt; Math.max(1, corePoolSize)); &#125; finally &#123; mainLock.unlock(); &#125; return canExit;&#125;void interruptIdleWorkers() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (Worker w : workers) //实际上调用的是worker的interruptIfIdle()方法 w.interruptIfIdle(); &#125; finally &#123; mainLock.unlock(); &#125;&#125; 假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。 addIfUnderMaximumPoolSize方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的 123456789101112131415private boolean addIfUnderMaximumPoolSize(Runnable firstTask) &#123; Thread t = null; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING) t = addThread(firstTask); &#125; finally &#123; mainLock.unlock(); &#125; if (t == null) return false; t.start(); return true;&#125; 要知道任务提交给线程池之后的处理策略，主要有4点： 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务； 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。 线程池中的线程初始化默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到： prestartCoreThread()：初始化一个核心线程； prestartAllCoreThreads()：初始化所有核心线程 12345678910public boolean prestartCoreThread() &#123; return addIfUnderCorePoolSize(null); //注意传进去的参数是null&#125; public int prestartAllCoreThreads() &#123; int n = 0; while (addIfUnderCorePoolSize(null))//注意传进去的参数是null ++n; return n;&#125; 注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的： 1r = workQueue.take(); 即等待任务队列中有任务。 任务缓存队列及排队策略任务缓存队列，即BlockingQueue&lt;Runnable&gt; workQueue，它用来存放等待执行的任务。 ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小； LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE； SynchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。 任务拒绝策略1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 线程池的关闭 shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 ThreadPoolExecutor类使用示例方式1：ThreadPoolExecutor使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class MainThreadPool &#123; public static void main(String[] args) &#123; ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); for (int i = 0; i &lt; 15; i++) &#123; MyTask myTask = new MyTask(i); poolExecutor.execute(myTask); System.out.println(&quot;第 &quot; + i + &quot;个 —— 线程池中线程数目：&quot; + poolExecutor.getPoolSize() + &quot;，队列中等待执行的任务数目：&quot; + poolExecutor.getQueue().size() + &quot;，已执行玩别的任务数目：&quot; + poolExecutor.getCompletedTaskCount()); &#125; poolExecutor.shutdown(); &#125; static class MyTask implements Runnable &#123; private int taskNum; public MyTask(int num) &#123; this.taskNum = num; &#125; @Override public void run() &#123; System.out.println(&quot;正在执行task &quot; + taskNum); try &#123; Thread.currentThread().sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;task &quot; + taskNum + &quot;执行完毕&quot;); &#125; &#125; /** * 当 i &lt; 5 时： 正在执行task 0 第 0个 —— 线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 第 1个 —— 线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 1 第 2个 —— 线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 2 第 3个 —— 线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 3 第 4个 —— 线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 4 task 1执行完毕 task 2执行完毕 task 3执行完毕 task 0执行完毕 - - - - - - - - - - - 当 i &lt; 10 时： 正在执行task 0 第 0个 —— 线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 第 1个 —— 线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 1 第 2个 —— 线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 2 第 3个 —— 线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 3 第 4个 —— 线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 第 5个 —— 线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0 第 6个 —— 线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0 正在执行task 4 第 7个 —— 线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0 第 8个 —— 线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0 第 9个 —— 线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0 task 0执行完毕 task 1执行完毕 task 3执行完毕 正在执行task 7 task 2执行完毕 正在执行task 8 正在执行task 5 正在执行task 6 task 4执行完毕 正在执行task 9 task 7执行完毕 task 6执行完毕 task 9执行完毕 task 5执行完毕 task 8执行完毕 */&#125; 方式2：Executors使用 Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE Executors.newSingleThreadExecutor(); //创建容量为1的缓冲池 Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池 三个方法的具体实现： 12345678910111213141516public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 多线程对于 成员变量 与 局部变量 的影响 如果一个变量是 成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是 彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。 如果一个变量是 局部变量，那么 每个线程 都会有一个 该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[他山之石，可以攻玉]]></title>
    <url>%2F%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%94%BB%E7%8E%89%2F</url>
    <content type="text"><![CDATA[总结 学习编程是有加速度的：知识结构越丰富，跑的就越快。 阅读源代码永远不是一件轻松的事，大部分情况下读不下去，不是方法不好而是投入力度不够。 为何阅读源代码那么难？ 语言自身特点 现在看到的源码：基本上都经过若干年迭代、很多人不断地完善后的，且枝枝蔓蔓非常多，魔鬼都在细节中，阅读的时候很容易陷进去。 什么？还有不可忽视的工具？ Github 那么，该怎么做？昨夜西风凋碧树，独上高楼，望尽天涯路登高望远，对其有一个宏观概念，了解源码概貌。 1. 阅读源码之前，需要有一定的技术储备 2. 必须得会使用这个框架/类库， 最好是精通各种各样的用法 3. 找书，找资料，了解这个软件的整体设计 4. 搭建系统，把源代码跑起来 衣带渐宽终不悔，为伊消得人憔悴 静态：看代码 动态：debug (从业务的角度) 5. 设计主要测试案例，进行debug 第1遍尽可能 抛弃细节，抓主要流程 。 第2遍、第3遍 …… 再看细节。 6. 文档记录 代码太复杂，人脑容量有限，因此记不住所有的细节。 而文档可以帮助记住关键点， 写作的同时对知识作出梳理，防止遗忘。 7. 丰富测试案例，debug分支流程 继续 debug。 众里寻他千百度，蓦然回首，那人却在灯火阑珊处坚持。 没有上下的求索，就不会有瞬间的顿悟和理解。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android屏幕适配]]></title>
    <url>%2FAndroid%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[屏幕适配总结 参考：https://blog.csdn.net/xxf377376701/article/details/78925646参考：https://www.jianshu.com/p/cd66b7e01d4a 概念 计算公式： px = density（基准比例） * dp; density（基准比例） = dpi / 160; px = dp * (dpi / 160); 参数获取方式： 12345678910DisplayMetrics dm = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(dm);dm.ydpi; //得到物理屏幕上 Y 轴方向每英寸的像素dm.xdpi; //得到物理屏幕上 X 轴方向每英寸的像素dm.density; //获取当前设备的基准比例dm.densityDpi; //获取系统dpi，随着 build.prop 文件中的代码而改变。dm.widthPixels; //获取屏幕宽度的像素数量 屏幕尺寸：inch 手机对角线的物理尺寸，单位：英寸（inch），1英寸=2.54cm。 屏幕分辨率：px 手机在横向、纵向上的像素点数总和。一般描述成屏幕的”宽x高”=AxB。例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点 单位：px（pixel），1px=1像素点。 屏幕像素密度：dpi 每英寸的像素点数，单位：dpi（dots per ich）。假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi。 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度： 密度类型|代表的分辨率（px）|屏幕像素密度（dpi）—|—|—低密度（ldpi）|240x320 |120中密度（mdpi）| 320x480 |160高密度（hdpi）| 480x800 |240超高密度（xhdpi） |720x1280 |320超超高密度（xxhdpi） |1080x1920 |480 屏幕尺寸、分辨率、像素密度 3者关系 密度无关像素：dp/dip Density-independent pixel，与终端上的实际物理像素点无关，以保证在不同屏幕像素密度的设备上显示相同的效果。 标准是160dip。即1dp对应1个pixel，计算公式如：px = dp * (dpi / 160) 。即：屏幕密度越大，1dp 对应 的像素点越多。 独立比例像素：sp/sip scale-independent pixel，单位：sp。Android开发时用此单位设置文字大小，可根据字体大小首选项进行缩放。 dp与px的转换 px = dp * (dpi / 160); 在Android中，规定以160dpi（即屏幕分辨率为320x480）为基准：1dp=1px 密度类型 代表的分辨率（px） 屏幕密度（dpi） 换算（px/dp） 比例 低密度（ldpi） 240x320 120 1dp=0.75px 3 中密度（mdpi） 320x480 160 1dp=1px 4 高密度（hdpi） 480x800 240 1dp=1.5px 6 超高密度（xhdpi） 720x1280 320 1dp=2px 8 超超高密度（xxhdpi） 1080x1920 480 1dp=3px 12 Android中资源限定符的 优先级顺序 及 匹配关系 参考：https://blog.csdn.net/jamikabin/article/details/50541652 详细：https://www.jianshu.com/p/1d0bfbdaab17?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation 适配碎片化 Android系统 Android屏幕尺寸 Android屏幕分辨率 适配 本质：使得“布局”、“布局组件”、“图片资源”匹配不同的屏幕尺寸。 图片资源匹配本质：使得图片资源在不同屏幕密度上显示相同的像素效果。 使用自动拉伸位图：Nine-Patch 的图片类型，后缀名是.9.png，放置在 drawable文件夹即可。 4个方向 黑线 的作用 参考： https://blog.csdn.net/zhaokaiqiang1992/article/details/45419023#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E4%BC%B8%E4%BD%8D%E5%9B%BE https://www.jb51.net/article/77482.htm https://blog.csdn.net/oudetu/article/details/78968067 UI设计师的.9.PNG：https://www.zcool.com.cn/article/ZMTExODI4.html 根据各个密度文件夹 drawable- 生成相关的切图。理论上来说只需要提供一种分辨率规格的图片资源就可以了，重点是选择哪一中屏幕密度的文件夹。 Android 图片文件处理Android SDK会根据 屏幕密 度自动选择 对应的资源文件 进行渲染加载。如果屏幕所对应的文件夹没有要找的图片，这个时候就需要根据一定的策略去寻找图片了。 Android系统寻找图片的步骤 到 对应密度屏幕文件夹 中寻找，有就用； 若没有，到比此密度文件夹高一级的 密度文件夹 中寻找，有就用； 若 上一级文件夹也没有，则继续向上级寻找； 如果到了 顶级密度文件夹中 仍没有图片，则到比自己低的密度文件夹中寻找，以此类推。注意：若当前查找的密度文件夹为：mhpi，且此文件夹中没有图片，则是直接到drawable中查找。若drawable中没有，则向ldpi文件夹中寻找 Android 对图片的缩放对于放在不同目录下的图片， 系统会按照一定比例对原始的图片进行放大或者缩小， 布局控件匹配-基本限定符的使用参考：https://blog.csdn.net/lecepin/article/details/51206896 本质：使得布局组件在不同屏幕密度上显示相同的像素效果。 多使用相对布局 使用”wrap_content”、”match_parent”和”weight“来控制视图组件的宽度和高度。 使用密度无关像素 ：由于各种屏幕的像素密度都有所不同，因此相同数量的像素在不同设备上的实际大小也有所差异，这样使用像素（px）定义布局尺寸就会产生问题。因此，使用密度无关像素 dp 或独立比例像素 sp 单位指定尺寸。 dp能兼容不同分辨率的设备的原因参考：https://www.jianshu.com/p/cd66b7e01d4a dpi 是内置的，例如在 1920*1080 分辨率的手机上 默认就使用480 的 dpi ，不管的你的尺寸是多大都是这样，除非厂家手动修改了配置文件。 亲自尝试一下以验证： .xml文件中： 12345&lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;Hello World!&quot; /&gt; 按照我们之前的公式手动计算，结果应为： height = 100 x 445 / 160 = 278.5px width = 200 x 445 / 160 = 556.25px .java文件中： 12345678layout = (RelativeLayout)findViewById(R.id.la);//要在控件绘制完成后才能获取到相关信息，所以这里要监听绘制状态layout.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123; public boolean onPreDraw() &#123; Log.d(&quot;hehehe&quot;, textView.getHeight() + &quot;/&quot; + textView.getWidth()); return true; &#125;&#125;); 内部实际计算过程为： height = 100 x 480 / 160 = 300px width = 200 x 480 / 160 = 600px 这是因为手机中的 /system/build.prop 文件，其中有一行是这样： ro.sf.lcd_density=480 这就指定了这个机型使用的dpi是多少。在系统中使用的全部都是系统 dpi，没有使用物理 dpi，也获取不到物理 dpi。物理 dpi 主要用于厂家对于手机的参数描述。 但是： Android屏幕设备的多样性，如果使用dp来作为度量单位，并不是所有的屏幕的宽度都具备相同的dp长度。 为什么？ 假设我们UI设计图是按屏幕宽度为360dp来设计的，那么在上述设备上，屏幕宽度其实为1080/(440/160)=392.7dp，也就是屏幕是比设计图要宽的。这种情况下， 即使使用dp也是无法在不同设备上显示为同样效果的。 同时还存在部分设备屏幕宽度不足360dp，这时就会导致按360dp宽度来开发实际显示不全的情况。 而且上述屏幕尺寸、分辨率和像素密度的关系，很多设备并没有按此规则来实现， 因此dpi的值非常乱，没有规律可循，从而导致使用dp适配效果差强人意。 所以说： dp 解决了同一数值在不同分辨率中展示相同（相似）尺寸大小的问题（即屏幕像素密度匹配问题）;没有解决设备尺寸大小匹配的问题。（即屏幕尺寸匹配问题）。 总结 因为屏幕密度（分辨率）不一样，所以不能用固定的px 因为屏幕宽度不一样，所以要小心的用dp 因为本质上是希望使得布局组件在不同屏幕密度上显示相同的像素效果，那么，之前是绕了个弯使用dp解决这个问题，==那么到底能不能直接用px解决呢==？ 1即根据不同屏幕密度，控件选择对应的像素值大小。 升级配置方式1：百分比法 以某一分辨率为基准，生成所有分辨率对应像素数列表 以某一分辨率为基准，生成所有分辨率对应像素数列表 将生成像素数列表存放在res目录下对应的values文件下 根据UI设计师给出设计图上的尺寸，找到对应像素数的单位，然后设置给控件即可 1. 以320x480的分辨率为基准： 将屏幕的宽度分为320份，取值为x1~x320。 将屏幕的高度分为480份，取值为y1~y480。 lay_x.xml（宽） 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;x1&quot;&gt;1.0px&lt;/dimen&gt; &lt;dimen name=&quot;x2&quot;&gt;2.0px&lt;/dimen&gt; &lt;dimen name=&quot;x3&quot;&gt;3.0px&lt;/dimen&gt; &lt;dimen name=&quot;x4&quot;&gt;4.0px&lt;/dimen&gt; ... &lt;dimen name=&quot;x316&quot;&gt;316.0px&lt;/dimen&gt; &lt;dimen name=&quot;x317&quot;&gt;317.0px&lt;/dimen&gt; &lt;dimen name=&quot;x318&quot;&gt;318.0px&lt;/dimen&gt; &lt;dimen name=&quot;x319&quot;&gt;319.0px&lt;/dimen&gt; &lt;dimen name=&quot;x320&quot;&gt;320px&lt;/dimen&gt;&lt;/resources&gt; lay_y.xml（高） 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;y1&quot;&gt;1.0px&lt;/dimen&gt; &lt;dimen name=&quot;y2&quot;&gt;2.0px&lt;/dimen&gt; &lt;dimen name=&quot;y3&quot;&gt;3.0px&lt;/dimen&gt; &lt;dimen name=&quot;y4&quot;&gt;4.0px&lt;/dimen&gt; ... &lt;dimen name=&quot;y480&quot;&gt;480px&lt;/dimen&gt;&lt;/resources&gt; 生成其他分辨率的文件 如：写1080x1920的分辨率 因为基准是320x480，所以 宽：1080/320=3.375px，高：1920/480=4px。 所以相应文件应该是： lay_x.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;x1&quot;&gt;3.375px&lt;/dimen&gt; &lt;dimen name=&quot;x2&quot;&gt;6.65px&lt;/dimen&gt; &lt;dimen name=&quot;x3&quot;&gt;10.125px&lt;/dimen&gt; ... &lt;dimen name=&quot;x320&quot;&gt;1080px&lt;/dimen&gt;&lt;/resources&gt; lay_y.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;y1&quot;&gt;4px&lt;/dimen&gt; &lt;dimen name=&quot;y2&quot;&gt;8px&lt;/dimen&gt; &lt;dimen name=&quot;y3&quot;&gt;12px&lt;/dimen&gt; &lt;dimen name=&quot;y4&quot;&gt;16px&lt;/dimen&gt; ... &lt;dimen name=&quot;y480&quot;&gt;1920px&lt;/dimen&gt;&lt;/resources&gt; 不同分辨率下生成不同的像素列表工具： https://github.com/hongyangAndroid/Android_Blog_Demos/tree/master/blogcodes/src/main/java/com/zhy/blogcodes/genvalues 例如：需要设置的基准是800x1280，额外支持尺寸：735x1152 ；3200x4500； java -jar 文件名.jar 800 1280 735，1152_3200,4500 2. 将生成像素数列表存放在res目录下对应的values文件下将生成像素数列表（lay_x.xml和lay_y.xml）存放在res目录下对应的values文件 注： values-480x320 是分辨率限定符 必须在 默认values 里面也创建对应 默认lay_x.xml 和 lay_y.xml 文件 lay_x.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt;&lt;resources&gt; &lt;dimen name=&quot;x1&quot;&gt;1.0dp&lt;/dimen&gt; &lt;dimen name=&quot;x2&quot;&gt;2.0dp&lt;/dimen&gt; ...&lt;/resources&gt; 对于没有生成对应分辨率文件的手机，会使用 默认values 文件夹，如果默认values文件夹没有（即没有对应的分辨率、没有对应dimen）就会报错，从而无法进行屏幕适配。 对应单位改为dp，而不同于上面的px。因为不知道机型的分辨率，所以默认分辨率文件只好默认为x1=1dp以保证尽量兼容（又回到dp老方法了），这也是这个解决方案的一个弊端. 3. 根据UI设计设计图上的尺寸，找到对应像素数的单位，设置给控件即可.123456&lt;Button android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/hello_world&quot; android:layout_width=&quot;@dimen/x160&quot; android:layout_height=&quot;@dimen/y160&quot;/&gt; 总结 使用的是 px 而非 dp ，未能使用 google 提倡的使用方式。 Material Design 提供的设计规范参考在实际开发中无法得到应用。如：间距一般为 8 的倍数，8，16，32等。 生成的 values- 文件无法动态覆盖所有机型，只能是手动编写已知机型的相关文件。 后期维护麻烦。 AutoLayout 使用 博客：https://blog.csdn.net/lmj623565791/article/details/49990941GitHub：https://github.com/hongyangAndroid/AndroidAutoLayout 作者原话： 那么首先说一下：这个1px并不代表1像素，我在内部会进行百分比化处理，也就是说：720px高度的屏幕，你这里填写72px，占据10%；当这个布局文件运行在任何分辨率的手机上，这个72px都代表10%的高度，这就是本库适配的原理。 根据设计图的 px 数值直接填写到 xml 的标签中。 分析 AutoLayout的使用方式之一就是在xml文件中的控件标签中直接使用com.zhy.autolayout.AutoLinearLayout。所以在AutoAttr 类中：比较auto字符串 1boolean log = view.getTag() != null &amp;&amp; view.getTag().toString().equals(&quot;auto&quot;); ScreenUtils 类，设备宽、高数据的获取： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ScreenUtils&#123; public static int getStatusBarHeight(Context context) &#123; int result = 0; try &#123; int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; result = context.getResources().getDimensionPixelSize(resourceId); &#125; &#125; catch (Resources.NotFoundException e) &#123; e.printStackTrace(); &#125; return result; &#125; public static int[] getScreenSize(Context context, boolean useDeviceSize) &#123; int[] size = new int[2]; WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); Display d = w.getDefaultDisplay(); DisplayMetrics metrics = new DisplayMetrics(); d.getMetrics(metrics);// since SDK_INT = 1; int widthPixels = metrics.widthPixels; int heightPixels = metrics.heightPixels; if (!useDeviceSize) &#123; size[0] = widthPixels; size[1] = heightPixels - getStatusBarHeight(context); return size; &#125;// includes window decorations (statusbar bar/menu bar) if (Build.VERSION.SDK_INT &gt;= 14 &amp;&amp; Build.VERSION.SDK_INT &lt; 17) try &#123; widthPixels = (Integer) Display.class.getMethod(&quot;getRawWidth&quot;).invoke(d); heightPixels = (Integer) Display.class.getMethod(&quot;getRawHeight&quot;).invoke(d); &#125; catch (Exception ignored) &#123; &#125;// includes window decorations (statusbar bar/menu bar) if (Build.VERSION.SDK_INT &gt;= 17) try &#123; Point realSize = new Point(); Display.class.getMethod(&quot;getRealSize&quot;, Point.class).invoke(d, realSize); widthPixels = realSize.x; heightPixels = realSize.y; &#125; catch (Exception ignored) &#123; &#125; size[0] = widthPixels; size[1] = heightPixels; return size; &#125;&#125; AutoLayoutConifg类，自己设置的宽、高数据的获取： 获取在AndroidManifest.xml文件中获取的设置宽、高参数： 123456789101112private void getMetaData(Context context)&#123; ... applicationInfo = packageManager.getApplicationInfo(context .getPackageName(), PackageManager.GET_META_DATA); if (applicationInfo != null &amp;&amp; applicationInfo.metaData != null) &#123; mDesignWidth = (int) applicationInfo.metaData.get(KEY_DESIGN_WIDTH); mDesignHeight = (int) applicationInfo.metaData.get(KEY_DESIGN_HEIGHT); &#125; ...&#125; AutoLayoutConifg类在 AutoLayoutHelper 、AutoUtils 、UseDeviceSizeApplication 中被调用 在 AutoUtils 中的作用为： 1会直接将view的LayoutParams上设置的width，height直接进行百分比处理 在UseDeviceSizeApplication中进行Application初始化操作： 123456789public class UseDeviceSizeApplication extends Application&#123; @Override public void onCreate() &#123; super.onCreate(); AutoLayoutConifg.getInstance().useDeviceSize().init(this); &#125;&#125; 在AutoLayoutHelper中进行初始化和检查操作 123456789101112private void initAutoLayoutConfig(ViewGroup host)&#123; mAutoLayoutConifg = AutoLayoutConifg.getInstance(); mAutoLayoutConifg.init(host.getContext());&#125;public void adjustChildren()&#123; AutoLayoutConifg.getInstance().checkParams(); ...&#125; AutoLayoutHelper在AutoLinearLayout中的作用： 1234567@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)&#123; if (!isInEditMode()) mHelper.adjustChildren(); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; AutoLayoutActivity的作用： 12345678910111213141516171819202122232425public class AutoLayoutActivity extends FragmentActivity &#123; private static final String LAYOUT_LINEARLAYOUT = &quot;LinearLayout&quot;; private static final String LAYOUT_FRAMELAYOUT = &quot;FrameLayout&quot;; private static final String LAYOUT_RELATIVELAYOUT = &quot;RelativeLayout&quot;; @Override public View onCreateView(String name, Context context, AttributeSet attrs) &#123; View view = null; if (name.equals(LAYOUT_FRAMELAYOUT)) &#123; view = new AutoFrameLayout(context, attrs); &#125; if (name.equals(LAYOUT_LINEARLAYOUT)) &#123; view = new AutoLinearLayout(context, attrs); &#125; if (name.equals(LAYOUT_RELATIVELAYOUT)) &#123; view = new AutoRelativeLayout(context, attrs); &#125; if (view != null) return view; return super.onCreateView(name, context, attrs); &#125;&#125; 是做了name的判断，如果是属性中的3中Layout，会自动替换成对应的AutoXXXLayout LinearLayout -&gt; AutoLinearLayout RelativeLayout -&gt; AutoRelativeLayout FrameLayout -&gt; AutoFrameLayout 如果不是，直接调用父类的View onCreateView（String name，Context context，AttributeSet attrs）。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存相关]]></title>
    <url>%2FAndroid%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Android内存总结 参考：https://www.cnblogs.com/lenkevin/p/5484610.html Android App为什么会OOM呢？其实就是申请的内存超过了Dalvik Heap的最大值。 Android常见内存问题：内存的溢出是内存分配达到了最大值；而内存泄漏是无用内存充斥了内存堆。 Android内存分配回收机制Anroid基于进程中运行的组件及其状态规定了默认的五个回收优先级： Empty process(空进程) Background process(后台进程) Service process(服务进程) Visible process(可见进程) Foreground process(前台进程) 系统需要进行内存回收时最先回收空进程,然后是后台进程，最后才会回收前台进程。Android中由ActivityManagerService 集中管理所有进程的内存资源分配。 内存泄漏与内存溢出1. 内存泄露 单例（主要原因还是因为一般情况下单例都是全局的，有时候会引用一些实际生命周期比较短的变量，导致其无法释放） 静态变量（同样也是因为生命周期比较长） Handler内存泄露[7] 匿名内部类（匿名内部类会引用外部类，导致无法释放，比如各种回调） 资源使用完未关闭（BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap） 2. 图片相关 分辨率：将图片放到hdpi/xhdpi/xxhdpi等不同文件夹进行适配。 压缩：BitmapFactory 在解码图片时，可以带一个Options。 资源文件需要选择合适的文件夹进行存放 3. 内存抖动Android里内存抖动是指内存频繁地分配和回收，而频繁的gc会导致卡顿，严重时还会导致OOM。因为大量小的对象频繁创建，导致内存碎片，从而当需要分配内存时，虽然总体上还是有剩余内存可分配，而由于这些内存不连续，导致无法分配，系统直接就返回OOM了。 4. 注意监听器的注销在Android程序里面存在很多需要register与unregister的监听器，需要确保在合适的时候及时unregister那些监听器。自己手动add的listener，需要记得及时remove这个listener。 5. 注意WebView的泄漏为WebView开启另外一个进程，通过AIDL与主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。 6. 注意Cursor对象是否及时关闭在程序中经常会进行查询数据库的操作，但时常会存在不小心使用Cursor之后没有及时关闭的情况。这些Cursor的泄露，反复多次出现的话会对内存管理产生很大的负面影响，需要对Cursor对象的及时关闭。 7. 优化布局层次，减少内存消耗越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的View无法实现足够扁平的时候考虑使用自定义View来达到目的。 工具1. LeakCanary使用参考 https://github.com/square/leakcanaryhttps://blog.csdn.net/wolinxuebin/article/details/52766817https://www.jianshu.com/p/1e7e9b576391 MAT使用参考 https://blog.csdn.net/itachi85/article/details/77075455]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IPC]]></title>
    <url>%2FAndroid-IPC%2F</url>
    <content type="text"><![CDATA[Android IPC 总结 1. IPC简介IPC（Inter-Process Communication）进程间通信/跨进程通信。指两个进程之间进行数据交换。 名称 描述 进程 一个执行单元；在Android中指一个一个程序或一个App；包含多个线程 线程 是CPU最小的调度单元；是一种有限的系统资源 在Android中：主线程也叫UI主线程，在UI主线程才能操作界面。 如果在UI主线程中进行大量耗时任务就会造成界面无法响应——ANR（Application Not Responding）。为耗时任务开辟新线程将会解决此问题。 在Android中：最有特色的进程间通信方式为：Binder，Socket、ContentProvider也可实现。 2. Android 多进程模式一般情况下，Android中的多进程是指 同一个应用中存在多个进程 的情况。 2.1 开启多进程1. 查看进程列表 参考：https://blog.csdn.net/moonshine2016/article/details/53422082 可使用 ： 1adb shell ps 进行查看。 Android系统会为每一个应用分配一个唯一的UID。具有相同UID并且相同签名的应用才能共享数据。 在Android中使用多进程只有一种方法，就是给四大组件的 AndroidManifest.xml 文件中设置 android:process=&quot;:remote&quot; 属性。 2. 开启方式 android:process=”:remote” 简写。是指要在当前进程名前附加当前包名。完整进程名为：com.exaple:remote 私有进程，其他应用组件不能和它跑在一个进程。 android:process=”com.exaple.remote” 完整的命名方式。 全局进程，其他应用可通过 ShareUID 运行在同一个进程中。 实际使用场景：百度地图。 在AndroidManifest.xml文件中，需要配置： 12345&lt;service android:name=&quot;com.baidu.location.f&quot; android:enabled=&quot;true&quot; android:process=&quot;:remote&quot; android:screenOrientation=&quot;portrait&quot;/&gt; 2.2 多进程的运行机制使用多进程带来的问题 - 内存导致 多进程带来的主要影响： 开启多进程的方式很简单，但是实际运行会出很多问题，绝非仅仅只是 android:process=&quot;:remote&quot; 那么简单。 Android为每一个应用（进程）分配一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间这就导致不同的虚拟机在访问同一个类的对象时，会产生多个副本，副本之间互不影响，即：修改了一个进程A中的对象的属性值后，进程B中同一个对象的属性值仍为修改之前的值。 所以，运行在 不同进程 中的四大组件，通过内存来 共享数据 都会失败 使用对进城会造成一下几个问题： 静态成员 + 单例模式完全失效 线程同步机制完全失效 不是一块内存，那么不管锁定的是对象还是全局类都无法保证线程同步，不同进程，不是同一块内存。 SharedPreference可靠性下降 SharedPreference 不支持2个进程同时去执行读/写操作，否则会导致一定几率的数据丢失，因为SharedPreference是通过 XML文件实现的。 Application多次创建 运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的，运行在不同进程中的组件拥有同的虚拟机和不同的Application及内存空间。 多进程模式的本质 同一个应用间的多进程就相当于：两个不同的应用采用SharedUID的模式 3. IPC基础概念 Serializable接口 Parcelable接口 Binder 3.1. Parcelable和Serializable3.1.1 的区别 参考：https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html参考：https://www.jianshu.com/p/a60b609ec7e7 这两个都是和序列化相关的接口。 Serializable只需要对某个类以及它的属性实现Serializable 接口即可。Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。 缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。 Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。 3.1.2 序列化、反序列化是什么？ 对象的序列化：Java对象 转化为 字节流 的过程； 对象的反序列化：字节流 转化为 Java对象 的过程。 3.1.3 两者区别是什么? Serializable 的作用是为了保存对象的属性到本地文件、数据库、网络流以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。 Android的 Parcelable 的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。 3.1.4 效率及选择？Parcelable的性能比Serializable好，在内存开销方面较小，所以在 内存间数据传输 时推荐使用Parcelable，如activity间传输数据，而Serializable可将数据持久化方便保存，所以在需要 保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。 3.1.5 Java 序列化中的一些高级认识 序列化 ID 问题 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（即：private static final long serialVersionUID = 1L） 静态变量序列化问题代码 12345678910111213141516171819202122232425262728293031323334public class Test implements Serializable &#123; private static final long serialVersionUID = 1L; public static int staticVar = 5; public static void main(String[] args) &#123; try &#123; //初始时staticVar为5 ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); out.writeObject(new Test()); out.close(); //序列化后修改为10 Test.staticVar = 10; ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); Test t = (Test) oin.readObject(); oin.close(); //再读取，通过t.staticVar打印新的值 System.out.println(t.staticVar); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。这个 System.out.println(t.staticVar) 语句输出的是 10。 之所以打印 10 的原因在于：序列化时并不保存静态变量。 这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。 3.1.6 父类的序列化与 Transient 关键字 情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。 解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。 Transient 关键字 其作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 除了使用 Transient 关键字可以使得字段不被序列化，还可以根据父类对象序列化的规则，将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化 上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient。 对敏感字段加密 情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单 3 展示了这个过程。 3.1.7 序列化存储规则1234567891011121314151617181920ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); Test test = new Test(); //试图将对象两次写入文件 out.writeObject(test); out.flush(); System.out.println(new File(&quot;result.obj&quot;).length()); out.writeObject(test); out.close(); System.out.println(new File(&quot;result.obj&quot;).length()); ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); //从文件依次读出两个文件 Test t1 = (Test) oin.readObject(); Test t2 = (Test) oin.readObject(); oin.close(); //判断两个引用是否指向同一个对象 System.out.println(t1 == t2); 对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。 一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如图: 第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是因为Java 序列化机制为了节省磁盘空间，具有特定的存储规则： 当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。 3.2 Binder BInder是Android中的一个类，实现了IBinder接口。 从IPC角度而言：BInder是Android中一种跨进程间通信的方式。 从Android应用层来说，BInder是客户端和服务端进行通信的媒介，当bindService()时，客户端可以接受服务端提供的服务或者数据。 从Android的Framework层来说，BInder是ServiceManager连接各种Manager和响应ManagerService的桥梁。 Android开发中，Binder主要用在Service中，包括AIDL（Android Interface Definition Language）和Messenger。普通Service中的Binder不涉及进程间通信。而Messenger底层是AIDL。 AIDL使用参考：https://blog.csdn.net/JoneRen/article/details/72885807要点：虽然在同一个包内，但是依然要手动导包，这是aidl的特殊之处。 详细示例查阅《Android开发艺术探索》P47-P61 4. IPC方式 Bundle 共享文件 Messager AIDL ContentProvider Socket 4.1 Bundle四大组件中，Activity、Service、Receiver都支持在Intent中传递Bundle数据，Bundle实现了Parcelable接口，方便在不同进程间传输。 特点： 典型：最简单的进程间通信方式。 特殊： 如：A进程进行计算，计算结束后启动B进程的一个组件并把结果传递给B进程，但是问题是这个计算结果不能放入Bundle中，无法使用Intent进行传递。 一个简单的实现方案是：使用Intnent启动进程B的Service组件，在Service中进行计算，计算完毕后再启动B进程真正需要启动的组件。因为Service也在进程B中，所以目标组件可以直接获取数据。 核心思想是：将A进程中的计算任务转移至B进程中的Service中进行。避免了进程间通信。 4.2 共享文件两个进程通过读/写同一个文件来交换数据。 特点： 并发读/写问题。所以此方式适合对数据同步要求不高的进程之间的通信，切要妥善处理读/写并发问题 不建议使用 SharedPreference。 4.3 Messager是一种轻量级的IPC解决方法。 通过 Messenger 可以在不同进程中传递Message对象，在 Message 中放入我们需要传递的数据即可。其底层是现实AIDL。 特点： 其一次处理一个请求，无需考虑线程同步问题，服务端不存在并发执行。 Messenger 的具体实现分为：客户端、服务端。 特点： Messenger 是以串行方式处理客户端发送的数据，如果有大量并发请求信息，那么使用 Messenger 则不合适。 Messenger 作用是主要是传递消息，要跨进程调用 服务端 方法时，则 Messenger无法做到。 4.4 AIDL支持的数据类型： 基本数据类型：4类8种 String 和 CharSequence List：只支持ArrayList，里面每个元素都必须能够被AIDL支持。 Map：只支持HashMap，里面每个元素都必须能够被AIDL支持，包括 key 和 value。 Parcelable：所有实现了Parcelable接口的对象。 AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。 注意： 自定义的Parcelable对象和AIDL对象必须要显示的import进来，无论是否和当前的AIDL文件在同一个包中。 如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和他同名的AIDL文件，并在其中将其声明为Parcelable类型。 AIDL中只支持方法，不支持声明静态变量。 AIDL的包结构在客户端和服务端要保持一致，否则出错，因为客户端要反序列化服务端中和AIDL接口相关的所有类 AIDL中除了基本数据类型之外，其他参数类型必须标上方向： in：输入型参数 out：输出型参数 inout：输入输出型参数 不能一概使用 inout，因为这在底层实现是有开销的。 实现过程： 服务端 客户端 4.5 ContentProvider4.6 Socket]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 迭代模式Iterator]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8FIterator%2F</url>
    <content type="text"><![CDATA[参考《Head First 设计模式》 封装变化 定义：迭代器模式提供一种方法：顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示。 迭代器模式源于对容器的访问，比如 Java 中的 List、Map、数组等。 使用场景： 访问一个聚合中的对象，而不需要暴露其内部的具体表示 对不同类型聚合中对象的进行遍历，提供统一的接口。 示例代码结构 示例 有两份“菜单”，其中一份是“List”结构，另一份的是“Array”结构，要在一个类中定义一个方法，在这个方法中：将两种不同结构的数据进行遍历输出。 以下为代码实现，测试结果见最下方。 对象类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MenuItem &#123; String name; String description; boolean vegerarian; double price; public MenuItem(String name, String description, boolean vegerarian, double price) &#123; this.name = name; this.description = description; this.vegerarian = vegerarian; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public boolean isVegerarian() &#123; return vegerarian; &#125; public void setVegerarian(boolean vegerarian) &#123; this.vegerarian = vegerarian; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125;&#125; 1.1 原始实现数组菜单1234567891011121314151617181920212223242526272829public class DinerMenu &#123; private static final int MAX_ITEMS = 4; private int numberOfItems = 0; private MenuItem[] menuItems; public DinerMenu() &#123; menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 1&quot;, true, 2.99); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 2&quot;, true, 1.97); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 3&quot;, true, 7.23); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 4&quot;, true, 5.56); &#125; private void addItem(String name, String description, boolean vegerarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegerarian, price); if (numberOfItems &gt;= MAX_ITEMS) &#123; System.out.println(&quot;has over!&quot;); &#125; else &#123; menuItems[numberOfItems] = menuItem; numberOfItems++; &#125; &#125; public MenuItem[] getMenuItems() &#123; return menuItems; &#125;&#125; List菜单12345678910111213141516171819202122public class PancakeHouseMenu &#123; private ArrayList&lt;MenuItem&gt; menuItems; public PancakeHouseMenu() &#123; menuItems = new ArrayList&lt;&gt;(); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 1&quot;, true, 2.99); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled fresh, tost - 2&quot;, true, 9.91); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 3&quot;, false, 4.29); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 4&quot;, true, 3.19); &#125; private void addItem(String name, String description, boolean vegerarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegerarian, price); menuItems.add(menuItem); &#125; public ArrayList&lt;MenuItem&gt; getMenuItems() &#123; return menuItems; &#125;&#125; 遍历菜单的 Waitress 类123456789101112131415161718192021222324252627282930public class Waitress &#123; private PancakeHouseMenu pancakeHouseMenu; private DinerMenu dinerMenu; public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; public void printMenu() &#123; ArrayList&lt;MenuItem&gt; arrayList = pancakeHouseMenu.getMenuItems(); MenuItem[] menuItems = dinerMenu.getMenuItems(); for (int i = 0; i &lt; arrayList.size(); i++) &#123; MenuItem menuItem = arrayList.get(i); System.out.print(menuItem.getName() + &quot; &quot;); System.out.print(menuItem.getPrice() + &quot; &quot;); System.out.println(menuItem.getDescription()); &#125; for (int i = 0; i &lt; menuItems.length; i++) &#123; MenuItem menuItem = menuItems[i]; System.out.print(menuItem.getName() + &quot; &quot;); System.out.print(menuItem.getPrice() + &quot; &quot;); System.out.println(menuItem.getDescription()); &#125; &#125;&#125; 测试1234567891011public class TestMain &#123; public static void main(String[] args) &#123; PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu(); DinerMenu dinerMenu = new DinerMenu(); Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu); waitress.printMenu(); &#125;&#125; UML类图 存在问题需要优化、修改就是 printMenu() 方法，2个方面。 暴露了具体的遍历过程 有相似、重复的代码 1.2 对 printMenu() 方法进行优化、去重自定义一个接口，封装 printMenu() 中的遍历操作123456public interface Iterator &#123; boolean hasNext(); Object next();&#125; 2个菜单分别实现 遍历接口数组菜单12345678910111213141516171819202122232425public class DinerMenuIterator implements Iterator &#123; MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if (position &gt;= items.length || items[position] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; MenuItem menuItem = items[position]; position++; return menuItem; &#125;&#125; List菜单12345678910111213141516171819202122232425public class PancakeHouseMenuIterator implements Iterator &#123; private int position = 0; private ArrayList&lt;MenuItem&gt; arrayList; public PancakeHouseMenuIterator(ArrayList&lt;MenuItem&gt; arrayList) &#123; this.arrayList = arrayList; &#125; @Override public boolean hasNext() &#123; if (position &gt;= arrayList.size() || arrayList.get(position) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; MenuItem menuItem = arrayList.get(position); position++; return menuItem; &#125;&#125; 在 Waitress类 中调用 遍历接口1234567891011121314151617181920212223242526272829public class Waitress &#123; private PancakeHouseMenu pancakeHouseMenu; private DinerMenu dinerMenu; public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; public void printMenu() &#123; Iterator panckIterator = pancakeHouseMenu.createIterator(); Iterator dinerIterator = dinerMenu.createIterator(); System.out.println(&quot;panck menu is :&quot;); doIterator(panckIterator); System.out.println(&quot;diner menu is :&quot;); doIterator(dinerIterator); &#125; private void doIterator(Iterator iterator) &#123; while (iterator.hasNext()) &#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.print(menuItem.getName() + &quot; &quot;); System.out.print(menuItem.getPrice() + &quot; &quot;); System.out.println(menuItem.getDescription()); &#125; &#125;&#125; 测试1234567891011public class IteratorMain &#123; public static void main(String[] args) &#123; DinerMenu dinerMenu = new DinerMenu(); PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu(); Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu); waitress.printMenu(); &#125;&#125; UML类图 存在问题在 Waitress 中： 1234567private PancakeHouseMenu pancakeHouseMenu;private DinerMenu dinerMenu;public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu;&#125; 可以发现，2个菜单的 遍历实现接口 完全一样， 但是没有为2个菜单设计一个共同的接口，目前2个菜单的还是独立的：PancakeHouseMenu、DinerMenu。 若2个菜单拥有共同的接口，在 Waitress 类中的代码更为简洁，面向对象中 多态 的 特性也得到体现。 1.3 使用 java.util.Iterator 作为共同接口定义一个共同的接口在 共同接口 Menu 中，定义一个方法使用 java.util.Iterator，实现 Iterator。 123public interface Menu &#123; public Iterator createIterator();&#125; 两个菜单分别实现 Menu 接口。PancakeHouseMenu12345678910111213141516171819202122232425262728public class PancakeHouseMenu implements Menu &#123; private ArrayList&lt;MenuItem&gt; menuItems; public PancakeHouseMenu() &#123; menuItems = new ArrayList&lt;&gt;(); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 1&quot;, true, 2.99); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled fresh, tost - 2&quot;, true, 9.91); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 3&quot;, false, 4.29); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 4&quot;, true, 3.19); &#125; private void addItem(String name, String description, boolean vegerarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegerarian, price); menuItems.add(menuItem); &#125; public ArrayList&lt;MenuItem&gt; getMenuItems() &#123; return menuItems; &#125; // 调用 java.util.Iterator 接口 @Override public Iterator createIterator() &#123; return menuItems.iterator(); &#125;&#125; 其中，在 PancakeHouseMenu 类中通过使用ArrayList已经实现的Iterator来实现 createIterator()。 DinerMenu1234567891011121314151617181920212223242526272829303132333435public class DinerMenu implements Menu &#123; private static final int MAX_ITEMS = 4; private int numberOfItems = 0; private MenuItem[] menuItems; public DinerMenu() &#123; menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 1&quot;, true, 2.99); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 2&quot;, true, 1.97); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 3&quot;, true, 7.23); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 4&quot;, true, 5.56); &#125; private void addItem(String name, String description, boolean vegerarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegerarian, price); if (numberOfItems &gt;= MAX_ITEMS) &#123; System.out.println(&quot;has over!&quot;); &#125; else &#123; menuItems[numberOfItems] = menuItem; numberOfItems++; &#125; &#125; public MenuItem[] getMenuItems() &#123; return menuItems; &#125; // 将 getMenuItems 修改为此方法。 @Override public Iterator createIterator() &#123; return new DinerMenuIterator(menuItems); &#125;&#125; 其中，此处的 createIterator() 方法 类 DinerMenuIterator() 是继承 Iterator 后，自定义实现的内部细节。 DinerMenuIterator 类的实现12345678910111213141516171819202122232425public class DinerMenuIterator implements Iterator &#123; MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if (position &gt;= items.length || items[position] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; MenuItem menuItem = items[position]; position++; return menuItem; &#125;&#125; 执行具体遍历的类：Waitress1234567891011121314151617181920212223242526272829public class Waitress &#123; private Menu pancakeHouseMenu; private Menu dinerMenu; public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; public void printMenu() &#123; Iterator panckIterator = pancakeHouseMenu.createIterator(); Iterator dinerIterator = dinerMenu.createIterator(); System.out.println(&quot;panck menu is :&quot;); doIterator(panckIterator); System.out.println(&quot;diner menu is :&quot;); doIterator(dinerIterator); &#125; private void doIterator(Iterator iterator) &#123; while (iterator.hasNext()) &#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.print(menuItem.getName() + &quot; &quot;); System.out.print(menuItem.getPrice() + &quot; &quot;); System.out.println(menuItem.getDescription()); &#125; &#125;&#125; 测试12345678910public class ClassMain &#123; public static void main(String[] args) &#123; Menu dinerMenu = new DinerMenu(); Menu pancakeHouseMenu = new PancakeHouseMenu(); Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu); waitress.printMenu(); &#125;&#125; 对比 UML类图 1.4 3个版本的测试结果12345678910panck menu is :K&amp;B&apos;s Pancake Breakfast 2.99 Panackes with scrambled eggs, tost - 1K&amp;B&apos;s Pancake Breakfast 9.91 Panackes with scrambled fresh, tost - 2K&amp;B&apos;s Pancake Breakfast 4.29 Panackes with scrambled eggs, tost - 3K&amp;B&apos;s Pancake Breakfast 3.19 Panackes with scrambled eggs, tost - 4diner menu is :Frank&apos;s Pancake Diner 2.99 Fruits with scrambled juice - 1Frank&apos;s Pancake Diner 1.97 Fruits with scrambled juice - 2Frank&apos;s Pancake Diner 7.23 Fruits with scrambled juice - 3Frank&apos;s Pancake Diner 5.56 Fruits with scrambled juice - 4]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-4]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4%2F</url>
    <content type="text"><![CDATA[参考：https://blog.csdn.net/u010297957/article/details/51974340 哈希(Hash，也翻译为：散列)1. 名词释义 哈希算法：指的是一类算法； 哈希函数：在 关键字 和 存储位置 之间建立一个 确定的对应关系 f，此关系使得每个关键字和结构中一个唯一的存储位置对应。此函数称为 哈希函数。形式大概就是 value = hash(key)。 哈希表（Hash table，也叫散列表）：由哈希函数构建的表就是哈希表。更为严谨的表示：根据设定的 哈希函数H(key) 和 处理冲突的方法，将 一组关键字 映像（通过H(key)）到一个 有限的连续的地址集（区间）上，并以关键字在地址集中的 映像（通过H(key)的值 作为记录在表中的 存储位置。 冲突：不同的关键字得到得到同一哈希地址。即： k1 != k2，但是 f(k1) = f(k2)。 2. 用处 加密： Hash哈希是把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做HASH值，Hash函数逼近单向函数，所以可以用来对数据进行加密。最广泛应用的Hash算法有MD4、MD5、SHA1。 压缩： Hash哈希是指 把一个大范围映射到一个小范围，往往是为了节省空间，使得数据容易保存。 2. 哈希表(Hash Table)2.1 查找问题：线性表、树这些结构中，记录 在 结构 中的相对位置是随机的，位置和记录的关键字之间不存在确定关系。因此，在结构中查找时需要进行一系列和关键字的比较，即：这一类查找方法建立在比较的基础上。 理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的 存储位置 和它的 关键字之间建立一个 确定的关系f ，使每个关键字和结构中一个唯一的存储位置相对应。 哈希表是通过 对应关系f 由 键来找到要查询的值，这是它区别于 比较 查询法的最大不同。 2.3 常用的Hash函数 构造方法： 平方取中法： 先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。 折叠法： 将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。 随机数法： 选择一个随机函数，取关键字的随机函数值作为Hash地址，通常用于关键字长度不同的场合。即f(key)=random(key)特点：通常，关键字长度不相等时，采用此法构建Hash函数 较为合适。 除留取余法： f(k)=k mod p ， p&lt;=m取关键字被某个不大于Hash表 长m 的数p 除后所得的余数为Hash地址 。 特点：这是最简单也是最常用的Hash函数构造方法。可以直接取模，也可以在平法法、折叠法之后再取模。 值得注意的是，在使用除留取余法 时，对p 的选择很重要，如果p 选的不好会容易产生同义词。由经验得知：p 最好选择不大于表长m 的一个质数、或者不包含小于20的质因数的合数。 2.4 处理冲突处理冲突：假设哈希表的地址集为 : 0−(n−1) ，那么 冲突 是指 : 由关键字得到的哈希地址为 j(0≤j≤n−1) 的位置上已存有记录，而 处理冲突 : 就是为该关键字的记录找到另一个 空的哈希地址 。]]></content>
      <categories>
        <category>温故知新</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解、反射]]></title>
    <url>%2FJava%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考：https://blog.csdn.net/wzgiceman/article/details/53406248参考：https://blog.csdn.net/wzgiceman/article/details/53483665参考：https://www.cnblogs.com/be-forward-to-help-others/p/6846821.html参考：https://blog.csdn.net/BabyGoodMorning/article/details/76349855 使用注解的作用 更早的发现程序的问题或者错误 更好的增加代码的描述能力 更加利于我们的一些规范约束 0. 注解：Annotation在Java中，注解(Annotation)引入始于Java5，用来描述Java代码的元数据，通常情况下注解不会直接影响代码的执行，尽管有些注解可以用来做到影响代码执行。 Annotation 是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，程序开发人员可以在不改变原有逻辑的情况下，在源文件嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation 提供了一条为程序元素设置元数据的方法，从某些方面来看，Annotation就像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被存储在Annotation的“name=value”对中。 需要指出的是：Annotation不能影响程序代码的执行，无论增加、删除Annotation，代码都始终如一地执行。如果希望让程序中的Annotation能在运行时起一定的作用，只有通过某种配套的工具对Annotation中的信息进行访问的处理，访问和处理Annotation的工具统称APT（Annotation Processing Tool）。 0.1 元数据（MetaData） 参考：http://www.ruanyifeng.com/blog/2007/03/metadata.html 元数据是用来描述数据的数据（Data that describes other data）。 一个列子： 一张RAW格式的数码照片，我们直接看到的照片是数据，而看不到的附加EXIF信息则是对于照片的额外描述。此时EXIF信息就是照片的元数据。级：EXIF信息是描述照片本身之外的数据。 0.2 java从源码到运行有3个阶段： source class runtime 0.3 功能 生成文档。这是最常见的，也是 java 最早提供的注解。常用的有 @param @return 等。 跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都 使用了这种配置来减少配置文件的数量 在编译时进行格式检查。如 @override 0.4 Java内置注解 @Deprecated @Override @SuppressWarnings @Deprecated：已过时这个注释是一个标记注释。所谓标记注释，就是在源程序中加入这个标记后，并不影响程序的编译，但有时编译器会显示一些警告信息。 @Override：限定重写父类的方法@SuppressWarnings：抑制编译器警告当我们的一个方法调用了弃用的方法或者进行不安全的类型转换，编译器会生成警告。我们可以为这个方法增加@SuppressWarnings注解，来抑制编译器生成警告可以修饰的元素为类，方法，方法参数，属性，局部变量 0.5 注解类型（元Annotation） @Documented @Inherited @Retention @Target @Documented：表示含有该注解类型的元素(带有注释的)会通过javadoc或类似工具进行文档化该类型应用于注解那些影响客户使用带注释(comment)的元素声明的类型。如果类型声明是用Documented来注解的，这种类型的注解被作为被标注的程序成员的公共API @Inherited：表示注解类型能被自动继承如果用户在当前类中查询这个元注解类型并且当前类的声明中不包含这个元注解类型，那么也将自动查询当前类的父类是否存在Inherited元注解，这个动作将被重复执行知道这个标注类型被找到，或者是查询到顶层的父类。 即：如果某个类使用了A Annotation（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动具有A注释。 eg: 12345678@Documented@Inheritedpublic @interface Ety &#123; @Deprecated String value(); @Deprecated String name();&#125; @Retention：表示该注解类型的注解保留的时长当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留方式 name explain SOURCE 注解仅存在于源码中，在class字节码文件中不包含 CLASS 存在Java源文件，以及经编译器后生成的Class字节码文件，但在运行时VM不再保留注释 RUNTIME 存在源文件、编译生成的Class字节码文件，以及保留在运行时VM中，可通过反射性地读取注解 eg: 123456789@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface Ety &#123; @Deprecated String value(); @Deprecated String name();&#125; @Target：表示注解类型所适用的程序元素的种类当注解类型声明中没有@Target元注解，则默认为可适用所有的程序元素。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素 ElementType explain TYPE 类、接口（包括注解类型）或枚举声明 CONSTRUCTOR 构造方法声明 PACKAGE 包声明 LOCAL_VARIABLE 局部变量声明 METHOD 方法声明 ANNOTATION_TYPE 注解类型声明 PARAMETER 参数声明 FIELD 字段声明（包括枚举常量） 0.6 自定义Annotation0.6.1 自定义自定义方式 1 ：无成员变量 定义新的Annotation类型使用@interface关键字，它用于定义新的Annotation类型。定义一个新的Annotation类型与定义一个接口非常像，如下代码可定义一个简单的Annotation： 12345@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface AValue &#123;&#125; 自定义方式 2 ：有成员变量 Annotation还可以带成员变量，Annotation的成员变量在Annotation定义中以无参数方法的形式声明。其方法名和返回值定义了该成员的名字和类型。如下代码可以定义一个有成员变量的Annotation： 123456@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface AValue &#123; int value();&#125; 自定义方式 3 ：有成员变量 123456@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface AValue &#123; int value() default 90;&#125; 0.6.2 使用定义了该Annotation之后，就可以在程序任何地方来使用该Annotation，使用Annotation时的语法非常类似于public、final这样的修饰符。通常可用于修饰程序中的类、方法、变量、接口等定义，通常我们会把Annotation放在所有修饰符之前，而且由于使用Annotation时可能还需要为其成员变量指定值，因而Annotation长度可能比较长，所以通常把Annotation另放一行，如下程序所示： 123456789101112public class MyBean &#123; @AValue(value = 48) private int valueDeal; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;valueDeal=&quot; + valueDeal + &apos;&#125;&apos;; &#125;&#125; 1. 反射：提取 Annotation 的信息Annotation接口是所有Annotation类型的父接口。 Java在java.lang.reflect包下有AnnotateElement接口，该接口代表程序中可以接受注释的程序元素，该接口主要有如下几个实现类（注意以下是类）： Package：类的包定义。 Class：类定义。 Constructor：构造器定义。 Field：类的成员变量定义。 Method：类的方法定义。 java.lang.reflect包下主要包含一些实现反射功能工具类，实际上，java.lang.reflect包提供的反射API扩充了读取运行时Annotation的能力。当一个Annotation类型被定义为运行时Annotation后，该注解才是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。 AnnotatedElement接口是所有程序元素（如Class、Method、Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象（如Class、Method、Constructor）之后，程序就可以调用该对象的如下三个方法来访问Annotation信息： getAnnotation(Class annotationClass); //返回该程序元素上存在的、指定类型的注释，如果该类型的注释不存在，则返回null。 Annotation[] getAnnotations(); //返回该程序元素上存在的所有注释。 boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass); //判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。 1.1 Field 注解、反射1234567891011/** * @author wenjia.Cheng cwj1714@163.com * @date 2018/5/31 * 生成一个 自定义注解 */@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface AValue &#123; int value();&#125; 123456789101112131415161718/** * @author wenjia.Cheng cwj1714@163.com * @date 2018/5/31 * 使用注解的类 */public class MyBean &#123; @AValue(value = 48) private int valueDeal; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;valueDeal=&quot; + valueDeal + &apos;&#125;&apos;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author wenjia.Cheng cwj1714@163.com * @date 2018/5/31 * 反射、注解的使用 */public class MainTest &#123; /** * bingo ： 反射 reflect * 首先反射注解，那么保留策略必须是Runtime，也就是@Retention(RetentionPolicy.RUNTIME) * @param args . */ public static void main(String[] args) &#123; try &#123; // 获取成员变量 Field field = MyBean.class.getDeclaredField(&quot;valueDeal&quot;); System.out.println(&quot;field is : &quot; + field.toString()); // 设置此元素可访问 field.setAccessible(true); // 判断此元素是否是AValue中的注解 if (field.isAnnotationPresent(AValue.class)) &#123; // 获取定义在 MyBean类 中的 成员变量 所属的注解 AValue AValue aValue = field.getAnnotation(AValue.class); // 从 AValue 中获取 value 属性的值 int valueRel = aValue.value(); // 将获取到的 数值 赋值到 具体使用注解的类中 MyBean myBean = new MyBean(); field.setInt(myBean, valueRel); //验证结果 System.out.println(myBean); &#125; else &#123; System.out.println(&quot;不是&quot;); &#125; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果 1234/** * 当 定义为：int value() default 100; 调用为：@AValue()/@AValue时 ：MyBean&#123;valueDeal=100&#125; * 当 定义为：int value() default 100;或者 int value(); 调用为：@AValue(48)/@AValue(value = 48)时 ：MyBean&#123;valueDeal=48&#125; */ 1.2 Method 注解、反射自定义注解 123456789@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Login &#123; String username() default &quot;zhangsan&quot;; String password() default &quot;123456&quot;;&#125; 反射 1234567891011121314151617181920212223242526272829303132public class MethoidMainTest &#123; @Login public void info()&#123; &#125; public static void main(String[] args) throws NoSuchMethodException &#123; // 通过反射获取info方法 Method method = MethoidMainTest.class.getMethod(&quot;info&quot;); // 判断此方法是否存在 @Login 注解 if (method.isAnnotationPresent(Login.class)) &#123; System.out.println(&quot;info方法上存在@Login注释&quot;); // 获取此方法上的所有注释 Annotation[] annotations = method.getAnnotations(); for (Annotation annotation : annotations) &#123; if (annotation != null &amp;&amp; annotation instanceof Login) &#123; String name = ((Login) annotation).username(); String pwd = ((Login) annotation).password(); System.out.println(&quot;name: &quot; + name + &quot;, pwd :&quot; + pwd); &#125; &#125; System.out.println(annotations); &#125; else &#123; System.out.println(&quot;info方法上 不 存在@Login注释&quot;); &#125; &#125;&#125; 1.3 Method 注解、反射自定义注解 12345678@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123; String testName() default &quot;hahaha&quot;; String testPwd() default &quot;00000&quot;;&#125; 使用注解 12345678910111213141516public class Junit &#123; @Test public void test1() &#123; &#125; public void test2() &#123; &#125; public void test3() &#123; &#125; @Test public void test4() &#123; &#125;&#125; 反射 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ClassMainTest &#123; public static void main(String[] args)&#123; try &#123; Class classes = Class.forName(&quot;com.example.shortcutsmy.reflect_class.Junit&quot;); System.out.println(&quot;classes name is : &quot; + classes.getName()); //Method[] methods = Junit.class.getDeclaredMethods(); Method[] methods = classes.getDeclaredMethods(); for (Method m : methods) &#123; System.out.println(&quot;method name is : &quot; + m.getName()); &#125; //测试的数量 int checkCount = 0; //未测试的数量 int uncheckCount = 0; for (Method m : methods) &#123; if (m.isAnnotationPresent(Test.class)) &#123; Annotation[] annotations = m.getAnnotations(); for (Annotation a : annotations) &#123; String name = ((Test)a).testName(); String pwd = ((Test)a).testPwd(); System.out.println(&quot;name is : &quot; + name + &quot;, pwd is : &quot; + pwd); &#125; checkCount++; &#125; else &#123; uncheckCount++; &#125; &#125; System.out.println(&quot;测试的方法有&quot; + checkCount); System.out.println(&quot;未测试的方法有&quot; + uncheckCount); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2. Android-注解 参考：https://blog.csdn.net/wzgiceman/article/details/53483665 ##2.1 Android注解给我们提供了三种主要和其他注释供我们使用： IntDef和StringDef注解； 资源类型注解； Null注解； 其他实用注解 ###2.1.1 一个使用 IntDef注解 替代枚举 使用注解修饰参数 1234567891011121314151617181920212223242526public class UserInter &#123; public static final int CHILDE = 0x1; public static final int MAN = 0x2; public static final int GIRL = 0x3; public static final int OTHER = 0x4; @Documented @Retention(RetentionPolicy.RUNTIME) @IntDef(&#123;CHILDE, MAN, GIRL&#125;) public @interface UInter&#123;&#125; private int mUType; public int getUserType()&#123; return mUType; &#125; public void setUertType(@UInter int type)&#123; this.mUType = type; &#125; public void setUertType2(@IdRes int type)&#123; this.mUType = type; &#125;&#125; 调用 123UserInter userInter = new UserInter();userInter.setUertType(UserInter.CHILDE);// userInter.setUertType(UserInter.OTHER); 2.1.2 资源类型注解资源注解是为了防止我们在使用程序资源的时候，错误传递资源类型给函数，导致程序错误。 name explain AnimRes 动画 AnimatorRes animator资源类型 AnyRes 任何资源类型 ArrayRes 数组资源类型 AttrRes 属性资源类型 BoolRes bool类型资源类型 ColorRes 颜色资源类型 DimenRes 长度资源类型 DrawableRes 图片资源类型 IdRes 资源id InterpolatorRes 动画插值器 LayoutRes layout资源 MenuRes me nu资源 RawRes raw资源 StringRes 字符串资源 StyleRes style资源 StyleableRes Styleable资源类型 TransitionRes transition资源类型 XmlRes xml 资源 2.1.3 Null注解null注解对应的有两个详细的注解： @NonNull：不能为空 @Nullable：可以为空 2.1.4 其他注解2.1.4.1 Threading 注解thread注解是帮助我们指定方法在特定线程中执行处理，如果和指定的线程不一致，抛出异常；Threading 注解类型： @UiThread： UI线程 @MainThread ：主线程 @WorkerThread： 子线程 @BinderThread ： 绑定线程 2.1.4.2 Value Constraints注解 @Size 这里size定了一个参数length的最小和最大长度 当搭配 String 使用时 123private void testDo(@Size(min = 1,max = 2)String s)&#123; Log.e(&quot;tag&quot;,&quot;--------&gt;&quot;+s);&#125; 使用效果为 此时，max = 2 表示的是 String 类型的参数的 长度即： 12&quot;22&quot; length = 2, 2 &lt;= max;&quot;223&quot; length = 3, 3 &gt;= max; @IntRange IntRange是用来指定int类型范围的注解 123private void setSizet(@IntRange(from = 1, to = 20) int s)&#123; Log.e(TAG, &quot;ヽ(｀Д´)ﾉ -&gt; setStrTest : &quot; + s);&#125; 运行结果 @FloatRange 同 @IntRange 使用。 @CallSuper @CallSuper注解主要是用来强调在覆盖父类方法时，需要实现父类的方法，及时调用对应的super.*方法,当用@CallSuper修饰了该方法，如果子类覆盖的后没有实现对呀的super方法会抛出异常。 @CheckResult 假设你定义了一个方法返回一个值，你期望调用者用这个值做些事情，那么你可以使用@CheckResult注解标注这个方法，强制用户定义一个相应的返回值，使用它。 public class ResultClass { @CheckResult public int getParam(){ return 11; } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-aar]]></title>
    <url>%2FAndroid-aar%2F</url>
    <content type="text"><![CDATA[参考：https://developer.android.com/studio/projects/android-library 1. 比较 结构上：Android 库 与 app 相同.可以提供构建应用所需的一切内容，包括源代码、资源文件和 Android 清单。 产生的文件：Android 库将编译到您可以用作 Android 应用模块依赖项的 Android 归档 (AAR) 文件，而不是在设备上运行的 APK。 AAR与JAR：AAR 文件可以包含 Android 资源和一个清单文件，这样，除了 Java 类与方法外，您还可以捆绑布局和可绘制对象等共享资源。 2. 作用 构建使用 某些相同组件（例如 Activity、服务或 UI 布局）的多个应用。 构建存在 多个 APK 变体（例如免费版本和付费版本）的应用并且需要在两种版本中 使用相同的核心组件。 3. 创建 将希望重用的文件移动到库模块中 然后以依赖的形式为每个应用模块添加库 3.1 直接创建 Android库3.2 将应用模块转换为库模块如果现有的应用模块包含有希望重用的所有代码，则可以按照以下步骤将其转换为库模块： 打开现有应用模块的 build.gradle 文件。您应在顶部看到以下内容： 1apply plugin: &apos;com.android.application&apos; 按照下面所示更改插件分配： 1apply plugin: &apos;com.android.library&apos; 点击 Sync Project with Gradle Files。 就这么简单。模块的整个结构仍然相同，但是现在它将作为 Android 库运行，构建也将创建一个 AAR 文件。 4. 注意事项 库模块不得包含原始资源 工具不支持在库模块中使用原始资源文件（保存在 assets/ 目录中）。应用使用的任何原始资源都必须存储在应用模块自身的 assets/ 目录中。 资源合并冲突 构建工具会将库模块中的资源与相关应用模块的资源合并。如果在两个模块中均定义了给定资源 ID，将使用应用中的资源。 如果多个 AAR 库之间发生冲突，将使用依赖项列表首先列出（位于 dependencies 块顶部）的库中的资源。 库模块可以包含 JAR 库 可以开发一个自身包含 JAR 库的库模块；不过需要手动编辑相关应用模块的构建路径，并添加 JAR 文件的路径。 库模块可以依赖外部 JAR 库 您可以开发一个依赖于外部库（例如 Maps 外部库）的库模块。在这种情况下，相关应用必须针对包含外部库（例如 Google API 插件）的目标构建。另外也要注意，库模块和相关应用都必须在其清单文件的 元素中声明外部库。 应用模块的 minSdkVersion 必须大于或等于库定义的版本 库作为相关应用模块的一部分编译，因此，库模块中使用的 API 必须与应用模块支持的平台版本兼容。 每个库模块都会创建自己的 R 类 在您构建相关应用模块时，库模块将先编译到 AAR 文件中，然后再添加到应用模块中。因此，每个库都有其自己的 R 类，并根据库的软件包名称命名。从主模块和库模块生成的 R 类会在所需的所有软件包（包括主模块的软件包和库的软件包）中创建。 5. AAR 文件详解AAR 文件的文件扩展名为 .aar，Maven 工件类型也应当是 aar。文件本身是一个包含以下强制性条目的 zip 文件： /AndroidManifest.xml /classes.jar /res/ /R.txt 此外，AAR 文件可能包含以下可选条目中的一个或多个： /assets/ /libs/名称.jar /jni/abi 名称/名称.so（其中 abi 名称 是 Android 支持的 ABI 之一） /proguard.txt /lint.jar]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle与Android]]></title>
    <url>%2FGradle%E4%B8%8EAndroid%2F</url>
    <content type="text"><![CDATA[Groovy：http://docs.groovy-lang.org/Gradle DSL: https://docs.gradle.org/current/javadoc/org/gradle/api/Project.htmlAndroid DSL 与 Task: http://google.github.io/android-gradle-dsl/current/index.html 关键词： Android、Groovy、DSL语言、Gradle 关系：-&gt; Android采用Gradle作为首选的构建自动化系统，使用Gradle强大的依赖关系管理功能-&gt; Gradle基于Groovy（一种用于编写Gradle的脚本语言），是一个开源构建自动化系统，它引入了基于Groovy的领域特定语言（DSL）来配置项目-&gt; Groovy是一种运行在JVM虚拟机上的脚本语言，能够与Java语言无缝结合。 区分：Android Plugin 版本 和 Gradle版本 Gradle插件 在Android中的用处： 插件化 VirtualAPK 热修复 Tinker、Robust 构建系统：多渠道打包 Gradle插件 1. Gradle概述 参考：https://docs.gradle.org/current/userguide/installation.html 1.1 安装1.1.1 先决条件Gradle可在所有主要操作系统上运行，并且只需要Java JDK 7或更高版本即可运行。检查，运行java -version。你应该看到这样的东西： 123❯java -version java version“1.8.0_151” Java™SE运行时环境（build 1.8.0_151-b12）Java HotSpot™64位服务器虚拟机（内置版本25.151-b12，混合模式） Gradle自带Groovy库，因此Groovy不需要安装。Gradle将忽略任何现有的Groovy安装。Gradle使用它在您的路径中找到的任何JDK。或者，您可以将JAVA_HOME环境变量设置为指向所需JDK的安装目录。 1.1.2 安装通过 homebrew 安装： 1brew install gradle 1.1.3 验证安装输入命令： 1gradle -v 得到的结果，如果为： 12345678910111213141516171819202122Welcome to Gradle 4.7!Here are the highlights of this release: - Incremental annotation processing - JDK 10 support - Grouped non-interactive console logs - Failed tests are re-run first for quicker feedbackFor more details see https://docs.gradle.org/4.7/release-notes.html------------------------------------------------------------Gradle 4.7------------------------------------------------------------Build time: 2018-04-18 09:09:12 UTCRevision: b9a962bf70638332300e7f810689cb2febbd4a6cGroovy: 2.4.12Ant: Apache Ant(TM) version 1.9.9 compiled on February 2 2017JVM: 1.8.0_131 (Oracle Corporation 25.131-b11)OS: Mac OS X 10.13.4 x86_64 则表示安装成功。 1.2 创建新的Gradle项目1.2.1 创建一个新的目录1mkdir Gradle_Projects 进入新创建的目录 1cd Gradle_Projects/ 1.2.2 初始化项目1gradle init 结果为： 1234Starting a Gradle Daemon (subsequent builds will be faster)BUILD SUCCESSFUL in 3s2 actionable tasks: 2 executed 表示初始化成功。 初始化成功后，项目的目录及文件功能说明： 1.2.3 创建一个新任务Gradle提供了用于通过基于Groovy或Kotlin的DSL创建和配置任务的API。 在项目的“根目录”下创建一个文件夹“src” 1mkdir src 并进入此文件夹 1cd src/ 在新创建的“src”目录下创建一个新文件“myfile.txt”，并写入“Hello,Word !”： 在项目配置脚本文件build.gradle中，定义一个copy方法，具体为： 1234task copy(type: Copy, group: &quot;Custom&quot;, description: &quot;Copies sources to the dest directory&quot;) &#123; from &quot;src&quot; into &quot;dest&quot;&#125; 在项目的“根目录”下执行 copy 方法的命令： 1./gradlew copy 若显示： 12BUILD SUCCESSFUL in 10m 11s1 actionable task: 1 executed 则表示任务添加成功。成功之后的项目树结构为： 1234567891011121314Gradle_Projects├── Gradle_Projects├── build.gradle├── dest│ └── myfile.txt├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat├── settings.gradle└── src └── myfile.txt 注意：本人在执行 copy 方法命令时，并没有直接显示结果，而是先下载了一个gradle-4.7-bin.zip文件 1.2.4 应用一个插件Gradle包含一系列插件，Gradle插件门户中提供了许多更多的插件。插件中包含的其中一个插件就是base插件。结合调用的核心类型Zip，可以使用配置的名称和位置创建项目的zip存档。 使用语法将base插件添加到build.gradle文件中plugins。确保plugins {}在文件顶部添加该块（否则失败）。 123plugins &#123; id &quot;base&quot;&#125; 现在添加一个从该src目录创建一个zip存档的任务。 123task zip(type: Zip, group: &quot;Archive&quot;, description: &quot;Archives sources in a zip file&quot;) &#123; from &quot;src&quot;&#125; 若显示： 12BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 则表示任务执行成功，文件树为： 1234567891011121314151617Gradle_Projects├── Gradle_Projects├── build│ └── distributions│ └── Gradle_Projects.zip├── build.gradle├── dest│ └── myfile.txt├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat├── settings.gradle└── src └── myfile.txt 此任务是将 src 文件夹中的 所有文件 打包。zip包中的内容为： 1.2.5 发现更多的可用 task执行命令： 1./gradlew tasks 结果为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374------------------------------------------------------------All tasks runnable from root project------------------------------------------------------------Android tasks-------------androidDependencies - Displays the Android dependencies of the project.signingReport - Displays the signing info for each variant.sourceSets - Prints out all the source sets defined in this project.Build tasks-----------assemble - Assembles all variants of all applications and secondary packages.assembleAndroidTest - Assembles all the Test applications.assembleDebug - Assembles all Debug builds.assembleRelease - Assembles all Release builds.build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it.buildNeeded - Assembles and tests this project and all projects it depends on.clean - Deletes the build directory.cleanBuildCache - Deletes the build cache directory.compileDebugAndroidTestSourcescompileDebugSourcescompileDebugUnitTestSourcescompileReleaseSourcescompileReleaseUnitTestSourcesmockableAndroidJar - Creates a version of android.jar that&apos;s suitable for unit tests.Build Setup tasks-----------------init - Initializes a new Gradle build.wrapper - Generates Gradle wrapper files.Help tasks----------buildEnvironment - Displays all buildscript dependencies declared in root project &apos;2018-07&apos;.components - Displays the components produced by root project &apos;2018-07&apos;. [incubating]dependencies - Displays all dependencies declared in root project &apos;2018-07&apos;.dependencyInsight - Displays the insight into a specific dependency in root project &apos;2018-07&apos;.dependentComponents - Displays the dependent components of components in root project &apos;2018-07&apos;. [incubating]help - Displays a help message.model - Displays the configuration model of root project &apos;2018-07&apos;. [incubating]projects - Displays the sub-projects of root project &apos;2018-07&apos;.properties - Displays the properties of root project &apos;2018-07&apos;.tasks - Displays the tasks runnable from root project &apos;2018-07&apos; (some of the displayed tasks may belong to subprojects).Install tasks-------------installDebug - Installs the Debug build.installDebugAndroidTest - Installs the android (on device) tests for the Debug build.uninstallAll - Uninstall all applications.uninstallDebug - Uninstalls the Debug build.uninstallDebugAndroidTest - Uninstalls the android (on device) tests for the Debug build.uninstallRelease - Uninstalls the Release build.Verification tasks------------------check - Runs all checks.connectedAndroidTest - Installs and runs instrumentation tests for all flavors on connected devices.connectedCheck - Runs all device checks on currently connected devices.connectedDebugAndroidTest - Installs and runs the tests for debug on connected devices.deviceAndroidTest - Installs and runs instrumentation tests using all Device Providers.deviceCheck - Runs all device checks using Device Providers and Test Servers.lint - Runs lint on all variants.lintDebug - Runs lint on the Debug build.lintRelease - Runs lint on the Release build.lintVitalRelease - Runs lint on just the fatal issues in the release build.test - Run unit tests for all variants.testDebugUnitTest - Run unit tests for the debug build.testReleaseUnitTest - Run unit tests for the release build.To see all tasks and more detail, run gradlew tasks --allTo see more detail about a task, run gradlew help --task &lt;task&gt; 说明： task任务参数 与 build.gradle 文件中的代码对比： 1.3 命令1.3.1 一般命令： Gradle命令符合以下结构，在任务名称之前和之后允许选项： 1gradle [taskName ...] [--option-name ...] 如果指定了多个任务，则应该用空格分隔。 接受值的选项可以在选项和参数之间使用或不使用=指定; 然而，推荐使用=。 1--console=plain 启用行为的选项具有长形式的选项，而用--no-指定的反向选项。 以下是相对的命令。 12--build-cache--no-build-cache 许多长期形式的期权都有相当于短期期权的选择。 以下是等同的： 12--help-h 1.3.2 执行任务 运行任务及。 1gradle myTask 在多项目构建中执行任务 在多项目构建中，可以使用 : 分隔 子项目名称 和 任务名称 来执行子项目任务。 从根项目运行时，以下内容得到的结果是等价的。 12gradle :mySubproject:taskNamegradle mySubproject:taskName 也可以仅使用任务名称为所有子项目运行任务。 例如，这将从根项目目录中调用时为所有子项目运行“测试”任务。 1gradle test 从子项目中调用Gradle时，应该省略项目名称： 12cd mySubprojectgradle taskName 执行多任务 1gradle test deploy 排除执行任务中的引用任务 您可以使用-x或--exclude-task命令行选项排除正在执行的任务，并提供要排除的任务的名称。 12345678910gradle dist --exclude-task test&gt; Task :compilecompiling source&gt; Task :distbuilding the distributionBUILD SUCCESSFUL in 0s2 actionable tasks: 2 executed 您可以看到 test 任务未执行，即使它是 dist 任务的依赖项。 测试任务的依赖项（如compileTest）也不会执行。 另一个任务所需的测试依赖关系，如编译，仍然执行。 强制任务执行 您可以使用 --rerun-tasks 选项强制Gradle执行所有忽略最新检查的任务： 1gradle test --rerun-tasks 发生故障时继续构建 默认情况下，一旦任何任务失败，Gradle将中止执行并使构建失败。 这样可以尽快完成构建，但隐藏了可能发生的其他故障。 为了在单个构建执行中发现尽可能多的失败，可以使用 --continue 选项。 1gradle test --continue 当使用--continue执行时，Gradle将执行每个要执行的任务，而该任务的所有依赖关系完成时不会失败，而不会在遇到第一个失败时立即停止。 每次遇到的故障将在构建结束时报告。 如果任务失败，则任何依赖它的后续任务将不会执行。 例如，如果测试中的代码出现编译失败，测试将不会运行; 因为测试任务将取决于编译任务（直接或间接）。 任务名称缩写 在命令行中指定任务时，不必提供任务的全名。 您只需提供足够的任务名称即可唯一标识任务。 举例来说，Gradle可能足以让Gradle识别检查任务。 您还可以缩写骆驼案件任务名称中的每个单词。 例如，您可以通过运行gradle compTest或gradle cT来执行任务compileTest。 示例：缩写骆驼案例任务名称 1gradle cT 您还可以将这些缩写与-x命令行选项一起使用。 1.3.3 常用 Task以下是由内置和最主要的Gradle插件应用的任务约定。 计算所有输出 在Gradle构建中，通常build指定汇编所有输出并运行所有检查。 1gradle build 运行应用程序 1gradle run 运行所有检查 所有验证任务都是常见的，包括测试和测试，都是使用check任务执行的 1gradle check 清洁输出 您可以使用clean任务删除构建目录的内容，但这样做会导致预先计算的输出丢失，从而导致后续任务执行的额外构建时间大大增加。 1gradle clean 1.3.4 项目信息 TaskGradle提供了几个内置任务，这些任务显示了构建的特定细节。这对理解构建的结构和依赖关系以及调试问题很有用。 列出 项目 1gradle projects 结果为： 12345678&gt; Task :projects------------------------------------------------------------Root project------------------------------------------------------------Root project &apos;HelloGradle&apos;\--- Project &apos;:app&apos; 列出 task -1： :app:tasks 1gradle :app:tasks 列出 task -2： gradle tasks 1gradle tasks 列出 task -3：gradle tasks –all 1gradle tasks --all 显示 task 使用详情 1gradle help --task check 结果为： 1234567891011121314&gt; Task :helpDetailed task information for check // 详细任务信息Path // 路径 :app:checkType // 类型 Task (org.gradle.api.Task)Description // 描述 Runs all checks.Group // 组 verification 列出项目依赖关系 参考：https://docs.gradle.org/current/userguide/inspecting_dependencies.html 运行gradle dependencies将为您提供所选项目的依赖关系列表，按配置细分。对于每个配置，该配置的直接和传递依赖关系都显示在树中。以下是此报告的一个示例： 1gradle dependencies 运行 gradle buildEnvironment 可视化所选项目的构建脚本依赖关系，类似于 gradle dependencies 可视化正在构建的软件的依赖关系。 列出项目属性 1gradle properties 列出 model 信息 1gradle model 结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&gt; Task :model------------------------------------------------------------Root project------------------------------------------------------------+ tasks | Type: org.gradle.model.ModelMap&lt;org.gradle.api.Task&gt; | Creator: Project.&lt;init&gt;.tasks() + buildEnvironment | Type: org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask | Value: task &apos;:buildEnvironment&apos; | Creator: tasks.addPlaceholderAction(buildEnvironment) | Rules: ⤷ copyToTaskContainer + clean | Type: org.gradle.api.tasks.Delete | Value: task &apos;:clean&apos; | Creator: Project.&lt;init&gt;.tasks.clean() | Rules: ⤷ copyToTaskContainer + components | Type: org.gradle.api.reporting.components.ComponentReport | Value: task &apos;:components&apos; | Creator: tasks.addPlaceholderAction(components) | Rules: ⤷ copyToTaskContainer + dependencies | Type: org.gradle.api.tasks.diagnostics.DependencyReportTask | Value: task &apos;:dependencies&apos; | Creator: tasks.addPlaceholderAction(dependencies) | Rules: ⤷ copyToTaskContainer + dependencyInsight | Type: org.gradle.api.tasks.diagnostics.DependencyInsightReportTask | Value: task &apos;:dependencyInsight&apos; | Creator: tasks.addPlaceholderAction(dependencyInsight) | Rules: ⤷ HelpTasksPlugin.Rules#addDefaultDependenciesReportConfiguration(DependencyInsightReportTask, ServiceRegistry) ⤷ copyToTaskContainer + dependentComponents | Type: org.gradle.api.reporting.dependents.DependentComponentsReport | Value: task &apos;:dependentComponents&apos; | Creator: tasks.addPlaceholderAction(dependentComponents) | Rules: ⤷ copyToTaskContainer + help | Type: org.gradle.configuration.Help | Value: task &apos;:help&apos; | Creator: tasks.addPlaceholderAction(help) | Rules: ⤷ copyToTaskContainer + init | Type: org.gradle.buildinit.tasks.InitBuild | Value: task &apos;:init&apos; | Creator: tasks.addPlaceholderAction(init) | Rules: ⤷ copyToTaskContainer + model | Type: org.gradle.api.reporting.model.ModelReport | Value: task &apos;:model&apos; | Creator: tasks.addPlaceholderAction(model) | Rules: ⤷ copyToTaskContainer + projects | Type: org.gradle.api.tasks.diagnostics.ProjectReportTask | Value: task &apos;:projects&apos; | Creator: tasks.addPlaceholderAction(projects) | Rules: ⤷ copyToTaskContainer + properties | Type: org.gradle.api.tasks.diagnostics.PropertyReportTask | Value: task &apos;:properties&apos; | Creator: tasks.addPlaceholderAction(properties) | Rules: ⤷ copyToTaskContainer + tasks | Type: org.gradle.api.tasks.diagnostics.TaskReportTask | Value: task &apos;:tasks&apos; | Creator: tasks.addPlaceholderAction(tasks) | Rules: ⤷ copyToTaskContainer + wrapper | Type: org.gradle.api.tasks.wrapper.Wrapper | Value: task &apos;:wrapper&apos; | Creator: tasks.addPlaceholderAction(wrapper) | Rules: ⤷ copyToTaskContainer model信息 - 模型元素的细节 详情 描述 类型-Type 这是模型元素的基础类型，通常是完全限定的类名。 值-Value 当模型元素可以表示为字符串时，在报告中有条件地显示。 创造者-Creator 每个模型元素都有一个创建者。创建者表示模型元素的起源（即创建模型元素的原因） 规则-Rules 是规则的列表，不包括为给定模型元素执行的创建者规则。规则的显示顺序反映了它们的执行顺序 2. Gradle 与 Android Studio 结合Android应用程序使用 Gradle 作为构建工具，通常通过唯一受支持的IDE：Android Studio。本小节来描述创建新的Android应用程序时生成的Gradle构建文件的细节，以及如何使用Gradle为其调用相关的构建任务。 2.1 Android 应用程序模块 的默认项目结构 Android Studio 将每个模块的源代码和资源逻辑分组到 源集（Source Set）中。Android Studio 不会自动创建它们。而是 Gradle 在特定版本的 Android插件下构建它们。 src/main/：该源代码集包括所有构建变体的 通用代码和资源。 2.2 工程配置文件 (Project: HelloWorldGradle) (Module: app) 附加（include ‘:app’）到 顶层构建文件。 gradle.properties。 一个是本地项目。 一个只有gradle.properties在.gradle主目录的子目录中有全局文件的同名文件才存在。 settings.gradle由Gradle用于 配置多项目构建，应该由一行代码组成： 1include &apos;:app&apos; 这告诉Gradle该app子目录也是一个Gradle项目。 gradle-wrapper.properties，它配置了所谓的 Gradle Wrapper。这使您可以构建Android项目，而无需首先安装Gradle。该文件的内容应该类似于： 12345distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip 前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在主目录.gradle/wrapper/dists中的目录中。 最后一行显示了distributionUrl Gradle将下载指定分布的位置的值。 local.properties 配置构建系统的本地环境属性，例如SDK安装路径。由于此文件的内容是由Android Studio自动生成的，并且特定于本地开发人员环境，因此您不应该手动修改此文件或将其检入您的版本控制系统。 2.2.1 Project 中的 build.gradle文件 DSL元素 http://google.github.io/android-gradle-dsl/current/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Top-level build file where you can add configuration options common to all sub-projects/modules./ ** * buildscript块是为Gradle本身配置存储库和依赖项的地方，也就是说，不应该在这里为模块包含依赖项。 * 例如，此块包含用于 * Gradle 的Android插件作为依赖项，因为它提供了Gradle 生成Android应用程序模块所需的附加指令。 * / buildscript &#123; / ** * repositories块配置Gradle用来 搜索或下载依赖项的存储库。 * Gradle预先配置对远程存储库的支持，如JCenter，Maven Central和Ivy。你也可以使用本地存储库或定义您自己的远程存储库。 * 下面的代码将JCenter 、google定义为Gradle应该用来查找其依赖项的存储库。 *使用Android Studio 3.0及更高版本创建的新项目还包括 Google的Maven存储库。 * / repositories &#123; google() jcenter() &#125; / ** *依赖关系块配置Gradle需要使用来构建项目的依赖项。以下行将Gradle 版本3.0.1的Android插件添加为类路径依赖项。 * / dependencies &#123; /**坐标语法：‘group：name：version’ 指定所需的插件，并告诉Gradle在哪里找到它，各个 `:` 间的字段说明为： 组 `com.android.tools.build` 名称 `gradle`名 版本 `3.0.1`。 */ classpath &apos;com.android.tools.build:gradle:3.0.1&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;/ ** * allprojects块是您配置 项目中所有模块使用的存储库和依赖项的位置，例如第三方插件或lib。* 但是，您应该在 每个模块级别的build.gradle文件中配置模块特定的依赖项。* 对于新项目， 默认情况下，Android Studio 包含JCenter和Google的Maven存储库，但不会 配置任何依赖关系。* 对于包含多个模块的Android项目，在项目级别定义某些属性并在所有模块间共享它们可能会很有用。您可以通过向顶层文件中的块添加额外的属性来完成此操作。* 额外属性：https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:extra_properties* /allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;// 特设任务task clean(type: Delete) &#123; delete rootProject.buildDir&#125;/*** 自定义任务* 注意：虽然Gradle允许您在模块级别定义项目范围的属性，但应该避免这样做，因为它会导致共享这些属性的模块被耦合。模块耦合使以后将模块作为独立项目导出变得更加困难*/ext &#123; compileSdkVersion = 26&#125; 在 build.gradle(app) 文件中调用 ext 时： 123456android &#123; // Use the following syntax to access properties you defined at the project level: // rootProject.ext.property_name compileSdkVersion rootProject.ext.compileSdkVersion ...&#125; 2.2.2 Module 中的 build.gradle 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/ ** * 构建配置中的第一行将Gradle 的Android插件应用于此构建，并使android块可用于指定Android特定的构建选项。 * /apply plugin: &apos;com.android.application&apos;/ ** * android块是您配置所有Android特定构建选项的地方。 * /android &#123; compileSdkVersion 27 / ** * defaultConfig块封装所有构建变体的默认设置和条目 * 并且可以从构建系统动态地覆盖main/AndroidManifest.xml 中的一些属性 * / defaultConfig &#123; / ** * 每个Android应用程序都有一个唯一的应用程序ID，applicationId * 此ID在设备和Google Play商店中唯一标识您的应用，你永远不应该改变应用程序ID。 * 应用程序ID 和 软件包名 彼此独立 * 但是，您的源代码仍应引用 main/ AndroidManifest.xml文件中的包属性定义的包名。 */ applicationId &quot;com.esint.hellogradle&quot; //定义运行应用程序所需的最低API级别。 minSdkVersion 19 //指定用于测试应用程序的API级别。 targetSdkVersion 27 //定义您的应用程序的版本号。 versionCode 1 //为应用定义一个用户友好的版本名称。 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; / ** * buildTypes块是您可以配置多个构建类型的位置。 * 默认情况下，构建系统定义两种构建类型：调试和发布。 * 调试版本类型没有在默认已经明确显示，但它包含调试工具，并用调试密钥签名。 * 构建类型应用Proguard设置，并且默认情况下未进行签名。 */ buildTypes &#123; release &#123; //为发布构建类型启用代码缩小。 minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; / ** * productFlavors块是您可以配置多个产品风格的地方。这允许您创建不同版本的应用程序，可以用自己的设置覆盖defaultConfig块。 * 产品风格是可选的，构建系统默认不会创建它们。这个例子： * 创建一个免费和付费的产品风格。然后指定每种产品风格自己的应用程序ID，以便它们可以同时存在于Google Play商店或Android设备上。 * 如果您使用Android插件3.0.0或更高版本，则还需要声明并将每种风味分配到风味维度。 */ productFlavors &#123; free &#123; applicationId &apos;com.example.myapp.free&apos; &#125; paid &#123; applicationId &apos;com.example.myapp.paid&apos; &#125; &#125; / ** * 分割块是您可以配置不同的APK构建的地方 * 每个仅包含支持屏幕密度或ABI的代码和资源。您还需要配置您的版本，以便每个APK具有不同的版本代码。 */ splits &#123; //设置根据屏幕密度构建多个APK。 density &#123; //启用或禁用构建多个APK。 enable false //构建多个APK时排除这些密度。 exclude &quot;ldpi&quot;, &quot;tvdpi&quot;, &quot;xxxhdpi&quot;, &quot;400dpi&quot;, &quot;560dpi&quot; &#125; &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:27.1.1&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;&#125; 配置文件块 - dependencies 12345678dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:27.1.1&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;&#125; 配置 依赖关系是构建Gradle应用程序的基础部分。在这种情况下，dependencies部分显示的值implementation，testImplementation和androidTestImplementation配置。 最简单的一个，testImplementation依赖关系只包含最新的稳定JUnit 4发行版。JUnit类和测试注释将在编译时在src/test/java层次结构中可用。 有三条线添加了对implementation 配置的依赖关系： 第一，fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])是一个 fileTree依赖项，它将文件libs夹中的所有jar文件添加到编译类路径中 第二，com.android.support:appcompat-v7:26.1.0将 Android兼容性库 添加到项目中。这使您可以在SDK版本7以前的任何Android应用程序中使用Material设计主题和其他功能。 第三，com.android.support.constraint:constraint-layout:1.0.2将Android约束布局添加到项目中。这使您可以在SDK版本9以前的任何Android应用程序中使用ConstraintLayout布局类。 androidTestImplementation依赖关系是指Espresso测试库，用于Android应用程序的集成测试。 2.3 在终端中运行 Android 的 Gradle 命令在通过 Android Studio 构建和部署应用程序时，可以通过在 终端中 进入项目的根目录，在该目录下，运行： 1./gradlew build 这将运行许多任务，并最终返回“构建成功”。要查看生成的APK（Android包，Android应用的可部署版本），可看目录app/build/outputs/apk。在那里你会找到一个debug和一个release目录。该debug目录包含app-debug.apk将被部署到模拟器或连接设备的APK版本。如果您想部署发行版APK，则需要首先创建签名配置. 123./gradlew：app：dependencies --configuration releaseCompileClasspath ./gradlew：app：dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath 注意：任何Gradle项目中都有 dependency 和 dependencyInsight 任务可用。它们可以帮助 追踪并解决与库版本冲突有关 的任何问题。 2.4 使用 Android Studio 中的 Gradle窗口Android Studio包含一个执行Gradle任务的特殊窗口。Android项目提供超过80种不同的任务，并且此窗口尝试将它们组织到不同的类别中。 可以通过此窗口，手动点击要执行的任务，查看在执行一种操作时，背后执行的具体tasks。 3. Gradle 与 APK 的构建 参考：https://developer.android.com/studio/build/gradle-tips Gradle 运行过程 Initializatin Configuration Execution 在构建App时，Gradle配置文件的执行过程： settings.gradle -&gt; (Project)build.gradle -&gt; (Module)build.gradle （可以使用 println()进行验证）即： 顺序执行 — 先运行 settings配置文件，再运行 Project，再运行 Module。 3.1 applicationId3.1.1 applicationId 与 Java包名称 每个Android应用程序都有一个唯一的应用程序ID，看起来像一个Java包名称，此ID在设备和Google Play商店中唯一标识您的应用。如果想上传应用程序的新版本，则应用程序ID（以及您对其签名的证书）必须与原始APK相同，如果更改应用程序ID，则Google Play Store会将APK视为完全不同的应用程序应用程序。所以一旦你发布你的应用程序，你永远不应该改变应用程序ID。 当在 Android Studio中 创建新项目时，applicationId 与在安装过程中选择的 Java风格包名称完全匹配。 但是，除此之外， 应用程序ID 和 软件包名称 彼此独立。 可以更改代码的包名称（代码名称空间），它不会影响应用程序ID，反之亦然（但是，一旦发布应用程序，不应再更改您的应用程序ID）。 命名规则： 它必须至少有两个部分（一个或多个点）。 每个部分必须以字母开头。 所有字符必须是字母数字或下划线[a-zA-Z0-9_]。 注意： applicationId用于 直接绑定到代码的包名称 ; 所以一些Android API在其方法名称和参数名称中使用术语 包名称 ，但这实际上是 applicationId。 3.1.2 更改 包名称尽管默认情况下 项目的包名称 与 应用程序ID 相匹配，但可以更改它。如果要更改软件包名称，请注意软件包名称（由项目目录结构定义）应始终与 AndroidManifest.xml 文件中的 package 属性匹配 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapp&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; &gt; gradle 使用这个 package属性 来做两件事情： 将此名称用作应用程序生成的 R.java类的名称空间 。 例子：通过上面的清单，R该类将会是 com.example.myapp.R。 使用它来 解析 清单文件中声明的 任何相关类名称。 示例：通过上面的清单，声明为 &lt;activity android:name=&quot;.MainActivity&quot;&gt; 已解析为 的活动为 com.example.myapp.MainActivity。 3.2.3 一个参考示例： 更改applicationId - “免费”和“专业版”如果想创建不同版本的应用在Google Play商店中显示为单独列表，例如“免费”和“专业版”，则需要创建单独的构建变体，每个变体都具有不同的应用程序标识。 在这种情况下，应该将每个构建变体定义为独立的产品风格。对于 productFlavors块内的每种风格，您可以重新定义该 applicationId 属性，或者可以使用以下代码段将缺省应用程序ID附加到一个段中applicationIdSuffix，如下所示： 12345678910111213android &#123; defaultConfig &#123; applicationId &quot;com.example.myapp&quot; &#125; productFlavors &#123; free &#123; applicationIdSuffix &quot;.free&quot; &#125; pro &#123; applicationIdSuffix &quot;.pro&quot; &#125; &#125;&#125; 这样，“免费”产品风格的应用程序ID是com.example.myapp.free。 您也可以使用applicationIdSuffix基于您的构建类型添加细分，如下所示： 12345678android &#123; ... buildTypes &#123; debug &#123; applicationIdSuffix &quot;.debug&quot; &#125; &#125;&#125; 因为Gradle在 产品风格 之后应用了 构建类型配置（debug、release），所以 免费-调试版apk 构建变体的 applicationId 现在是： com.example.myapp.free.debug。 当希望将 免费-调试版本apk 和 免费-发布版本apk 构建在 同一设备上时，这非常有用，因为没有两个APK可以具有相同的应用程序ID。 3.2 构建流程。典型 APK 的构建流程 注意 编译器 源代码 转换成 DEX（Dalvik Executable) 文件（其中包括运行在 Android 设备上的字节码），将所有其他内容转换成已编译资源。 APK 打包器将 DEX 文件和已编译资源 合并 成单个 APK。不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。 APK 打包器使用调试或发布密钥库签署 APK： 如果您构建的是调试版本的应用（即专用于测试和分析的应用），打包器会使用调试密钥库签署您的应用。Android Studio 自动使用调试密钥库配置新项目。 如果您构建的是打算向外发布的发布版本应用，打包器会使用发布密钥库签署应用。要创建发布密钥库。 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，减少其在设备上运行时的内存占用。 task执行过程：既可以执行 单个task，又可以将 多个tasks串联执行 参照对应：apk的打包流程图 在对 APK 执行具体的构建时，Gradle 运行的顺序为： 1settings.gradle -&gt; (Project)build.gradle -&gt; (Module)build.gradle -&gt; 所需的 Tasks 如图，执行 assembleDebu task 的过程： 3.3 配置文件中几种常见的配置 Build Types 构建类型定义了Gradle在构建和打包应用程序时使用的特定属性，并且通常针对开发生命周期的不同阶段进行配置。例如， 调试构建类型启用调试选项并使用调试密钥对APK进行签名， 发布构建类型可能会缩小、混淆并用发布密钥对APK进行签名进行分发。 必须至少定义一种构建类型，才能构建应用程序。Android Studio默认创建 调试 和 发布 构建类型。 Product Flavors 产品风格 代表您可能发布给用户的不同版本的应用，例如免费和付费版本的应用。您可以自定义产品风格以使用不同的代码和资源，同时共享和重复使用适用于所有版本应用程序的通用部件。产品风格是可选的，须手动创建它们 Manifest Entries 您可以在构建变体配置中为清单文件的某些属性指定值。这些构建值会 覆盖清单文件中的现有值。如果您希望为您的模块生成多个APK，其中每个apk文件都具有不同的应用程序名称，最低SDK版本或目标SDK版本 Dependencies 构建系统从 本地文件系统 和 远程存储库管理项目 依赖关系。这样可以防止您必须手动搜索，下载和复制依赖关系的二进制包到项目目录中 Signing 构建系统使您能够在构建配置中指定签名设置，并且可以在构建过程中自动签署APK。 ProGuard 构建系统使您能够为每个构建变体指定不同的ProGuard规则文件。构建系统可以在构建过程中运行ProGuard来混淆你的类。 3.4 依赖项：dependencies问题 https://developer.android.com/studio/build/dependenciesDSL参考：http://google.github.io/android-gradle-dsl/current/ 3.4.1 依赖的3种类型 本地库模块依赖关系 1compile project(&quot;:mylibrary&quot;) 本地依赖 1compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) 远程依赖 1compile &apos;com.example.android:app-magic:12.3&apos; 3.4.2 库依赖配置在dependencies块内部，可以使用几种不同的依赖配置之一来声明库依赖关系（如上compile所示）。每个依赖配置都提供了有关如何使用该库的Gradle不同指导。 compile Gradle将该依赖项添加到编译类路径和APK中。 apk Gradle只将相关性添加到APK（它不会被添加到编译类路径中）。 provided Gradle仅将编译类路径添加到编译类路径中（它不会添加到APK中）。这在创建Android库模块时非常有用， 并且在编译期间需要依赖关系，但在运行时存在此选项是可选的。也就是说，如果你使用这个配置，那么你的库模块必须包含一个运行时条件来检查依赖关系是否可用，然后适当地改变它的行为，以便它在没有提供时仍然可以运行。这有助于减少最终APK的大小，因为不会添加不重要的临时依赖项。 注意：以上配置适用于项目的主源集，该集适用于所有构建变体。如果您不想为特定的构建变体源集或 测试源集声明一个依赖项 ，则必须大写配置名称，并在其前面加上构建变体或测试源集的名称。 1) 要将compile依赖项仅添加到“免费”产品特征（使用远程二进制依赖项），它看起来像这样： 123dependencies &#123; freeCompile &apos;com.google.firebase:firebase-ads:9.8.0&apos;&#125; 2) 如果要为组合产品风格和构建类型的变体添加依赖项，则必须在configurations块中初始化配置名称。以下示例将apk依赖项添加到“freeDebug”构建变体（使用本地二进制依赖项）： 12345678configurations &#123; // Initializes a placeholder for the freeDebugApk dependency configuration. freeDebugApk &#123;&#125;&#125;dependencies &#123; freeDebugApk fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])&#125; 3) 要compile为您的本地测试和仪器测试添加依赖项，它看起来像这样： 1234567dependencies &#123; // Adds a remote binary dependency only for local tests. testCompile &apos;junit:junit:4.12&apos; // Adds a remote binary dependency only for the instrumented test APK. androidTestCompile &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;&#125; 4) 如果你的lib模块提供了多种变体，你可以为不同的应用变体添加不同的lib变体，如下所示 1234567dependencies &#123; // Adds the &apos;debug&apos; variant of the library to the debug variant of the app debugCompile project(path: &apos;:my-library-module&apos;, configuration: &apos;debug&apos;) // Adds the &apos;release&apos; variant of the library to the release variant of the app releaseCompile project(path: &apos;:my-library-module&apos;, configuration: &apos;release&apos;)&#125; 3.4.3 远程存储库当依赖项不是本地库或文件树时，Gradle会在文件repositories块中指定的任何联机存储库中查找这些 build.gradle文件。 默认情况下，新的Android Studio项目将JCenter声明为项目顶层build.gradle文件中的存储库位置，如下所示： 12345allprojects &#123; repositories &#123; jcenter() &#125;&#125; 如果想从Maven中央存储库中获取某些内容，请添加 mavenCentral()或为本地存储库使用mavenLocal()： 1234567allprojects &#123; repositories &#123; jcenter() mavenCentral() mavenLocal() &#125;&#125; 或者，可以按如下方式声明特定的Maven或Ivy存储库： 12345678910111213allprojects &#123; repositories &#123; maven &#123; url &quot;https://repo.example.com/maven2&quot; &#125; maven &#123; url &quot;file://local/repo/&quot; &#125; ivy &#123; url &quot;https://repo.example.com/ivy&quot; &#125; &#125;&#125; 3.4.4 Google的Maven存储库Google的Maven存储库提供了以下Android库的最新版本 Android Support Library Architecture Components Library Constraint Layout Library Android Test Databinding Library Android Instant App Library Wear OS Google Play services Firebase 要将这些库中的一个添加到您的版本中，请在您的顶级build.gradle文件中包含Google的Maven存储库 1234567891011allprojects &#123; repositories &#123; google() // If you&apos;re using a version of Gradle lower than 4.1, you must instead use: // maven &#123; // url &apos;https://maven.google.com&apos; // &#125; // An alternative URL is &apos;https://dl.google.com/dl/android/maven2/&apos; &#125;&#125; 然后将所需的库添加到您的模块的dependencies块。例如， appcompat库 看起来像这样： 123dependencies &#123; compile &apos;com.android.support:appcompat-v7:27.1.1&apos;&#125; 3.4.5 依赖顺序第一个库的优先级高于第二个，第二个的优先级高于第三个，依此类推。在资源合并或 清单元素从库中合并到您的应用中时，此顺序非常重要 。 例如，如果您的项目声明以下内容: Dependency on LIB_A and LIB_B (依次) And LIB_A depends on LIB_C and LIB_D (依次) And LIB_B also depends on LIB_C 然后，平面相关性顺序如下： LIB_A LIB_D LIB_B LIB_C 3.4.6 收缩代码要使用ProGuard缩小代码，minifyEnabled true 请注意缩短代码会减慢构建时间，所以如果可能的话，应该避免在调试版本上使用它。 123456789android &#123; buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125; ...&#125; 注意：使用Instant Run时，Android Studio会禁用ProGuard。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-3]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3%2F</url>
    <content type="text"><![CDATA[参考：https://blog.csdn.net/zolalad/article/details/11848739 对于给定的算法，通常做2项分析： 数学证明正确性 分析算法复杂度 度量一个程序的执行时间通常有2种方法： 事后统计分析：不建议。一是必须要先运行；二是计算机本身硬件环境易掩盖算法本身缺陷。 事前估算分析：建议。依据统计方法对算法进行估算。 一个用高级语言编写的程序在计算机上运行的时间取决于：（1）算法采用的策略、方法（2）编译产生的代码质量（3）问题的输入规模（4）机器执行指令的速度 一个算法是由控制结构（顺序、分支、循环3种）和原操作（固有数据类型的操作）构成的，算法的时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常的做法是：从算法中选取一种对于所研究的问题（活算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间度量。 1.时间复杂度（1）时间频度 一个算法执行所耗费的时间。从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 （2）时间复杂度 在时间频度中，n为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n))为算法的渐进时间复杂度，简称时间复杂度。 另外，上面公式中用到的 Landau符号其实是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。 T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 $ T (n) ≤ C*f(n) $ 。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T (n)的上界是C f(n)。其虽然对 $f(n)$没有规定，但是一般都是取尽可能简单的函数。例如，$ O(2n^2+n +1) = O (3n^2+n+3) = O (7n^2 + n) = O ( n2 ) $，一般都只用 $O(n^2) $表示就可以了。注意到*大O符号里隐藏着一个常数C，所以 $ f(n)$ 里一般不加系数。如果把 $T(n)$当做一棵树，那么 $ O(f(n)) $ 所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。 在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如 $ T(n)=n^2+3n+4 $ 与 $ T(n)=4n^2+2n+1 $ 它们的频度不同，但时间复杂度相同，都为 $ O(n^2) $。 （3）按数量级递增排列，常见的时间复杂度有： 常数阶：$O(1)$ 。表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。 对数阶：$O(log_2 n)$。 多项式时间 线性阶：$O(n)$。 多项式时间 线性对数阶：$O(nlog_2 n)$。 多项式时间 平方阶：$O(n^2)$。 多项式时间 立方阶：$O(n^3)$。 多项式时间 … k次方阶：$O(n^k)$。 多项式时间 指数阶：$O(2^n)$。指数时间 $ Ο(n!) $。 指数时间 随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 注意： 多项式时间复杂度的算法是有效算法，把这类问题称为P（Polynomial,多项式）类问题； 指数时间复杂度的算法称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。 从图中可见，我们应该尽可能选用多项式阶O(nk)的算法，而不希望用指数阶的算法。 常见的算法时间复杂度由小到大依次为： $$ Ο(1)＜Ο(log_2 n)＜Ο(n)＜Ο(nlog_2 n)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)$$ （4）求解算法的时间复杂度的具体步骤是： 找出算法中的基本语句： 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 计算基本语句的执行次数的数量级： 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 用大 $Ο$ 记号表示算法的时间性能： 将基本语句执行次数的数量级放入大 $Ο$ 记号中。如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加 示例： 12345678// 第1个for (i = 1; i &lt;= n; i++) x++; // 第2个for ( i=1 ; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) x++; 时间复杂度解： 第1个：$ O(n) $ 第2个：$ O(n^2) $ （5）计算算法时间复杂度的几个简单的分析法则: 对于一些简单的输入输出语句或赋值语句,近似认为需要$O(1)$时间 对于顺序结构，需要依次执行一系列语句所用的时间可采用 $大O$ 下”求和法则“ 求和法则： 同n时，是指若算法的2个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$ ,则 $T1(n)+T2(n)=O(max(f(n), g(n)))$。 不同n时，特别地，若 $T1(m)=O(f(m)), T2(n)=O(g(n))$，则 $T1(m)+T2(n)=O(f(m) + g(n))$ 对于选择结构，如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要 $O(1)$ 时间。 对于循环结构，循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用 $大O$ 下”乘法法则“ 乘法法则: 是指若算法的2个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$，则 $ T1T2=O(f(n)g(n)) $ 对于复杂的算法,可以将它拆分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度 另外还有以下2个运算法则:(1) 若 $g(n)=O(f(n))$ ，则 $O(f(n))+ O(g(n))= O(f(n))$；(2) $O(Cf(n)) = O(f(n))$，其中C是一个正常数 2.空间复杂度]]></content>
      <categories>
        <category>温故知新</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TensorFlow]]></title>
    <url>%2F%E5%85%B3%E4%BA%8ETensorFlow%2F</url>
    <content type="text"><![CDATA[TensorFlow入门，2018年五一节。 时代发展的综合产物：大数据 + 云计算 = 人工智能 Android ？ TensorFlow ？ Google？ TensorFlow 是一个用于人工智能的开源神器 作为一个Android开发者，其实在人工智能火爆的开始也想着自己怎么能加入到开发的大军中。可是自己却迟迟没有下手，这其中是有很多原因的：如何入手？从哪个方面？哪个领域？哪个方向？以及入手后如何开始，如何使这项学习长期继续下去？有哪些已有成果能作为参考？ 当然最重要的一点：如何与自己目前所做的Android开发联系起来，因为一旦建立联系后，在自己熟悉的领域作为起步，可能得到的成就感和实际效果会好的多。 在去年就看到了关于TensorFlow的消息，当时就对其有了印象。以至于每每想到“人工智能”、“深度学习”这个词汇总是想到他。 更重要的一点：Android与TensorFlow都是Google的产品，同出一门。 一、 前言1. 深度学习深度学习是什么？它能够为我们做什么？如何把这个技术应用到实际场景当中去？ 深度学习并不是一个突然出现的技术领域，它的核心算法就是神经网络。神经网络是一种机器学习的模型，这个模型主要特点就是，它可以拟合任何数学上的函数，特别是利用大数据反复迭代的一种类似方法来训练好这个模型。 这个以神经网络模型为核心的深度学习技术，在很多应用领域都可以大大提高过去软件系统需要完成的任务。最经典的应用领域大家肯定很熟悉，就是图像识别。自2012年以来，在这个领域，自动图像识别的错误率从20%一直持续下降到4%左右，已经超过了一个普通人分辨图像的能力。 2. TensorFlow Google在2015年10月开源了TensorFlow。 2.1 关于TensorFlowTensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。 2.2 什么是数据流图（Data Flow Graph）? 数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。 1(Tensor)张量：size可动态调整的多维数据数组 TensorFlow可被用于语音识别或图像识别等多项机器学习和深度学习领域，对2011年开发的深度学习基础架构DistBelief进行了各方面的改进，它可在小到一部智能手机、大到数千台数据中心服务器的各种设备上运行。 2.3 TensorFlow的特征 高度的灵活性 TensorFlow 不是一个严格的“神经网络”库。只要你可以将你的计算表示为一个数据流图，你就可以使用Tensorflow。你来构建图，描写驱动计算的内部循环。我们提供了有用的工具来帮助你组装“子图”（常用于神经网络），当然用户也可以自己在Tensorflow基础上写自己的“上层库”。定义顺手好用的新复合操作和写一个python函数一样容易，而且也不用担心性能损耗。当然万一你发现找不到想要的底层数据操作，你也可以自己写一点c++代码来丰富底层的操作。 真正的可移植性（Portability） Tensorflow 在CPU和GPU上运行，比如说可以运行在台式机、服务器、手机移动设备等等。想要在没有特殊硬件的前提下，在你的笔记本上跑一下机器学习的新想法？Tensorflow可以办到这点。准备将你的训练模型在多个CPU上规模化运算，又不想修改代码？Tensorflow可以办到这点。想要将你的训练好的模型作为产品的一部分用到手机app里？Tensorflow可以办到这点。你改变主意了，想要将你的模型作为云端服务运行在自己的服务器上，或者运行在Docker容器里？Tensorfow也能办到。 将科研和产品联系在一起 过去如果要将科研中的机器学习想法用到产品中，需要大量的代码重写工作。那样的日子一去不复返了！在Google，科学家用Tensorflow尝试新的算法，产品团队则用Tensorflow来训练和使用计算模型，并直接提供给在线用户。使用Tensorflow可以让应用型研究者将想法迅速运用到产品中，也可以让学术性研究者更直接地彼此分享代码，从而提高科研产出率。 自动求微分 基于梯度的机器学习算法会受益于Tensorflow自动求微分的能力。作为Tensorflow用户，你只需要定义预测模型的结构，将这个结构和目标函数（objective function）结合在一起，并添加数据，Tensorflow将自动为你计算相关的微分导数。计算某个变量相对于其他变量的导数仅仅是通过扩展你的图来完成的，所以你能一直清楚看到究竟在发生什么。 多语言支持 Tensorflow 有一个合理的c++使用界面，也有一个易用的python使用界面来构建和执行你的graphs。你可以直接写python/c++程序，也可以用交互式的ipython界面来用Tensorflow尝试些想法，它可以帮你将笔记、代码、可视化等有条理地归置好。当然这仅仅是个起点——我们希望能鼓励你创造自己最喜欢的语言界面，比如Go，Java，Lua，Javascript，或者是R。 性能最优化 比如说你又一个32个CPU内核、4个GPU显卡的工作站，想要将你工作站的计算潜能全发挥出来？由于Tensorflow 给予了线程、队列、异步操作等以最佳的支持，Tensorflow 让你可以将你手边硬件的计算潜能全部发挥出来。你可以自由地将Tensorflow图中的计算元素分配到不同设备上，Tensorflow可以帮你管理好这些不同副本。 2.4 持多种硬件的平台TensorFlow现在已经演化成一个相当完整的深度学习软件开放平台。它支持CPU、GPU混合搭建的数据中心的训练平台，它也支持将数据中心训练好的模型，相对便捷地部署到不同的移动端应用上，可以支持类似Google自主研发的TPU处理器。 2.5 支持多种开发环境支持多种硬件的平台是基础，TensorFlow一直以来的一个目标，就是能够帮助尽量多的开发者，能够把深度学习的技术利用起来，最终使得广大的用户从中能力得到益处，基于这个想法，TensorFlow一直很重视多种程序员开发环境的支持。比如说，开发者可以在主要的开发环境中使用TensorFlow。 TensorFlow在Google内部的应用推广是非常全面和彻底的，比如说TensorFlow很早就帮助Google的核心业务（搜索和广告），实施了深度学习的模型，并且在核心业务上体现了他们的性能。 在垃圾邮件过滤中，我们也使用了TensorFlow训练的模型，同时在安卓的应用程序推荐上，也上线了TensorFlow的模型等等。很多TensorFlow应用都是发生后台，大多数用户可能没有直接的体验。 2.6 深入移动端 安卓手机自拍功能 安卓手机最近的版本当中增加了一个自拍功能，这个自拍功能就是通过应用深度学习训练出来的视觉模型，可以非常准确地分离前景像素和后景像素，对前景像素和后景像素分别处理，这样就可以实现背景虚化。实现这种功能，传统上手机厂商需要增加第二个摄像头，这就会增加手机的成本，同时现有的手机就不太容易获得这样的效果，通过新的算法，我们可以实现一些过去可能非常昂贵才能实现的效果。 智能音箱 和图像处理一样，语音处理是另一个被深度学习深刻改变的领域，语音识别要比图像处理更早地采用神经网络。产品方面，这些年智能音箱语音主力大行其道，其中一个很大的原因就是深度学习算法把语音识别和语音生成的技术门槛大大地降低了，过去可能需要20—50个博士的团队才能完成的任务，现在下载一个现有模型定制一下，就可以达到同样的效果。通用的机器学习框架，可以帮助到更多的开发人员，开发出适合特定应用场景的语音应用。 机器翻译 现在你可以用手机拍一张照片，手机软件可以自动的识别出图形中的文字，把文字翻译成另外一种语言，看似简单的应用，其实是图像技术和机器翻译技术很自然的结合。 邮件自动回复功能 比如说你今天早上收到一份你朋友发的邮件，“晚上是不是要到哪里吃饭”，大多数情况只有三种可能的回答：我会准时到；对不起我没有空不能来；我有空，但是我可能需要晚一点到。 我们现在邮箱会自动地给你提供三个选择，这样的话在路上看到邮箱，只要一键就可以完成邮件回复，极大方便了用户在手机上处理邮件的效率。 2.7 其他领域 AlphaGo 过去两年努力推进AlphaGo的工作，这就得益于TensorFlow框架本身的帮助，因为TensorFlow可以利用超大计算机集群，支持最新的加速器，AlphaGo团队可以更加专注于算法的研究。 智能医疗 由于TensorFlow是一个通用的框架，他们可以很方便地重用现在已有的图像识别模型或者是自然语言处理的模型，针对特定的应用领域和数据，重新训练微调一下模型，就可以在检测视网膜病变任务上面获得超过95%的准确率，这个准确率已经超过了普通眼科专家91%的水平。 自动驾驶 在自动驾驶方面，也在利用TensorFlow不断改进自动驾驶系统当中的深度模型，包括对路况场景的分割、雷达信号的处理等等。 婴儿食品制作 过去两年我们看到很多和互联网毫无相关的行业，也开始尝试利用深度学习的技术和方法，比如说这家公司是一个婴儿食品制作的公司，引进了TensorFlow训练好的智能系统，这个智能系统可以把婴儿食品的原料进行分类，把一些烂掉的苹果和香蕉更准确地排除出去，这样可以准确地控制婴儿食品的质量。 科学研究——太空 TensorFlow在计算机科学以外的科学研究上也得到了使用，比如说上个月美国航天总署宣布一项研究成果，美国航天总署有个开普勒计划，他们的科学家和我们的同事联合开发了一个TensorFlow的模型。 科学研究——海洋 人们不仅仰望星空，同时我们在回望我们的地球，在这个应用的例子里面，澳大利亚的科学家用TensorFlow开发的图像识别模型，在数万张海洋航拍图照片中，快速并且准确地找到需要保护的大型海洋哺乳类动物，比如说珍惜动物海牛。 3. TensorFlow在中国 TensorFlow的中文网站：http://www.tensorfly.cn/ 公司： 京东内部搭建了TensorFlow训练平台，用于开发图像、自然语言相关的模型，并且把他们用到客服广告等领域。 小米也在尝试类似的技术路线，支持他们生态线上各种特殊的应用。 网易的有道笔记、网易翻译君也使用了TensorFlow视觉和语言的模型。 Eager模式 一个TensorFlow模式，这个模式能够更加有利于前端的开发，便于调试，支持更多动态的编程模式。 Lite模式 TensorFlow Lite模式，这个模式是专门针对移动和嵌入式应用场景打造的机器学习平台，它的目标是希望把在云端训练的机器学习模型，更加简单、高效的迁移到移动端上进行部署。 第二代TPU 二、 配置1. python版本在 终端 环境中，直接输入 python3 即可将python的解释环境切换至python3。 2. 安装 TensorFlow CPU版，环境 macOS、Python3使用virtualenv安装 2.1 安装pip,若已经安装 pip ,忽略此步骤； 1sudo easy_install pip 检查 pip 更新 1pip install --upgrade pip 2.2 安装 virtualenv， 1sudo pip install --upgrade virtualenv 或者，指定python3编译环境。关于 Python 3 virtualenv问题可参考：https://stackoverflow.com/questions/28923926/python-3-virtualenv-problems 1pip3 install virtualenv 2.3 创建虚拟环境，此处为python3环境，TensorFlowDir 为 自己定义的目录文件名 1virtualenv --system-site-packages -p python3 TensorFlowDir # for Python 3.n 2.4 激活虚拟环境，如果你的终端运行的是bash, sh, ksh, or zsh，注意，此处TensorFlowDir为上一条命令中的自定义目录文件名 1source ~/TensorFlowDir/bin/activate 如果是：csh or tcsh，执行 1source ~/TensorFlowDir/bin/activate.csh 2.5 安装 TensorFlow 及其所有依赖 1pip3 install --upgrade tensorflow 2.6 激活虚拟环境，其中TensorFlowDir 表示创建环境时自定义的 目录文件名 注意：每打开一个新的 shell 使用 TensorFlow 都必须激活虚拟环境。如果当前虚拟环境没有被激活（也就是提示符不是 TensorFlowDir），执行以下任一命令 12$ source ~/TensorFlowDir/bin/activate # bash, sh, ksh, or zsh$ source ~/TensorFlowDir/bin/activate.csh # csh or tcsh 提示符变成下面这样说明 TensorFlow 环境已经激活： 1(TensorFlowDirDir) YannisCheng:~ yannischeng$ 2.7 退出虚拟环境 1(TensorFlowDirDir) YannisCheng:~ yannischeng$ deactivate 2.8 卸载TensorFlow 环境 1rm -r ~/tensorflow 2.9 删除 virtualenv环境 1rm -r virtualenv venv 3. 配置TensorFlow与PyCharm3.1 选择路径查看安装了tensorflow的python3.6在本地的位置，如果知道知道安装位置，可忽略 进入 python3 -&gt; tensorflow 环境后， 1tf.__path__ 输出位置：[‘/Users/yannischeng/TensorFlowDir/lib/python3.6/site-packages/tensorflow’] 直接通过 preference 进行选择： 3.2 在 pycharm 中创建新项目，选择刚刚配置的路径 4. 异常 1. tensorflow/core/platform/cpu_feature_guard.cc:140] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA 您的CPU支持未编译使用此TensorFlow二进制文件的说明：AVX2 FMA 参考：https://blog.csdn.net/PJ7410/article/details/78886048， https://github.com/lakshayg/tensorflow-buildhttps://stackoverflow.com/questions/47068709/your-cpu-supports-instructions-that-this-tensorflow-binary-was-not-compiled-to-u?answertab=votes#tab-top 三、 相关工具1. NumPy官网：http://www.numpy.org/# NumPy是用Python进行科学计算的基础软件包。它包含以下内容： 一个强大的N维数组对象 复杂的（广播）功能 用于集成C / C ++和Fortran代码的工具 有用的线性代数，傅里叶变换和随机数能力 除了明显的科学用途外，NumPy还可以用作通用数据的高效多维容器。可以定义任意数据类型。这使得NumPy能够与各种数据库无缝并快速地整合。 四、 TensorFlow 的使用1. 综述TensorFlow是一个编程系统，使用 图来表示计算任务。图中的结点被称为op（操作的缩写）。一个op获得0个或多个Tensor（张量），执行计算，产生0个或多个Tensor。每个张量是一个类型化的多维数组。 一个TensorFlow图描述了计算的过程。为了进行计算，图必须在会话（Session）里被启动。 会话将图的op分发到诸如CPU或GPU之类的设备上，同时提供执行op的方法。这些方法执行后，将产生的张量返回。在Python语言中，返回的张量是 numpy ndarray对象; 在C和C ++语言中，返回的张量是 tensorflow::Tensor实例。 2. TensorFlow 名词 使用图（graph）来表示计算任务。 在被称之为会话 (Session)的上下文（context）中执行图。 使用张量（Tensor）表示数据。 通过变量 (Variable)维护状态。 使用feed和fetch可以为任意的操作赋值或从其中获取数据。 3. 计算图TensorFlow程序通常有2个阶段： 构建阶段。在构建阶段，op的执行步骤被描述为一个图，通常在构建阶段创建一个图来表示和训练神经网络。 执行阶段。在执行阶段，使用会话执行图中的操作，在执行阶段反复执行图中的训练op。 TensorFlow支持C，C ++，Python编程语言。目前，TensorFlow的Python库更加易于使用，它提供了大量的辅助函数来简化构建图的工作，这些函数尚未被C和C ++库支持。 4. 构建图图文档：http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph 构建图的第一步，是创建源op（source op）。源op不需要任何输入，例如常量 (Constant)。源op的输出被传递给其它op做运算。 Python库中，op构造器的返回值代表被构造出的op的输出，这些返回值可以传递给其它op构造器作为输入。 TensorFlow Python库有一个默认图，op构造器可以为其增加节点。这个默认图对许多程序来说已经足够用了。阅读图类文档来了解如何管理多个图。 5. 在一个会话中启动图]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本变更]]></title>
    <url>%2F%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%2F</url>
    <content type="text"><![CDATA[Android各个版本的变更 ww Android 6.0（API 23）1. 运行时权限 参考：https://developer.android.com/guide/topics/permissions/overview 检查应用是否被授予权限：checkSelfPermission()；请求权限：requestPermissions() 2. 低电耗模式和应用待机模式 参考：https://developer.android.com/training/monitoring-device-state/doze-standby 2.1 低电耗模式如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。 2.2 应用待机模式应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。 优化 - 加入白名单 应用可以触发ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS Intent，让用户直接进入 Battery Optimization，他们可以在其中添加应用。 具有 REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 权限的应用可以触发系统对话框，让用户无需转到“设置”即可直接将应用添加到白名单。应用将通过触发ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Intent 来触发该对话框。 3. 取消支持 Apache HTTP 客户端Android 取消了 HttpClient 的使用，仅能使用 HttpURLConnection 4. 硬件标识访问权为给用户提供更严格的数据保护，从此版本开始，对于使用 WLAN API 和 Bluetooth API 的应用，Android 移除了对设备本地硬件标识符的编程访问权。WifiInfo.getMacAddress() 方法和 BluetoothAdapter.getAddress() 方法现在会返回常量值 02:00:00:00:00:00。 要通过 Bluetooth 和 WLAN 扫描访问附近外部设备的硬件标识符，您的应用必须拥有 ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION 权限。 5. 通知改用 Notification.Builder 类来构建通知。要重复更新通知，请重复使用 Notification.Builder 实例。调用 build() 方法可获取更新后的 Notification 实例。 6. 音频管理器变更不再支持通过 AudioManager 类直接设置音量或将特定音频流静音。setStreamSolo() 方法已弃用，您应该改为调用 requestAudioFocus() 方法。类似地，setStreamMute() 方法也已弃用，请改为调用 adjustStreamVolume() 方法并传入方向值 ADJUST_MUTE 或 ADJUST_UNMUTE。 7. WLAN和网络连接变更现在，您的应用只能更改由您创建的 WifiConfiguration 对象的状态。系统不允许您修改或删除由用户或其他应用创建的 WifiConfiguration 对象。在之前的版本中，如果应用利用带有 disableAllOthers=true 设置的 enableNetwork() 强制设备连接特定 WLAN 网络，设备将会断开与移动数据网络等其他网络的连接。在此版本中，设备不再断开与上述其他网络的连接。如果您的应用的 targetSdkVersion 为 “20” 或更低，则会固定连接所选 WLAN 网络。如果您的应用的 targetSdkVersion 为 “21” 或更高，请使用多网络 API（如 openConnection()、bindSocket() 和新增的 bindProcessToNetwork() 方法）来确保通过所选网络传送网络流量。 8. 相机服务变更访问模式由 先到先得 -&gt; 高优先级进程优先。 带有对用户可见 Activity 或前台 Activity 的应用进程一般会被授予较高的优先级，从而使相机资源的获取和使用更加可靠； 当高优先级的应用尝试使用相机时，系统可能会“驱逐”正在使用相机客户端的 低优先级 应用 多进程用例中 禁止同时访问。即使并没有其他应用直接尝试访问同一相机设备，此变更也可能导致低优先级客户端被“驱逐”。 更改当前用户会导致之前用户帐户拥有的应用内活动相机客户端被驱逐 9. APK验证该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。 Android 7.0（API 24）1. 低电耗模式 Android 6.0（API 级别 23）引入了低电耗模式，当用户设备未插接电源、处于静止状态且屏幕关闭时，该模式会推迟 CPU 和网络活动，从而延长电池寿命。 Android 7.0 则通过在设备未插接电源且屏幕关闭状态下、但 不一定要处于静止状态（例如用户外出时把手持式设备装在口袋里）时应用部分 CPU 和网络限制，进一步增强了低电耗模式。 分级应用 当设备处于 充电状态 且 屏幕已关闭一定时间后，设备会进入低电耗模式并应用 第一部分 限制：关闭应用网络访问、推迟作业和同步 进入低电耗模式 后设备 处于静止状态达到一定时间，系统则会对 PowerManager.WakeLock、AlarmManager闹铃 、GPS 和 WLAN 扫描应用余下的低电耗模式限制。 无论是应用部分还是全部低电耗模式限制，系统都会唤醒设备以提供简短的维护时间窗口，在此窗口期间，应用程序可以访问网络并执行任何被推迟的作业/同步。 1.2 后台优化移除了三项隐式广播，因为隐式广播会在后台频繁启动已注册侦听这些广播的应用。 不会收到 CONNECTIVITY_ACTION 广播，即使它们已有清单条目来请求接受这些事件的通知。在前台运行的应用如果使用 BroadcastReceiver 请求接收通知，则仍可以在主线程中侦听 CONNECTIVITY_CHANGE。 无法发送或接收 ACTION_NEW_PICTURE 或 ACTION_NEW_VIDEO 广播。 2. 权限更改应用私有目录被限制访问 私有文件的文件权限不应再由所有者放宽，为使用 MODE_WORLD_READABLE 和/或 MODE_WORLD_WRITEABLE 而进行的此类尝试将触发 SecurityException。 传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:// URI 会触发 FileUriExposedException。分享私有文件内容的推荐方法是使用 FileProvider。 DownloadManager 不再按文件名分享私人存储的文件。对于由 DownloadManager 公开的文件，首选的访问方式是使用ContentResolver.openFileDescriptor()。 3. 在应用间共享文件要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。 Android 7.1（API 25）多窗口支持App Shortcuts通过使用新的快捷方式功能，可以将用户从启动器直接发送到应用中的关键操作界面中。用户只需长按应用程序的启动器图标，即可显示应用程序的快捷方式，然后点击快捷方式跳转到相关操作。 每个快捷方式都引用一个intent，每个intent都会启动一个特定的操作或任务。 您可以通过将应用程序添加到APK中的资源文件来静态创建应用程序的快捷方式，也可以在运行时动态添加它们。静态快捷方式是常见操作的理想选择，动态快捷方式允许您根据用户的首选项，行为，位置等突出显示操作。可以在每个应用中提供最多五个快捷方式。 图形、图标资源应用程序现在可以定义圆形启动器图标，这些图标在支持它们的设备上使用。当启动器请求应用程序图标时，框架将返回 android:icon 或android:roundIcon，具体取决于设备构建配置。 改进的VR线程调度Android 7.1提供了改进VR线程调度的新功能。虚拟现实应用对延迟非常敏感。 应用程序现在可以将一个线程指定为VR线程。当应用程序处于 VR模式时，系统将更积极地调度该线程以最小化延迟。一个进程一次只能有一个VR线程，系统可能会对该线程的运行时间进行限制。当应用程序未处于VR模式时，该设置无效。 Android 8.0 （API 26）针对所有API 应用后台执行限制 参考：https://developer.android.com/about/versions/oreo/background 为提高电池续航时间而引入的变更之一是：当您的应用进入已缓存状态时，如果没有活动的组件，系统将解除应用具有的所有唤醒锁。 为提高设备性能，系统会限制未在前台运行的应用的某些行为。具体而言： 现在，在后台运行的应用对后台服务的访问受到限制。 应用无法使用其清单注册大部分隐式广播（即，并非专门针对此应用的广播）。 Android 8.0 还对特定函数做出了以下变更： 如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 startService() 函数，则该函数将引发一个 IllegalStateException。 新的 Context.startForegroundService() 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 Context.startForegroundService()。不过，应用必须在创建服务后的五秒内调用该服务的 startForeground() 函数。 Android 后台位置限制 参考：https://developer.android.com/about/versions/oreo/background-location-limits 为节约电池电量、保持良好的用户体验和确保系统健康运行，在运行 Android 8.0 的设备上使用后台应用时，降低了后台应用接收位置更新的频率。 此类变更会影响以下 API： Fused Location Provider (FLP) Geofencing Location Manager Wi-Fi Manager 为确保您的应用按预期方式运行，请完成以下步骤： 查看您的应用的逻辑，并确保您使用的是最新的位置 API。 测试您的应用是否在每个用例中都表现出预期行为。 考虑使用 Fused Location Provider (FLP) 或地理围栏来处理依赖于用户当前位置的用例。 应用快捷键 参考：https://developer.android.com/about/versions/oreo/android-8.0-changes Android 8.0 对应用快捷方式做出了以下变更： com.android.launcher.action.INSTALL_SHORTCUT 广播不再会对您的应用有任何影响，因为它现在是私有的隐式广播。相反，您应使用 ShortcutManager 类中的 requestPinShortcut() 函数创建应用快捷方式。 现在，ACTION_CREATE_SHORTCUT Intent 可以创建可使用 ShortcutManager 类进行管理的应用快捷方式。此 Intent 还可以创建不与 ShortcutManager 交互的旧版启动器快捷方式。在以前，此 Intent 只能创建旧版启动器快捷方式。 现在，使用 requestPinShortcut() 创建的快捷方式和在处理 ACTION_CREATE_SHORTCUT Intent 的操作组件中创建的快捷方式均已转换为功能齐全的应用快捷方式。因此，应用现在可以使用 ShortcutManager 中的函数来更新这些快捷方式。 旧版快捷方式仍然保留了它们在旧版 Android 中的功能，但您必须在应用中手动将它们转换成应用快捷方式。 提醒窗口如果应用使用 SYSTEM_ALERT_WINDOW 权限并且尝试使用以下窗口类型之一来在其他应用和系统窗口上方显示提醒窗口： TYPE_PHONE TYPE_PRIORITY_PHONE TYPE_SYSTEM_ALERT TYPE_SYSTEM_OVERLAY TYPE_SYSTEM_ERROR 那么，这些窗口将始终显示在使用 TYPE_APPLICATION_OVERLAY 窗口类型的窗口下方。如果应用针对的是 Android 8.0，则应用会使用 TYPE_APPLICATION_OVERLAY 窗口类型来显示提醒窗口。 网页表单自动填充针对8.0应用权限在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。 对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。 例如，假设某个应用在其清单中列出 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE。应用请求 READ_EXTERNAL_STORAGE，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予 WRITE_EXTERNAL_STORAGE，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 READ_EXTERNAL_STORAGE；不过，如果该应用后来又请求 WRITE_EXTERNAL_STORAGE，则系统会立即授予该权限，而不会提示用户。 Android 8.1 （API 27）Android P （API 28）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>版本变更</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于NFC（Near Field Communication）近场通讯]]></title>
    <url>%2F%E5%85%B3%E4%BA%8ENFC%EF%BC%88Near%20Field%20Communication%EF%BC%89%E8%BF%91%E5%9C%BA%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[目前NFC已经出现了一些应用，例如电子标签识别、刷手机、点对点付款、身份识别、信息记录等 NFC（Near Field Communication，近场通信）是一种数据传输技术。与Wi-Fi、蓝牙、红外线等数据传输技术的一个主要差异就是有效距离一般不能超过4厘米。 使用到的类 NfcManager : 用于获取此设备NfcAdapter。可以使用获取实例: getSystemService(Class) NfcAdapter : 代表本地NFC适配器。 它是您进行NFC操作的入口点。您可以通过getDefaultAdapter()或 获取实例getDefaultAdapter(android.content.Context)。 NdefMessage : 代表不可变的NDEF消息。这是在设备和标签之间传输携带数据的“记录”的标准格式。您的应用程序可以从ACTION_TAG_DISCOVERED意图中接收这些消息。 NdefRecord : 代表不可变的NDEF记录。 它在a中提供，NdefMessage并描述正在共享的数据类型并携带数据本身。 NfcEvent : 包装与任何NFC事件相关的信息。 Tag : 代表已发现的NFC标签。 使用到的接口 NfcAdapter.CreateBeamUrisCallback ： NfcAdapter.CreateNdefMessageCallback ：当另一个能够进行NDEF推送的NFC设备（Android Beam）处于范围内时，要调用的回调。 NfcAdapter.OnNdefPushCompleteCallback ： 系统成功将您的NdefMessage 设备交付给其他设备时要调用的回调。 NfcAdapter.OnTagRemovedListener ： 将标记从字段中删除时调用的回调。 NfcAdapter.ReaderCallback ：当前台活动在阅读器模式下运行时系统找到标签时要调用的回调。 释义NFC是一组短距离无线技术，通常需要4cm（近场）距离或更短距离才能启动连接。NFC可让您在NFC标签和Android设备之间或两台Android设备之间共享小型有效载荷数据。 标签的范围可能很复杂： 简单的标签：只提供读写语义，有时还有一次性可编程区域，使卡片成为只读。 更复杂的标签：提供数学运算，并具有加密硬件来验证对扇区的访问。 最复杂的标签：包含操作环境，允许与标签上执行的代码进行复杂的交互。 存储在标签中的数据也可以用各种格式编写，但许多Android框架API基于称为NDEF（NFC数据交换格式）的NFC论坛标准。 采用NFC的Android设备同时支持三种主要的操作模式： 读写器模式：允许NFC设备读取和/或写入无源NFC标签和贴纸。 P2P模式：允许NFC设备与其他NFC对等设备交换数据; 此操作模式由Android Beam使用。 卡模拟模式：允许NFC设备本身充当NFC卡。然后可以通过外部NFC阅读器访问仿真的NFC卡，例如NFC销售点终端。 NFC 基础知识在使用NDEF数据和Android时有两种主要用例： 从NFC标签读取NDEF数据 从NFC标签读取NDEF数据由标签调度系统处理,此系统分析发现的NFC标签，对数据进行适当分类，并启动对分类数据感兴趣的应用程序。想要处理扫描的NFC标签的应用程序可以声明意图过滤器并请求处理数据。 使用Android Beam将NDEF消息从一台设备传送到另一台设备 Android Beam功能允许设备将NDEF消息推送到另一台设备上，方法是将这些设备一起物理地轻击。这种交互提供了一种比其他无线技术（如蓝牙）更容易发送数据的方式，因为使用NFC时，不需要手动设备发现或配对。当两个设备进入范围时，连接自动启动。Android Beam通过一组NFC API可用，因此任何应用程序都可以在设备之间传输信息。例如，联系人，浏览器和YouTube应用程序使用Android Beam与其他设备共享联系人，网页和视频。 标签调度系统除非在设备的“设置”菜单中禁用NFC，否则Android设备通常会在屏幕解锁时查找NFC标签。当Android设备发现NFC标签时，理想的行为是让最合适的活动处理意图，而不要询问用户使用什么应用程序。由于设备在非常短的范围内扫描NFC标签，因此使用户手动选择活动可能会迫使他们将设备从标签移开并中断连接。所以应该开展活动以仅处理您的活动关心的NFC标签，以防止活动选择器出现。 为了帮助实现这一目标，Android提供了一个特殊的标签调度系统，用于分析扫描的NFC标签，对其进行分析并尝试定位对扫描数据感兴趣的应用程序。它是这样做的： 解析NFC标签并找出标识标签中数据有效载荷的MIME类型或URI。 将MIME类型或URI和有效负载封装到意图中。 根据意图启动一项活动。 NFC标签如何映射到MIME类型和URI在开始编写NFC应用程序之前，了解 NFC标签的不同类型、标签调度系统解析NFC标签的方式以及标签调度系统在检测到NDEF消息时执行的特殊工作非常重要。 NDEF数据封装在NdefMessage包含一个或多个记录（NdefRecord）的消息中。每个NDEF记录必须按照您要创建的记录类型的规范进行格式良好。 NDEF数据的操作 当Android设备驱动的设备扫描包含NDEF格式数据的NFC标签时，它会解析该消息并尝试找出数据的MIME类型或标识URI。 为此，系统读取第一个NdefRecord内容NdefMessage以确定如何解释整个NDEF消息（NDEF消息可以具有多个NDEF记录）。在格式良好的NDEF消息中，第一个NdefRecord 包含以下字段： 3位TNF（类型名称格式） 指示如何解释可变长度类型字段。 可变长度类型 描述记录的类型。如果使用TNF_WELL_KNOWN，使用此字段指定记录类型定义（RTD）。 可变长度ID 记录的唯一标识符。此字段不常使用，但如果您需要唯一标识标签，则可以为其创建标识。 可变长度有效载荷 您想要读取或写入的实际数据有效载荷。NDEF消息可以包含多个NDEF记录，因此不要假定完整的有效负载位于NDEF消息的第一个NDEF记录中。 标签调度系统使用TNF和类型字段尝试将MIME类型或URI映射到NDEF消息。如果成功，它会将该信息ACTION_NDEF_DISCOVERED与实际有效负载一起封装在意图中。但是，有些情况下，标签调度系统无法根据第一个NDEF记录确定数据的类型。当NDEF数据无法映射到MIME类型或URI，或者NFC标签不包含NDEF数据时，会发生这种情况。在这种情况下，Tag具有关于标签的技术和有效载荷的信息的对象被封装在ACTION_TECH_DISCOVERED意图的内部。 表1描述了标签调度系统如何将TNF和类型字段映射到MIME类型或URI。它还描述了哪些TNF不能映射到MIME类型或URI。在这些情况下，标签调度系统会回退到 ACTION_TECH_DISCOVERED。 例如，如果标签调度系统遇到类型记录TNF_ABSOLUTE_URI，它会将该记录的可变长度类型字段映射到URI中。标签调度系统将该URI ACTION_NDEF_DISCOVERED与其他关于标签的信息（例如有效载荷）一起封装在意图的数据字段中。另一方面，如果它遇到类型记录TNF_UNKNOWN，它会创建一个封装标签技术的意图。 NFC标签如何分配给应用程序当标签调度系统完成创建封装NFC标签及其标识信息的意图时，它将意向发送给感兴趣的应用程序，以针对意图进行过滤。如果多个应用程序可以处理该意图，则显示活动选择器，以便用户可以选择该活动。标签调度系统定义了三个意图，按照从高到低的顺序列出： ACTION_NDEF_DISCOVERED： 当包含NDEF有效载荷的标签被扫描并且是识别类型时，该意图用于启动Activity。这是最高优先级的意图，并且标签调度系统尽可能在任何其他意图之前尝试用此意图启动一个活动。 ACTION_TECH_DISCOVERED： 如果没有活动注册来处理ACTION_NDEF_DISCOVERED 意图，则标签调度系统会尝试以此意图启动应用程序。ACTION_NDEF_DISCOVERED如果扫描的标签包含无法映射到MIME类型或URI的NDEF数据，或者该标签不包含NDEF数据，但是具有已知的标记技术，则此直接启动（无需先启动）。 ACTION_TAG_DISCOVERED： 如果没有任何活动处理ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED 意图，则此意图开始。 标签调度系统的基本工作方式如下 尝试使用解析NFC标签（ACTION_NDEF_DISCOVERED或者ACTION_TECH_DISCOVERED）时由标签调度系统创建的意图启动一个活动 。 如果没有任何活动过滤该意图，请尝试启动具有下一个最低优先级意图的活动（ACTION_TECH_DISCOVERED或者ACTION_TAG_DISCOVERED），直到应用程序过滤该意图或直到标签调度系统尝试所有可能的意图。 如果没有应用程序筛选任何意图，则不执行任何操作。 只要有可能，就使用NDEF消息和ACTION_NDEF_DISCOVERED意图，因为它是三者中最具体的。这种意图使您能够在比其他两种意图更合适的时间启动您的应用程序，从而为用户提供更好的体验。 具体使用1. 在Android清单中请求NFC访问在访问设备的NFC硬件并正确处理NFC意图之前，请在AndroidManifest.xml文件中声明这些项目： 用于访问NFC硬件的NFC 元件： 1&lt;uses-permission android:name=&quot;android.permission.NFC&quot; /&gt; 您的应用程序可以支持的最低SDK版本。API级别9仅支持有限的标签分发ACTION_TAG_DISCOVERED，并且只能通过EXTRA_NDEF_MESSAGES额外的方式访问NDEF消息。没有其他标签属性或I / O操作可以访问。API级别10包括全面的读写器支持以及前台NDEF推送，而API level 14提供了一种使用Android Beam和其他便捷方法将NDEF消息推送到其他设备以创建NDEF记录的更简单的方法。 1&lt;uses-sdk android:minSdkVersion=&quot;10&quot;/&gt; 该uses-feature元素使您的应用程序仅在具有NFC硬件的设备上显示在Google Play中： 1&lt;uses-feature android:name=&quot;android.hardware.nfc&quot; android:required=&quot;true&quot; /&gt; 如果应用程序使用NFC功能，但这些功能是不是你的应用是至关重要的，你可以省略uses-feature元素和检查，看看是否在运行时检查NFC avalailbility getDefaultAdapter() 是null。 2. 过滤NFC intent要扫描想要处理的NFC标签时启动应用程序，您的应用程序可以筛选Android清单中的一个、两个或全部三个NFC意图 但是，通常需要筛选ACTION_NDEF_DISCOVERED意图，以便在您的应用程序启动时进行最大限度的控制。ACTION_TECH_DISCOVERED目的是回退ACTION_NDEF_DISCOVERED时没有应用程序过滤器ACTION_NDEF_DISCOVERED或当负载不NDEF。过滤ACTION_TAG_DISCOVERED通常过于笼统。 许多应用程序会为之前ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED之前进行过滤ACTION_TAG_DISCOVERED，因此您的应用程序的启动概率较低。 ACTION_TAG_DISCOVERED仅适用于在没有安装其他应用程序来处理ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED意图的情况下过滤应用程序的最后手段 。 由于NFC标签的部署有所不同并且多次不受控制，因此这并非总是可行，因此您可以在必要时回退到其他两个意图。当可以控制写入的标签和数据类型时，建议使用NDEF格式化标签。以下各节介绍如何针对每种意图类型进行过滤。 ACTION_NDEF_DISCOVERED 要过滤ACTION_NDEF_DISCOVERED意图，请声明意图过滤器以及要过滤的数据类型。以下示例筛选ACTION_NDEF_DISCOVERED MIME类型为以下内容的意图text/plain： 12345&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:mimeType=&quot;text/plain&quot; /&gt;&lt;/intent-filter&gt; 以下示例以URI形式过滤 http://developer.android.com/index.html。 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;developer.android.com&quot; android:pathPrefix=&quot;/index.html&quot; /&gt;&lt;/intent-filter&gt; ACTION_TECH_DISCOVERED 如果您的action按照ACTION_TECH_DISCOVERED意图进行过滤，则必须创建一个XML资源文件，以指定您的活动在一个tech-list集合内支持的技术。如果某个tech-list集合是标记所支持的技术的子集，则您的活动被视为匹配，您可以通过调用获取该技术getTechList()。 例如，如果扫描的标签支持MifareClassic，NdefFormatable和NfcA，则您的 tech-list设置必须指定全部三种，两种或一种技术（而不是其他任何技术），以便使您的活动得到匹配。 以下示例定义了所有技术。你可以删除那些你不需要的。保存这个文件（你可以将它命名为任何你想要的）在 /res/xml文件夹中。 12345678910111213&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcV&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NdefFormatable&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.MifareClassic&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.MifareUltralight&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt; 您也可以指定多个tech-list集合。每个tech-list 集合都是独立考虑的，如果任何一个tech-list集合是返回的技术的子集，那么您的活动就被认为是匹配 的getTechList()。这提供了AND与OR 匹配技术，语义。以下示例匹配可以支持NfcA和Ndef技术或可以支持NfcB和Ndef技术的标签： 12345678910111213&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt;&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt; 在你的AndroidManifest.xml文件中， 像下面的例子那样，在元素内部的元素中指定刚创建的资源文件： 12345678910&lt;activity&gt; ... &lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot; android:resource=&quot;@xml/nfc_tech_filter&quot; /&gt; ...&lt;/activity&gt; ACTION_TAG_DISCOVERED 要过滤ACTION_TAG_DISCOVERED使用以下意图过滤器： 123&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.TAG_DISCOVERED&quot;/&gt;&lt;/intent-filter&gt; 3. 从intent获取信息如果某个action是由于NFC的intent而启动的，则您可以从intent获取有关扫描的NFC标签的信息。intent可以包含以下附加内容，具体取决于扫描的标签： EXTRA_TAG（必需）：Tag代表扫描标签的对象。 EXTRA_NDEF_MESSAGES（可选）：从标签解析的NDEF消息数组。这个额外的ACTION_NDEF_DISCOVERED意图是强制性的 。 EXTRA_ID （可选）：标签的低级ID。 要获取这些附加内容，请检查您的活动是否以NFC意图之一启动，以确保扫描标签，然后从意图中获取附加信息。以下示例检查ACTION_NDEF_DISCOVERED 意图并从意图附加中获取NDEF消息。 1234567891011121314151617@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); ... if (intent != null &amp;&amp; NfcAdapter.ACTION_NDEF_DISCOVERED.equals(intent.getAction())) &#123; Parcelable[] rawMessages = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES); if (rawMessages != null) &#123; NdefMessage[] messages = new NdefMessage[rawMessages.length]; for (int i = 0; i &lt; rawMessages.length; i++) &#123; messages[i] = (NdefMessage) rawMessages[i]; &#125; // Process the messages array. ... &#125; &#125;&#125; 或者，您可以Tag从intent获取对象，该对象将包含有效内容并允许枚举标记的技术： 1Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG); 4. 创建常见的NDEF记录类型以下将会介绍创建常见类型的NDEF记录以在使用Android Beam编写NFC标签或发送数据时使用。从Android 4.0（API级别14）开始，该 createUri()方法可以帮助您自动创建URI记录。在开始的Android 4.1（API级别16）， createExternal() 并且createMime()可以帮助您创建MIME和外部类型NDEF记录。尽可能使用这些帮助器方法，以避免在手动创建NDEF记录时出错。 以下还将会介绍如何为记录创建相应的intent过滤器。所有这些NDEF记录示例应该放在NDEF消息的第一个NDEF记录中，您正在写入标签或发送。 TNF_ABSOLUTE_URI 建议使用 RTD_URI类型而不是TNF_ABSOLUTE_URI，因为它更高效。您可以TNF_ABSOLUTE_URI通过以下方式创建NDEF记录： 1234NdefRecord uriRecord = new NdefRecord( NdefRecord.TNF_ABSOLUTE_URI , &quot;http://developer.android.com/index.html&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;)), new byte[0], new byte[0]); 以前的NDEF记录的intent filter 如下所示： 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;developer.android.com&quot; android:pathPrefix=&quot;/index.html&quot; /&gt;&lt;/intent-filter&gt; TNF_MIME_MEDIA 您可以TNF_MIME_MEDIA通过以下方式创建NDEF记录：使用createMime()方法： 12NdefRecord mimeRecord = NdefRecord.createMime(&quot;application/vnd.com.example.android.beam&quot;, &quot;Beam me up, Android&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;))); NdefRecord手动创建： 1234NdefRecord mimeRecord = new NdefRecord( NdefRecord.TNF_MIME_MEDIA , &quot;application/vnd.com.example.android.beam&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;)), new byte[0], &quot;Beam me up, Android!&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;))); 以前的NDEF记录的意图过滤器如下所示 12345&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.com.example.android.beam&quot; /&gt;&lt;/intent-filter&gt; TNF_WELL_KNOWN与RTD_TEXT 1234567891011121314public NdefRecord createTextRecord(String payload, Locale locale, boolean encodeInUtf8) &#123; byte[] langBytes = locale.getLanguage().getBytes(Charset.forName(&quot;US-ASCII&quot;)); Charset utfEncoding = encodeInUtf8 ? Charset.forName(&quot;UTF-8&quot;) : Charset.forName(&quot;UTF-16&quot;); byte[] textBytes = payload.getBytes(utfEncoding); int utfBit = encodeInUtf8 ? 0 : (1 &lt;&lt; 7); char status = (char) (utfBit + langBytes.length); byte[] data = new byte[1 + langBytes.length + textBytes.length]; data[0] = (byte) status; System.arraycopy(langBytes, 0, data, 1, langBytes.length); System.arraycopy(textBytes, 0, data, 1 + langBytes.length, textBytes.length); NdefRecord record = new NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_TEXT, new byte[0], data); return record;&#125; 以前的创建方式 12345&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;text/plain&quot; /&gt;&lt;/intent-filter&gt; TNF_WELL_KNOWN与RTD_URI 使用 createUri(String) 创建 1NdefRecord rtdUriRecord1 = NdefRecord.createUri(&quot;http://example.com&quot;); 使用 createUri(Uri) 创建 12Uri uri = new Uri(&quot;http://example.com&quot;);NdefRecord rtdUriRecord2 = NdefRecord.createUri(uri); NdefRecord手动创建： 123456byte[] uriField = &quot;example.com&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;));byte[] payload = new byte[uriField.length + 1]; //add 1 for the URI Prefixbyte payload[0] = 0x01; //prefixes http://www. to the URISystem.arraycopy(uriField, 0, payload, 1, uriField.length); //appends URI to payloadNdefRecord rtdUriRecord = new NdefRecord( NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_URI, new byte[0], payload); 以前的创建方式 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;example.com&quot; android:pathPrefix=&quot;&quot; /&gt;&lt;/intent-filter&gt; TNF_EXTERNAL_TYPE 使用 createExternal() 方法 1234byte[] payload; //assign to your dataString domain = &quot;com.example&quot;; //usually your app&apos;s package nameString type = &quot;externalType&quot;;NdefRecord extRecord = NdefRecord.createExternal(domain, type, payload); NdefRecord手动创建： 1234byte[] payload;...NdefRecord extRecord = new NdefRecord( NdefRecord.TNF_EXTERNAL_TYPE, &quot;com.example:externalType&quot;, new byte[0], payload); 以前的创建方式 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;vnd.android.nfc&quot; android:host=&quot;ext&quot; android:pathPrefix=&quot;/com.example:externalType&quot;/&gt;&lt;/intent-filter&gt; 5. Android应用程序记录 Android Application Record (AAR)在Android 4.0（API级别14）中引入Android应用程序记录（AAR）可以更强有力地确定您的应用程序在扫描NFC标签时启动。 AAR具有嵌入NDEF记录内的应用程序的包名称。 您可以将AAR添加到NDEF消息的任何NDEF记录中，因为Android会在整个NDEF消息中搜索AAR。 如果它发现AAR，它将根据AAR中的包名称启动应用程序。 如果设备上没有应用程序，则会启动Google Play以下载应用程序。 如果想要阻止其他应用程序针对相同的意图进行过滤并可能处理您已部署的特定标记，则AAR很有用。AAR仅在应用程序级别受支持，因为包名称约束，而不是在意图过滤的活动级别。 如果标签包含AAR，则标签分派系统按以下方式分派：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>NFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager与Fragment]]></title>
    <url>%2FViewPager%E4%B8%8EFragment%2F</url>
    <content type="text"><![CDATA[在ViewPager与Fragment的搭配使用中，生命周期函数的调用顺序 注意：此处的log输出是 RadioGroup + ViewPager + Fragment 实现的 在此种情况的搭配下: 在宿主Activity中不会调用Fragment的 ‘onDestroy()’ 与 ‘onDetach()’ 方法 ViewPager与Fragment搭配说明：主MainActivity中有1个ViewPager与4个Fragment，其中第2个Fragment中嵌套1个ViewPager与2个Fragment. Activity调用顺序Activity的生命周期有7个函数 启动时，生命周期函数的调用顺序：12303-22 13:35:18.621 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 13:35:18.782 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 13:35:18.787 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onResume : 在长期黑屏后，调用： 1203-22 13:36:18.400 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 13:36:18.458 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onStop : 再次被唤醒 后，调用： 12303-22 13:42:43.822 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onRestart : 03-22 13:42:43.834 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 13:42:43.884 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onResume : 由当前ActivityA跳转至另一个ActivityB后，原ActivityA调用顺序为： 12345ActivityB调用onCreate、onStart、onResume后，再调用：03-22 13:44:20.090 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 13:44:20.888 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onStop :03-22 13:50:01.678 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onDestroy : Fragment调用顺序参考：https://www.cnblogs.com/fajieyefu/p/6092465.html Fragment的生命周期有11个函数 Fragment声明周期函数： Fragment声明周期函数调用： 进入宿主Activity中时： 123456789101112131415161718192021222303-22 14:36:54.109 MainActivity: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:36:54.147 MainActivity: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:36:54.151 MainActivity: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:36:54.178 AA: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:36:54.178 AA: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:36:54.178 AA: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:36:54.230 AA: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:36:54.233 AA: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:36:54.233 AA: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:36:54.256 BB: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:36:54.256 BB: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:36:54.178 BB: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:36:54.256 CC: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:36:54.256 CC: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:36:54.178 CC: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:36:54.276 BB: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:36:54.279 BB: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:36:54.279 BB: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:36:54.294 CC: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:36:54.297 CC: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:36:54.297 CC: ヽ(｀Д´)ﾉ -&gt; onResume : 在长期黑屏后，调用： 1234567803-22 14:37:20.726 AA: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:37:20.726 BB: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:37:20.726 CC: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:37:20.726 MainActivity: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:37:20.786 AA: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:37:20.786 BB: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:37:20.787 CC: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:37:20.787 MainActivity: ヽ(｀Д´)ﾉ -&gt; onStop : 再次被唤醒 后，调用： 12345678903-22 14:37:39.228 MainActivity: ヽ(｀Д´)ﾉ -&gt; onRestart : 03-22 14:37:39.240 AA: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:37:39.240 BB: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:37:39.240 CC: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:37:39.241 MainActivity: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:37:39.244 MainActivity: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:37:39.245 AA: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:37:39.245 BB: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:37:39.245 CC: ヽ(｀Д´)ﾉ -&gt; onResume : 当点击第2个Fragment时，第4个Fragment的调用： 12345603-22 14:38:46.521 DD: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:38:46.521 DD: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:38:46.521 DD: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:38:46.556 DD: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:38:46.558 DD: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:38:46.559 DD: ヽ(｀Д´)ﾉ -&gt; onResume : 直接点击第4个Fragment时，第1、5个Fragment的调用： 12345678910111213141503-22 14:41:31.900 DD: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:41:31.900 DD: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:41:31.900 DD: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:41:31.900 EE: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:41:31.900 EE: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:41:31.900 EE: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:41:31.930 DD: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:41:31.933 DD: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:41:31.933 DD: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:41:31.976 EE: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:41:31.979 EE: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:41:31.979 EE: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:41:32.322 AA: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:41:32.322 AA: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:41:32.323 AA: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 点击第5个Fragment时，第1、2、3个Fragment的调用： 12345678903-22 14:41:32.322 AA: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:41:32.322 AA: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:41:32.323 AA: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 03-22 14:42:59.494 BB: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:42:59.494 CC: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:42:59.494 BB: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:42:59.494 CC: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:42:59.495 BB: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 03-22 14:42:59.497 CC: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 再次点击第1个Fragment时，第4、5个Fragment的调用： 1234567891003-22 14:44:16.794 AA: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:44:16.794 AA: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:44:16.797 EE: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:44:16.798 EE: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:44:16.798 EE: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 03-22 14:44:16.799 AA: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:44:16.799 AA: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:44:36.074 DD: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:44:36.074 DD: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:44:36.075 DD: ヽ(｀Д´)ﾉ -&gt; onDestroyView :]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView相关]]></title>
    <url>%2FRecycleView%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[与RecyclerView使用相关的集合 1. item 滑动删除、更改位置：SimpleItemTouchHelperCallback类的使用12345678private ItemTouchHelper.Callback mCallback = null;...mCallback = new SimpleItemTouchHelperCallback(mAdapter);ItemTouchHelper touchHelper = new ItemTouchHelper(mCallback);touchHelper.attachToRecyclerView(mRecyclerView); 注意： 12345678910111213141516@Override public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) &#123; . . . // 此处的操作是根据 具体的item view布局具体执行的。 if ((int) dX &gt; oldDX) &#123; ((TextView) mViewGroup.getChildAt(1).findViewById(R.id.notice_view)).setText("松手取消删除"); &#125; else &#123; ((TextView) mViewGroup.getChildAt(1).findViewById(R.id.notice_view)).setText("继续左划删除"); &#125; . . . &#125; 2. 数据加载滑动处理2.1 xml局部布局文件注意：在布局文件中，SwipeToLoadLayout 、RefreshHeadView、RecyclerView 、 LoadMoreFooterView 控件的 id值均是固定的，不可修改的。 123456789101112131415161718192021222324252627282930313233343536373839&lt;com.zhy.autolayout.AutoRelativeLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/tv_nodate" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:text="暂无数据" android:textColor="@color/Deep_Orange_700" android:textSize="@dimen/text56" android:visibility="gone"/&gt; &lt;com.aspsine.swipetoloadlayout.SwipeToLoadLayout android:id="@+id/swipeToLoadLayout" style="@style/SwipeToLoadLayout"&gt; &lt;smallb.com.smallenterpriseserver.view.recycler_view_load_refresh.RefreshHeadView android:id="@+id/swipe_refresh_header" android:layout_width="match_parent" android:layout_height="300px" android:gravity="center" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/swipe_target" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/Grey_100"/&gt; &lt;smallb.com.smallenterpriseserver.view.recycler_view_load_refresh.LoadMoreFooterView android:id="@+id/swipe_load_more_footer" android:layout_width="match_parent" android:layout_height="300px" android:gravity="center"/&gt; &lt;/com.aspsine.swipetoloadlayout.SwipeToLoadLayout&gt;&lt;/com.zhy.autolayout.AutoRelativeLayout&gt; 2.2 xml布局中使用到的style样式文件1234567891011121314151617181920&lt;!-- RecyclerView上拉、下拉样式--&gt;&lt;style name="SwipeToLoadLayout"&gt; &lt;!--是否可以上拉、下拉刷新--&gt; &lt;item name="refresh_enabled"&gt;true&lt;/item&gt; &lt;item name="load_more_enabled"&gt;true&lt;/item&gt; &lt;!-- 宽高--&gt; &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt; &lt;item name="android:layout_height"&gt;match_parent&lt;/item&gt; &lt;!-- 上拉、下拉持续时间--&gt; &lt;item name="load_more_complete_delay_duration"&gt;50&lt;/item&gt; &lt;item name="refresh_complete_delay_duration"&gt;50&lt;/item&gt; &lt;!--上拉、下拉最大可拖动量--&gt; &lt;item name="load_more_final_drag_offset"&gt;200px&lt;/item&gt; &lt;item name="refresh_final_drag_offset"&gt;200px&lt;/item&gt; &lt;!-- 释放上拉、下拉持续的时间--&gt; &lt;item name="release_to_loading_more_scrolling_duration"&gt;1000&lt;/item&gt; &lt;item name="release_to_refreshing_scrolling_duration"&gt;1000&lt;/item&gt; &lt;!-- 设置下拉刷新与上拉加载的样式，其值为classic，above，blew或scale--&gt; &lt;item name="swipe_style"&gt;blew&lt;/item&gt;&lt;/style&gt; 2.3 java代码中使用 加载控件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119@Overridepublic void connectOK() &#123; mData.setVisibility(View.VISIBLE); mNullData.setVisibility(View.GONE); initMyView(); initMyData(); initSwipeLayout(); click();&#125;private void click() &#123; searchBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mSwipeToLoadLayout.isLoadingMore()) &#123; mSwipeToLoadLayout.setLoadMoreEnabled(false); &#125; mListBeans.clear(); list_num = 1; initMyData(); mSwipeToLoadLayout.setLoadMoreEnabled(true); mSwipeToLoadLayout.setRefreshing(false); &#125; &#125;); &#125;// 初始化 刷新、加载控件private void initSwipeLayout() &#123; mSwipeToLoadLayout.setRefreshHeaderView(mSwipeRefreshHeader); mSwipeToLoadLayout.setLoadMoreFooterView(mSwipeLoadMoreFooter); mSwipeToLoadLayout.setLoadMoreEnabled(true); mSwipeToLoadLayout.setRefreshEnabled(true); //刷新 mSwipeToLoadLayout.setOnRefreshListener(new OnRefreshListener() &#123; @Override public void onRefresh() &#123; if (mSwipeToLoadLayout.isLoadingMore()) &#123; mSwipeToLoadLayout.setLoadMoreEnabled(false); &#125; mListBeans.clear(); list_num = 1; initMyData(); mSwipeToLoadLayout.setLoadMoreEnabled(true); mSwipeToLoadLayout.setRefreshing(false); &#125; &#125;); //加载更多 mSwipeToLoadLayout.setOnLoadMoreListener(new OnLoadMoreListener() &#123; @Override public void onLoadMore() &#123; if (mSwipeToLoadLayout.isRefreshing()) &#123; mSwipeToLoadLayout.setRefreshEnabled(false); &#125; list_num = list_num + 1; initMyData(); mSwipeToLoadLayout.setRefreshEnabled(true); mSwipeToLoadLayout.setLoadingMore(false); &#125; &#125;);&#125;// 在 网络请求获取数据的过程中使用private void initMyData() &#123; HttpParams params = new HttpParams(); params.put(&quot;idcode&quot;, choseidcode); params.put(&quot;page&quot;, list_num); OkGo.post(MEASURE_HISTORY_PRESSURE).params(params).execute(new StringDialogCallback(mContext) &#123; @Override public void onSuccess(String s, Call call, Response response) &#123; Log.e(&quot;aaaaaa&quot;, s); History_Pressure history_pressure = JSON.parseObject(s, History_Pressure.class); if (history_pressure.getCode() == 100) &#123; if (history_pressure.getData().getList().get(0) != null) &#123; nodataTv.setVisibility(View.GONE); mSwipeToLoadLayout.setVisibility(View.VISIBLE); if (history_pressure.getData().getList().size() &lt; 10) &#123; mSwipeToLoadLayout.setLoadMoreEnabled(false); showToast(HistoryPressureActivity.this, &quot;没有更多数据&quot;); &#125; if (history_pressure.getData().getList().size() &gt; 0) &#123; for (History_Pressure.DataBean.ListBean listBean : history_pressure.getData().getList()) &#123; mListBeans.add(listBean); mAdapter.notifyDataSetChanged(); &#125; &#125; else &#123; showToast(HistoryPressureActivity.this, &quot;没有更多数据&quot;); mSwipeToLoadLayout.setLoadMoreEnabled(false); &#125; &#125; else &#123; if (list_num == 1) &#123; nodataTv.setVisibility(View.VISIBLE); mSwipeToLoadLayout.setVisibility(View.GONE); &#125; // showToast(HistoryPressureActivity.this, &quot;暂无数据&quot;); mSwipeToLoadLayout.setLoadMoreEnabled(false); &#125; &#125; else &#123; showToast(mContext, &quot;加载数据失败&quot;); &#125; &#125; &#125;);&#125;// 初始化界面中的各个控件private void initMyView() &#123; mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mRecyclerView.setItemAnimator(new DefaultItemAnimator()); mAdapter = new HealthAdapter(HistoryPressureActivity.this, mListBeans); mRecyclerView.setAdapter(mAdapter); lists = new ArrayList&lt;&gt;(); mFamilyBeans = new ArrayList&lt;&gt;();&#125; 3. 适配器万能适配器：点击事件处理 compile ‘com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.15’数据加载、刷新 ：自己的工具类item条目的处理（滑动、位置移动）：自己的工具类 使用参考：https://www.jianshu.com/p/1e20f301272e官方参考：http://www.recyclerview.org/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架-MVP初探]]></title>
    <url>%2F%E6%A1%86%E6%9E%B6-MVP%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[关于Android 的 MVP 框架 csdn 参考：https://www.jianshu.com/p/2ecfc1f4561d简书 参考：http://blog.csdn.net/hanchendong/article/details/61919599简书 对象销毁 参考：https://www.jianshu.com/p/1f91cfd68d48简书 命名规范（个人）：https://www.jianshu.com/p/c43b558c72b4 铺垫 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 项目分析设计原则：面向接口编程 他山之石，可以攻玉： 接口的作用类似给层与层之间制定的一种通信协议，两个不同的层级相互交流，只要遵守这些协议即可，并不需要知道具体的实现是怎样 构建框架的最终目的是增强项目代码的可读性 ，维护性，和方便测试 。要解决上述的三个问题，核心思想有两种： 分层 模块化 。 两个方法最终要实现的就是解耦，分层讲的是纵向层面上的解耦，模块化则是横向上的解耦。 说明 Activity是全体的控制器，它创建并连接views和presenters 一般来说，业务逻辑在presenter中，并且依赖view（在相应的Activity中实现各个View接口）去做Android UI（在View接口的方法中进行数据布置）的工作。 view几乎不包含业务逻辑，它将presenter的命令转换为UI动作（在View接口的方法中进行数据布置），并且监听用户动作传递给presenter（接口方法被回调）。 合同接口用于定义views和presenters之间的联系。 注意： 在一个MVP环境中，”View”项被重载（实现各个View接口）。 在MVP中从presenter接受命令的视图被简单的称为”view” 各个角色 Contract（合同） Activity Fragment Presenter（主持人-业务逻辑） View（UI动作） Mode（数据操作） 简述引用了诸多 mvp、mvc架构的网络图片，总有那么几张能让自己豁然开朗。 Android MVC框架 Activity 或者 Fragment 直接与数据层交互 Android MVP框架 多了两个层，一个是 Presenter 和 DataManager 层。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库-Retrofit2的了解]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E5%BA%93-Retrofit2%E7%9A%84%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/ljd2038/article/details/51046512参考：https://www.jianshu.com/p/af8bd1abda82 retrofit2.0它依赖于OkHttp,不需要显示的导入okHttp,在retrofit中已经导入okhttp3。 retrofit的官网 ：http://square.github.io/retrofit/ 1. 基本使用1.1 将HTTP API 转换为 java接口1234public interface GitHubService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125; 1.2 接口的实现类12345Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .build();GitHubService service = retrofit.create(GitHubService.class); 1.3 Call创建的每个GitHubService请求都可以向远程Web服务器发出同步或异步HTTP请求。12345678910111213Call &lt;List &lt;Repo &gt;&gt; repos = service.listRepos（“octocat”）;call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; ··· &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125;&#125;); 1.4 取消请求我们可以终止一个请求。终止操作是对底层的httpclient执行cancel操作。即使是正在执行的请求，也能够立即终止。 1call.cancel(); 2. 配置2.1.1 为Retrofit添加Gson转换器1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); gson依赖： 1compile &apos;com.squareup.retrofit2:converter-gson:2.0.1&apos; Simple XML依赖: 1compile &apos;com.squareup.retrofit2:converter-simplexml&apos; 2.1.2 自定义转换器如果您需要与使用Retrofit不支持开箱即用的内容格式（例如YAML，txt，自定义格式）的API进行通信，或者希望使用不同的库来实现现有格式，则可以轻松创建你自己的转换器。创建一个扩展Converter.Factory类并在构建适配器时传入实例的类。 2.2 增加日志信息在retrofit2.0中是没有日志功能的。但是retrofit2.0中依赖OkHttp，所以也就能够通过OkHttp中的interceptor来实现实际的底层的请求和响应日志。 12345678910111213// 创建 OkHttp日志拦截器HttpLoggingInterceptor httpLoggingInterceptor = new HttpLoggingInterceptor();httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);OkHttpClient okHttpClient = new OkHttpClient.Builder() .addInterceptor(httpLoggingInterceptor) .build(); // 在 Retrofit 2.0 中通过&apos;client()&apos;进行配置Retrofit retrofit = new Retrofit.Builder() .client(okHttpClient) .baseUrl(&quot;https://api.github.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); 日志信息-需要添加如下依赖。 1compile &apos;com.squareup.okhttp3:logging-interceptor:3.1.2&apos; 2.3 添加请求头例如： 1234567@Headers(&#123; &quot;Accept: application/vnd.github.v3.full+json&quot;, &quot;User-Agent: RetrofitBean-Sample-App&quot;, &quot;name:ljd&quot;&#125;)@GET(&quot;repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)Call&lt;List&lt;Contributor&gt;&gt; contributorsAndAddHeader(@Path(&quot;owner&quot;) String owner,@Path(&quot;repo&quot;) String repo); http的header：https://www.cnblogs.com/printN/p/6534529.html : http://blog.csdn.net/qingkongyeyue/article/details/54925741 3 请求每个方法都必须有一个提供请求方法和相对URL的HTTP注释。有五个内置注释：GET，POST，PUT，DELETE，和HEAD。资源的相对URL在注释中指定。 3.1 Get请求3.1.1 请求方法直接一个url：，@Url，它允许我们直接传入一个请求的URL 12@GETCall&lt;List&lt;Contributor&gt;&gt; repoContributorsPaginate(@Url String url); 路径式 1@GET(&quot;users/list&quot;) 3.1.2 网址操作可以使用方法上的替换块和参数动态更新请求URL。替换块是由{和包围的字母数字字符串}。相应的参数必须@Path使用相同的字符串进行注释。 12@GET(&quot;group/&#123;id&#125;/users&quot;)Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId); 您也可以在URL中指定查询参数。 1@GET(&quot;users/list?sort=desc&quot;) 3.1.3 查询参数也可以添加查询参数也可以添加。 12@GET(&quot;group/&#123;id&#125;/users&quot;)Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @Query(&quot;sort&quot;) String sort); 3.1.4 对于复杂的查询参数组合，Map可以使用对于复杂的查询参数组合，Map可以使用。 12@GET(&quot;group/&#123;id&#125;/users&quot;)Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @QueryMap Map&lt;String, String&gt; options); 4. Form encoded：发送表单数据4.1 表单数据使用@FormUrlEncoded注解来发送表单数据。使用 @Field注解和参数来指定每个表单项的Key，value为参数的值。 123@FormUrlEncoded@POST("user/edit")Call&lt;User&gt; updateUser(@Field("first_name") String first, @Field("last_name") String last); 4.2 多个表单参数可以通过@FieldMap注解和Map对象参数来指定每个表单项的Key，value的值。 123@FormUrlEncoded@POST(&quot;user/edit&quot;)Call&lt;User&gt; updateUser(@FieldMap Map&lt;String,String&gt; fieldMap); 5. Multipart 图片上传 参考：http://blog.csdn.net/ITjianghuxiaoxiong/article/details/52135748单图片：http://blog.csdn.net/sw5131899/article/details/52062321http://blog.csdn.net/sk719887916/article/details/51755427完整：http://blog.csdn.net/sk719887916/article/details/51755427封装：https://www.jianshu.com/p/29c2a9ac5abf基础：https://www.jianshu.com/p/308f3c54abddhttp基础：https://www.jianshu.com/p/e544b7a76dac 示例： 123@Multipart @POST("/member/uploadMemberIcon.do") Call&lt;Result&lt;String&gt;&gt; uploadMemberIcon(@Part MultipartBody.Part part/*, @Part(ParamKey.TOKEN) RequestBody token*/); 6. Retrofit与RxJava结合创建retrofit对象实例时，通过addCallAdapterFactory来添加对RxJava的支持。 123456Retrofit retrofit = new Retrofit.Builder() .client(okHttpClient) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .baseUrl("https://api.github.com/") .build(); 使用Observable创建一个API接口。 12@GET("repos/&#123;owner&#125;/&#123;repo&#125;/contributors")Observable&lt;List&lt;Contributor&gt;&gt; contributorsByRxJava(@Path("owner") String owner,@Path("repo") String repo);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-2]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2%2F</url>
    <content type="text"><![CDATA[温故知新 根本： 一般：存储不一样，操作不一样； 泛型：存储不一样，操作也一样。 流程 –&gt; 功能 –&gt; 试数 1. 数据存储1.1 存储结构 线性结构：把所有的结点（数组中的元素、个体）用一根直线穿起来。 连续存储：数组 离散存储：链表 非线性结构 1.2 存储结构应用 栈 队列 2. 存储结构 - 数组【连续存储】2.1 数组定义：元素类型相同，大小相等。 2.2 数组定义： 优点： 存取效率高 缺点： 插入、删除慢 需要占用大块连续的内存空间 需要知道数组的长度 2.3 代码实践：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &lt;stdio.h&gt;#include &lt;mm_malloc.h&gt;#include &lt;stdbool.h&gt;// 定义一个数据类型，该数据类型名字叫：struct ArrayYCA。数组所具有的条件:4个struct ArrayYCA&#123; int * arrayBase; // 存储的是数组的第一个元素的地址 int length; // 数组所能容纳的最大元素个数 int cnt; // 当前数组的有效个数 int increment; // 数组自动增长因子：当当前数组的元素个数已达到最大元素个数时,通过增加“increment”个元素个数，来扩充当前数组的内存空间。&#125;;// 定义一个数据类型，该数据类型名字叫：struct ArrayYCB。数组所具有的条件：3个struct ArrayYCB&#123; int * arrayBase; // 存储的是数组的第一个元素的地址 int length; // 数组所能容纳的最大元素个数 int cnt; // 当前数组的有效个数&#125;;// 是否已满bool is_full(struct ArrayYCB * array)&#123; if (array-&gt;cnt == array-&gt;length) return true; else return false;&#125;// 追加bool append_array(struct ArrayYCB * array, int value)&#123; if (is_full(array)) &#123; printf("当前数组已满！\n"); return false; &#125; else &#123; array-&gt;arrayBase[array-&gt;cnt] = value; array-&gt;cnt++; return true; &#125;&#125;// 插入 position的值从1开始bool insert_array(struct ArrayYCB * array, int value, int position)&#123; int i = 0; if (is_full(array)) &#123; printf("已满，插入失败\n"); return false; &#125; if (position &lt; 1 || position &gt; array-&gt;cnt + 1) &#123; printf("position参数输入异常\n"); return false; &#125; for (i = array-&gt;cnt - 1; i &gt;= position - 1; i--) &#123; array-&gt;arrayBase[i+1] = array-&gt;arrayBase[i]; &#125; array-&gt;arrayBase[position-1] = value; array-&gt;cnt++; return true;&#125;// 判空bool is_empty(struct ArrayYCB * array)&#123; if (0 == array-&gt;cnt) return true; else return false;&#125;// 删除 删除指定元素后，既能返回 删除bool值，又能返回所删除的具体值。bool delete_array(struct ArrayYCB * array, int position, int * delValue)&#123; if (is_empty(array)) return false; if (position &lt; 1 || position &gt; array-&gt;cnt) &#123; return false; &#125; int i = 0; // 主函数中获取删除的数值 * delValue = array-&gt;arrayBase[position - 1]; for (i = position; i &lt; array-&gt;cnt; ++i) &#123; printf("更新前数值为： %d, 更新后数值为： %d， 当前i值为： %d \n", array-&gt;arrayBase[i-1], array-&gt;arrayBase[i], i); array-&gt;arrayBase[i-1] = array-&gt;arrayBase[i]; &#125; array-&gt;cnt--; return true;&#125;// 输出void show_array(struct ArrayYCB * array)&#123; if (is_empty(array)) printf("当前数组为空！\n"); else &#123; for (int i = 0; i &lt; array-&gt;cnt; i++) &#123; printf("%d ",array-&gt;arrayBase[i]); &#125; printf("\n"); &#125;&#125;// 排序bool sort_array(struct ArrayYCB * array)&#123; int temp; for (int i = 0; i &lt; array-&gt;cnt; i++) &#123; printf("i is %d\n", array-&gt;arrayBase[i]); for (int j = i+1; j &lt; array-&gt;cnt; j++) &#123; printf("j is %d, ", array-&gt;arrayBase[j]); if (array-&gt;arrayBase[i] &gt; array-&gt;arrayBase[j]) &#123; temp = array-&gt;arrayBase[i]; array-&gt;arrayBase[i] = array-&gt;arrayBase[j]; array-&gt;arrayBase[j] = temp; &#125; &#125; printf("\n第 %d 次排序后的结果为：", i+1); show_array(array); printf("\n"); &#125; return true;&#125;// 倒序void inversion_array(struct ArrayYCB * array)&#123; int i = 0; int j = array-&gt;cnt - 1; int temp; while (i &lt; j) &#123; temp= array-&gt;arrayBase[i]; array-&gt;arrayBase[i] = array-&gt;arrayBase[j]; array-&gt;arrayBase[j] = temp; i++; j--; &#125;&#125;// 初始化void init_array(struct ArrayYCB * array, int length)&#123; // array这个指针变量指向结构体变量中的arrayBase； array-&gt;arrayBase = (int *)malloc(sizeof(int) * length); if (NULL == array-&gt;arrayBase) &#123; printf("状态内存分配异常！\n"); // 终止整个程序 exit(-1); &#125; else &#123; //(*array).length = 99; array-&gt;length = length; array-&gt;cnt = 0; &#125; return;&#125;// 主函数int main(int argc, const char * argv[]) &#123; struct ArrayYCB arr; init_array(&amp;arr,6); append_array(&amp;arr, 11); append_array(&amp;arr, 22); append_array(&amp;arr, 33); append_array(&amp;arr, 44); append_array(&amp;arr, 55); insert_array(&amp;arr,99,2); // if (!append_array(&amp;arr, 7)) &#123;// printf("追加失败\n");// &#125; printf("删除前结果为："); show_array(&amp;arr); int val; // 为获取删除元素的数值声明变量 if (delete_array(&amp;arr, 3, &amp;val)) &#123; printf("删除成功！\n"); printf("删除的数值 = %d\n",val); &#125; printf("到序前结果为："); show_array(&amp;arr); inversion_array(&amp;arr); printf("到序结果为："); show_array(&amp;arr); sort_array(&amp;arr); printf("排序结果为："); show_array(&amp;arr); return 0;&#125; 运行结果： 1234567891011121314151617181920212223242526272829删除前结果为：11 99 22 33 44 55 更新前数值为： 22, 更新后数值为： 33， 当前i值为： 3 更新前数值为： 33, 更新后数值为： 44， 当前i值为： 4 更新前数值为： 44, 更新后数值为： 55， 当前i值为： 5 删除成功！删除的数值 = 22到序前结果为：11 99 33 44 55 到序结果为：55 44 33 99 11 i is 55j is 44, j is 33, j is 99, j is 11, 第 1 次排序后的结果为：11 55 44 99 33 i is 55j is 44, j is 99, j is 33, 第 2 次排序后的结果为：11 33 55 99 44 i is 55j is 99, j is 44, 第 3 次排序后的结果为：11 33 44 99 55 i is 99j is 55, 第 4 次排序后的结果为：11 33 44 55 99 i is 99第 5 次排序后的结果为：11 33 44 55 99 排序结果为：11 33 44 55 99 3. 存储结构 - 链表【离散存储】3.1 重要性链表 -&gt; 树、图 3.2 链表定义： n个结点地址离散分配，彼此通过指针相连； （除首尾结点外）每个结点只有一个前驱结点和一个后续结点； 首结点没有前驱结点，尾结点没有后续结点。 3.3 名词： 头结点：第一个有效结点之前的结点。 无数据 无链表中结点个数 无实际含义，仅方便操作 头结点与首结点数据类型形同 首结点：第一个有效结点（存放数据） 尾结点：最后一个有效结点（存放数据） 头指针：指向头结点的指针变量 尾指针：指向尾结点的指针变量 通过函数对一个链表进行处理，只需要1个参数确定唯一链表：头指针 3.3 链表分类： 单链表 双链表：每一个结点有2个指针域 循环链表：能通过任何一个结点找到其他所有的结点。 非循环链表 3.4 链表算法： 优点： 空间没有限制 插入、删除元素快 缺点： 存取速度慢 3.5 链表算法： 遍历、输出元素 查找 清空 销毁 求长度 排序 删除结点 插入结点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;stdio.h&gt;#include &lt;mm_malloc.h&gt;#include &lt;stdlib.h&gt;// 链表数据结构typedef struct Node&#123; int data; // 数据域 struct Node * pNext; // 指针域&#125; NODE, * PNODE;// 函数声明// 创建链表PNODE create_link(void);// 输出链表void traverse_link(PNODE pHead);// 判空bool is_empty(PNODE pHead);// 长度int length_link(PNODE pHead);// 插入bool insert_link(PNODE pHead, int postion, int val);// 删除bool delete_link(PNODE pHead, int postion, int * val);// 排序void sort_link(PNODE pHead);int main(void)&#123; PNODE pHead = NULL; pHead = create_link(); if (is_empty(pHead)) printf("该链表为空！"); else traverse_link(pHead); int length = length_link(pHead); printf("link length = %d\n",length); // link length = 2 sort_link(pHead); traverse_link(pHead); // data = 12, data = 34, data = 54, data = 88, insert_link(pHead, 4, 76); traverse_link(pHead); int val; delete_link(pHead,3,&amp;val); traverse_link(pHead); printf("删除的数据 = %d\n",val);&#125;// 创建链表PNODE create_link(void)&#123; int len; int i; int val; // 1.分配了一个不存放数据的 头结点 PNODE pHead = (PNODE)malloc(sizeof(NODE)); if (NULL == pHead) &#123; printf("程序内存分配失败，终止！"); exit(-1); &#125; // 2. 指向 头结点 PNODE pTail = pHead; pTail-&gt;pNext = NULL; printf("请输入链表结点个数 = "); scanf("%d",&amp;len); for (i = 0; i &lt; len; i++) &#123; printf("请输入第%d个数值:",i+1); scanf("%d",&amp;val); // 3.创建带有实际数据的结点 PNODE pNew = (PNODE)malloc(sizeof(NODE)); if (NULL == pNew) &#123; printf("程序内存分配失败，终止！"); exit(-1); &#125; // pTail的出现是使得pNew永远指向 尾结点 pNew-&gt;data = val; // 将新生成的pNew结点 “挂” 到链表中 pTail-&gt;pNext = pNew; // 使得 pNew成为尾结点 pNew-&gt;pNext = NULL; // 使得pTail成为尾结点 pTail = pNew; &#125; return pHead;&#125;// 输出链表void traverse_link(PNODE pHead)&#123; PNODE p = pHead-&gt;pNext; while (NULL != p) &#123; printf("data = %d, ",p-&gt;data); // data = 21, data = 23, p = p-&gt;pNext; &#125; printf("\n");&#125;/** 请输入链表结点个数 = 4 请输入第1个数值:21 请输入第2个数值:23 请输入第3个数值:34 请输入第4个数值:45 data = 21, data = 23, data = 34, data = 45, */// 判空bool is_empty(PNODE pHead)&#123; if (NULL == pHead-&gt;pNext) return true; else return false;&#125;// 长度int length_link(PNODE pHead)&#123; int count = 0; PNODE p = pHead-&gt;pNext; while (NULL != p) &#123; count++; p = p-&gt;pNext; &#125; return count;&#125;// 排序void sort_link(PNODE pHead)&#123; int length = length_link(pHead); int i, j, temp; PNODE p,q; for (i = 0, p = pHead-&gt;pNext; i &lt; length - 1; i++, p = p-&gt;pNext) &#123; for (j = i + 1, q = p-&gt;pNext; j &lt;length; j++, q = q-&gt;pNext) &#123; if (p-&gt;data &gt; q-&gt;data) &#123; temp = p-&gt;data; p-&gt;data = q-&gt;data; q-&gt;data = temp; &#125; &#125; &#125; return;&#125;// 插入// 在pHead所指向的链表的第position个结点前面插入一个新的结点。插入结点的值是val，并且position的值是1bool insert_link(PNODE pHead, int postion, int val)&#123; int i = 0; PNODE p = pHead; printf("pHead 当前地址 = %X\n",p); // 进行条件判断 while (NULL != p &amp;&amp; i &lt; postion - 1) &#123; // 获取到对应position-1位置的链表结点 p = p-&gt;pNext; int pVal = p-&gt;data; printf("pHead %d 当前地址 = %X, 对应的数据为 = %d\n",i, p, pVal); i++; &#125; if (i &gt; postion || NULL == p) &#123; return false; &#125; // 声明一个新结点 PNODE pNew = (PNODE)malloc(sizeof(PNODE)); if (NULL == pNew) &#123; printf("内次分配失败，退出！"); exit(-1); &#125; // 为新增加的结点赋值 pNew-&gt;data = val; PNODE q = p-&gt;pNext; p-&gt;pNext = pNew; pNew-&gt;pNext = q; return true;&#125;// 删除 , 得到删除的元素值bool delete_link(PNODE pHead, int postion, int * val)&#123; int i = 0; PNODE p = pHead; while (NULL != p-&gt;pNext &amp;&amp; i &lt; postion - 1) &#123; p = p-&gt;pNext; i++; &#125; if (i &gt; postion || NULL == p) &#123; return false; &#125; PNODE q = p-&gt;pNext; *val = q-&gt;data; p-&gt;pNext = p-&gt;pNext-&gt;pNext; free(q); q = NULL; return true;&#125; 运行结果为： 123456789101112131415请输入链表结点个数 = 4请输入第1个数值:21请输入第2个数值:32请输入第3个数值:14请输入第4个数值:55data = 21, data = 32, data = 14, data = 55, link length = 4data = 14, data = 21, data = 32, data = 55, pHead 当前地址 = 4072E0pHead 0 当前地址 = 407360, 对应的数据为 = 14pHead 1 当前地址 = 40C520, 对应的数据为 = 21pHead 2 当前地址 = 601040, 对应的数据为 = 32data = 14, data = 21, data = 32, data = 76, data = 55, data = 14, data = 21, data = 76, data = 55, 删除的数据 = 32 汉诺塔 手动分析步骤： 123456789101112131415161718192021222324252627282930313233(1） n == 1 第1次 1号盘 A----&gt;C sum = 1 次(2) n == 2 第1次 1号盘 A----&gt;B 第2次 2号盘 A----&gt;C 第3次 1号盘 B----&gt;C sum = 3 次(3) n == 3 第1次 1号盘 A----&gt;C 第2次 2号盘 A----&gt;B 第3次 1号盘 C----&gt;B 第4次 3号盘 A----&gt;C 第5次 1号盘 B----&gt;A 第6次 2号盘 B----&gt;C 第7次 1号盘 A----&gt;C sum = 7 次 . . . 移动次数为：2^n - 1 分析 实现这个算法可以简单分为三个步骤： （1） 把n-1个盘子由A 移到 B； （2） 把第n个盘子由 A移到 C； （3） 把n-1个盘子由B 移到 C； 继续细节分析： （1）中间的一步是把最大的一个盘子由A移到C上去； （2）中间一步之上可以看成把A上n-1个盘子通过借助辅助塔（C塔）移到了B上， （3）中间一步之下可以看成把B上n-1个盘子通过借助辅助塔（A塔）移到了C上； Java代码实现 12345678910111213141516171819202122232425262728public class Hannuo &#123; static int m = 0; public static void main(String[] args) &#123; int disks = 3; char A = &apos;A&apos;; char B = &apos;B&apos;; char C = &apos;C&apos;; Hannuo.hannuo(disks, A, B, C); &#125; private static void move(int disks, char M, char N) &#123; System.out.println(&quot;第&quot; + (++m) + &quot; 次移动 : &quot; + &quot; 把 &quot; + disks + &quot; 号圆盘从 &quot; + M + &quot; -&gt;移到-&gt; &quot; + N); &#125; public static void hannuo(int n, char A, char B, char C) &#123; if (n == 1) &#123; Hannuo.move(n, A, C); &#125; else &#123; hannuo(n - 1, A, C, B); Hannuo.move(n, A, C); hannuo(n - 1, B, A, C); &#125; &#125;&#125; 运行结果 1234567第1 次移动 : 把 1 号圆盘从 A -&gt;移到-&gt; C第2 次移动 : 把 2 号圆盘从 A -&gt;移到-&gt; B第3 次移动 : 把 1 号圆盘从 C -&gt;移到-&gt; B第4 次移动 : 把 3 号圆盘从 A -&gt;移到-&gt; C第5 次移动 : 把 1 号圆盘从 B -&gt;移到-&gt; A第6 次移动 : 把 2 号圆盘从 B -&gt;移到-&gt; C第7 次移动 : 把 1 号圆盘从 A -&gt;移到-&gt; C]]></content>
      <categories>
        <category>温故知新</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-1]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1%2F</url>
    <content type="text"><![CDATA[温故知新 根本： 一般：存储不一样，操作不一样； 泛型：存储不一样，操作也一样。 流程 –&gt; 功能 –&gt; 试数 1. 基础1.1 数据结构定义： 完整： 把现实中大量而复杂的问题以特定的数据类型（个体）和特定的存储结构（个体间的关系）保存到主存储器（内存）中，以及在此基础上为实现某一个功能而执行的相应操作，这个操作就叫做算法。 数据结构是转门研究数据存储的问题。 数据的存储包含2方面：个体的存储 + 个体关系的存储 简述： 数据结构 = 个体 + 个体间的关系 算法 = 对存储数据的操作 - 狭义的算法：与数据的存储方式密切相关 - 伪算法。 - 广义的算法：与数据的存储方式无关 - 代码算法。 泛型：利用某种技术达到的效果就是：不同的数据存储方式，执行的操作是一样的。 1.2 衡量算法的标准： 时间复杂度：研究中。算法执行过程中大概执行的次数，而非时间。 空间复杂度：研究中。算法执行过程中大概所占用的最大内存 难易程度：应用中。 健壮性 1.3 数据结构重要性： 程序 = 数据存储（数据结构） ＋ 数据操作（算法） ＋ 可以被计算机执行的语言（语言） 1.4 其他 地址： 地址 就是 内存单元编号。地址对应的内存中的位置是固定的，但地址对应的内存中的位置的数值是可变的。 从0开始的非负整数 范围：［0 － 4G-1］ 指针： 指针是C语言的灵魂。 指针 ＜＝＞ 地址 指针变量是存放内存单元地址的变量 指针本质是一个操作受限的非负整数 指针分类： 结构体 动态内存分配和释放 1.5 存储方式 1. 线性：数组 数组名：一维数组名是个指针常量，存放的是一维数组的的第一个元素的地址，他的值不能被改变，一维数组名指向的是数组的第一个元素。 下标：a[i] &lt;&lt; = = &gt;&gt; *(a +i) 常见应用： 栈 队列 2. 离散：链表 3. 数组存储不一样，操作不一样，泛型 2. 指针、指针变量、指针指向 在函数没有返回值的情况下，通过函数修改实参的值，仅通过获取实参地址。 修改变量地址的写法： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main(void)&#123; int * p; // 这个一个指针变量。'p'是变量名字，是内存抽象地址的实例表示;'int *' 表示p变量只能存储‘int类型变量’的地址，即，此时的p仅能存储‘int类型’的地址 printf("init p address :%X\n",p); printf("init p value :%D\n",*p); int i = 12; // 这是一个普通变量 int j; printf("init value : %d, %d, %d\n",i,j,*p); printf("init i address :%X\n",&amp;i); p = &amp;i; // int *p = &amp;i; printf("change p address :%X\n",p); printf("change p value :%D\n",*p); // 修改*p的数值 *p = 21; printf("change p value %d\n", *p); printf("init i value :%d\n",i); // 修改i的数值 i = 33; printf("change p value %d\n", *p); printf("init i value :%d\n",i); j = *p; // j = i; printf("chagne value : %d, %d, %d\n",i,j,*p); return 0;&#125; 运行结果 1234567891011init p address :EFBFF590init p value :0init value : 12, 0, 0init i address :EFBFF56Cchange p address :EFBFF56Cchange p value :12change p value 21init i value :21change p value 33init i value :33chagne value : 33, 33, 33 通过方法改变变量的数值 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;// 注意：此处不是定义了一个名字叫做 *p的形参(int *p)，而是定义了一个形参，形参的名字叫做p(int * p),类型是int *// 此处有误' ',都不形象参数的类型。void func(int * p)&#123; *p = 100;&#125;int main(void)&#123; int * p; // 这个一个指针变量。'p'是变量名字，是内存抽象地址的实例表示;'int *' 表示p变量只能存储‘int类型变量’的地址，即，此时的p仅能存储‘int类型’的地址 printf("init p address :%X\n",p); printf("init p value :%D\n",*p); int i = 12; // 这是一个普通变量 int j = 0; printf("init value : %d, %d, %d\n",i,j,*p); printf("init i address :%X\n",&amp;i); p = &amp;i; // int *p = &amp;i; printf("change p address :%X\n",p); printf("change p value :%D\n",*p); // 修改*p的数值 *p = 21; printf("change p value %d\n", *p); printf("init i value :%d\n",i); // 修改i的数值 i = 33; printf("change p value %d\n", *p); printf("init i value :%d\n",i); j = *p; // j = i; printf("chagne value : %d, %d, %d\n",i,j,*p); func(&amp;j); printf("j = %d\n",j); // 结果：j = 100 return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void func(int * temp)&#123; *temp = 100;&#125;// 仅需要知道一个数组的 首地址 和 数组长度 ，即可操作此数组void Show_Array(int *p, int len)&#123; p[2] = 33; for(int i = 0; i &lt; len;i++) &#123; printf("%d\n", p[i]); &#125; /** 1 2 33 4 5 */&#125;void array()&#123; int a[5] = &#123;1,2,3,4,5&#125;; printf("a[0] address is %d,*a address is %d\n",&amp;a[0],a); printf("*a + 3 = %d\n",*a+3); printf("a[0] is %d,*a is %d\n",a[0],*a); printf("a[4] is %d,*(a+4) is %d\n",a[4],*(a+4)); printf("a[0] address is %d\n",&amp;a[0]); printf("a[1] address is %d\n",&amp;a[1]); printf("a[2] address is %d\n",&amp;a[2]); printf("a[3] address is %d\n",&amp;a[3]); printf("a[4] address is %d\n",&amp;a[4]); /** a[0] address is -272632336,*a address is -272632336 a[0] is 1,*a is 1 a[4] is 5,*(a+4) is 5 a[0] == *(a),a[3] == *(a+3) a[0] address is -272632336 a[1] address is -272632332 a[2] address is -272632328 a[3] address is -272632324 a[4] address is -272632320 */ Show_Array(a,5); printf("a[2] = %d\n",a[2]); /** a[2] = 33 */&#125;int main(void)&#123; int j = 10; func(&amp;j); printf("j is %d\n",j); array(); return 0;&#125; 3. 结构体描述： 类似java类，模拟事物 只有属性，没有方法 为了表示一些复杂的数据，而普通的基本数据无法满足需要。用户根据自己的实际需要，自己定义的数据类型，非变量，未分配内存。 123456789101112131415161718// 结构体, 数据类型叫：struct Student，struct Student&#123; int sid; char name[200]; int age;&#125;;int main(void)&#123; // 结构体声明变量 struct Student stu = &#123;101,"zhansan",32&#125;; // 访问结构体变量的成员 printf("%d, %s, %d\n",stu.age,stu.name,stu.age); // 32, zhansan, 32 return 0;&#125; 修改结构体数值方式 12345678910// 修改数值方式1 stu.age = 33; // age = 33 printf("age = %d\n",stu.age); // 修改数值方式2 pst = &amp;stu; pst-&gt;age = 23;// pst-&gt;age == (*pst).age == stu.age printf("age age = %d\n",(*pst).age); // age age = 23 pst-&gt;age含义（链表）：pst所指向的结构体变量中的age这个成员 注意： 结构体变量之间不能“+ - /”，但是*可以相互赋值 普通结构体变量 和 结构体指针变量作为函数传参的问题： 1234567891011// 输出结构体 方式1：整个结构体内存void goStruct(struct Student stu)&#123; printf("goStruct data is %d, %s, %d\n",stu.sid,stu.name,stu.age);&#125;// 输出结构体 方式2：仅传递结构体地址void goStructPointer(struct Student * stu)&#123; printf("goStructPointer data is %d, %s, %d\n",stu-&gt;sid,stu-&gt;name,stu-&gt;age);&#125; 应用函数： 123456789struct Student stu = &#123;101,"zhansan",32&#125;;// 不推荐，耗时、内存goStruct(stu);// goStruct data is 1111, www, 66 // 推荐goStructPointer(&amp;stu);// goStructPointer data is 1111, www, 66 4. 动态内存分配和释放java中的new 实例： A aa = new A(); 类似于c中的： A * aaM = (A *)malloc(sizeof(A)); 主要语句： 12345#include &lt;mm_malloc.h&gt;// int类型地址int * mArray = (int *)malloc(sizeof(int) * len);free(mArray); 完整： 12345678910111213141516171819202122232425262728293031323334// malloc() 动态函数void myMalloc()&#123; int len; printf("input length:\n"); // 手动输入数组长度 scanf("%d",&amp;len); // int类型地址 int * mArray = (int *)malloc(sizeof(int) * len); // 手动初始数组: printf("input array item :\n"); for (int i = 0; i &lt; len; i++) &#123; scanf("%d, ",&amp;mArray[i]); &#125; // 1 2 3 4 5 // 遍历数组 for (int i = 0; i &lt; len; i++) &#123; printf("%d, ",*(mArray+i)); &#125; // 1, 2, 3, 4, 5, printf("\n"); free(mArray);&#125;int main(void)&#123; // 动态内存 myMalloc(); return 0;&#125; 跨函数调用内存空间 -通过动态申请内存空间一般情况下，当一个函数调动完毕之后，该函数之前占用的内存将会被释放。下图展示的是，当一个main函数调用另一个fun函数后，fun函数中的变量所占用的内存仍然保留，未释放的例子： 实例： 123456789101112131415161718192021222324252627282930// 动态分配内存struct StudentA * CreateStudentA(void)&#123; struct StudentA * newSA = (struct StudentA *)malloc(sizeof(struct StudentA)); printf("newSA address is : %d\n",&amp;newSA); newSA-&gt;age = 120; newSA-&gt;sid = 1001; return newSA;&#125;// 展示内存中的数据void ShowStudentA(struct StudentA * aa)&#123; printf("ShowStudentA ：aa = %d , sid = %d \n", aa-&gt;age, aa-&gt;sid);&#125;int main(void)&#123; struct StudentA * sa; sa = CreateStudentA(); printf("sa address is : %d\n",&amp;sa); ShowStudentA(sa); printf("sa address is : %d\n",&amp;sa); /** init sa address is : -272632288 newSA address is : -272632328 sa address is : -272632288 ShowStudentA ：aa = 120 , sid = 1001 */ return 0;&#125; 图文 5. struct与typedef的使用1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;// typedef 的使用// typedef的作用就是为已存在的数据类型重新取一个名字，即：别名typedef int YC;typedef struct Student&#123; int sid; char name[100]; int age;&#125; ST;int main(int argc, const char * argv[]) &#123; YC num = 100; printf("YC's num is %d \n",num); //struct Student stu; 等价于 ST stu; //struct Student * stuA; 等价于 ST * stuA; ST stu; stu.age = 32; printf("stu age = %d\n", stu.age); return 0;&#125; 运行结果 12YC's num is 100 stu age = 32 12345678typedef struct Student&#123; int sid; char name[100]; int age;&#125; * PST,ST;// * PS 等价于 struct Student *// ST 等价于 struct Student]]></content>
      <categories>
        <category>温故知新</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源的许可证GPL、LGPL、BSD、Apache 2.0的通俗解释]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E7%9A%84%E8%AE%B8%E5%8F%AF%E8%AF%81GPL%E3%80%81LGPL%E3%80%81BSD%E3%80%81Apache-2-0%E7%9A%84%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[参考：https://www.cnblogs.com/jacob-tian/p/5976088.html 软件开发者要开源软件，不单单是开放源代码就可以了，选择一种许可证很重要，一个许可证之于软件就相当于价值观之于普通人，代表了这个软件的基本品性。一个错误的许可证选择可能会直接导致整个项目的失败。 各种开源的许可证主要的限制还是在redistribution（发布），所以个人/商业公司开发的软件包含了GPL的代码，只要你不发布，是可以任意使用的。 下面是几个开源许可证的区别： GPL GPL软件的使用者有权力得到软件的代码，只要使用了GPL，在发布(redistribution)时，整个项目也必须是GPL的，即主程序和静态链接的库（linux的.a和Windows的.lib）必须是GPL的，动态链接库(Linux的.so，Windows的.dll)必须是GPL兼容的。所谓GPL兼容，也就是GPL软件中可以使用的库，这些许可证必须比GPL弱(如LGPL，BSD)，而不能是某个商业许可证。正因如此，GPL是带有很强的传染性，只要你的软件使用了GPL的代码，那么就请以GPL开放源代码吧，并且你的项目中也不能有任何和GPL不兼容的库。 LGPL GPL 带有很强的传染性，那么如果一个库使用GPL发布，那么使用这个库的所有软件也必须使用GPL发布，这对不想开放源代码的商业软件来讲是致命的打击——你可以不使用其他的库，但最基本的libc是无论如何绕不开的，如果libc是以GPL发布，就相当于所有软件必须以GPL发布了。所以，LGPL(Lesser GPL)诞生了。 LGPL定义为，在以LGPL发布的库的基础上开发新的库的时候，新的库必须以LGPL发布，但是如果仅仅是动态链接，那么则不受任何限制。这样商业软件就可以随意的使用LGPL的库了。因此，LGPL也具有传染性，但限制在其基础上开发的库上，而并不限制使用它的程序本身——它的传染性远小于GPL。 BSD、Apache 2.0 相对GPL/LGPL的开放源代码，BSD，Apache 2.0就宽松许多——商业软件可以任意的使用BSD，Apache 2.0发布的软件代码，而不需要开放源代码，只需要提及代码的原出处就可以了。BSD和Apache 2.0提及的方式稍有不同，具体可以参考协议的详细内容。它们是GPL兼容的 看看下面选择开源许可证的案例： andorid 使用宽松的Apache 2.0发布，因为Google作为一个商业公司，并不想失去商业软件的支持，它希望团结一切可以团结的力量加入的Android的开发中来，壮大自己的阵营，使用Apache 2.0就无可厚非了。而Google本身，并没有丧失对Android的控制权，不会担心另外一个公司拿走了Android的代码开发出一个闭源 Android的对手。因为，只要Android不断的出新版，社区不停的跟进，并且不停的修改API，其他基于Android开发的公司不得不把自己的Patch提回到主干上，否则，必然将耗费大量人力物力在维护自己的Patch上(钱这方面你斗得过Google？)，得不偿失。而且，闭源之后，与整个社区为敌，作为一个定位软件平台的项目，会流失大量应用软件开发者，以小博大，任何一个商业公司都不会干这种胜算不高的蠢事。 再看以GPL发布的Linux为什么比以BSD发布的FreeBSD成功。其实正是因为GPL的传染性。当一个开发人员在Linux基础上开发一个新功能之后， 不得不以GPL开放源代码，贡献回Linux，这样Linux本身才能越来也越壮大而且留住了相当的开发人员，形成了一个 优秀软件-&gt;很多使用者和贡献者-&gt;贡献－&gt;更优秀的软件-&gt;更多的使用者和贡献者… 的良性循环。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Service]]></title>
    <url>%2FAndroid-Service%2F</url>
    <content type="text"><![CDATA[参考：http://www.sunnyang.com/215.html 简介Service 是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。 服务不提供用户界面。 例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与 Activity 的交互。 诸如 Activity 等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 Service 并不是一个进程也不是一个线程，是运行在主线程中的，因此如果处理cpu密集工作，建议在service开启一个新的子线程的。 应用程序告诉系统在后台处理一些事情，甚至不需要用户同应用程序直接交互，系统主要是通过Context.startService()来启动服务的，除非Service本身或者其他人明确来停止它否则将一直运行下去。 将应用程序自己的某些功能暴露给其它程序，这种交互主要通过Context.bindService(),允许长连接的服务来与之交互。 服务基本上分为两种形式：启动当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。 绑定当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 注意： 服务可以同时以这两种方式运行，也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是在于您是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。 无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，您可以通过清单文件将服务声明为私有服务，并阻止其他应用访问 服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。 基础要创建服务，必须创建 Service 子类（或使用它的一个现有子类）。在实现中，您需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括： onStartCommand()当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。） onBind()当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。 onCreate()首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。 onDestroy()当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。 如果组件通过调用startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。 如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。 清单文件声明服务要声明服务，请添加 元素作为 元素的子元素。例如： 1234567&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;service android:name=&quot;.ExampleService&quot; /&gt; ... &lt;/application&gt;&lt;/manifest&gt; 为了确保应用的安全性，请始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。 此外，还可以通过添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。 服务生命周期: 左图显示了使用 startService() 所创建的服务的生命周期，右图显示了使用 bindService() 所创建的服务的生命周期。 服务生命周期的两个嵌套循环： 服务的整个生命周期从调用 onCreate() 开始起，到 onDestroy() 返回时结束。与 Activity 类似，服务也在 onCreate() 中完成初始设置，并在 onDestroy() 中释放所有剩余资源。例如，音乐播放服务可以在 onCreate() 中创建用于播放音乐的线程，然后在 onDestroy() 中停止该线程。无论服务是通过 startService() 还是 bindService() 创建，都会为所有服务调用 onCreate() 和 onDestroy() 方法。 服务的有效生命周期从调用 onStartCommand() 或 onBind() 方法开始。每种方法均有 {Intent 对象，该对象分别传递到 startService() 或 bindService()。对于启动服务，有效生命周期与整个生命周期同时结束（即便是在 onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在 onUnbind() 返回时结束。 启动方式1：创建启动服务启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。 服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。 应用组件（如 Activity）可以通过 调用startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。 例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。 可以扩展两个类来创建启动服务： Service这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。 IntentService这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果您不要求服务同时处理多个请求，这是最好的选择。 您只需实现 onHandleIntent()方法即可，该方法会接收每个启动请求的 Intent，使您能够执行后台工作。 #启动方式2：创建绑定服务 绑定服务允许应用组件通过调用 bindService() 与其绑定，以便创建长期连接。 如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。 要创建绑定服务，必须实现 onBind() 回调方法以返回 IBinder，用于定义与服务通信的接口。然后，其他应用组件可以调用 bindService() 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（不必按通过 onStartCommand() 启动的服务那样来停止绑定服务）。 要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 IBinder 的实现，并且服务必须从 onBind() 回调方法返回它。一旦客户端收到 IBinder，即可开始通过该接口与服务进行交互。 多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。 可以通过三种方法定义接口： 扩展 Binder 类 如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service 中可用的公共方法。如果服务只是您的自有应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，您的服务被其他应用或不同的进程占用。 使用 Messenger 如需让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口。服务可以这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，后者随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向服务发送命令。此外，客户端还可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，这样就不必对服务进行线程安全设计 使用 AIDL AIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的服务必须具备多线程处理能力，并采用线程安全式设计。如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。 扩展 Binder 类注：此方法只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效。 具体的设置方法： 在您的服务中，创建一个可满足下列任一要求的 Binder 实例： 包含客户端可调用的公共方法 返回当前 Service 实例，其中包含客户端可调用的公共方法 或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法 从 onBind() 回调方法返回此 Binder 实例。 在客户端中，从 onServiceConnected() 回调方法接收 Binder，并使用提供的方法调用绑定服务。 向用户发送通知 Toast 通知是指出现在当前窗口的表面、片刻随即消失不见的消息，而状态栏通知则在状态栏中随消息一起提供图标，用户可以选择该图标来采取操作（例如启动 Activity）。 通常，当某些后台工作已经完成（例如文件下载完成）且用户现在可以对其进行操作时，状态栏通知是最佳方法。 当用户从展开视图中选定通知时，通知即可启动 Activity（例如查看已下载的文件）。 在前台运行服务前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。 例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。 要请求让服务运行于前台，请调用startForeground()。此方法采用两个参数：唯一标识通知的整型数和状态栏的 Notification。例如： 1234567Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 注意：提供给 startForeground() 的整型 ID 不得为 0。 要从前台移除服务，请调用 stopForeground()。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被移除。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android各个支持库]]></title>
    <url>%2FAndroid%E5%90%84%E4%B8%AA%E6%94%AF%E6%8C%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[参考：https://developer.android.google.cn/topic/libraries/support-library/features.html 一般而言，建议添加 v4 支持库和 v7 appcompat 库，因为它们支持一系列 Android 版本，并且可以为推荐的用户界面模式提供 API。 v4 支持库这些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。 注意：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果您在 Gradle 脚本中列出了 support-v4，您的 APK 将包含所有的 v4 模块。不过，要减少 APK 大小，我们建议仅列出应用需要的特定模块。 v4 compat 库为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-compat:24.2.0 v4 core-utils 库提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-core-utils:24.2.0 v4 core-ui 库实现各种 UI 相关组件，例如 ViewPager、NestedScrollView 和 ExploreByTouchHelper。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-core-ui:24.2.0 v4 media-compat 库向后移植部分媒体框架，包括 MediaBrowser 和 MediaSession。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-media-compat:24.2.0 v4 fragment 库添加对使用片段封装用户界面和功能的支持，从而使应用能够提供可以在大屏幕设备与小屏幕设备之间进行调节的布局。此模块依赖于compat、core-utils、core-ui 和 media-compat。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-fragment:24.2.0 v7 支持库一些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。这些库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。 v7 appcompat 库此库添加了对操作栏用户界面设计模式的支持。此库包含对 Material Design 用户界面实现的支持。 注意：此库依赖于 v4 支持库。 下面是 v7 appcompat 库中包含的一些关键类： ActionBar - 提供操作栏用户界面模式的实现。如需了解有关使用操作栏的详细信息，请参阅操作栏开发者指南。 AppCompatActivity - 添加一个应用 Activity 类，此类可作为使用支持库操作栏实现的 Activity 的基础类。 AppCompatDialog - 添加一个对话框类，此类可作为 AppCompat 主题对话框的基础类。 ShareActionProvider - 包含对可以添加到操作栏中的标准化分享操作（例如电子邮件或发帖至社交应用）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:appcompat-v7:24.2.0 v7 cardview 库此库添加了对 CardView 小部件的支持，让您能够在卡片内显示信息，从而使应用具备一致的外观。这些卡片对 Material Design 实现非常有用，并在电视应用布局中广为使用。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:cardview-v7:24.2.0 v7 gridlayout 库下载 Android 支持库后，此库可以添加对 GridLayout 类的支持，让您能够使用网状方格安排用户界面元素。如需了解有关 v7 gridlayout 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.widget 软件包。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:gridlayout-v7:24.2.0 v7 mediarouter 库此库可以提供 MediaRouter、MediaRouteProvider 和支持 Google Cast 的相关媒体类。 一般而言，利用 v7 mediarouter 库中的 API，您可以控制当前设备到外部屏幕、扬声器和其他目标设备的媒体渠道和流的路由。此库包含的 API 可以用于发布应用特定的媒体路由提供程序、发现和选择目标设备，以及检查媒体状态，等等。如需了解有关 v7 mediarouter 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.media 软件包。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:mediarouter-v7:24.2.0 v7 palette 库v7 palette 支持库包含 s 类，此类让您可以从图像中抽取突出颜色。例如，音乐应用可以使用 Palette 对象从专辑封面抽取主要颜色，然后使用这些颜色创建一个色彩协调的歌曲标题卡。 此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:palette-v7:24.2.0 v7 recyclerview 库recyclerview 库添加了 RecyclerView 类。此类能够为 RecyclerView 小部件提供支持，RecyclerView 是一种通过提供有限的数据项窗口有效显示大数据集的视图。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:recyclerview-v7:24.2.0 v7 Preference 支持库首选项软件包提供的 API 支持添加 preference 对象（例如 CheckBoxPreference 和 ListPreference），方便用户修改 UI 设置。 v7 Preference 库添加了对接口（例如 Preference.OnPreferenceChangeListener 和 Preference.OnPreferenceClickListener）以及类（例如 CheckBoxPreference 和 ListPreference）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:preference-v7:24.2.0 Dalvik 可执行文件分包支持库此库可以为使用多个 Dalvik Executable (DEX) 文件开发应用提供支持。引用超过 65536 个方法的应用须使用 Dalvik 可执行文件分包配置。如需了解有关使用 Dalvik 可执行文件分包的详细信息，请参阅使用超过 6.4 万种方法开发应用。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:multidex:1.0.0 注解支持库注解软件包提供的 API 支持向应用中添加注解元数据。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-annotations:24.2.0 设计支持库设计软件包提供的 API 支持向应用中添加 Material Design 组件和模式。 设计支持库添加了对应用开发者依赖的各种 Material Design 组件和模式的支持，例如抽屉式导航栏、浮动操作按钮 (FAB)、快捷信息栏和标签页。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:design:24.2.0]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android传统蓝牙开发]]></title>
    <url>%2FAndroid%E4%BC%A0%E7%BB%9F%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[参考：https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html 蓝牙这项无线技术的名称取自古代丹麦维京国王Harald Blåtand的名字，他以统一了因宗教战争和领土争议而分裂的挪威与丹麦而闻名于世，而这个名字的英文便是Harald Bluetooth。 “Bluetooth”一词是斯堪的纳维亚语言词汇Blåtand/Blåtann的英语化。这个词的来源是10世纪丹麦和挪威国王蓝牙哈拉尔（丹麦语：Harald Blåtand Gormsen），借国王的绰号“Blåtand”当名称，直接翻译成中文为“蓝牙”（blå＝蓝，tand＝牙）。2006年，蓝牙技术联盟组织已将全球中文译名统一改采直译为“蓝牙”，并注册为该组织的注册商标。 蓝牙的标志是卢恩字母 Runic letter ior.svg（Hagall，ᚼ）和 Runic letter berkanan.svg（Bjarkan，ᛒ）的组合，也就是Harald Blåtand的首字母HB的合写。 这是一种无线通讯技术标准，用来让固定与移动设备，在短距离间交换数据，以形成个人局域网（PAN）。其使用短波特高频（UHF）无线电波，经由2.4至2.485 GHz的ISM频段来进行通信。1994年由电信商爱立信（Ericsson）发展出这个技术。它最初的设计，是希望创建一个RS-232数据线的无线通信替代版本。它能够链接多个设备，克服同步的问题。 蓝牙2.1+EDR/3.0+HS版本(通常指“标准蓝牙技术”)与蓝牙低能耗(BLE)技术有许多共同点：它们都是低成本、短距离、可互操作的鲁棒性无线技术，工作在免许可的2.4GHz ISM射频频段。 重要区别：蓝牙低能耗技术从一开始就设计为超低功耗(ULP)无线技术，而标准蓝牙技术主要是能够构成“低功耗的”无线连接。 工作方式蓝牙技术分为基础率/增强数据率（BR/EDR）和低耗能（LE）两种技术类型。其中BR/EDR型是以点对点网络拓扑结构创建一对一设备通信；LE型则使用点对点（一对一）、广播（一对多）和网格（多对多）等多种网络拓扑结构 发展 不同版本的特性，参考:http://www.eepw.com.cn/article/201709/364609.htm 第三代，2009年4月21日，蓝牙技术联盟颁布了蓝牙核心规范3.0版（3.0+HS），是一种全新的交替射频技术。蓝牙3.0+HS提高了数据传输速率，集成802.11PAL最高速度可达24Mbps。是蓝牙2.0速度的8倍。此外，引入了增强电源控制，实际空闲功耗明显降低。 第四代，2010年7月7日，蓝牙技术联盟推出了蓝牙4.0规范。其最重要的特性是支持省电。Bluetooth 4.0是Bluetooth从诞生至今唯一的一个综合协议规范。还提出了“低功耗蓝牙”、“传统蓝牙”和“高速蓝牙”三种模式。 高速蓝牙主：攻数据交换与传输； 传统蓝牙：则以信息沟通、设备连接为重点； 蓝牙低功耗：顾名思义，以不需占用太多带宽的设备连接为主。前身其实是NOKIA开发的Wibree技术，本是作为一项专为移动设备开发的极低功耗的移动无线通信技术，在被SIG接纳并规范化之后重命名为Bluetooth Low Energy（后简称低功耗蓝牙）。 这三种协议规范还能够互相组合搭配、从而实现更广泛的应用模式，此外，Bluetooth 4.0还把蓝牙的传输距离提升到100米以上（低功耗模式条件下） 2013年底，蓝牙技术联盟推出了蓝牙4.1规范，其目的是为了让 Bluetooth Smart 技术最终成为物联网(Internet of Things)发展的核心动力。 第五代，在2016年6月宣布蓝牙5.0。在有效传输距离上将是4.2LE版本的4倍（理论上可达300米），传输速度将是4.2LE版本的2倍（速度上限为24Mbps）。蓝牙5.0还支持室内定位导航功能（结合WiFi可以实现精度小于1米的室内定位），允许无需配对接受信标的数据（比如广告、Beacon、位置信息等，传输率提高了8倍），针对物联网进行了很多底层优化。 相关名词ISM频段ISM频段（Industrial Scientific Medical Band），中文意思分别是工业的(Industrial)、科学的(Scientific)和医学的(Medical)，因此顾名思义ISM频段就是各国挪出某一段频段主要开放给工业，科学和医学机构使用。应用这些频段无需许可证或费用，只需要遵守一定的发射功率（一般低于1W），并且不要对其它频段造成干扰即可。ISM频段在各国的规定并不统一。因此无线局域网（IEEE 802.11b/IEEE 802.11g），蓝牙，ZigBee等无线网络，均可工作在2.4GHz频段上。 RS-232个人计算机上的通讯接口之一，由电子工业协会(Electronic Industries Association，EIA) 所制定的异步传输标准接口。通常 RS-232 接口以9个引脚 (DB-9) 或是25个引脚 (DB-25) 的型态出现，一般个人计算机上会有两组 RS-232 接口，分别称为 COM1 和 COM2。 rs232（9针）接口 蓝牙技术联盟（Bluetooth Special Interest Group：SIG）其拥有蓝牙的商标，负责制定蓝牙规范、认证制造厂商，授权他们使用蓝牙技术与蓝牙标志，但本身不负责蓝牙设备的设计、生产及贩售。 蓝牙协议堆栈依照其功能可分四层： 核心协议层（HCI、LMP、L2CAP、SDP） 线缆替换协议层（RFCOMM） 电话控制协议层（TCS-BIN） 选用协议层（PPP、TCP、IP、UDP、OBEX、IrMC、WAP、WAE） 蓝牙规范（Profile） 更多参考：https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99%E8%A6%8F%E7%AF%84 释义其是指蓝牙通信在哪一种用途下应该使用的通信协议和相关的规范。Profile目的是要确保Bluetooth设备间的互通性（interoperability）。Profile中文译名有很多，比如配置文件，剖面，应用协议，轮廓等，每一种翻译代表了一种对于profile的不同理解， 剖面 这个说法可能更贴切一点。 因为profile其实是蓝牙对应于每一个具体的应用场景以及每一种应用的不同的协议栈，也就是说它其实是实现某种功能对应的自下而上的协议的组合。类似于对于横向协议的纵向组合。 结构porile之间也并非平行的关系，他们是相互依赖组合构成的，存在明显的层级关系的。 蓝牙1.1定义的profile有13个。SIG认为蓝牙设备有4个最基本的Profile： 通用接入剖面：General Access Profile（GAP） 定义两个蓝牙单元如何发现对方并建立连接，保证两个蓝牙单元，无论其生产厂商及进行的应用，可以通过蓝牙交换信息从而发现个单元支持何种应用。所有蓝牙单元都必须支持GAP以保证基本的互操作性和共存性。 服务发现应用剖面：Service Discovery Application Profile（SDAP） 定义如何发现蓝牙单元支持的业务，该剖面可以用来搜索已知的特定业务，也可以用来进行普通业务浏览搜索。 串行端口剖面：Serial Port Profile（SPP） 定义如何在两个设备之间建立虚拟串行端口，并用蓝牙将其连接。采用串行端口剖面可在蓝牙单元上仿真基于RS-232控制信令的串行线缆，该剖面可保证高达128kbit/s的数据速率。 普通对象交换剖面：General Object Exchange Profile（GOEP） 定义处理对象交换的应用需采用的协议和程序，基于GOEP的应用模型（如文件传输、同步等）假定链路和信道已经建立如GAP所述，GOEP描述从一个蓝牙设备Push数据到另一个蓝牙设备的程序，还规定如何在两个单元之间Pull数据。 干扰Bluetooth在2.4GHz的电波干扰问题一直为大家所诟病，特别和无线局域网间的互相干扰问题。有干扰发生时，就以重新发送数据包的方法来解决干扰。 Android 传统蓝牙 Bluetooth API传统蓝牙适用于电池使用强度较大的操作，例如 Android 设备之间的流式传输和通信等。使用 Bluetooth API，Android 应用可执行以下操作： 扫描其他蓝牙设备 查询本地蓝牙适配器的配对蓝牙设备 建立 RFCOMM 通道 通过服务发现连接到其他设备 与其他设备进行双向数据传输 管理多个连接 基础使用 Android Bluetooth API 来完成使用蓝牙进行通信的四项主要任务： 设置蓝牙 查找局部区域内的配对设备或可用设备 连接设备 在设备之间传输数据 创建蓝牙连接所需的类和接口：BluetoothAdapter表示本地蓝牙适配器（蓝牙无线装置）。 BluetoothAdapter 是所有蓝牙交互的入口点。 利用它可以发现其他蓝牙设备，查询绑定（配对）设备的列表，使用已知的 MAC 地址实例化 BluetoothDevice，以及创建 BluetoothServerSocket 以侦听来自其他设备的通信。 BluetoothDevice表示远程蓝牙设备。利用它可以通过 BluetoothSocket 请求与某个远程设备建立连接，或查询有关该设备的信息，例如设备的名称、地址、类和绑定状态等。BluetoothSocket表示蓝牙套接字接口（与 TCP Socket 相似）。这是允许应用通过 InputStream 和 OutputStream 与其他蓝牙设备交换数据的连接点。 BluetoothServerSocket表示用于侦听传入请求的开放服务器套接字（类似于 TCP ServerSocket）。 要连接两台 Android 设备，其中一台设备必须使用此类开放一个服务器套接字。 当一台远程蓝牙设备向此设备发出连接请求时， BluetoothServerSocket 将会在接受连接后返回已连接的 BluetoothSocket。 BluetoothClass描述蓝牙设备的一般特征和功能。 这是一组只读属性，用于定义设备的主要和次要设备类及其服务。 不过，它不能可靠地描述设备支持的所有蓝牙配置文件和服务，而是适合作为设备类型提示。BluetoothProfile表示蓝牙配置文件的接口。 蓝牙配置文件是适用于设备间蓝牙通信的无线接口规范。 免提配置文件便是一个示例。 如需了解有关配置文件的详细讨论，请参阅使用配置文件 BluetoothHeadset提供蓝牙耳机支持，以便与手机配合使用。 其中包括蓝牙耳机和免提（1.5 版）配置文件。 BluetoothA2dp定义高质量音频如何通过蓝牙连接和流式传输，从一台设备传输到另一台设备。“A2DP”代表高级音频分发配置文件。 BluetoothHealth表示用于控制蓝牙服务的健康设备配置文件代理。 BluetoothHealthCallback用于实现 BluetoothHealth 回调的抽象类。您必须扩展此类并实现回调方法，以接收关于应用注册状态和蓝牙通道状态变化的更新内容。 BluetoothHealthAppConfiguration表示第三方蓝牙健康应用注册的应用配置，以便与远程蓝牙健康设备通信。 BluetoothProfile.ServiceListener在 BluetoothProfile IPC 客户端连接到服务（即，运行特定配置文件的内部服务）或断开服务连接时向其发送通知的接口。 蓝牙权限 蓝牙权限 BLUETOOTH : 要在应用中使用蓝牙功能，必须声明蓝牙权限 BLUETOOTH。您需要此权限才能执行任何蓝牙通信，例如请求连接、接受连接和传输数据等。 蓝牙权限 BLUETOOTH_ADMIN : 如果你希望你的应用启动设备发现或操作蓝牙设置 注意：如果要使用 BLUETOOTH_ADMIN 权限，则还必须拥有 BLUETOOTH 权限。 设置蓝牙获取BluetoothAdapter，并检测设备是否支持蓝牙1234BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();if (mBluetoothAdapter == null) &#123; // Device does not support Bluetooth&#125; 启用蓝牙1234if (!mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125; 注意 ： 此处的 REQUEST_ENABLE_BT 是自己编写定义的局部常量（必须&gt;0） 进行判断之后，监听用户的操作：方式1： 重写onActivityResult()如果成功启用蓝牙，Activity 将会在 onActivityResult() 回调中收到 RESULT_OK 结果代码。 如果由于某个错误（或用户响应“No”）而没有启用蓝牙，则结果代码为 RESULT_CANCELED。 方式2：侦听 ACTION_STATE_CHANGED 广播 Intent每当蓝牙状态发生变化时，系统都会广播此 Intent。 此广播包含额外字段 EXTRA_STATE 和 EXTRA_PREVIOUS_STATE，二者分别包含新的和旧的蓝牙状态。 这些额外字段可能的值包括 STATE_TURNING_ON、STATE_ON、STATE_TURNING_OFF 和 STATE_OFF。侦听此广播适用于检测在您的应用运行期间对蓝牙状态所做的更改。 提示 ：启用可检测性将会自动启用蓝牙。 如果您计划在执行蓝牙 Activity 之前一直启用设备的可检测性，则可以跳过 “启用蓝牙”步骤 查找设备使用 BluetoothAdapter，可以通过设备发现或通过查询配对（绑定）设备的列表来查找远程蓝牙设备。 设备发现是一个扫描过程，它会搜索局部区域内已启用蓝牙功能的设备，然后请求一些关于各台设备的信息。但局部区域内的蓝牙设备仅在其当前已启用可检测性时才会响应发现请求。 如果设备可检测到，它将通过共享一些信息（例如设备名称、类及其唯一 MAC 地址）来响应发现请求。 利用此信息，执行发现的设备可以选择发起到被发现设备的连接。 在首次与远程设备建立连接后，将会自动向用户显示配对请求。 设备完成配对后，将会保存关于该设备的基本信息（例如设备名称、类和 MAC 地址），并且可使用 Bluetooth API 读取这些信息。 利用远程设备的已知 MAC 地址可随时向其发起连接，而无需执行发现操作（假定该设备处于有效范围内）。 注：Android 设备默认处于不可检测到状态。 用户可通过系统设置将设备设为在有限的时间内处于可检测到状态，或者，应用可请求用户在不离开应用的同时启用可检测性。 查询已配对的设备在执行设备发现之前，有必要查询已配对的设备集，以了解所需的设备是否处于已知状态。 123456Set&lt;BluetoothDevice&gt; devices = mBluetoothAdapter.getBondedDevices(); if (devices.size() &gt; 0) &#123; for (BluetoothDevice device: devices) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; dealBluetooth device Name : " + device.getName() + ", Address : " + device.getAddress()); &#125; &#125; 若要发起连接，BluetoothDevice 对象仅仅需要提供 MAC 地址即可。 发现设备要开始发现设备，只需调用 startDiscovery()。该进程为异步进程，并且该方法会立即返回一个布尔值，指示是否已成功启动发现操作。 发现进程通常包含约12 秒钟的查询扫描，之后对每台发现的设备进行页面扫描，以检索其蓝牙名称。 您的应用必须针对 ACTION_FOUND Intent 注册一个 BroadcastReceiver，以便接收每台发现的设备的相关信息。 针对每台设备，系统将会广播 ACTION_FOUND Intent。此 Intent 将携带额外字段 EXTRA_DEVICE 和 EXTRA_CLASS，二者分别包含 BluetoothDevice 和 BluetoothClass。 例如，下面说明了在发现设备时如何注册以处理广播。 12345678910111213141516// Create a BroadcastReceiver for ACTION_FOUNDprivate final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); // When discovery finds a device if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123; // Get the BluetoothDevice object from the Intent BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); // Add the name and address to an array adapter to show in a ListView mArrayAdapter.add(device.getName() + "\n" + device.getAddress()); &#125; &#125;&#125;;// Register the BroadcastReceiverIntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);registerReceiver(mReceiver, filter); // Don't forget to unregister during onDestroy 注意：执行设备发现对于蓝牙适配器而言是一个非常繁重的操作过程，并且会消耗大量资源。 在找到要连接的设备后，确保始终使用 cancelDiscovery()停止发现，然后再尝试连接。 此外，如果您已经保持与某台设备的连接，那么执行发现操作可能会大幅减少可用于该连接的带宽，因此不应该在处于连接状态时执行发现操作。 启用可检测性如果希望将本地设备设为可被其他设备检测到，请使用 ACTION_REQUEST_DISCOVERABLE 操作 Intent 调用 startActivityForResult(Intent, int)。这将通过系统设置发出启用可检测到模式的请求（无需停止您的应用）。 默认情况下，设备将变为可检测到并持续 120 秒钟。您可以通过添加 EXTRA_DISCOVERABLE_DURATION Intent Extra 来定义不同的持续时间。 应用可以设置的最大持续时间为 3600 秒，值为 0 则表示设备始终可检测到。 任何小于 0 或大于 3600 的值都会自动设为120秒。 例如，以下片段会将持续时间设为 300 秒： 123Intent discoverableIntent = newIntent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300); 如果您将要发起到远程设备的连接，则无需启用设备可检测性。 仅当您希望您的应用托管将用于接受传入连接的服务器套接字时，才有必要启用可检测性，因为远程设备必须能够发现该设备，然后才能发起连接 连接设备要在两台设备上的应用之间创建连接，必须同时实现服务器端和客户端机制，因为其中一台设备必须开放服务器套接字，而另一台设备必须发起连接（使用服务器设备的 MAC 地址发起连接）。 当服务器和客户端在同一 RFCOMM 通道上分别拥有已连接的 BluetoothSocket 时，二者将被视为彼此连接。 这种情况下，每台设备都能获得输入和输出流式传输，并且可以开始传输数据。 服务器设备和客户端设备分别以不同的方法获得需要的 BluetoothSocket。服务器将在传入连接被接受时收到套接字。 客户端将在其打开到服务器的 RFCOMM 通道时收到该套接字。 一种实现技术是自动将每台设备准备为一个服务器，从而使每台设备开放一个服务器套接字并侦听连接。然后任一设备可以发起与另一台设备的连接，并成为客户端。 或者，其中一台设备可显式“托管”连接并按需开放一个服务器套接字，而另一台设备则直接发起连接。 如果两台设备之前尚未配对，则在连接过程中，Android 框架会自动向用户显示配对请求通知或对话框。因此，在尝试连接设备时，您的应用无需担心设备是否已配对。 连接为服务器当您需要连接两台设备时，其中一台设备必须通过保持开放的 BluetoothServerSocket 来充当服务器。 服务器套接字的用途是侦听传入的连接请求，并在接受一个请求后提供已连接的 BluetoothSocket。 从 BluetoothServerSocket 获取 BluetoothSocket 后，可以（并且应该）舍弃 BluetoothServerSocket，除非您需要接受更多连接。 连接为客户端待续……]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android BLE 蓝牙开发]]></title>
    <url>%2FAndroid%20BLE%20%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[参考文章：https://www.jianshu.com/p/3a372af38103参考文章：https://www.jianshu.com/p/29a730795294android developers：https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html#terms部分图片来源：https://www.youtube.com/watch?v=vUbFB1Qypg8经典蓝牙使用参考：http://blog.csdn.net/axinmeng88/article/details/79059468BLE设备地址参考：http://www.wowotech.net/bluetooth/ble_address_type.html 蓝牙唯一身份标识 MAC地址：这个地址是唯一的，就像网络上的IP地址 UUID（Universally Unique Identifier）：可以把它理解为是IP地址中的端口号 12更多UUID接口参考：https://www.jianshu.com/p/3de46c75f8ce，官网：https://www.bluetooth.com/zh-cn/specifications/assigned-numbers/service-discovery MAC + UUID = IP地址 + 端口号。这两者合起来就是蓝牙的唯一身份标识。BLE扫描的过程，设备会生成随机地址。根据随机地址也能进行连接。 BLE (Bluetooth Low Energy) 低功耗蓝牙Android 4.3（API级别18）引入了以低功耗蓝牙（BLE）为中心角色的内置平台支持，并提供应用程序可用于发现设备，查询服务和传输信息的API 常见用例包括以下内容： 在附近的设备之间传输少量的数据 与Google Beacons等接近传感器进行互动，为用户提供基于当前位置的定制体验。 传统蓝牙可以用于数据量比较大的传输，如语音，音乐，较高数据量传输等，但是比较耗电，低功耗蓝牙这样应用于实时性要求比较高，功耗比较低，但是数据速率比较低的产品，如遥控类的，如鼠标，键盘，遥控鼠标(Air Mouse)，传感设备的数据发送，如心跳带，血压计，温度传感器等。 关键术语（Key Terms）和 概念（Concepts） GATT图示1 GATT图示2 通用属性配置文件 Generic Attribute Profile（GATT）：GATT配置文件是通过BLE链接发送和接收被称为“属性”的短小数据的通用规范。目前所有的低能耗应用程序都基于GATT。 蓝牙SIG为低能耗设备定义了许多配置文件。 配置文件是设备如何在特定应用程序中工作的规范。 请注意，设备可以实现多个配置文件。 例如，一个设备可以包含一个心率监测器和一个电池电量检测器。 你可以把他看成xml来理解： 每个GATT由完成不同功能的Service组成； 每个Service由不同的Characteristic组成； 每个Characteristic由一个value和一个或者多个Descriptor组成； Service、Characteristic相当于标签（Service相当于他的类别，Characteristic相当于它的名字），而value才真正的包含数据，Descriptor是对这个value进行的说明和描述，当然我们可以从不同角度来描述和说明，因此可以有多个Descriptor. 举一个简单的例子进行说明： 常见的小米手环是一个BLE设备，（假设）它包含三个Service,分别是提供设备信息的Service、提供步数的Service、检测心率的Service;而设备信息的service中包含的characteristic包括厂商信息、硬件信息、版本信息等；而心率Service则包括心率characteristic等，而心率characteristic中的value则真正的包含心率的数据，而descriptor则是对该value的描述说明，比如value的单位啊，描述啊，权限啊等。 属性协议 Attribute Protocol（ATT）：GATT建立在属性协议（ATT）之上。 这也被称为GATT / ATT。 ATT经过优化，可在BLE设备上运行。 为此，它使用尽可能少的字节。 每个属性由一个通用唯一标识符（UUID）唯一标识，该标识符是用于唯一标识信息的字符串ID的标准化128位格式。 ATT传输的属性被格式化为特征和服务。 特性 Characteristic： 特性包含描述特性值的单个值和0-n个描述符。一个特征可以被认为是一个类，类似于一个阶级。是最小的数据逻辑单元。 描述符 Descriptor： 描述符是描述特征值的定义属性。 例如，一个描述符可以指定一个可读的描述，一个特征值的可接受范围，或者一个特征值特有的度量单位。value、descriptor中存储数据的解析由Server的工程师决定，并无规范，双发按照约定开发。 服务 Service： 服务是一个特征的集合。 例如，您可以拥有一个名为“心率监测器”的服务，其中包含“心率测量”等特性。 您可以在bluetooth.org上找到现有基于GATT的配置文件和服务的列表。Service/Characteristic均有一个唯一的UUID标识，UUID既有16位的也有128位的，我们需要了解的是16位的UUID是经过蓝牙组织认证的，是需要购买的，当然也有一些通用的16位UUID。例如Heart Rate服务的UUID就是0X180D,代码中表示为0X00001800-0000-1000-8000-00805f9b34fb,其他位为固定的。而128位的UUID则可以自定义。 角色（Roles）和责任（Responsibilities）以下是Android设备与BLE设备交互时适用的角色和职责： 中央（Central） 与 周边（Peripheral）。这适用于BLE连接本身。处于中心角色的设备扫描，寻找广告，并且在外围角色中的设备进行广告。 GATT服务器 与 GATT客户端。这决定了两台设备在建立连接后如何相互通话。 为了理解这个区别，假设你有一个Android手机和一个BLE设备的活动追踪器。 手机支持中心角色; 活动跟踪器支持外设角色（建立一个BLE连接，你需要每两个事物中只有一个支持外围设备的人不能彼此交谈，也不能只支持两个事物）。 一旦手机和活动追踪器建立了连接，他们就开始将GATT元数据转移到另一个。根据他们传输的数据的种类，其中一个或另一个可能充当服务器。例如，如果活动跟踪器想要将传感器数据报告给电话，则活动跟踪器可以充当服务器。如果活动跟踪器想要从手机接收更新，那么手机作为服务器可能是有意义的。 在本文档中使用的示例中，Android应用程序（在Android设备上运行）是GATT客户端。该应用程序从GATT服务器获取数据，GATT服务器是支持心率档案的BLE心率监测器。但你也可以设计你的Android应用程序来扮演GATT服务器的角色。有关更多信息，请参阅BluetoothGattServer。 BLE 权限（Permissions） 为了在您的应用程序中使用蓝牙功能，您必须声明（declare） 权限1：BLUETOOTH。您需要此权限才能执行（perform）任何 蓝牙通信 ，例如 请求连接，接受连接以及传输数据。 如果您希望您的应用启动设备发现或操纵（manipulate）蓝牙设置，则还必须声明 权限2：BLUETOOTH_ADMIN。 注意：如果您使用BLUETOOTH_ADMIN权限，则还必须具有BLUETOOTH权限。 在应用程序清单文件中声明蓝牙许可。例如： 12&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 如果您想声明您的应用仅适用于具有BLE功能的设备，请在应用的清单中包含以下内容： 1&lt;uses-feature android:name=&quot;android.hardware.bluetooth_le&quot; android:required=&quot;true&quot;/&gt; 但是，如果您想让您的应用可用于不支持BLE的设备，则应该在应用的清单中包含此元素，但设置required =“false”。 然后在运行时，您可以使用PackageManager.hasSystemFeature（）来确定BLE可用性： 123456// Use this check to determine whether BLE is supported on the device. Then// you can selectively disable BLE-related features.if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123; Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show(); finish();&#125; 注意：LE信标往往与位置有关。 为了在没有过滤器的情况下使用BluetoothLeScanner，您必须通过在应用的清单文件中声明 权限3：ACCESS_COARSE_LOCATION 或 权限3：ACCESS_FINE_LOCATION 权限来请求用户的许可。 没有这些权限，扫描将不会返回任何结果。 设置BLE在您的应用程序可以通过BLE进行通信之前，您需要验证设备是否支持BLE，如果是，请确保已启用BLE。请注意，只有在设置为false时才需要执行此项检查 如果不支持BLE，那么您应该禁用任何BLE功能。如果BLE支持，但被禁用，那么您可以请求用户启用蓝牙，而无需离开您的应用程序。 使用BluetoothAdapter，可以分两步完成此设置： 1. 获取 BluetoothAdapterBluetoothAdapter是任何和所有的蓝牙活动所必需的。 BluetoothAdapter代表设备自己的蓝牙适配器（蓝牙无线电）。整个系统有一个蓝牙适配器，您的应用程序可以使用这个对象与它进行交互。下面的代码展示了如何获取适配器。请注意，此方法使用getSystemService（）返回BluetoothManager的实例，然后用于获取适配器。 Android 4.3（API Level 18）介绍了BluetoothManager： 123456private BluetoothAdapter mBluetoothAdapter;...// Initializes Bluetooth adapter.final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);mBluetoothAdapter = bluetoothManager.getAdapter(); 2. 启用蓝牙接下来，您需要确保蓝牙已启用。调用isEnabled（）来检查当前是否启用了蓝牙。如果此方法返回false，则蓝牙被禁用。以下片段检查是否启用了蓝牙。如果不是，该片段会显示一个错误，提示用户转到设置以启用蓝牙： 123456// Ensures Bluetooth is available on the device and it is enabled. If not,// displays a dialog requesting user permission to enable Bluetooth.if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125; 注意：传递给 startActivityForResult（android.content.Intent，int）的REQUEST_ENABLE_BT常量是系统在onActivityResult（int，int，android.content）中返回给您的本地定义的整数（它必须大于0））实现作为requestCode参数。 查找BLE设备要查找BLE设备，请使用startLeScan（）方法。 此方法将BluetoothAdapter.LeScanCallback作为参数。 您必须实现此BluetoothAdapter.LeScanCallback，因为这是如何返回扫描结果。 由于扫描耗电量大，您应遵守以下准则: 一旦找到所需的设备，请停止扫描 切勿扫描循环，并在扫描上设置时间限制。以前可用的设备可能已移出范围，并继续扫描电池电量。 以下片段显示了如何启动和停止扫描： 123456789101112131415161718192021222324252627282930313233/** * Activity for scanning and displaying available BLE devices. */public class DeviceScanActivity extends ListActivity &#123; private BluetoothAdapter mBluetoothAdapter; private boolean mScanning; private Handler mHandler; // Stops scanning after 10 seconds. private static final long SCAN_PERIOD = 10000; ... private void scanLeDevice(final boolean enable) &#123; if (enable) &#123; // Stops scanning after a pre-defined scan period. mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; &#125;, SCAN_PERIOD); mScanning = true; mBluetoothAdapter.startLeScan(mLeScanCallback); &#125; else &#123; mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; ... &#125;...&#125; 如果只想扫描特定类型的外设，则改为调用startLeScan（UUID []，BluetoothAdapter.LeScanCallback），提供指定您的应用程序支持的GATT服务的UUID对象数组。 以下是BluetoothAdapter.LeScanCallback的一个实现，它是用于传递BLE扫描结果的接口🤔： 1234567891011121314151617private LeDeviceListAdapter mLeDeviceListAdapter;...// Device scan callback.private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mLeDeviceListAdapter.addDevice(device); mLeDeviceListAdapter.notifyDataSetChanged(); &#125; &#125;); &#125;&#125;; 注意：您只能扫描蓝牙LE设备或扫描经典蓝牙设备，如蓝牙中所述。您无法同时扫描Bluetooth LE和传统设备。 连接到GATT服务器（发送数据的BLE设备） 与BLE设备交互的第一步是连接到它，更具体地说，连接到设备上的GATT服务器。 要连接到BLE设备上的GATT服务器，请使用connectGatt（）方法。 此方法有三个参数：一个Context对象，autoConnect（布尔值，指示是否在BLE设备变为可用时自动连接）以及对BluetoothGattCallback的引用： 1mBluetoothGatt = device.connectGatt(this, false, mGattCallback); 这将连接到由BLE设备托管的GATT服务器，并返回一个BluetoothGatt实例，然后您可以使用该实例来执行GATT客户端操作。 调用者（Android应用程序）是GATT客户端。 BluetoothGattCallback用于向客户端传递结果，例如连接状态，以及任何其他GATT客户端操作 在这个例子中，BLE应用程序提供了一个Activity（DeviceControlActivity）来连接，显示数据，并显示设备支持的GATT服务和特性。 根据用户输入，此Activity与一个名为BluetoothLeService的服务进行通信，该服务通过Android BLE API与BLE设备进行交互： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// A service that interacts with the BLE device via the Android BLE API.public class BluetoothLeService extends Service &#123; private final static String TAG = BluetoothLeService.class.getSimpleName(); private BluetoothManager mBluetoothManager; private BluetoothAdapter mBluetoothAdapter; private String mBluetoothDeviceAddress; private BluetoothGatt mBluetoothGatt; private int mConnectionState = STATE_DISCONNECTED; private static final int STATE_DISCONNECTED = 0; private static final int STATE_CONNECTING = 1; private static final int STATE_CONNECTED = 2; public final static String ACTION_GATT_CONNECTED = &quot;com.example.bluetooth.le.ACTION_GATT_CONNECTED&quot;; public final static String ACTION_GATT_DISCONNECTED = &quot;com.example.bluetooth.le.ACTION_GATT_DISCONNECTED&quot;; public final static String ACTION_GATT_SERVICES_DISCOVERED = &quot;com.example.bluetooth.le.ACTION_GATT_SERVICES_DISCOVERED&quot;; public final static String ACTION_DATA_AVAILABLE = &quot;com.example.bluetooth.le.ACTION_DATA_AVAILABLE&quot;; public final static String EXTRA_DATA = &quot;com.example.bluetooth.le.EXTRA_DATA&quot;; public final static UUID UUID_HEART_RATE_MEASUREMENT = UUID.fromString(SampleGattAttributes.HEART_RATE_MEASUREMENT); // Various callback methods defined by the BLE API. private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; String intentAction; if (newState == BluetoothProfile.STATE_CONNECTED) &#123; intentAction = ACTION_GATT_CONNECTED; mConnectionState = STATE_CONNECTED; broadcastUpdate(intentAction); Log.i(TAG, &quot;Connected to GATT server.&quot;); Log.i(TAG, &quot;Attempting to start service discovery:&quot; + mBluetoothGatt.discoverServices()); &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123; intentAction = ACTION_GATT_DISCONNECTED; mConnectionState = STATE_DISCONNECTED; Log.i(TAG, &quot;Disconnected from GATT server.&quot;); broadcastUpdate(intentAction); &#125; &#125; @Override // New services discovered public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); &#125; else &#123; Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status); &#125; &#125; @Override // Result of a characteristic read operation public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); &#125; &#125; ... &#125;;...&#125; 当一个特定的回调被触发时，它会调用相应的broadcastUpdate（）辅助方法并传递一个动作。 请注意，本节中的数据解析是根据蓝牙心率测量配置文件规范执行的： 12345678910111213141516171819202122232425262728293031323334353637private void broadcastUpdate(final String action) &#123; final Intent intent = new Intent(action); sendBroadcast(intent);&#125;private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) &#123; final Intent intent = new Intent(action); // This is special handling for the Heart Rate Measurement profile. Data // parsing is carried out as per profile specifications. if (UUID_HEART_RATE_MEASUREMENT.equals(characteristic.getUuid())) &#123; int flag = characteristic.getProperties(); int format = -1; if ((flag &amp; 0x01) != 0) &#123; format = BluetoothGattCharacteristic.FORMAT_UINT16; Log.d(TAG, &quot;Heart rate format UINT16.&quot;); &#125; else &#123; format = BluetoothGattCharacteristic.FORMAT_UINT8; Log.d(TAG, &quot;Heart rate format UINT8.&quot;); &#125; final int heartRate = characteristic.getIntValue(format, 1); Log.d(TAG, String.format(&quot;Received heart rate: %d&quot;, heartRate)); intent.putExtra(EXTRA_DATA, String.valueOf(heartRate)); &#125; else &#123; // For all other profiles, writes the data formatted in HEX. final byte[] data = characteristic.getValue(); if (data != null &amp;&amp; data.length &gt; 0) &#123; final StringBuilder stringBuilder = new StringBuilder(data.length); for(byte byteChar : data) stringBuilder.append(String.format(&quot;%02X &quot;, byteChar)); intent.putExtra(EXTRA_DATA, new String(data) + &quot;\n&quot; + stringBuilder.toString()); &#125; &#125; sendBroadcast(intent);&#125; 回到DeviceControlActivity中，这些事件由BroadcastReceiver处理： 1234567891011121314151617181920212223242526272829// Handles various events fired by the Service.// ACTION_GATT_CONNECTED: connected to a GATT server.// ACTION_GATT_DISCONNECTED: disconnected from a GATT server.// ACTION_GATT_SERVICES_DISCOVERED: discovered GATT services.// ACTION_DATA_AVAILABLE: received data from the device. This can be a// result of read or notification operations.private final BroadcastReceiver mGattUpdateReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) &#123; mConnected = true; updateConnectionState(R.string.connected); invalidateOptionsMenu(); &#125; else if (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) &#123; mConnected = false; updateConnectionState(R.string.disconnected); invalidateOptionsMenu(); clearUI(); &#125; else if (BluetoothLeService. ACTION_GATT_SERVICES_DISCOVERED.equals(action)) &#123; // Show all the supported services and characteristics on the // user interface. displayGattServices(mBluetoothLeService.getSupportedGattServices()); &#125; else if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) &#123; displayData(intent.getStringExtra(BluetoothLeService.EXTRA_DATA)); &#125; &#125;&#125;; 读取BLE属性一旦你的Android应用程序连接到GATT服务器并发现服务，它就可以在支持的地方读取和写入属性。例如，这个代码片段遍历服务器的服务和特性，并在UI中显示它们： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class DeviceControlActivity extends Activity &#123; ... // （演示）Demonstrates how to （遍历）iterate through the supported GATT // Services/Characteristics. // In this sample, we （填充）populate the data structure that is bound to the // ExpandableListView on the UI. private void displayGattServices(List&lt;BluetoothGattService&gt; gattServices) &#123; if (gattServices == null) return; String uuid = null; String unknownServiceString = getResources(). getString(R.string.unknown_service); String unknownCharaString = getResources(). getString(R.string.unknown_characteristic); ArrayList&lt;HashMap&lt;String, String&gt;&gt; gattServiceData = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); ArrayList&lt;ArrayList&lt;HashMap&lt;String, String&gt;&gt;&gt; gattCharacteristicData = new ArrayList&lt;ArrayList&lt;HashMap&lt;String, String&gt;&gt;&gt;(); mGattCharacteristics = new ArrayList&lt;ArrayList&lt;BluetoothGattCharacteristic&gt;&gt;(); // Loops through available GATT Services. for (BluetoothGattService gattService : gattServices) &#123; HashMap&lt;String, String&gt; currentServiceData = new HashMap&lt;String, String&gt;(); uuid = gattService.getUuid().toString(); currentServiceData.put( LIST_NAME, SampleGattAttributes. lookup(uuid, unknownServiceString)); currentServiceData.put(LIST_UUID, uuid); gattServiceData.add(currentServiceData); ArrayList&lt;HashMap&lt;String, String&gt;&gt; gattCharacteristicGroupData = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = gattService.getCharacteristics(); ArrayList&lt;BluetoothGattCharacteristic&gt; charas = new ArrayList&lt;BluetoothGattCharacteristic&gt;(); // Loops through available Characteristics. for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) &#123; charas.add(gattCharacteristic); HashMap&lt;String, String&gt; currentCharaData = new HashMap&lt;String, String&gt;(); uuid = gattCharacteristic.getUuid().toString(); currentCharaData.put( LIST_NAME, SampleGattAttributes.lookup(uuid, unknownCharaString)); currentCharaData.put(LIST_UUID, uuid); gattCharacteristicGroupData.add(currentCharaData); &#125; mGattCharacteristics.add(charas); gattCharacteristicData.add(gattCharacteristicGroupData); &#125; ... &#125;...&#125; 接收GATT通知BLE应用程序在设备上发生特定特征变化时要求收到通知是很常见的。这段代码展示了如何使用setCharacteristicNotification（）方法为特性设置通知 12345678910private BluetoothGatt mBluetoothGatt;BluetoothGattCharacteristic characteristic;boolean enabled;...mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);...BluetoothGattDescriptor descriptor = characteristic.getDescriptor( UUID.fromString(SampleGattAttributes.CLIENT_CHARACTERISTIC_CONFIG));descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);mBluetoothGatt.writeDescriptor(descriptor); 一旦为特征启用了通知，如果特性在远程设备上发生变化，则会触发onCharacteristicChanged（）回调： 123456@Override// Characteristic notificationpublic void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);&#125; 关闭客户端App一旦您的应用程序使用BLE设备，应该调用close（），以便系统可以正确释放资源： 1234567public void close() &#123; if (mBluetoothGatt == null) &#123; return; &#125; mBluetoothGatt.close(); mBluetoothGatt = null;&#125; Android BLE APIBluetoothAdapter代表本地设备蓝牙适配器。 BluetoothAdapter允许您执行基本的蓝牙任务，例如启动设备发现，查询绑定（配对）设备列表，使用已知的MAC地址实例化BluetoothDevice，并创建BluetoothServerSocket以侦听来自其他设备的连接请求，并启动扫描蓝牙LE设备。 要获得代表本地蓝牙适配器的BluetoothAdapter，请在BluetoothManager上调用getAdapter（）函数。在JELLY_BEAN_MR1和下面，您将需要使用静态getDefaultAdapter（）方法。 从根本上说，这是所有蓝牙操作的起点。一旦你有了本地适配器，你就可以用getBondedDevices（）获得一组代表所有配对设备的BluetoothDevice对象。用startDiscovery（）启动设备发现;或者用listenUsingRfcommWithServiceRecord（String，UUID）创建一个BluetoothServerSocket监听传入的连接请求;或使用startLeScan（LeScanCallback）开始扫描蓝牙LE设备。 注：大多数方法需要BLUETOOTH权限，有些还需要BLUETOOTH_ADMIN权限。 BluetoothAdapter.LeScanCallback：用于提供LE扫描结果的回调接口。 BluetoothManager用于获取BluetoothAdapter的实例并进行整体蓝牙管理。使用带有BLUETOOTH_SERVICE的getSystemService（java.lang.String）来创建一个BluetoothManager，然后调用getAdapter（）来获得BluetoothAdapter BluetoothGatt蓝牙GATT配置文件的公共API。 本class提供蓝牙GATT功能，以实现与Bluetooth Smart或Smart Ready设备的通信。 要连接到远程外围设备，请创建一个BluetoothGattCallback并调用connectGatt（Context，boolean，BluetoothGattCallback）来获取此类的一个实例。 使用蓝牙设备发现或BLE扫描过程可以发现支持GATT的设备。 BluetoothGattCallback这个抽象类的作用是实现BluetoothGatt的回调。 BluetoothGattCharacteristic代表蓝牙GATT特性。GATT特性是用于构建GATT服务的基本数据元素，BluetoothGattService。 该特性包含一个值以及附加信息和可选的GATT描述符BluetoothGattDescriptor。 BluetoothGattService代表一个蓝牙GATT服务。Gatt服务包含一系列BluetoothGattCharacteristic以及引用的服务。 BluetoothGattDescriptor代表一个蓝牙GATT描述符.GATT描述符包含GATT特性的附加信息和属性，BluetoothGattCharacteristic。 它们可以用来描述特征的特征或控制特征的某些行为。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3-Scrapy爬取地址5级联动数据 - 初级]]></title>
    <url>%2FPython3-Scrapy%E7%88%AC%E5%8F%96%E5%9C%B0%E5%9D%805%E7%BA%A7%E8%81%94%E5%8A%A8%E6%95%B0%E6%8D%AE%20-%20%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Scrapy使用 - “区划代码和城乡划分代码”数据爬取 - 初级 1. 数据来源国家统计局： http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html 2. Scrapy框架、项目结构： 3. 原始数据3.1 第一级：省、直辖市 3.2 第二级：地级市 3.3 第三级：区、县、乡 3.4 第四级：街道、镇 3.5 第五级：社区、居委会、村 3.6 区域代码含义：37(省)07(市)84(区)118(镇)224(村) 3.7 城乡分类代码 100 城镇 110 城区 111 主城区 112 城乡结合区 120 镇区 121 镇中心区 122 镇乡结合区 123 特殊区域 200 乡村 210 乡中心区 220 村庄 4. 数据库结构4.1 整体结构 4.2 类似的表结构 5. 爬取数据结果5.1 第四级：镇数据获取log 5.2 第五级：村数据获取log 5.3 第四级：镇数据 数量 - 42866 5.4 第五级：村数据 数量 - 666655 6. 执行代码6.1 核心处理： 目的数据解析： 12node = sel.xpath('//tr[@class="provincetr"]/td/a/text()')node_href = sel.xpath('//tr[@class="provincetr"]/td/a/@href') 爬取嵌套URL： 12 cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + province_href[1:8]yield Request(url=cl, callback=self.parse_second, dont_filter=True) 向数据库填写数据： 1234567891011121314151617181920n = len(node_city) m = 0 while m &lt; n: code = json.dumps((node_city[m:m + 1]).extract(), ensure_ascii=False) name = json.dumps((node_city[m + 1:m + 2]).extract(), ensure_ascii=False) print(code[1:len(code) - 1]) print(name[1:len(name) - 1]) db = NorthernOpenSpacePipeline() sql = "insert into city_table (" + 'city_code,' + 'city_name,' + 'simple_city_code,' + 'grade' + ") VALUE (" + code[ 1:len( code) - 1] + "," + name[ 1:len( name) - 1] + "," + ( code[ 1:len( code) - 1])[ 1:5] + "," + "2" + ")" db.insertIntoTable(sql=sql) m = m + 2 6.2 代码版本展示Version 1 - 获取数据，通过Terminal显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222# coding=utf-8# 要在代码中使用"中文"注释，应该首先添加如上注释，说明是中文注释import jsonfrom scrapy import Spider, Selectorfrom scrapy.http.request import Requestimport reclass NOSSpider(Spider): name = "NOS" allowed_domains = ["www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm"] start_urls = ["http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"] # 第一级 url， 省级信息 一级 def parse(self, response): sel = Selector(response) items = [] node = sel.xpath('//tr[@class="provincetr"]/td/a/text()') node_href = sel.xpath('//tr[@class="provincetr"]/td/a/@href') for item_node in node: province_name = json.dumps(item_node.extract(), ensure_ascii=False) # 名称 ："山东省" # print(province_name) for item_node2 in node_href: province_href = json.dumps(item_node2.extract(), ensure_ascii=False) province_code = province_href[1:3] # Url ："37.html" # print(province_href) # 代码 ：37 # print(province_code) # 获取当前省级名称下的 地级市信息 二级 cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + province_href[1:8] yield Request(url=cl, callback=self.parse_second, dont_filter=True) def parse_second(self, response): second = Selector(response) # node_city = json.dumps(sell.xpath('//tr[@class="citytr"]/td/a/text()').extract(), ensure_ascii=False) node_city = second.xpath('//tr[@class="citytr"]/td/a/text()') node_city_href = second.xpath('//tr[@class="citytr"]/td/a/@href') # print(node_city) # 城市代码list city_codes = [] # 城市名称list city_name = [] # 城市href list city_href = [] for item in node_city: city = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if city[1:13].isdigit(): # 将字符串数据存至list类型数据中 city_codes.append(city) # print("代码：") # print(city) else: city_name.append(city) # print("名称：") # print(city) for href_item in node_city_href: city_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "城市href" 添加至 "list中" city_href.append(city_href_item) # 对得到的 "城市href" 做 "list去重" city_href = list(set(city_href)) city_codes = list(set(city_codes)) city_name = list(set(city_name)) for item in city_href: cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + item[1:13] # 第三级数据展示 yield Request(url=cl, callback=self.parse_thread, dont_filter=True) def parse_thread(self, response): thread = Selector(response) node_county = thread.xpath('//tr[@class="countytr"]/td/a/text()') node_county_href = thread.xpath('//tr[@class="countytr"]/td/a/@href') # 县区级 代码list county_codes = [] # 县区级 名称list county_name = [] # 县区级 href list county_href = [] for item in node_county: county = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if county[1:13].isdigit(): # 将字符串数据存至list类型数据中 county_codes.append(county) # print("代码：") # print(county) else: county_name.append(county) # print("名称：") # print(county) for href_item in node_county_href: county_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "县区级 href" 添加至 "list中" county_href.append(county_href_item) # 对得到的 "县区级 href" 做 "list去重" county_href = list(set(county_href)) county_codes = list(set(county_codes)) # print(county_codes) county_name = list(set(county_name)) for href, codes in zip(county_href, county_codes): # 57 68 cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + codes[1:3] + "/" + href[1:15] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # 第四级数据展示 yield Request(url=cl, callback=self.parse_fourth, dont_filter=True) def parse_fourth(self, response): thread = Selector(response) node_towntr = thread.xpath('//tr[@class="towntr"]/td/a/text()') node_towntr_href = thread.xpath('//tr[@class="towntr"]/td/a/@href') # 街道办 代码list towntr_codes = [] # 街道办 名称list towntr_name = [] # 街道办 href list towntr_href = [] for item in node_towntr: towntr = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if towntr[1:13].isdigit(): # 将字符串数据存至list类型数据中 towntr_codes.append(towntr) print("代码：") print(towntr) else: towntr_name.append(towntr) print("名称：") print(towntr) for href_item in node_towntr_href: towntr_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # print(towntr_href_item) # 将单个 "街道办 href" 添加至 "list中" towntr_href.append(towntr_href_item) # 对得到的 "街道办 href" 做 "list去重" towntr_href = list(set(towntr_href)) towntr_codes = list(set(towntr_codes)) towntr_name = list(set(towntr_name)) for href, code in zip(towntr_href, towntr_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + code[1:3] + "/" + code[3:5] + "/" + href[1:18] print(cl) # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/65/29/652927.html # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/21/211321001.html # code : 211321001000 # href : 21/211321001.html # 第五级数据展示 yield Request(url=cl, callback=self.parse_Five, dont_filter=True) def parse_Five(self, response): thread = Selector(response) node_village = thread.xpath('//tr[@class="villagetr"]/td/text()') # 社区 区划代码 list village_codes = [] # 社区 城乡分类代码 list village_categary = [] # 社区 名称 list village_name = [] for item in node_village: village = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if village[1:12].isdigit(): # 将字符串数据存至list类型数据中 village_codes.append(village) print("代码：") print(village) elif village[1:4].isdigit(): print("城乡分类代码：") village_categary.append(village) print(village) else: village_name.append(village) print("名称：") print(village) # 对得到的 "街道办 href" 做 "list去重" village_categary = list(set(village_categary)) village_codes = list(set(village_codes)) village_name = list(set(village_name)) Version 2 - 处理，简化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215# coding=utf-8# 要在代码中使用"中文"注释，应该首先添加如上注释，说明是中文注释import jsonfrom scrapy import Spider, Selectorfrom scrapy.http.request import Request"""从"国家统计局"官网爬取行政区域数据url:http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"""class NOSSpider(Spider): # 基础配置 - 唯一名称 name = "NOS" # 基础配置 - 允许访问的域名 allowed_domains = ["www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm"] # 基础配置 - 开发爬取的地址 start_urls = ["http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"] """第一级：省级、直辖市 数据爬取""" def parse(self, response): sel = Selector(response) node = sel.xpath('//tr[@class="provincetr"]/td/a/text()') node_href = sel.xpath('//tr[@class="provincetr"]/td/a/@href') for item_node, item_node2 in zip(node, node_href): # 名称 ："山东省" province_name = json.dumps(item_node.extract(), ensure_ascii=False) # 名称 ："37.html" province_href = json.dumps(item_node2.extract(), ensure_ascii=False) # 名称 ："37" province_code = province_href[1:3] # 拼接：地级市信息 二级 cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + province_href[1:8] yield Request(url=cl, callback=self.parse_second, dont_filter=True) """第二级：地级市 数据爬取""" def parse_second(self, response): second = Selector(response) node_city = second.xpath('//tr[@class="citytr"]/td/a/text()') node_city_href = second.xpath('//tr[@class="citytr"]/td/a/@href') # 城市代码list city_codes = [] # 城市名称list city_name = [] # 城市href list city_href = [] for item, href_item in zip(node_city, node_city_href): city = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if city[1:13].isdigit(): # 将字符串数据存至list类型数据中 city_codes.append(city) # print("代码：") else: city_name.append(city) # print("名称：") city_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "城市href" 添加至 "list中" city_href.append(city_href_item) # 做 "list去重" city_href = list(set(city_href)) city_codes = list(set(city_codes)) city_name = list(set(city_name)) for item in city_href: cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + item[1:13] # 第三级url拼接 yield Request(url=cl, callback=self.parse_thread, dont_filter=True) """第三级：区县乡级 数据爬取""" def parse_thread(self, response): thread = Selector(response) node_county = thread.xpath('//tr[@class="countytr"]/td/a/text()') node_county_href = thread.xpath('//tr[@class="countytr"]/td/a/@href') # 县区级 代码list county_codes = [] # 县区级 名称list county_name = [] # 县区级 href list county_href = [] for item, href_item in zip(node_county, node_county_href): county = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if county[1:13].isdigit(): # 将字符串数据存至list类型数据中 county_codes.append(county) # print("代码：") else: county_name.append(county) # print("名称：") county_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "县区级 href" 添加至 "list中" county_href.append(county_href_item) # 做 "list去重" county_href = list(set(county_href)) county_codes = list(set(county_codes)) county_name = list(set(county_name)) for href, codes in zip(county_href, county_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + codes[1:3] + "/" + href[1:15] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # 第四级url拼接 yield Request(url=cl, callback=self.parse_fourth, dont_filter=True) """第四级：街道、居委会级 数据爬取""" def parse_fourth(self, response): thread = Selector(response) node_towntr = thread.xpath('//tr[@class="towntr"]/td/a/text()') node_towntr_href = thread.xpath('//tr[@class="towntr"]/td/a/@href') # 街道办 代码list town_codes = [] # 街道办 名称list town_name = [] # 街道办 href list town_href = [] for item, href_item in zip(node_towntr, node_towntr_href): town = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if town[1:13].isdigit(): town_codes.append(town) # print("代码：") else: town_name.append(town) # print("名称：") towntr_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "街道办 href" 添加至 "list中" town_href.append(towntr_href_item) # 做 "list去重" town_href = list(set(town_href)) town_codes = list(set(town_codes)) town_name = list(set(town_name)) for href, code in zip(town_href, town_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + code[1:3] + "/" + code[3:5] + "/" + href[ 1:18] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/21/211321001.html # code : 211321001000 # href : 21/211321001.html # 第五级url拼接 yield Request(url=cl, callback=self.parse_Five, dont_filter=True) """第五级：社区级 数据爬取""" def parse_Five(self, response): thread = Selector(response) node_village = thread.xpath('//tr[@class="villagetr"]/td/text()') # 社区 区划代码 list village_codes = [] # 社区 城乡分类代码 list village_categary = [] # 社区 名称 list village_name = [] for item in node_village: village = json.dumps(item.extract(), ensure_ascii=False) if village[1:12].isdigit(): # 将字符串数据存至list类型数据中 village_codes.append(village) print("代码：") print(village) elif village[1:4].isdigit(): print("城乡分类代码：") village_categary.append(village) print(village) else: village_name.append(village) print("名称：") print(village) # 做 "list去重" village_categary = list(set(village_categary)) village_codes = list(set(village_codes)) village_name = list(set(village_name)) """ 最终结果： 代码： "610626001222" 城乡分类代码： "220" 名称： "陈砭村委会" """ Version 3 - 将数据写入到MySQL数据库0. 注意： 从本项目的一个文件中导入此文件中的某一个类时，需要导入一个完整的路劲。否则提示：ImportError: No module named items。在 settings文件中编写路径类时，同样需要编写带有路径的文件类，否则不认，同上错误 1. settings.py 1234567891011121314151617# 自动生成BOT_NAME = 'Northern_Open_Space'SPIDER_MODULES = ['Northern_Open_Space.spiders']NEWSPIDER_MODULE = 'Northern_Open_Space.spiders'ROBOTSTXT_OBEY = True# 设置请求头部，添加urlDEFAULT_REQUEST_HEADERS = &#123; "User-Agent": "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;", 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'&#125;# 手动添加FEED_EXPORT_ENCODING = 'utf-8'ITEM_PIPELINES = &#123; 'Northern_Open_Space.pipelines.NorthernOpenSpacePipeline': 300, # 保存到mysql数据库&#125; 2. pipelines.py 12345678910111213141516171819202122232425class NorthernOpenSpacePipeline(object): def insertIntoTable(self, sql): # 创建连接 conn = pymysql.connect( host='127.0.0.1', port=3306, user='root', passwd='0987', db='area_database', charset='utf8') # 要指定编码，否则中文可能乱码 # 创建游标 cursor = conn.cursor() # 执行查询语句 cursor.execute(sql) # 提交，不然无法保存新建或者修改的数据 conn.commit() # 关闭游标 cursor.close() # 关闭连接 conn.close() 3. XXXXpider.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244class NOSSpider(Spider): # 基础配置 - 唯一名称 name = "NOS" # 基础配置 - 允许访问的域名 allowed_domains = ["www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm"] # 基础配置 - 开发爬取的地址 start_urls = ["http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"] """第一级：省级、直辖市 数据爬取""" def parse(self, response): sel = Selector(response) node = sel.xpath('//tr[@class="provincetr"]/td/a/text()') node_href = sel.xpath('//tr[@class="provincetr"]/td/a/@href') for item_node, item_node2 in zip(node, node_href): # 名称 ："山东省" province_name = json.dumps(item_node.extract(), ensure_ascii=False) # 名称 ："37.html" province_href = json.dumps(item_node2.extract(), ensure_ascii=False) # 名称 ："37" province_code = province_href[1:3] # self.insertIntoProvince(province_code, province_name) cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + province_href[1:8] yield Request(url=cl, callback=self.parse_second, dont_filter=True) def insertIntoProvince(self, province_code, province_name): # 将获取的数据插入到数据库中 db = NorthernOpenSpacePipeline() sql = "insert into province_table (" + 'province_name,' + 'province_code,' + 'simple_province_code,' + 'grade' + ") VALUE (" + province_name + "," + province_code + '0000000000' + "," + province_code + "," + "1" + ")" db.insertIntoTable(sql=sql) """第二级：地级市 数据爬取""" def parse_second(self, response): second = Selector(response) node_city = second.xpath('//tr[@class="citytr"]/td/a/text()') # print(len(node_city)) # print(json.dumps(node_city.extract(), ensure_ascii=False)) node_city_href = second.xpath('//tr[@class="citytr"]/td/a/@href') # self.insertToCity(node_city) # 城市href list city_href = [] for href_item in node_city_href: city_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "城市href" 添加至 "list中" city_href.append(city_href_item) # 做 "list去重" city_href = list(set(city_href)) for item in city_href: cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + item[1:13] # 第三级url拼接 yield Request(url=cl, callback=self.parse_thread, dont_filter=True) def insertToCity(self, node_city): # 循环赋值 n = len(node_city) m = 0 while m &lt; n: code = json.dumps((node_city[m:m + 1]).extract(), ensure_ascii=False) name = json.dumps((node_city[m + 1:m + 2]).extract(), ensure_ascii=False) print(code[1:len(code) - 1]) print(name[1:len(name) - 1]) db = NorthernOpenSpacePipeline() sql = "insert into city_table (" + 'city_code,' + 'city_name,' + 'simple_city_code,' + 'grade' + ") VALUE (" + code[ 1:len( code) - 1] + "," + name[ 1:len( name) - 1] + "," + ( code[ 1:len( code) - 1])[ 1:5] + "," + "2" + ")" db.insertIntoTable(sql=sql) m = m + 2 """第三级：区县乡级 数据爬取""" def parse_thread(self, response): thread = Selector(response) node_county = thread.xpath('//tr[@class="countytr"]/td/a/text()') node_county_href = thread.xpath('//tr[@class="countytr"]/td/a/@href') # self.insertIntoCounty(node_county)# 县区级 代码list county_codes = [] # 县区级 名称list county_name = [] # 县区级 href list county_href = [] for item, href_item in zip(node_county, node_county_href): county = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if county[1:13].isdigit(): # 将字符串数据存至list类型数据中 county_codes.append(county) # print("代码：") else: county_name.append(county) # print("名称：") county_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "县区级 href" 添加至 "list中" county_href.append(county_href_item) # 做 "list去重" county_href = list(set(county_href)) county_codes = list(set(county_codes)) county_name = list(set(county_name)) for href, codes in zip(county_href, county_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + codes[1:3] + "/" + href[1:15] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # 第四级url拼接 yield Request(url=cl, callback=self.parse_fourth, dont_filter=True) def insertIntoCounty(self, node_county): n = len(node_county) m = 0 while m &lt; n: code = json.dumps((node_county[m:m + 1]).extract(), ensure_ascii=False) name = json.dumps((node_county[m + 1:m + 2]).extract(), ensure_ascii=False) print(code[1:len(code) - 1]) print(name[1:len(name) - 1]) db = NorthernOpenSpacePipeline() sql = "insert into county_table (" + 'county_code,' + 'county_name,' + 'simple_county_code,' + 'grade' + ") VALUE (" + code[ 1:len( code) - 1] + "," + name[ 1:len( name) - 1] + "," + ( code[ 1:len( code) - 1])[ 1:7] + "," + "3" + ")" db.insertIntoTable(sql=sql) m = m + 2 """第四级：街道、居委会级 数据爬取""" def parse_fourth(self, response): thread = Selector(response) node_towntr = thread.xpath('//tr[@class="towntr"]/td/a/text()') node_towntr_href = thread.xpath('//tr[@class="towntr"]/td/a/@href') print(json.dumps(node_towntr.extract(), ensure_ascii=False)) # self.insertIntoTown(node_towntr)# 街道办 代码list town_codes = [] # 街道办 名称list town_name = [] # 街道办 href list town_href = [] for item, href_item in zip(node_towntr, node_towntr_href): town = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if town[1:13].isdigit(): town_codes.append(town) # print("代码：") else: town_name.append(town) # print("名称：") towntr_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "街道办 href" 添加至 "list中" town_href.append(towntr_href_item) # 做 "list去重" town_href = list(set(town_href)) town_codes = list(set(town_codes)) town_name = list(set(town_name)) for href, code in zip(town_href, town_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + code[1:3] + "/" + code[3:5] + "/" + href[ 1:18] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/21/211321001.html # code : 211321001000 # href : 21/211321001.html # 第五级url拼接 yield Request(url=cl, callback=self.parse_Five, dont_filter=True) def insertIntoTown(self, node_towntr): n = len(node_towntr) m = 0 while m &lt; n: code = json.dumps((node_towntr[m:m + 1]).extract(), ensure_ascii=False) name = json.dumps((node_towntr[m + 1:m + 2]).extract(), ensure_ascii=False) # print(code[1:len(code) - 1]) # print(name[1:len(name) - 1]) db = NorthernOpenSpacePipeline() sql = "insert into town_table (" + 'town_code,' + 'town_name,' + 'simple_town_code,' + 'grade' + ") VALUE (" + code[ 1:len( code) - 1] + "," + name[ 1:len( name) - 1] + "," + ( code[ 1:len( code) - 1])[ 7:10] + "," + "4" + ")" db.insertIntoTable(sql=sql) m = m + 2 """第五级：社区级 数据爬取""" def parse_Five(self, response): thread = Selector(response) node_village = thread.xpath('//tr[@class="villagetr"]/td/text()') print(json.dumps(node_village.extract(), ensure_ascii=False)) n = len(node_village) m = 0 while m &lt; n: code = json.dumps((node_village[m:m + 1]).extract(), ensure_ascii=False) simple_code = json.dumps((node_village[m + 1:m + 2]).extract(), ensure_ascii=False) name = json.dumps((node_village[m + 2:m + 3]).extract(), ensure_ascii=False) print(code[1:len(code) - 1]) print(simple_code[1:len(simple_code) - 1]) print(name[1:len(name) - 1]) print((code[11:14])) db = NorthernOpenSpacePipeline() sql = "insert into village_table (" + \ 'village_code,' + 'village_name,' + 'simple_village_code,' + 'village_category_code,' + 'grade' + ") VALUE (" + \ code[1:len(code) - 1] + "," + name[1:len(name) - 1] + "," + code[11:14] + "," + simple_code[1:len(simple_code) - 1] + "," + "5" + ")" db.insertIntoTable(sql=sql) m = m + 3]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库-GreenDao数据库的使用]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E5%BA%93-GreenDao%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[GreenDao数据库使用 使用参考：http://blog.csdn.net/liuchao9876543210/article/details/54378859 一. 添加依赖1. 项目gradle中：12345678dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.2&apos; //GreenDao3依赖 classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.1&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125; 2. Module中：12//使用greendaoapply plugin: &apos;org.greenrobot.greendao&apos; 12345678android &#123; ··· //greendao配置 greendao &#123; //版本号，升级时可配置 schemaVersion 1 &#125;&#125; 1234567dependencies &#123; ··· //greendao依赖 compile &apos;org.greenrobot:greendao:3.2.0&apos; //解决greendao使用过程中分包导致的异常、解决缺少类的异常 compile &apos;net.zetetic:android-database-sqlcipher:3.5.7&apos;&#125; 二. 实际使用1. 实体对象（表）的创建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * StudentBase 学生基本信息表 * * DAO：Data Access Object * @author wenjia.Cheng cwj1714@163.com * @date 2018/1/20 */@Entitypublic class StudentBase &#123; /** * 当前表中的学生数量的id值 */ @Id(autoincrement = true) private long id_num_stu; /** * 学生的学号 */ @Unique @NotNull private String id_stu; /** * 身份证号 */ @Unique @NotNull private String id_card_stu;&#125;``` ### 注意：- 在创建完“实体”后，记得要“build”一下，“build”之后就会生成相应的“StudentBaseDao”类文件，否则不能使用。供之后调用。- 主键必须是long类型### 注解说明： - **@Entity**：告诉GreenDao该对象为实体，只有被@Entity注释的Bean类才能被dao类操作 - **@Id**：对象的Id，使用**Long**类型作为EntityId，否则会报错。 - **@Property**：可以自定义字段名，注意外键不能使用该属性 - **@NotNull**：属性不能为空 - **@Transient**：使用该注释的属性不会被存入数据库的字段中 - **@Unique**：该属性值必须在数据库中是唯一值 - **@Generated**：编译后自动生成的构造函数、方法等的注释，提示构造函数、方法等不能被修改 - **@ToOne**：定义与另一个实体（一个实体对象）的关系（底下会有详解）.如： - **@ToMany**：定义与多个实体对象的关系（底下会有详解） - **@OrderBy(date desc)**：降序### 关联：&gt; 参考：https://www.jianshu.com/p/dbec25bd575f- **1对1 ：@ToOne(joinProperty = “userId”)** ：通过外键来关联另一个实体。使用到的两个对象类为：（User，Picture） ```java@Entitypublic class User &#123; @Id private Long UserId; private long pictureId; @Property(nameInDb = "NAME") private String name; @Property(nameInDb = "AGE") private String age; @Property(nameInDb = "SEX") private String sex; @ToOne(joinProperty = "pictureId")//pictureId是我们需要关联的外键 private Picture picture;&#125;@Entitypublic class Picture implements Serializable &#123; private static final long serialVersionUID = 11; @Id private Long pictureId; private long userId; @Property private String pictureName; @Property(nameInDb = "width") private String width; @Property(nameInDb = "height") private String height; @ToOne(joinProperty = "userId") private User user;&#125; 1对n： 注意：Intent传递对象需要用到：Serializable，必须把serialVersionUID 给带上，不然会报错。 12345@ToMany(referencedJoinProperty = "customerId")joinProperties这个参数是referencedJoinProperty 参数的升级版@ToMany(joinProperties = &#123; @JoinProperty(name = "id", referencedName = "customerId") &#125;) 1234567891011121314151617181920@Entitypublic class Customer &#123; @Id private Long id; @Property private String name; // @ToMany(referencedJoinProperty = "customerId") @ToMany(joinProperties = &#123;@JoinProperty(name = "id", referencedName = "customerId")&#125;) @OrderBy("date ASC") private List&lt;Order&gt; orders;&#125;@Entitypublic class Order &#123; @Id private Long id; @Property private Date date; private long customerId;&#125; m:n 多对多: 创建三个实体类，其中一个为关联类。 1234567891011121314151617181920212223242526272829@Entitypublic class Order &#123; @Id private Long id; @Property private Date date; private long customerId;&#125;@Entitypublic class Product &#123; @Id private Long id; @ToMany @JoinEntity( entity = JoinProductsWithOrders.class, sourceProperty = "productId", targetProperty = "orderId" ) private List&lt;Order&gt; ordersWithThisProduct;&#125;@Entitypublic class JoinProductsWithOrders &#123; @Id private Long id; private Long productId; private Long orderId;&#125; 2. 数据库的创建： 需要在自定义的“Application”类中进行声明。 12345678910111213141516171819202122232425262728293031323334353637public class App extends Application &#123; private static DaoSession daoSession; @Override public void onCreate() &#123; super.onCreate(); ··· //配置数据库 setupDatabase(); &#125; /** * 配置数据库 * * 1、DevOpenHelper：创建SQLite数据库的SQLiteOpenHelper的具体实现 * 2、DaoMaster：GreenDao的顶级对象，作为数据库对象、用于创建表和删除表 * 3、DaoSession：管理所有的Dao对象，Dao对象中存在着增删改查等API */ private void setupDatabase() &#123; // 创建数据库:49_class_info.db DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this,"jujia.db",null); // 获取可写数据库 SQLiteDatabase db = helper.getWritableDatabase(); // 获取数据库对象 DaoMaster daoMaster = new DaoMaster(db); // 获取Dao对象管理者 daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoInstant() &#123; return daoSession; &#125;&#125; 3. 最基本的CURD3.1 C ：增3.1 Read : 查 orderAsc：升序排序 orderDesc：降序排序 eq()： == noteq(): != gt(): &gt; t(): &lt; ge: &gt;= le: &lt;= like(): 包含 between: 两者之间 in: 在某个范围之内 notIn: 不在某个范围之内 limit(int): 限制查询的数量 - 分页 offset(int): 每次返回的数量 - 分页 unique(): 如果只想获取一个结果时 list(): 获取查询结果集合 - LazyList listLazy()懒查询：只有当调用list()中的实体对象时才会执行查询操作并且只缓存第一次被查询的结果，需要关闭 - LazyList listlazyUncached()懒查询：只有当调用list()中的实体对象时才会执行查询操作并且不缓存，需要关闭 - LazyList listIterator()：对查询结果进行遍历，不缓存，需要关闭 - LazyList 示例：123456789101112131415161718192021222324252627282930313233343536373839public class UserInfoCURD &#123; private static final String TAG = "UserInfoCURD"; /** * 增 * @param userInfoBean 实体对象 */ public static long insertToStudent(UserInfoBean userInfoBean)&#123; return App.getDaoInstant().getUserInfoBeanDao().insert(userInfoBean); &#125; /** * 删 * @param userInfoBean 实体对象 */ public static void deleteFromStudent(UserInfoBean userInfoBean)&#123; App.getDaoInstant().getUserInfoBeanDao().delete(userInfoBean); &#125; public static void deleteFromStudentAll()&#123; App.getDaoInstant().getUserInfoBeanDao().deleteAll(); &#125; /** * 改 * @param userInfoBean 实体对象 */ public static void updateToStudent(UserInfoBean userInfoBean)&#123; App.getDaoInstant().getUserInfoBeanDao().update(userInfoBean); &#125; /** * 查 - 全部 */ public static List&lt;UserInfoBean&gt; queryFromStudent()&#123; return App.getDaoInstant().getUserInfoBeanDao().loadAll(); &#125;&#125; 4. 数据库升级 参考：http://blog.csdn.net/huangxiaoguo1/article/details/54574713 （1）思路： 创建临时表 –&gt; 删除旧表 –&gt; 创建新表 –&gt; 复制临时表中的数据到新表中，并删除临时表 （2）注意： 在对数据库进行升级的过程中，有时候会遇到“”的问题，要避免的这样的问题就要： 新增加的和修改的字段最好为String类型，避免字段不能为null的情况发生 不要用基础数据类型，用封装的数据类型 附录：MigrationHelper类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.choe.greendaodemo.utils;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.text.TextUtils;import android.util.Log;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import de.greenrobot.dao.AbstractDao;import de.greenrobot.dao.internal.DaoConfig;import me.itangqi.dao.DaoMaster;/** * Created by cyk */public class MigrationHelper &#123; private static final String CONVERSION_CLASS_NOT_FOUND_EXCEPTION = "MIGRATION HELPER - CLASS DOESN'T MATCH WITH THE CURRENT PARAMETERS"; private static MigrationHelper instance; public static MigrationHelper getInstance() &#123; if(instance == null) &#123; instance = new MigrationHelper(); &#125; return instance; &#125; public void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; generateTempTables(db, daoClasses); DaoMaster.dropAllTables(db, true); DaoMaster.createAllTables(db, false); restoreData(db, daoClasses); &#125; /** * 生成临时列表 * @param db * @param daoClasses */ private void generateTempTables(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for(int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String divider = ""; String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat("_TEMP"); ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(); StringBuilder createTableStringBuilder = new StringBuilder(); createTableStringBuilder.append("CREATE TABLE ").append(tempTableName).append(" ("); for(int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if(getColumns(db, tableName).contains(columnName)) &#123; properties.add(columnName); String type = null; try &#123; type = getTypeByClass(daoConfig.properties[j].type); &#125; catch (Exception exception) &#123; exception.printStackTrace(); &#125; createTableStringBuilder.append(divider).append(columnName).append(" ").append(type); if(daoConfig.properties[j].primaryKey) &#123; createTableStringBuilder.append(" PRIMARY KEY"); &#125; divider = ","; &#125; &#125; createTableStringBuilder.append(");"); db.execSQL(createTableStringBuilder.toString()); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append("INSERT INTO ").append(tempTableName).append(" ("); insertTableStringBuilder.append(TextUtils.join(",", properties)); insertTableStringBuilder.append(") SELECT "); insertTableStringBuilder.append(TextUtils.join(",", properties)); insertTableStringBuilder.append(" FROM ").append(tableName).append(";"); db.execSQL(insertTableStringBuilder.toString()); &#125; &#125; /** * 存储新的数据库表 以及数据 * @param db * @param daoClasses */ private void restoreData(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for(int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat("_TEMP"); ArrayList&lt;String&gt; properties = new ArrayList(); for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if(getColumns(db, tempTableName).contains(columnName)) &#123; properties.add(columnName); &#125; &#125; StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append("INSERT INTO ").append(tableName).append(" ("); insertTableStringBuilder.append(TextUtils.join(",", properties)); insertTableStringBuilder.append(") SELECT "); insertTableStringBuilder.append(TextUtils.join(",", properties)); insertTableStringBuilder.append(" FROM ").append(tempTableName).append(";"); StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append("DROP TABLE ").append(tempTableName); db.execSQL(insertTableStringBuilder.toString()); db.execSQL(dropTableStringBuilder.toString()); &#125; &#125; private String getTypeByClass(Class&lt;?&gt; type) throws Exception &#123; if(type.equals(String.class)) &#123; return "TEXT"; &#125; if(type.equals(Long.class) || type.equals(Integer.class) || type.equals(long.class)) &#123; return "INTEGER"; &#125; if(type.equals(Boolean.class)) &#123; return "BOOLEAN"; &#125; Exception exception = new Exception(CONVERSION_CLASS_NOT_FOUND_EXCEPTION.concat(" - Class: ").concat(type.toString())); exception.printStackTrace(); throw exception; &#125; private static List&lt;String&gt; getColumns(SQLiteDatabase db, String tableName) &#123; List&lt;String&gt; columns = new ArrayList&lt;&gt;(); Cursor cursor = null; try &#123; cursor = db.rawQuery("SELECT * FROM " + tableName + " limit 1", null); if (cursor != null) &#123; columns = new ArrayList&lt;&gt;(Arrays.asList(cursor.getColumnNames())); &#125; &#125; catch (Exception e) &#123; Log.v(tableName, e.getMessage(), e); e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return columns; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的aseets中的文件读取]]></title>
    <url>%2FAndroid%E7%9A%84aseets%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[assets中文件的使用 1. Android资源文件大致可以分为两种： res目录下存放的可编译的资源文件：这种资源文件系统会在R.java里面自动生成该资源文件的ID，所以访问这种资源文件比较简单，通过R.XXX.ID即可； assets目录下存放的原生资源文件：系统在编译的时候不会编译assets下的资源文件。AssetManager提供对应用程序的原始资源文件进行访问；这个类提供了一个低级别的API，它允许你以简单的字节流的形式打开和读取和应用程序绑定在一起的原始资源文件。 2. AssetsManager类常量： ACCESS_UNKNOWN : 未指定具体的读取模式 ACCESS_RANDOM : 随机读取 ACCESS_STREAMING : 顺序读取 （默认） ACCESS_BUFFER : 缓存读取 方法： close(); 关闭asset manager String[] list(String path); 列出该目录下的下级文件和文件夹名称 InputStream open(String fileName); 以顺序读取模式打开文件，默认模式为ACCESS_STREAMING InputStream open(String fileName, int accessMode); 以指定模式打开文件 AssetFileDescriptor openFd (String fileName) 注意：Android中还有另外一个文件夹raw,和assets差不多,也不会被R文件编译,但是raw下不能在建文件夹,assets文件下是可以在建文件夹的,下面是获取raw文件夹下资源的方法: 1InputStream is = getResources().openRawResource(R.id.filename); 3. assets目录下主要存放四种文件： 文本文件 图像文件 网页文件（包括html中引用的js/ccs/jpg等资源 音频视频文件 4. 读取四种文件： 读取文本文件eg： 123456String fileName = "newFile.txt";InputStream is = getAssets().open(fileName); int lenght = is.available(); byte[] buffer = new byte[lenght]; is.read(buffer); String result = = new String(buffer, "utf8"); 读取图像文件： 123InputStream is = getAssets().open(fileName); bitmap = BitmapFactory.decodeStream(is); ivImg.setImageBitmap(bitmap); 读取网页文件： 1webView.loadUrl("file:///android_asset/html/index.htmll"); 读取音视频文件： 12345678910// 打开指定音乐文件,获取assets目录下指定文件的AssetFileDescriptor对象 AssetFileDescriptor afd = am.openFd(music); mPlayer.reset(); // 使用MediaPlayer加载指定的声音文件。 mPlayer.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()); // 准备声音 mPlayer.prepare(); // 播放 mPlayer.start(); 5. 将assets下的文件复制到SD卡中12345678910111213141516171819202122232425262728293031323334/** * 从assets目录中复制整个文件夹内容 * @param context Context 使用CopyFiles类的Activity * @param oldPath String 原文件路径 如：/aa * @param newPath String 复制后路径 如：xx:/bb/cc */ public void copyFilesFassets(Context context,String oldPath,String newPath) &#123; try &#123; String fileNames[] = context.getAssets().list(oldPath);//获取assets目录下的所有文件及目录名 if (fileNames.length &gt; 0) &#123;//如果是目录 File file = new File(newPath); file.mkdirs();//如果文件夹不存在，则递归 for (String fileName : fileNames) &#123; copyFilesFassets(context,oldPath + "/" + fileName,newPath+"/"+fileName); &#125; &#125; else &#123;//如果是文件 InputStream is = context.getAssets().open(oldPath); FileOutputStream fos = new FileOutputStream(new File(newPath)); byte[] buffer = new byte[1024]; int byteCount=0; while((byteCount=is.read(buffer))!=-1) &#123;//循环从输入流读取 buffer字节 fos.write(buffer, 0, byteCount);//将读取的输入流写入到输出流 &#125; fos.flush();//刷新缓冲区 is.close(); fos.close(); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); //如果捕捉到错误则通知UI线程 MainActivity.handler.sendEmptyMessage(COPY_FALSE); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EChart第三方JS库图表html文档示例]]></title>
    <url>%2FEChart%E7%AC%AC%E4%B8%89%E6%96%B9JS%E5%BA%93%E5%9B%BE%E8%A1%A8html%E6%96%87%E6%A1%A3%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[示例文档： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;&lt;div id="main" style="width: 100% ;height: 1000%; "&gt;&lt;/div&gt;&lt;!-- 编写JavaScript代码 --&gt;&lt;script type="text/javascript"&gt; // var arrName = []; // 高压 var arrDataH = []; // 低压 var arrDataL = []; // 心率 var arrDataM = []; //js调用Java function getEveryDay() &#123; return window.Fragment_Day.getDataByDay(); &#125; function getLocalTime(nS) &#123; return new Date(parseInt(nS) * 1000); &#125; function formatDate(now) &#123; var year = now.getFullYear(), month = now.getMonth() + 1, date = now.getDate(); return year + "-" + month + "-" + date; &#125; function topData() &#123; //var strData = getEveryDay(); var strData = [&#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;, &#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;, &#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;, &#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;, &#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;] console.log(strData); for (var i = 0; i &lt; strData.length; i++) &#123; arrName.push(formatDate(getLocalTime(strData[i].addtime))); console.log(formatDate(getLocalTime(strData[i].addtime))); arrDataH.push(strData[i].h_pressure); arrDataL.push(strData[i].l_pressure); arrDataM.push(strData[i].pulse); &#125; &#125; window.onload = function () &#123; topData(); var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; // 整体位置设置 grid: &#123; top: '10%', left: '10%', right: '4%', bottom: '15%' &#125;, // 图例设置 legend: &#123; //name=legend.data的时候才能显示图例 data: ['高压', '低压', '心率'], top: '2%', right: '10%', itemGap: 150, &#125;, // 字体大小设置 textStyle: &#123; fontSize: "150%" &#125;, // x轴设置 xAxis: &#123; type: 'category', boundaryGap: false, data: arrName, axisLabel: &#123; interval: 0, rotate: 45, formatter: '&#123;value&#125;', textStyle: &#123; fontSize: 24, &#125; &#125; &#125;, // y轴设置 yAxis: &#123; axisLabel: &#123; textStyle: &#123; fontSize: 24 &#125; &#125; &#125;, // 绘制折线 series: [ // 高压 &#123; /** * 图表样式 */ name: '高压', type: 'line', label: &#123; normal: &#123; show: true, position: 'top', fontSize: 24 &#125; &#125;, /** * 设置折线颜色 */ itemStyle: &#123; normal: &#123; color: "#cc3300", barBorderColor: "#cc3300", &#125; &#125;, /** * 设置y轴对应的具体数据 */ data: arrDataH, &#125;, // 低压 &#123; /** * 图表样式 */ name: '低压', type: 'line', label: &#123; normal: &#123; show: true, position: 'top', fontSize: 24 &#125; &#125;, /** * 设置折线颜色 */ itemStyle: &#123; normal: &#123; color: "#33aa00", barBorderColor: "#33aa00", &#125; &#125;, /** * 设置y轴对应的具体数据 */ data: arrDataL, &#125;, // 心率 &#123; /** * 图表样式 */ name: '心率', type: 'line', label: &#123; normal: &#123; show: true, position: 'top', fontSize: 24 &#125; &#125;, /** * 设置折线颜色 */ itemStyle: &#123; normal: &#123; color: "#388CD9", barBorderColor: "#388CD9", &#125; &#125;, /** * 设置y轴对应的具体数据 */ data: arrDataM, &#125;] &#125; window.onresize = myChart.resize; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终结果样式:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库-RxJava的了解]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E5%BA%93-RxJava%E7%9A%84%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[参考：https://gank.io/post/560e15be2dca930e00da1083 一. 准备 Java泛型中&lt;？ extends E&gt;和&lt;？ super E&gt;的区别 参考：http://blog.csdn.net/u014513883/article/details/49820569 PECS法则 生产者（Producer）使用extends 如果你需要一个**提供**E类型元素的集合，使用泛型通配符&lt;? extends E&gt;。它好比一个生产者，可以提供数据。 消费者（Consumer）使用super 如果你需要一个只能**装入**E类型元素的集合，使用泛型通配符&lt;? super E&gt;。它好比一个消费者，可以消费你提供的数据。 既是生产者也是消费者既要存储又要读取，那就别使用泛型通配符 二. 使用方式（一）Observable中创造事件序列的方法1. create()1). Subscriber完整定义的回调123456789101112131415161718192021// Subscriber完整定义的回调Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("订阅者接收到----Hello"); subscriber.onNext("订阅者接收到----RxJava"); subscriber.onNext("订阅者接收到----Android"); subscriber.onCompleted(); &#125;&#125;).subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; onNext : " + s); &#125;&#125;); 2). Action1不完整定义的回调123456789101112131415// Action1不完整定义的回调Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("订阅者接收到----Hello"); subscriber.onNext("订阅者接收到----RxJava"); subscriber.onNext("订阅者接收到----Android"); subscriber.onCompleted(); &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + s); &#125;&#125;); Action1 和 Action0区别： Action0：是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。 Action1 ：也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。 2. just(T…) : 将传入的参数依次发送出来。12345678910111213141516171819202122232425262728293031// 使用单个StringObservable.just("just Hello", "just RxJava", "just Android").subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + s); &#125;&#125;);// 使用数组效果String[] strs = new String[]&#123;"just Hello", "just RxJava", "just Android"&#125;;Observable.just(strs).subscribe(new Action1&lt;String[]&gt;() &#123; @Override public void call(String[] strings) &#123; for (String item : strings) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + item); &#125; &#125;&#125;);// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted();/** * 结果： * just Hello * just RxJava * just Android */ 3. from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。12345678910111213141516171819202122232425// 一下两种方式产生的结果相同// 方式1String[] strs = &#123;"From Hello", "From RxJava", "From Android"&#125;;Observable.from(strs).subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; onNext haha : " + s); &#125; &#125;); // 方式2Observable.from(strs).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + s); &#125; &#125;); （二） 线程控制 ： Scheduler调度方法： subscribeOn() : 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn() ：指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 常用线程： Schedulers.immediate() : 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread() ：总是启用新线程，并在新线程执行操作。 Schedulers.io() : I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。顺序有变化。 Schedulers.computation() : 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。 AndroidSchedulers.mainThread() ：Android专用的 ，它指定的操作将在 Android 主线程运行。 示例： 123456789101112131415161718192021222324Observable.create(new Observable.OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getResources().getDrawable(R.mipmap.ic_launcher_round); subscriber.onNext(drawable); &#125;&#125;). subscribeOn(Schedulers.io()). observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onCompleted() &#123; Log.e(TAG, "aboutObservable_03 onCompleted"); &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, "aboutObservable_03 onError"); &#125; @Override public void onNext(Drawable drawable) &#123; mImage.setImageDrawable(drawable); &#125;&#125;); （三）变换将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 1. map() : 返回值为结果集。事件对象的直接变换，是一对一的转化，是 RxJava 最常用的变换。 释义 返回一个Observable，它将一个指定的函数应用于源Observable发出的每个项目，并发出这些函数应用程序的结果。 Func1()，包装的是有返回值的方法。 12345678910111213Observable.just("images/logo.png") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap &#125; &#125;) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap showBitmap(bitmap); &#125; &#125;); 2. flatMap() : 无顺序。嵌套操作。返回值为 Observable 对象。flat铺平。是一对多的转化。 释义 对Observable发射的数据都应用(apply)一个函数，这个函数返回一个Observable，然后合并这些Observables，并且发送（emit）合并的结果。 flatMap和map操作符很相像，flatMap发送的是合并后的Observables，map操作符发送的是应用函数后返回的结果集 原理： 嵌套 ：使用传入的事件对象创建一个 Observable 对象，此处嵌套Observable操作； 并不发送这个 Observable, 而是将它激活（Observable执行 “产生数据”的过程，此时，每一个事件产生若干个结果集合），但是不发送结果集合； 合并(merge)操作 —— 事件传入顺序 != 传出顺序 -&gt; 顺序混乱：每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件（结果集的集合）**统一**交给 Subscriber 的回调方法。 1234567891011121314151617181920212223242526272829303132333435363738List&lt;Course&gt; list1 = new ArrayList&lt;Course&gt;();list1.add(new Course("three - Android", 1));list1.add(new Course("three - JSP", 3));List&lt;Course&gt; list2 = new ArrayList&lt;Course&gt;();list2.add(new Course("three - Object-C", 1));list2.add(new Course("three - HTML 5", 2));StudentInCourse[] students = new StudentInCourse[]&#123; new StudentInCourse("张三", "男", 10, list1), new StudentInCourse("張小盒", "女", 20, list2),&#125;; Observable.from(students). flatMap(new Func1&lt;StudentInCourse, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(StudentInCourse studentInCourse) &#123; return Observable.from(studentInCourse.getList()); &#125; &#125;).subscribe(new Subscriber&lt;Course&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(Course course) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; onNext : " + course.toString()); &#125;&#125;);/** * Course&#123;name='three - Android', id=1&#125; * Course&#123;name='three - JSP', id=3&#125; * Course&#123;name='three - Object-C', id=1&#125; * Course&#123;name='three - HTML 5', id=2&#125; */ 详细说明：图片来自网络：https://www.jianshu.com/p/52cd2d514528 123由上图可以看出Student1、Student2经过flatMap后，按顺序依次经历了Observable1、Observable2，分别转化为Course。最后按顺序得到Course1、Course2、Course3、Course4、Course5、Course6，其中1-3由Student1得到，4-6由Student2得到。 我个人是在看到如上的配图+文字说明后，才恍然大悟的。 3. concatMap() ：有顺序性。同flatMap()相似 4.1 concat() : 多个数据源建立联系，one by one 参考：https://www.jianshu.com/p/94c433057440 官方图 网络图：多个数据源一个接一个的连接成为一个数据源 注意： 在使用此方法时，需要搭配onComplete() 或者 onError()。否则，最终返回的结果只能是第一个数据请求得到的结果。 使用场景： 4.1 需要同时处理多个数据请求，最终需要将其作为一个统一的数据进行返回。 4.2 依次检查memory、disk和network中是否存在数据，任何一步一旦发现数据后面的操作都不执行。 搭配使用： first() : 请求多数据源时，只要有一个请求到数据（满足需求），即停止其他请求，动作。 takeFirst() : 当请求多数据源时，所有的请求都没有数据时，为null时，不会报异常。 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 信息1Observable&lt;Object&gt; oneOb = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; String one = "商品信息1"; subscriber.onNext(one); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io());// 信息2Observable&lt;Object&gt; twoOb = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; String one = "这是艺术家的信息"; subscriber.onNext(one); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io());// 信息3Observable&lt;Object&gt; threeOb = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; Integer one = 123; subscriber.onNext(one); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io());// 信息汇总Observable.concat(oneOb, twoOb, threeOb).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object o) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + o.toString()); &#125;&#125;);/** * 商品信息1 * 这是艺术家的信息 * 123 */ // 只需要其中一个数据源有数据即可，即停止当前数据请求 Observable.concat(oneOb, twoOb, threeOb) // first()函数的使用 .first() .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object o) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + o.toString()); &#125;&#125;);/** * 商品信息1 */ 4.2 merge() 合并 4.3 compose() 组合5. zip() : 合并多个数据流，然后发送最终合并的数据。 参考：http://blog.csdn.net/johnny901114/article/details/51614927 使用场景： 在很多app种都会有图片上传的功能，比如商品的评价，客户端允许用户拍照上传(可能多张)，把图片上传到服务器，然后获取图片的url，再把图片的信息（图片url，图片大小）发送给服务器。 参考代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 1,先把所有的图片上传到又拍云（比如3张图片） * 2,获取图片的url路径，图片大小等 * 3,最后把数据全部提交给服务器 *///需要上传的图片Picture[] ps = xxx;Observable.zip( Observable.from(ps), getUpYunAddress(ps.length),//获取上传的url new Func2&lt;Picture, UpYunAddress, Picture&gt;() &#123; @Override public Picture call(Picture picture, UpYunAddress upYunAddress) &#123; //如果该图片已经上传则不应该上传 if (TextUtils.isEmpty(picture.getSource())) &#123; try &#123; //使用又拍云提供的工具类，上传图片 String path = UpYunUtil.uploadImage(upYunAddress, picture.getLocalUrl()); //获取最终的url String finalUrl = upYunAddress.getPrefix() + path; picture.setSource(finalUrl); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return picture; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) //上传成功后获取图片大小 .flatMap(new Func1&lt;Picture, Observable&lt;Picture&gt;&gt;() &#123; @Override public Observable&lt;Picture&gt; call(Picture picture) &#123; if (TextUtils.isEmpty(picture.getHeight()) || TextUtils.isEmpty(picture.getWidth())) &#123; BitmapFactory.Options options; if (!TextUtils.isEmpty(picture.getLocalUrl())) &#123; options = ImageUtil.getBitmapOptions(picture.getLocalUrl()); picture.setLocalUrl(null); &#125; else &#123; options = ImageUtil.getBitmapOptions(picture.getSource()); &#125; picture.setWidth(String.valueOf(options.outWidth)); picture.setHeight(String.valueOf(options.outHeight)); &#125; return Observable.just(picture); &#125; &#125;); //最后处理最终的数据。 4. filter() ：集合进行过滤5. each() ：遍历集合6. take() ：取出集合中的前几个7. skip() ：跳过前几个元素]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View - 手势动画处理]]></title>
    <url>%2FView-%E6%89%8B%E5%8A%BF%E5%8A%A8%E7%94%BB%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考：https://developer.android.com/reference/android/view/MotionEvent.html 相关的类 MotionEvent类：存储触摸事件的信息 VelocityTracker类：速度追踪类 Gandroid.view.GestureDetector : 手势操作的识别类，通过他来使用下面的识别接口。 android.view.GestureDetector.SimpleOnGestureListener : 手势识别的接口类，使用他可以按需重载自己想要的方法，方法多 android.view.GestureDetector.OnGestureListener : 手势识别的类，SimpleOnGestureListener接口的父类。使用他需要实现他所有的方法。 Android事件响应机制View.java 12public boolean dispatchTouchEvent(MotionEvent event)public boolean onTouchEvent(MotionEvent event) ViewGroup.java 123public boolean dispatchTouchEvent(MotionEvent event)public boolean onTouchEvent(MotionEvent event) public boolean onInterceptTouchEvent(MotionEvent event) onTouchEvent是真正用来进行业务逻辑处理的地方，返回true表示已经将该事件消费，返回false表明事件继续传递。 onInterceptTouchEvent是用来进行判断是否需要对事件进行拦截从而阻止其继续往子组件传递的，返回false表示无需拦截，则递归的调用子组件的dispatchTouchEvent方法；返回true表示需要拦截，则直接调用本组件的onTouchEvent方法进行处理。 一般我们是在View的onTouchEvent方法中处理MotionEvent对象的. 1public boolean onTouchEvent(MotionEvent event) 1. 概述：MotionEvent 用于报告移动事件对象 通过“动作代码” + “一组轴值”来描述运动。 动作代码 ：发生的状态变化，如指针向下或向上一族轴值 ：描述位置和其他运动属性 例如，当用户第一次触摸屏幕时，系统View通过动作代码ACTION_DOWN 和一组包含触摸的X和Y坐标的轴值以及关于触摸的压力，大小和方向的信息接触面积。 运动事件 与 指针 有些设备可以同时报告多个移动轨迹。多点触摸屏为每个手指发出一个运动轨迹。产生运动轨迹的各个手指或其他物体被称为指针。运动事件包含有关当前活动的所有指针的信息，即使其中一些指针自从上次事件发送以来尚未移动。除非手势被取消，否则指针的数目只会随着单个指针的上下而改变。 指针 “ID” 与 “索引” 每个指针都有一个唯一的标识，当它第一次出现时被分配（用ACTION_DOWNor 表示ACTION_POINTER_DOWN）。指针ID保持有效，直到指针最终上升（由ACTION_UP 或指示ACTION_POINTER_UP）或手势被取消（由指示 ACTION_CANCEL）。 所述MotionEvent类提供许多方法来查询位置和指针，如其他性质getX(int)，getY(int)，getAxisValue(int)， getPointerId(int)，getToolType(int)，和许多其他。大多数这些方法接受指针索引作为参数，而不是指针ID。事件中每个指针的指针索引的范围从0到1小于返回的值getPointerCount()。 单个指针在运动事件中出现的顺序是不确定的。因此，指针的指针索引可以从一个事件改变到下一个，但是只要指针保持活动状态，指针的指针ID就保证保持不变。使用该getPointerId(int)方法获取指针的指针ID，以在手势中的所有后续运动事件中跟踪指针。然后对于连续运动事件，使用该findPointerIndex(int)方法获取该运动事件中给定指针标识的指针索引。 坐标 使用最新的指针坐标 ：使用getX(int)和可以getY(int)。使用较早坐标 ： 使用 getHistoricalX(int, int)和访问批次内的getHistoricalY(int, int)。坐标是“历史的”，只要它们比批中的当前坐标更早; 然而，它们仍然不同于之前的动作事件中报告的任何其他坐标。要按时间顺序处理批次中的所有坐标，请先消耗历史坐标，然后消耗当前坐标。 设备类型 MotionEvent内容的解释根据设备的源类别而有很大的不同。 一致性保证 运动事件始终作为事件的一致性流传递给视图。什么构成一个一致的流取决于设备的类型。对于触摸事件来说，一致性意味着指针一次一个地下移，一个一个地移动，然后一次一个地移动或取消。 2. 静态内部类MotionEvent.PointerCoords ：传递对象的指针坐标。3. 静态内部类MotionEvent.PointerProperties ：传递对象的指针属性。4. 主要常量ACTION_MASK : 作为动作本身的动作代码部分的位掩码 常量 getActionMasked() 非触摸事件，所以它被传递给 onGenericMotionEvent(MotionEvent) ACTION_BUTTON_PRESS 按钮已被按下。常量值：11（0x0000000b） ACTION_BUTTON_RELEASE 一个按钮已被释放。常量值：12（0x0000000c） ACTION_HOVER_ENTER 指针未关闭，但已经进入窗口或视图的边界。常量值：9（0x00000009） ACTION_HOVER_EXIT 指针没有关闭，但已经退出了窗口或视图的边界。常量值：10（0x0000000a） ACTION_HOVER_MOVE 发生了改变，但指针没有下降（不像ACTION_MOVE）常量值：7（0x00000007） ACTION_SCROLL 运动事件包含相对垂直和/或水平滚动偏移。常量值：8（0x00000008） 常量 getActionMasked() 使用getButtonState()检索按钮状态 ACTION_DOWN 按下的手势已经开始，运动包含初始起始位置。常量值：0（0x00000000） ACTION_MOVE 在按下手势期间（在ACTION_DOWN和之间ACTION_UP）发生改变。常数值：2（0x00000002） ACTION_UP 按下的手势已经完成，常数值 : 1 (0x00000001) ACTION_CANCEL 当前手势已被中止。如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个ACTION_CANCEL事件。常数值 : 3 (0x00000003) ACTION_OUTSIDE 移动发生在UI元素的正常界限之外。注意：由于任何事件的位置都将超出视图层次结构的范围，因此默认情况下不会将其分派给ViewGroup的任何子项。因此，ACTION_OUTSIDE的移动应该以根View或适当的方式Window.Callback （例如Activity或Dialog）来处理。常量值：4（0x00000004） ACTION_POINTER_DOWN 非主指针已关闭 ACTION_POINTER_UP 非主指针已经上升。 ACTION_POINTER_INDEX_MASK 代表指针索引的动作代码中的位，与 ACTION_POINTER_DOWN和一起使用 ACTION_POINTER_UP。 非主指针已经上升。常量值：1（0x00000001） ACTION_POINTER_INDEX_SHIFT 按照定义，保存指针索引的动作位的位移ACTION_POINTER_INDEX_MASK 5. 主要公共方法 公共方法 说明 getAction() 返回正在执行的操作。 getActionButton() 获取在按下或释放操作期间哪个按钮已被修改。 findPointerIndex(int pointerId) 给定一个指针标识符，在事件中找到它的数据索引 getActionIndex() 对于ACTION_POINTER_DOWN或ACTION_POINTER_UP 作为返回getActionMasked()，这将返回关联的指针索引。 getActionMasked() 返回正在执行的被屏蔽的操作，没有指针索引信息。 getDeviceId() 获取此事件来自的设备的ID。 getDownTime() 返回用户最初按下时启动位置事件流的时间（以毫秒为单位）。 getFlags() 获取运动事件标志。 getHistoricalEventTime(int pos) 返回在此事件和上一个事件之间发生历史移动的uptimeMillis()时间。 getHistoricalOrientation(int pointerIndex, int pos) 根据getOrientation(int)在此事件与给定指针的上一个事件之间发生的历史方向坐标返回历史方向坐标。 setSource(int source) 修改事件的来源。 setLocation(float x, float y) 设置这个事件的位置。 offsetLocation(float deltaX, float deltaY) 调整此事件的位置。 setAction(int action) 设置此事件的操作。 recycle() 回收MotionEvent，以供稍后调用者重新使用。 getYPrecision() 返回正在报告的Y坐标的精度。 getY(int pointerIndex) 返回给定指针索引的此事件的Y坐标 （用于getPointerId(int)查找此索引的指针标识符）。 getY() getY(int) 为第一个指针索引（可能是一个任意的指针标识符）。 getRawY() 返回此事件的原始Y坐标。 getPressure(int pointerIndex) 返回给定指针索引的此事件的当前压力 （用于getPointerId(int)查找此索引的指针标识符）。 getSize(int pointerIndex) 返回给定指针索引的近似大小的缩放值 （用于getPointerId(int)查找此索引的指针标识符）。 getPointerCount() 包含在这个事件中的数据指针的数量。 getOrientation(int pointerIndex) 返回给定指针索引（用于getPointerId(int)查找此索引的指针标识符）的触摸区域和工具区域的方向，从垂直方向顺时针旋转弧度。 getSource() 获取事件的来源。 6. 事件坐标的含义 getX()和getY()：由这两个函数获得的x,y值是相对的坐标值，相对于消费这个事件的视图的左上点的坐标。 getRawX()和getRawY():有这两个函数获得的x,y值是绝对坐标，是相对于屏幕的。 相对坐标与绝对坐标 7. 事件类型123456789int action = MotionEventCompat.getActionMasked(event); switch(action) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: break; case MotionEvent.ACTION_UP: break; &#125; 8. Pointer为了可以表示多个触摸点的动作，MotionEvent中引入了Pointer的概念，一个pointer就代表一个触摸点，每个pointer都有自己的事件类型，也有自己的横轴坐标值。一个MotionEvent对象中可能会存储多个pointer的相关信息，每个pointer都会有一个自己的id和index。pointer的id在整个事件流中是不会发生变化的，但是index会发生变化。 MotionEvent类中的很多方法都是可以传入一个int值作为参数的，其实传入的就是pointer的index值。比如getX(pointerIndex)和getY(pointerIndex)，此时，它们返回的就是index所代表的触摸点相关事件坐标值。 由于pointer的index值在不同的MotionEvent对象中会发生变化，但是id值却不会变化。所以，当我们要记录一个触摸点的事件流时，就只需要保存其id,然后使用findPointerIndex(int)来获得其index值，然后再获得其他信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243private final static int INVALID_ID = -1; private int mActivePointerId = INVALID_ID; private int mSecondaryPointerId = INVALID_ID; private float mPrimaryLastX = -1; private float mPrimaryLastY = -1; private float mSecondaryLastX = -1; private float mSecondaryLastY = -1; public boolean onTouchEvent(MotionEvent event) &#123; int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; case MotionEvent.ACTION_DOWN: int index = event.getActionIndex(); mActivePointerId = event.getPointerId(index); mPrimaryLastX = MotionEventCompat.getX(event,index); mPrimaryLastY = MotionEventCompat.getY(event,index); break; case MotionEvent.ACTION_POINTER_DOWN: int index = event.getActionIndex(); mSecondaryPointerId = event.getPointerId(index); mSecondaryLastX = event.getX(index); mSecondaryLastY = event.getY(index); break; case MotionEvent.ACTION_MOVE: int index = event.findPointerIndex(mActivePointerId); int secondaryIndex = MotionEventCompat.findPointerIndex(event,mSecondaryPointerId); final float x = MotionEventCompat.getX(event,index); final float y = MotionEventCompat.getY(event,index); final float secondX = MotionEventCompat.getX(event,secondaryIndex); final float secondY = MotionEventCompat.getY(event,secondaryIndex); break; case MotionEvent.ACTION_POINTER_UP: xxxxxx(涉及pointer id的转换，之后的文章会讲解) break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mActivePointerId = INVALID_ID; mPrimaryLastX =-1; mPrimaryLastY = -1; break; &#125; return true; &#125; 除了pointer的概念，MotionEvent还引入了两个事件类型： ACTION_POINTER_DOWN:代表用户又使用一个手指触摸到屏幕上，也就是说，在已经有一个触摸点的情况下，有新出现了一个触摸点。 ACTION_POINTER_UP:代表用户的一个手指离开了触摸屏，但是还有其他手指还在触摸屏上。也就是说，在多个触摸点存在的情况下，其中一个触摸点消失了。它与ACTION_UP的区别就是，它是在多个触摸点中的一个触摸点消失时（此时，还有触摸点存在，也就是说用户还有手指触摸屏幕）产生，而ACTION_UP可以说是最后一个触摸点消失时产生。 那么，用户先两个手指先后接触屏幕，同时滑动，然后在先后离开这一套动作所产生的事件流是什么样的呢？它所产生的事件流如下： 先产生一个ACTION_DOWN事件，代表用户的第一个手指接触到了屏幕。 再产生一个ACTION_POINTER_DOWN事件，代表用户的第二个手指接触到了屏幕。很多的ACTION_MOVE事件，但是在这些MotionEvent对象中，都保存着两个触摸点滑动的信息 一个ACTION_POINTER_UP事件，代表用户的一个手指离开了屏幕。如果用户剩下的手指还在滑动时，就会产生很多ACTION_MOVE事件。 一个ACTION_UP事件，代表用户的最后一个手指离开了屏幕 9. getAction 和 getActionMasked一个MotionEvent对象中可以包含多个触摸点的事件。当MotionEvent对象只包含一个触摸点的事件时，上边两个函数的结果是相同的，但是当包含多个触摸点时，二者的结果就不同啦。getAction获得的int值是由pointer的index值和事件类型值组合而成的，而getActionWithMasked则只返回事件的类型值 举个例子（注:假设了int中不同位所代表的含义，可能不是例子所中的前8位代表id,后8位代表事件类型）: 123getAction() returns 0x0105.getActionMasked() will return 0x0005其中0x0100就是pointer的index值。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 使用频率较少的控件]]></title>
    <url>%2FAndroid%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87%E8%BE%83%E5%B0%91%E7%9A%84%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[控件了解 控件1.CheckedTextView - 列表文字选择 参考：http://blog.csdn.net/zouchengxufei/article/details/51029489 2.QuickContactBadge - 联系人快捷标识3.Space - 用于填充View组件中的间隙 4.SearchView - 原生的搜索框控件 参考：http://blog.csdn.net/airsaid/article/details/51087226参考： https://www.cnblogs.com/LT5505/p/5534357.html 5.ExpandableListView - 显示二级节点的ListView 参考：https://www.cnblogs.com/hebao0514/p/4760939.html 6.Chronometer - 一个计时器,用来记录用户进行某项操作所消耗的时间 参考：https://www.cnblogs.com/xianfeng-zhang/p/8110053.html参考：http://blog.csdn.net/mengweiqi33/article/details/76903986 6.1 CountDownTimer - 倒计时 https://www.jianshu.com/p/3c10432a4726 7.TextClock - 显示时间 参考：http://blog.csdn.net/EthanCo/article/details/72829656 8.ImageSwitcher - 图像切换器 参考：http://blog.csdn.net/android_gjw/article/details/51759499参考：https://www.cnblogs.com/scetopcsa/p/3695272.html 9.AdapterViewFlipper - 显示上一个、下一个view 参考：http://blog.csdn.net/yan8024/article/details/46879867 10.StackView - 卡片堆叠 参考：http://blog.csdn.net/qq_16628781/article/details/49308355参考：http://blog.csdn.net/Small_Lee/article/details/51544975 11.TextSwitcher - 文字切换 参考：http://blog.csdn.net/bsmmaoshenbo/article/details/61198996参考：http://blog.csdn.net/u011418943/article/details/51871482 12.ViewAnimator - View视图切换 参考：http://www.jizhuomi.com/android/course/312.html参考：http://blog.csdn.net/lgy64422575/article/details/50255657 13.ViewFlipper - 循环滚动的效果 参考：http://blog.csdn.net/u011150924/article/details/60867499参考：http://blog.csdn.net/qq_31715429/article/details/50972357 14.include、merge 、ViewStub - 布局优化 参考：http://blog.csdn.net/xyz_lmn/article/details/14524567 15.SurfaceView与TextureView 参考：http://blog.csdn.net/hejjunlin/article/details/58582919 16.NumberPicker - 数字选择器 参考：https://www.cnblogs.com/xiaofeixiang/p/4125560.html参考：https://www.2cto.com/kf/201407/320686.html 17.TextInputLayout - TextView容器 参考：http://blog.csdn.net/q4878802/article/details/49780691参考：https://segmentfault.com/a/1190000009282096 18.GridView - 宫格布局 http://blog.csdn.net/sinat_25926481/article/details/70880047 18.GridLayout - 网格布局，平均分布 参考：http://blog.csdn.net/sunsteam/article/details/69486658行划分：http://blog.csdn.net/huangxiaominglipeng/article/details/17448045 具体示例：http://blog.csdn.net/yisizhu/article/details/51753003主体、cell元素：http://blog.csdn.net/k316378085/article/details/52316633 区分 GridView 与 GridLayout 参考：http://blog.csdn.net/studyboyjlu4/article/details/18192677 GridView是一种适配器布局,它的继承关系是ViewGroup–&gt;AdapterView–&gt;AbsListView–&gt;GridView，他是从一个adapter中取出内容填充到GridView中的每一个子View。 GridLayout是一个布局，它大大简化了对复杂布局的处理，提高了性能。他直接继承自ViewGroup，和LinearLayout这种是类似的。 区分 GridView 与 GridLayout 与 TableLayout 参考：http://blog.csdn.net/shareus/article/details/52063761]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kit]]></title>
    <url>%2FKit%2F</url>
    <content type="text"><![CDATA[工具 常用总结0. Android屏幕适配 参考：https://www.jianshu.com/p/ec5a1a30694b 1. String 类的replace方法替换字符串“无效”、“不起作用”原因l 参考： http://blog.csdn.net/huqingpeng321/article/details/52915324 没有特殊字符的话，则返回的是同一个对象的引用；若出现特殊字符，则new一个新的对象,替换之前的对象。 实际使用：1234567891011121314151617// 存储待遍历img地址List&lt;String&gt; array = MatchHtmlValue.match(tempHtml,&quot;img&quot;, &quot;src&quot;);StringBuilder builder = new StringBuilder();// 执行遍历for (int i = 0; i &lt; array.size(); i++) &#123; String oldHtmlVal = array.get(i); String newHtmlVal = MyCommon.URL_BASE_IMG + array.get(i); // ！！！ 此处执行替换时必须重新生成一个新的String串 builder.append(tempHtml.replace(oldHtmlVal,newHtmlVal));&#125;// 字符串拼接html.append(&quot;联系电话为：&quot; + tel);html.append(builder); *//*html.append(getServerInfo.getData().getDesc().replace(&quot;/public/upload/20171213/31d2fd1460e2471bd0fbbb59689c9c50.png&quot;,&quot;http://192.168.31.178:8088/public/upload/20171213/31d2fd1460e2471bd0fbbb59689c9c50.png&quot;));*//*Log.e(TAG, &quot;ヽ(｀Д´)ﾉ -&gt; onSuccess tel : &quot; + tel + &quot;; \n html : &quot; + html);htmlStr = html.toString();CommonWebViewSets.setHtmlCode(mServerWebView,htmlStr); 2. 通过正则表达式获取html标签中的指定属性值 参考：http://blog.csdn.net/andybbc/article/details/50556668 1234567891011121314151617181920212223242526public class MatchHtmlElementAttrValue &#123; /** * 获取指定HTML标签的指定属性的值 * @param source 要匹配的源文本 * @param element 标签名称 * @param attr 标签的属性名称 * @return 属性值列表 */ public static List&lt;String&gt; match(String source, String element, String attr) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); String reg = &quot;&lt;&quot; + element + &quot;[^&lt;&gt;]*?\\s&quot; + attr + &quot;=[&apos;\&quot;]?(.*?)[&apos;\&quot;]?\\s.*?&gt;&quot;; Matcher m = Pattern.compile(reg).matcher(source); while (m.find()) &#123; String r = m.group(1); result.add(r); &#125; return result; &#125; public static void main(String[] args) &#123; String source = &quot;&lt;a title=中国体育报 href=&apos;&apos;&gt;aaa&lt;/a&gt;&lt;a title=&apos;北京日报&apos; href=&apos;&apos;&gt;bbb&lt;/a&gt;&quot;; List&lt;String&gt; list = match(source, &quot;a&quot;, &quot;title&quot;); System.out.println(list); &#125; &#125; 3.Android 输入框与键盘之间的关系为了不让键盘阻挡输入框，添加此配置 123&lt;activity android:name="..." android:windowSoftInputMode="adjustResize" /&gt; 4. TextView跑马灯效果 在java文件中作出的修改 获取当前控件，将当前控件设置为： 12// 不设置这个属性,字体不会开始滚动tv.setSelected(true); 在xml文件中作出的修改 1234567891011121314&lt;TextView android:id="@+id/myTextView" android:layout_width="50dp" android:layout_height="wrap_content" android:layout_centerInParent="true" android:ellipsize="marquee" android:focusable="true" android:marqueeRepeatLimit="marquee_forever" android:singleLine="true" android:text="文本区域" android:textColor="@android:color/black" &gt; &lt;/TextView&gt; 5. 账户相关属性正则表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * 账户相关属性验证工具 * */public class AccountValidatorUtil &#123; /** * 正则表达式：验证用户名 */ public static final String REGEX_USERNAME = "^[a-zA-Z]\\w&#123;5,20&#125;$"; /** * 正则表达式：验证密码 */ public static final String REGEX_PASSWORD = "^[a-zA-Z0-9]&#123;6,20&#125;$"; /** * 正则表达式：验证手机号 */ public static final String REGEX_MOBILE = "^((17[0-9])|(14[0-9])|(13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d&#123;8&#125;$"; /** * 正则表达式：验证邮箱 */ public static final String REGEX_EMAIL = "^([a-z0-9A-Z]+[-|\\.]?)+[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\.)+[a-zA-Z]&#123;2,&#125;$"; /** * 正则表达式：验证汉字 */ public static final String REGEX_CHINESE = "^[\u4e00-\u9fa5],&#123;0,&#125;$"; /** * 正则表达式：验证身份证 */ public static final String REGEX_ID_CARD = "(^\\d&#123;18&#125;$)|(^\\d&#123;15&#125;$)"; /** * 正则表达式：验证URL */ public static final String REGEX_URL = "http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?"; /** * 正则表达式：验证IP地址 */ public static final String REGEX_IP_ADDR = "(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d)"; /** * 校验用户名 * * @param username * @return 校验通过返回true，否则返回false */ public static boolean isUsername(String username) &#123; return Pattern.matches(REGEX_USERNAME, username); &#125; /** * 校验密码 * * @param password * @return 校验通过返回true，否则返回false */ public static boolean isPassword(String password) &#123; return Pattern.matches(REGEX_PASSWORD, password); &#125; /** * 校验手机号 * * @param mobile * @return 校验通过返回true，否则返回false */ public static boolean isMobile(String mobile) &#123; return Pattern.matches(REGEX_MOBILE, mobile); &#125; /** * 校验邮箱 * * @param email * @return 校验通过返回true，否则返回false */ public static boolean isEmail(String email) &#123; return Pattern.matches(REGEX_EMAIL, email); &#125; /** * 校验汉字 * * @param chinese * @return 校验通过返回true，否则返回false */ public static boolean isChinese(String chinese) &#123; return Pattern.matches(REGEX_CHINESE, chinese); &#125; /** * 校验身份证 * * @param idCard * @return 校验通过返回true，否则返回false */ public static boolean isIDCard(String idCard) &#123; return Pattern.matches(REGEX_ID_CARD, idCard); &#125; /** * 校验URL * * @param url * @return 校验通过返回true，否则返回false */ public static boolean isUrl(String url) &#123; return Pattern.matches(REGEX_URL, url); &#125; /** * 校验IP地址 * * @param ipAddr * @return */ public static boolean isIPAddr(String ipAddr) &#123; return Pattern.matches(REGEX_IP_ADDR, ipAddr); &#125;&#125; 6. 将多次Toast弹出改为一次弹出1234567891011121314151617public class Util &#123; private static Toast toast; public static void showToast(Context context, String content) &#123; if (toast == null) &#123; toast = Toast.makeText(context, content, Toast.LENGTH_SHORT); &#125; else &#123; toast.setText(content); &#125; toast.show(); &#125;&#125; 调用的： 1Util.showToast(context, "things happened"); 7. 数据 转 json123//生成Json对象Gson gson = new Gson();String valueDateJson = gson.toJson(dataBean.getData()); 7. 关于 时间 与 时间戳7.1 js中时间戳转换为时间 参考：https://www.cnblogs.com/sufei/archive/2012/12/03/2799480.html参考：https://www.cnblogs.com/mr-wuxiansheng/p/6296646.html 12345678910111213function getLocalTime(nS) &#123; return new Date(parseInt(nS) * 1000);&#125;function formatDate(now) &#123; var year = now.getFullYear(), month = now.getMonth() + 1, date = now.getDate(); return year + "-" + month + "-" + date;&#125;console.log(formatDate(getLocalTime(strData[i].addtime))); 原始时间戳（示例）：1516165200转换为时间（示例）：2018-01-17 7.2 处理后的时间转换为时间戳12345678strNew[0] = year + "-" + month + "-" + day;Date date = null;try &#123; date = new SimpleDateFormat("yyyy-MM-dd").parse(strNew[0]);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125;unixTimestamp = date.getTime() / 1000; 关键： parse() 得到的时间：2018-01-17处理后的时间戳1：Wed Jan 17 00:00:00 GMT-05:00 2018处理后的时间戳2：1516165200 7.3 java中时间戳与时间格式的转换1234567891011/* * 将时间转换为时间戳 */ public static String dateToStamp(String s) throws ParseException&#123; String res; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = simpleDateFormat.parse(s); long ts = date.getTime(); res = String.valueOf(ts); return res;&#125; 1234567891011/* * 将时间戳转换为时间 */public static String stampToDate(String s)&#123; String res; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); long lt = new Long(s); Date date = new Date(lt); res = simpleDateFormat.format(date); return res;&#125; 8. Java - Collections 集合操作的静态多态方法，是一个工具类。 参考：http://blog.csdn.net/qq924862077/article/details/48022135 9. String／StringBuffer／StringBuilder它们之间的区别 参考：http://mp.weixin.qq.com/s/U1aIOERz7hqeC8JUH-fI6A 为什么要引入其它两种字符串处理类?提高字符串连接效率。在大部分情况下，字符串的拼接速度为：StringBuilder &gt; StringBuffer &gt; String String 不可变。因此每次对其操作改变其变量值，其实是生成一个新的对象，然后将变量引用指向新对象，因此速度慢。 线程安全。 存放在常量池，在编译期已经被确定了。new String()不是字符串常量，它有自己的地址空间，存放在堆空间 StringBuffer 可变。对其操作即直接操作对象指向的引用，无需产生新对象，速度很快； 线程安全。在维护多线程的同步等也会消耗一点性能。 堆空间 StringBuilder 可变。是jdk5之后新增的，其用法与StringBuffer完全一致， 非线程安全。在单线程中最佳，因为其不需要维护线程的安全，因此是最快的。 堆空间 10. AS 编译时提示error please select android sdk出现问题的界面： 解决方法：在File-&gt; Project Structure-&gt;app的属性中设置Compile Sdk Version即可。 11. 打开应用时出现“你的手机上未安装应用程序”–实际上该应用已经安装123456&lt;activity ··· android:exported=&quot;false&quot; &gt; ···&lt;/activity&gt; 问题就是出在：android:exported=&quot;false&quot;。该属性的意思 “是否允许activity被其它程序调用”，默认为 true。 12. Git 提示fatal: remote origin already exists 错误解决办法参考：http://blog.csdn.net/top_code/article/details/50381432 解决办法： 1、先删除远程 Git 仓库 $ git remote rm origin 2、再添加远程 Git 仓库 $ git remote add origin xxx 13. Http结构图 14. Activity生命周期图官方： 15. 修改App的包名http://blog.csdn.net/mr_zdd/article/details/78739485 16. App基本UI框架UI项目主框架： TabLayout + ViewPager效果图 0. 变量 12345TabLayout mTabLayout;private List&lt;String&gt; titles = new ArrayList&lt;&gt;();private List&lt;Fragment&gt; mFragmentList = new ArrayList&lt;&gt;();private FragmentAdapter mFragmentAdapter; 1. 自定义TabLayout的TabItem布局文件：item_tab_layout_layout 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.zhy.autolayout.AutoLinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="129px" android:orientation="vertical"&gt; &lt;ImageView android:id="@+id/img" android:layout_width="47px" android:layout_height="47px" android:layout_gravity="center" android:layout_marginTop="24px"/&gt; &lt;TextView android:id="@+id/text_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="10px" android:gravity="center|top" android:text="通知公告" android:textColor="@color/bottom_text_color_selector" android:textSize="@dimen/text_content_text_size"/&gt;&lt;/com.zhy.autolayout.AutoLinearLayout&gt; 2. 主界面xml布局文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.zhy.autolayout.AutoRelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/container" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" android:orientation="vertical"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/main_view_pager" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_above="@+id/line_main"/&gt; &lt;View android:layout_above="@+id/navigation_01" android:id="@+id/line_main" android:layout_width="match_parent" android:layout_height="1px" android:background="#cacaca"/&gt; &lt;android.support.design.widget.TabLayout android:layout_alignParentBottom="true" android:id="@+id/navigation_01" android:layout_width="match_parent" android:layout_height="129px"/&gt;&lt;/com.zhy.autolayout.AutoRelativeLayout&gt; 3. 选中样式配置 xml文件 3.1 选中字体样式配置： bottom_text_color_selector 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:color="@color/colorPrimary" android:state_selected="true"/&gt; &lt;item android:color="@color/textColor" android:state_selected="false"/&gt;&lt;/selector&gt; 3.2 选中图片样式配置： notice_checked_selector 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_selected="true" android:drawable="@drawable/bottom_notice_check"/&gt; &lt;item android:state_selected="false" android:drawable="@drawable/bottom_notice_uncheck"/&gt;&lt;/selector&gt;xx 4. 适配器：FragmentAdapter 1234567891011121314151617181920212223242526public class FragmentAdapter extends FragmentStatePagerAdapter &#123; private List&lt;String&gt; mStringList ; private List&lt;Fragment&gt; mFragmentList ; public FragmentAdapter(FragmentManager fm, List&lt;String&gt; mStrings, List&lt;Fragment&gt; mFragments) &#123; super(fm); this.mStringList = mStrings; this.mFragmentList = mFragments; &#125; @Override public Fragment getItem(int position) &#123; return mFragmentList.get(position); &#125; @Override public int getCount() &#123; return mFragmentList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mStringList.get(position); &#125;&#125; 5. Activity中UI控件配置 123456789101112131415161718192021222324252627282930313233private void initAdapter() &#123; titles.add("通知公告"); titles.add("临时任务"); titles.add("日常巡检"); titles.add("设置"); mFragmentList.add(new NoticeFragment()); mFragmentList.add(new TempTaskFragment()); mFragmentList.add(new CheckUsuallyFragment()); mFragmentList.add(new SettingFragment()); int[] imgs = new int[]&#123;R.drawable.notice_checked_selector,R.drawable.task_checked_selector,R.drawable.check_checked_selector,R.drawable.setting_checked_selector&#125;; mFragmentAdapter = new FragmentAdapter(getSupportFragmentManager(),titles,mFragmentList); mMainViewPager.setAdapter(mFragmentAdapter); mTabLayout.setupWithViewPager(mMainViewPager); mTabLayout.setSelectedTabIndicatorHeight(0); for (int i = 0; i &lt; titles.size(); i++) &#123; //获得到对应位置的Tab TabLayout.Tab itemTab = mTabLayout.getTabAt(i); if (itemTab != null) &#123; //设置自定义的标题 itemTab.setCustomView(R.layout.item_tab_layout_layout); TextView textView = (TextView) itemTab.getCustomView().findViewById(R.id.text_title); textView.setText(titles.get(i)); ImageView imageView= (ImageView) itemTab.getCustomView().findViewById(R.id.img); imageView.setImageResource(imgs[i]); &#125; &#125; mTabLayout.getTabAt(0).getCustomView().setSelected(true);&#125; 17. 转义字符\n 回车换行\t 横向跳到下一制表位置 \v 竖向跳格\b 退格\r 回车\f 走纸换页\ 反斜线符”\”\’ 单引号符\ddd 1～3位八进制数所代表的字符\xhh 1～2位十六进制数所代表的字符 空格的ASC是32，转换为16进制是x20，使用转义字符为 \x20 18. 安装apk时INSTALL_FAILED_NO_MATCHING_ABIS 参考：https://stackoverflow.com/questions/24572052/install-failed-no-matching-abis-when-install-apk 这个错误是由于使用了native libraries 。该native libraries 不支持当前的cpu的体系结构。 解决方式，在app的build.gradle文件中： 12345678splits &#123; abi &#123; enable true reset() include &apos;x86&apos;, &apos;armeabi-v7a&apos; universalApk true &#125;&#125; 修改依据： 19. 线性表、链表、哈希表数组、链表、树（二叉树、平衡树）、哈希表被称为通用数据结构。之所以称之为通用数据结构是因为它们通过关键字的值来存储、查找数据。 具体使用哪一种数据结构，可以参考下图： 上体育课的时候，老师说：你们站一队，每个人记住自己是第几个，我喊到几，那个人就举手，这就是数组。 老是说，你们每个人记住自己前面的人和后面的人，然后老师只知道第一人是谁。 然后你们各自由活动，老是要找某一个人，是不是每次都是从第一个开始往自己身后的人开始传达？这就是链表。 老师说： 大家1，2，3，4报数，凡是报1，为1队，凡是报2的为2队。。。。 而这个4就相当于预定义好的桶的个数。这就是散列（哈希）。 程序中，存放指定的数据最常用的数据结构有两种：数组和链表。 数组和链表的区别：： 数组是将元素在内存中连续存放。链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。 数组必须事先定义固定的长度，不能适应数据动态的增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费； 链表动态地进行存储分配，可以适应数据动态地增减的情况。 （静态）数组从栈中分配空间，对于程序员方便快速，但是自由度小； 链表从堆中分配空间，自由度大但是申请管理比较麻烦。 但是数组和链表在存储数据方面到底谁好？根据数组和链表的特性，分两种情况讨论： 1，当进行数据查询时，数组可以直接通过下标迅速访问数组中的元素。而链表则需要从第一个元素开始一直找到需要的元素位置，显然，数组的查询效率会比链表的高。 2，当进行增加或删除元素时，在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样，如果想删除一个元素，需要移动大量去填掉被移动的元素，而链表只需改动元素中的指针即可实现增加或删除元素。 那么哈希表，是既能具备数组的快速查询的优点，又能融合链表方便快捷的增加删除元素的优势。 哈希表 参考：https://blog.csdn.net/xiaoxik/article/details/74926090参考：https://www.cnblogs.com/s-b-b/p/6208565.html Hash table是指针的数组或者说向量表。哈希表(Hash Table)也叫散列表，是根据关键码值（Key Value）而直接进行访问的数据结构。它通过把关键码值映射到哈希表中的一个位置来访问记录，以加快查找的速度。这个映射函数就做散列函数，存放记录的数组叫做散列表。 一张图类比描述哈希表： 最典型的的例子就是字典，如果我想要获取“按”字详细信息，我肯定会去根据拼音an去查找 拼音索引（当然也可以是偏旁索引），我们首先去查an在字典的位置，查了一下得到安，结果如下。这过程就是键码映射，在公式里面，就是通过key去查找f(key)。其中，按就是关键字（key），f（）就是字典索引，也就是哈希函数，查到的页码4就是哈希值。 20. Java中常见数据结构：list与map 20.1. Collection（单列集合）20.1.1 （有序、可重复）List ArrayList：底层数据结构是数组,查询快,增删慢；线程不安全,效率高 Vector：底层数据结构是数组,查询快,增删慢；线程安全,效率低 LinkedList：底层数据结构是链表,查询慢,增删快结构是链表,查询慢,增删快；线程不安全,效率高 20.1.12 (无序,唯一)Set HashSet 底层数据结构是哈希表。 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 最终：自动生成hashCode()和equals()即可 LinkedHashSet： 底层数据结构由**链表**和**哈希表**组成。 由链表保证元素有序。 由哈希表保证元素唯一。 TreeSet 底层数据结构是红黑树。(是一种自平衡的二叉树) 20.2 Map(双列集合) Map集合的数据结构仅仅针对键有效，与值无关。 存储的是键值对形式的元素，键唯一，值可重复。 HashMap 底层数据结构是哈希表。线程不安全，效率高 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 LinkedHashMap 底层数据结构由链表和哈希表组成。 由链表保证元素有序。 由哈希表保证元素唯一。 21. Java中的 强引用、软引用、弱引用、虚引用 引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 在内存不足时 对象缓存 内存不足时终止 弱引用 在垃圾回收时 对象缓存 gc运行后终止 虚引用 Unknown Unknown Unknown 1、强引用（StrongReference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下： Object o=new Object(); // 强引用 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。 12345678private transient Object[] elementData; public void clear() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。 2、软引用（SoftReference） 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 12String str=new String(&quot;abc&quot;); // 强引用 SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str); // 软引用 当内存不足时，等价于： 1234If(JVM.内存不足()) &#123; str = null; // 转换为软引用 System.gc(); // 垃圾回收器进行回收 &#125; 如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。这时候就可以使用软引用 12345678Browser prev = new Browser(); // 获取页面进行浏览 SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用 if(sr.get()!=null)&#123; rev = (Browser) sr.get(); // 还没有被回收器回收，直接获取 &#125;else&#123; prev = new Browser(); // 由于内存吃紧，所以对软引用的对象回收了 sr = new SoftReference(prev); // 重新构建 &#125; 3、弱引用（WeakReference） 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。 123String str=new String(&quot;abc&quot;); WeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str); str=null; 下面的代码会让str再次变为一个强引用： 1String abc = abcWeakRef.get(); 4、虚引用（PhantomReference）与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 22. int、Integer有什么区别Java是面向对象的编程语言，一切都是对象，但是为了编程的方便还是引入了基本数据类型，为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型。 12原始类型：boolean，char，byte，short，int，long，float，double包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double int：属于简单类型，不存在“引用”这个概念；其数据是存储在栈空间中Integer：属于继承自Object的类，是按照java存储对象的内存模型来存储的；引用存储在栈中，对象数据存储在堆中；基于这个原理不同，所以在进行参数传递的时候，int是值传递，其在栈中的数据不可变； 而Integer类型是引用传递，引用指向的内存地址中的数据是可以变化的，但是栈中的引用是不变的。 int的初始化值是0 ，Integer初始化的值是null。，你不能把null值赋给int。 泛型支持Integer，并不支持int 。如： ArrayList list = new ArrayList()你不能在泛型中写int; 行为不一样 12int a =10; Integer b= new Integer(10); 在方法调用中：a是基本类型，并没有什么方法可言；因为方法是类的特性。b有很多方法，因为方法是对象中定义的；一些转换操作，如转为字符串等 23 Java中的 位运算符 详解与（ &amp; ）、非（ ~ ）、或（ | ）、异或（ ^ ） 参考：https://blog.csdn.net/vebasan/article/details/6193916 位运算符 主要针对 二进制 ，它包括了：“与”、“非”、“或”、“异或”。从表面上看似乎有点像逻辑运算符，但 逻辑运算符 是 针对两个关系运算符 来进行逻辑运算，而位运算符主要针对 两个二进制数 的位进行逻辑运算。 1. 与 （ &amp; ）运算符两个操作数中 位都为1，结果才为1，否则结果为0 如 ：129 &amp; 128，结果为 : 128 129转换成二进制就是10000001，128转换成二进制就是10000000。 根据与运算符的运算规律，只有两个位都是1，结果才是1，可以知道结果就是10000000，即128. 2. 或 （ | ） 运算符两个位 只要有一个为1，那么结果就是1，否则就为0 如：128 | 129 ，结果是：129 129转换成二进制就是10000001，128转换成二进制就是10000000。 根据或运算符的运算规律，只有两个位有一个是1，结果才是1，可以知道结果就是10000001，即129。 3. 非 （ ~ ） 运算符如果位为0，结果是1，如果位为1，结果是0 4. 异或 （ ^ ） 运算符两个操作数的位中，相同则结果为0，不同则结果为1。 如：15 ^ 2 , 结果是：13 15转换成二进制为 1111，2转换成二进制为0010，根据异或的运算规律，可以得出其结果为1101 即 13。 24 String的不变性如： 12String s = &quot;abcd&quot;;s = s.concat(&quot;ef&quot;); 25 targetSdkVersiontargetSdkVersion 是 Android 系统提供向前兼容的主要手段。随着 Android 系统的升级，某个系统的 API 或者模块的行为可能会发生改变，但是为了保证老 APK 的行为还是和以前兼容。只要 APK 的 targetSdkVersion 不变，即使这个 APK 安装在新 Android 系统上，其行为还是保持老的系统上的行为，这样就保证了系统对老应用的前向兼容性。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView的使用]]></title>
    <url>%2FWebView%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WebView的设置 Web相关代码块1. WebVIew的 Setting 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191/** * CommonWebViewSets WebView设置工具类 * * @author wenjia.Cheng cwj1714@163.com * @date 2017/12/29 */public class CommonWebViewSets &#123; /** * 设置URL * * @param webView 控件 * @param url url地址 */ public static void setUrl(WebView webView, String url,ProgressBar mProgressBar) &#123; initWeb(webView,mProgressBar); webView.loadUrl(url); &#125; /** * 设置html源代码，无base Url * * @param webView 控件 * @param html html源代码 */ public static void setHtmlCode(WebView webView, String html,ProgressBar mProgressBar) &#123; initWeb(webView,mProgressBar); webView.loadDataWithBaseURL(&quot;我的服务商&quot;, html, &quot;text/html&quot;, &quot;utf-8&quot;, null); &#125; /** * 设置html源代码，有base Url * * @param webView 控件 * @param baseUrl baseUrl * @param html html源代码 */ public static void setHtmlCodeBaseUrl(WebView webView, String baseUrl, String html,ProgressBar mProgressBar) &#123; initWeb(webView,mProgressBar); webView.loadDataWithBaseURL(baseUrl, html, &quot;text/html&quot;, &quot;utf-8&quot;, null); &#125; /** * @param webView 控件 */ @SuppressLint(&quot;SetJavaScriptEnabled&quot;) public static void initWeb(WebView webView, final ProgressBar mProgressBar) &#123; // 获取webview设置属性 WebSettings settings = webView.getSettings(); // 设置编码格式 settings.setDefaultTextEncodingName(&quot;utf-8&quot;); // 进行屏幕适配设置 settings.setUseWideViewPort(true); settings.setLoadWithOverviewMode(true); // 设置支持JavaScript settings.setJavaScriptEnabled(true); // 这个是给图片设置点击监听的，如果你项目需要webview中图片，点击查看大图功能，可以这么添加 // webView.addJavascriptInterface(new JavaScriptInterface(this), &quot;imagelistner&quot;); settings.setAllowContentAccess(false); settings.setAllowFileAccessFromFileURLs(false); settings.setAllowUniversalAccessFromFileURLs(false); settings.setAllowFileAccess(false); // 把html中的内容放大webview等宽的一列中 settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN); //settings.setDefaultFontSize(44); // 设置可以支持缩放 //webView.getSettings().setSupportZoom(true); // 设置出现缩放工具 //webView.getSettings().setBuiltInZoomControls(true); //webView.getSettings().setDisplayZoomControls(true); //如果不设置WebViewClient，请求会跳转系统浏览器 webView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; //该方法在Build.VERSION_CODES.LOLLIPOP以前有效，从Build.VERSION_CODES.LOLLIPOP起，建议使用shouldOverrideUrlLoading(WebView, WebResourceRequest)&#125; instead //返回false，意味着请求过程里，不管有多少次的跳转请求（即新的请求地址），均交给webView自己处理，这也是此方法的默认处理 //返回true，说明你自己想根据url，做新的跳转，比如在判断url符合条件的情况下，我想让webView加载http://ask.csdn.net/questions/178242 /*if (url.toString().contains(&quot;sina.cn&quot;))&#123; view.loadUrl(&quot;http://ask.csdn.net/questions/178242&quot;); return true; &#125;*/ return false; &#125; @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; //返回false，意味着请求过程里，不管有多少次的跳转请求（即新的请求地址），均交给webView自己处理，这也是此方法的默认处理 //返回true，说明你自己想根据url，做新的跳转，比如在判断url符合条件的情况下，我想让webView加载http://ask.csdn.net/questions/178242 /*if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; if (request.getUrl().toString().contains(&quot;sina.cn&quot;))&#123; view.loadUrl(&quot;http://ask.csdn.net/questions/178242&quot;); return true; &#125; &#125;*/ return false; &#125; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); //imgReset(view);//重置webview中img标签的图片大小 // html加载完成之后，添加监听图片的点击js函数 //addImageClickListner(view); &#125; &#125;); if (mProgressBar == null) &#123; &#125; else &#123; webView.setWebChromeClient(new WebChromeClient()&#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; // TODO 自动生成的方法存根 if(newProgress==100)&#123; mProgressBar.setVisibility(View.GONE);//加载完网页进度条消失 &#125; else&#123; mProgressBar.setVisibility(View.VISIBLE);//开始加载网页时显示进度条 mProgressBar.setProgress(newProgress);//设置进度值 &#125; &#125; &#125;); &#125; &#125; /** * 这段js函数的功能就是，遍历所有的img节点，并添加onclick函数，函数的功能是在图片点击的时候调用本地java接口并传递url过去 * * @param view view */ private static void addImageClickListner(WebView view) &#123; view.loadUrl(&quot;javascript:(function()&#123;&quot; + &quot;var objs = document.getElementsByTagName(\&quot;img\&quot;); &quot; + &quot;for(var i=0;i&lt;objs.length;i++) &quot; + &quot;&#123;&quot; + &quot; objs[i].onclick=function() &quot; + &quot; &#123; &quot; + &quot; window.imagelistner.openImage(this.src); &quot; + &quot; &#125; &quot; + &quot;&#125;&quot; + &quot;&#125;)()&quot;); &#125; /** * 对图片进行重置大小，宽度就是手机屏幕宽度，高度根据宽度比便自动缩放 **/ private static void imgReset(WebView view) &#123; view.loadUrl(&quot;javascript:(function()&#123;&quot; + &quot;var objs = document.getElementsByTagName(\&quot;img\&quot;); &quot; + &quot;for(var i=0;i&lt;objs.length;i++) &quot; + &quot;&#123;&quot; + &quot;var img = objs[i]; &quot; + &quot; img.style.maxWidth = &apos;100%&apos;; img.style.height = &apos;auto&apos;; &quot; + &quot;&#125;&quot; + &quot;&#125;)()&quot;); &#125; private static class JavaScriptInterface &#123; private Context context; public JavaScriptInterface(Context context) &#123; this.context = context; &#125; //点击图片回调方法 //必须添加注解,否则无法响应 @JavascriptInterface public void openImage(String img) &#123; Log.i(&quot;TAG&quot;, &quot;响应点击事件!&quot;); Intent intent = new Intent(); intent.putExtra(&quot;image&quot;, img); // BigImageActivity查看大图的类，自己定义就好 // intent.setClass(context, BigImageActivity.class); context.startActivity(intent); &#125; &#125;&#125; 2. WebView 不仅可以通过 URL 装载网页，也可以直接装载 HTML 代码，WebView 类有两个方法可以装载 HTML 代码:1loadData(String data, String mimeType, String encoding) 此方法在装载包含中文的 HTML 代码时会有乱码 与 1loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl) 此方法不会有乱码 参数： baseUrl: 获得相对路径的根 URL, 如果设为null, 默认值为 about:blank historyUrl: 如果HTML代码装载失败或为 null, WebView 组件会装载这个参数指定的URL. data : HTML代码 mimeType: Mime类型， 一般为 text/html encoding: HTML代码的编码， 例如： GBK, uft-8 3. 在HTML文档中设置自适应屏幕（文字）1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 4. 在Android的WebView中点击“返回按钮”时的操作123456789101112131415161718192021/** * webView监听返回按钮 * * @param keyCode 按钮码 * @param event 事件 * @return 。 */@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KeyEvent.KEYCODE_BACK)) &#123; if (web_act_view.canGoBack()) &#123; //goBack()表示返回WebView的上一页面 web_act_view.goBack(); return true; &#125; else &#123; finish(); return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 8.0/8.1 Notification的使用]]></title>
    <url>%2FAndroid%208.0%208.1%20Notification%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/rentee/article/details/78303532非常全面的参考：https://www.jianshu.com/p/d2051a785309 起因 - 设置“Notification”后，状态栏并没有任何提示最近项目中需要使用到“Notification”，这个原本在android中非常简单就能实现的功能，如今我却怎么设置都不成功，这让我颇为郁闷。 然后开始查看别人是怎么写的，但是同样并没有任何效果。然后我意识到我的系统版本时Android 8.1。设置方式已经变了。 一个前版本的例子： 1234567891011Notification.Builder builder = new Notification.Builder(this); Intent intent = new Intent(this, TraceActivity.class); Bitmap icon = BitmapFactory.decodeResource(this.getResources(), R.drawable.ic_person_pin_circle_cyan_700_24dp); //设置pendingIntent builder.setContentIntent(PendingIntent.getActivity(this, 0, intent, 0)) .setLargeIcon(icon) .setContentTitle(&quot;领队定位&quot;) .setSmallIcon(R.drawable.ic_person_pin_circle_white_18dp) .setContentText(&quot;定位服务正在运行中……&quot;); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.notify(1, builder.build()); 这样的写法运行在Android 8.0之上是没有任何效果的。 Android 8.0 Notification注意： 代码中添加了：NotificationChannel这个类。这是Android O新增的通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。 NotificationChannel是Android O新增的特性，为了兼容老代码，如果channelId为null的话，Android O会把通知归到“Other Channel”上。PS：将targetSdkVersion提到26以上的话，就必须设置channel了，不能为null。 使用到的类1. NotificationChannel官方解释为：适用于类似主题通知的集合的设置的表示形式。使用方式为： 123456// 创建自己的的NotificationChannel 参数1：id：channeId；参数2：name：自定义类别的名字，在&quot;设置界面&quot;的类别栏下回显示 name；参数3：重要等级NotificationChannel channel = new NotificationChannel(&quot;10&quot;,&quot;普通通知&quot;,NotificationManager.IMPORTANCE_DEFAULT);// NotificationManager管理器NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);// 使用channel对象mNotifyMgr.createNotificationChannel(channel); 2. NotificationManager官方解释为：通知用户发生事件的类。 这是如何告诉用户在后台发生了什么事情。 123NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);// 发出通知mNotifyMgr.notify(10, notification); 3. Notification.Builder官方解释：一个类，它表示如何使用一个持久化通知呈现给用户 初步使用实例的图解较为完整的通知示例图解 通知频道的名称：new NotificationChannel(“10”,”普通通知”,NotificationManager.IMPORTANCE_DEFAULT); 未设置颜色的样式： 添加自定义提醒12345678910111213// 添加自定义声音提醒builder.setSound(Uri.parse("path/to/sound"));// 添加自定义震动提醒// 延迟200ms后震动300ms，再延迟400ms后震动500mslong[] pattern = new long[]&#123;200,300,400,500&#125;; builder.setVibrate(pattern);// 添加自定义呼吸灯提醒，自动添加FLAG_SHOW_LIGHTSint argb = 0xffff0000; // led灯光颜色int onMs = 300; // led亮灯持续时间int offMs = 100; // led熄灯持续时间builder.setLights(argb, onMs, offMs); 一个完整的Notification 初步使用 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * android 8.0 新的Notification */@RequiresApi(api = Build.VERSION_CODES.O)private void initNotification() &#123; Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_map_cyan_700_48dp); // 创建自己的的NotificationChannel 参数1：id：channeId；参数2：name：自定义类别的名字，在&quot;设置界面&quot;的类别栏下回显示 name；参数3：重要等级 NotificationChannel channel = new NotificationChannel(&quot;10&quot;,&quot;普通通知&quot;,NotificationManager.IMPORTANCE_DEFAULT); channel.enableLights(true); channel.setLightColor(Color.RED); channel.setShowBadge(true); channel.setDescription(&quot;description&quot;); // NotificationManager管理器 NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); // 使用channel对象 mNotifyMgr.createNotificationChannel(channel); // 点击通知之后的意图 PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, TraceActivity.class), 0); PendingIntent pendingIntent2 = PendingIntent.getActivity(this, 0, new Intent(this, ChangePwdActivity.class), 0); Notification notification = new Notification.Builder(this,&quot;10&quot;) // 设置通知 右侧 大图标 .setLargeIcon(bitmap) // 设置通知的图标、app文字名称，若不设置则整个通知均为黑灰色 .setColor(getResources().getColor(R.color.Deep_Orange_700)) // 无障碍服务所需文字 .setTicker(&quot;这是什么玩意？- 国旅&quot;) // 小图标 .setSmallIcon(R.drawable.ic_person_pin_circle_cyan_700_24dp) // 标题文本 .setContentTitle(&quot;Notification Title&quot;) // 解释内容 - 子文本 .setContentText(&quot;Text &amp; Text&quot;) // 在项目app名称右侧显示的内容文字 .setSubText(&quot;Sub_tex&quot;) // 设置通知的动作数组 .setActions(new Notification.Action[]&#123;new Notification.Action(R.drawable.contact_me,&quot;进入Map&quot;,pendingIntent),new Notification.Action(R.drawable.contact_me,&quot;修改密码&quot;,pendingIntent2)&#125;) // 设置单个动作 //.setActions(new Notification.Action(R.drawable.contact_me,&quot;修改密码&quot;,pendingIntent2)) // 仅当 配合&quot;setContentIntent(pendingIntent)&quot;使用时，点击通知会自动消失 .setAutoCancel(true) // 为通知设置意图 //.setContentIntent(pendingIntent) // 同时实现：铃声/振动/灯呼吸 三种提醒方式 .setDefaults(Notification.DEFAULT_ALL) .setWhen(0) .setNumber(3) .build(); // getNotification() deprecated in API level 16 // 发出通知 mNotifyMgr.notify(10, notification);&#125; 说明 如果该通知只是起到 “通知”的作用，不希望用户点击后有相应的跳转，那么，intent、pendingIntent这几行代码可以不写，可以创建延时操作，当通知被成功 notify 后，一段时间后调用manager.cancel(notificationID)，将通知清除，此时builder.setAutoCancel()方法不写也可以。 如果通知栏下拉后，希望用户点击并有相应的跳转事件。那么，要注意跳转后，通知是否有必要继续存在。如果点击后通知消失，两种方法： 设置setAutoCancel 参数设置为 true，默认是false， 在intent事件中的如本例中的MainActivity的onCreate()方法调用 manager.cancel(notificationID)取消该通知，此ID要和创建通知的ID一致，否则通知不消失。 如果点击不消失，将setAutoCancel 参数设置为 false即可。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>版本新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三方-开源库]]></title>
    <url>%2F%E7%AC%AC%E4%B8%89%E6%96%B9-%E5%BC%80%E6%BA%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[总结 1. SwipeToLoadLayout滑动加载布局，可以实现下拉刷新与上拉加载更多。该库支持对ListView，GridView，RecyclerView，WebView，ScrollView等滑动视图的下载刷新与上拉加载更多。 1.1 配置 首先在工程的build.gradle上面添加JitPack仓库 123456allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 在模块的build.gradle上面添加依赖 123dependencies &#123; compile &apos;com.github.Aspsine:SwipeToLoadLayout:1.0.3&apos;&#125; 1.2 基本使用SwipeToLoadLayout下面定义三个子视图: SwipeRefreshHeaderLayout : 代表下拉刷新的头部 RecyclerView: 代表滑动视图主体 SwipeLoadMoreFooterLayout: 代表上拉加载更多的尾部 1234567891011121314151617181920212223&lt;com.aspsine.swipetoloadlayout.SwipeToLoadLayout android:id=&quot;@+id/swipeToLoadLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.aspsine.swipetoloadlayout.SwipeRefreshHeaderLayout android:id=&quot;@id/swipe_refresh_header&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:gravity=&quot;center&quot;/&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/swipe_target&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;com.aspsine.swipetoloadlayout.SwipeLoadMoreFooterLayout android:id=&quot;@id/swipe_load_more_footer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:gravity=&quot;center&quot; /&gt;&lt;/com.aspsine.swipetoloadlayout.SwipeToLoadLayout&gt; 这三个子视图的id必须是上面所写的，否则会出错 1.3 常用属性 app:refresh_enabled：设置是否可以下拉刷新 app:load_more_enabled：设置是否可以上拉加载更多 app:swipe_style：设置下拉刷新与上拉加载的样式，其值为classic，above，blew或scale app:refresh_trigger_offset：触发下拉刷新的偏移量，默认值是下拉刷新头部的高度 app:load_more_trigger_offset：触发上拉加载更多的偏移量，默认值是上拉加载更多的高度 app:refresh_final_drag_offset：下拉刷新最大可以拖动的偏移量 app:load_more_final_drag_offset：上拉加载更多最大可以拖动的偏移量 app:release_to_refreshing_scrolling_duration：释放下拉刷新持续滚动的时间 app:release_to_loading_more_scrolling_duration：释放上拉加载更多持续滚动的时间 app:refresh_complete_delay_duration：下拉刷新完成延迟的持续时间 app:load_more_complete_delay_duration：上拉加载更多完成延迟的持续时间 app:refresh_complete_to_default_scrolling_duration：默认完成下拉刷新持续滚动时间 app:load_more_complete_to_default_scrolling_duration： 默认完成上拉加载更多持续滚动时间 app:default_to_refreshing_scrolling_duration：默认下拉刷新滚动时间 app:default_to_loading_more_scrolling_duration：默认上拉加载更多滚动时间 1.4 自定义下拉刷新头部与上拉加载更多尾部 定义下拉刷新头部视图只需要实现SwipeRefreshTrigger, SwipeTrigger两个接口就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class RefreshHeaderView extends TextView implements SwipeRefreshTrigger, SwipeTrigger &#123; public RefreshHeaderView(Context context) &#123; super(context); &#125; public RefreshHeaderView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void onRefresh() &#123; setText("REFRESHING"); &#125; @Override public void onPrepare() &#123; setText(""); &#125; @Override public void onMove(int yScrolled, boolean isComplete, boolean automatic) &#123; if (!isComplete) &#123; if (yScrolled &gt;= getHeight()) &#123; setText("RELEASE TO REFRESH"); &#125; else &#123; setText("SWIPE TO REFRESH"); &#125; &#125; else &#123; setText("REFRESH RETURNING"); &#125; &#125; @Override public void onRelease() &#123; &#125; @Override public void onComplete() &#123; setText("COMPLETE"); &#125; @Override public void onReset() &#123; setText(""); &#125;&#125; 定义上拉加载更多尾部视图只需要实现SwipeLoadMoreTrigger, SwipeTrigger两个接口就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LoadMoreFooterView extends TextView implements SwipeTrigger, SwipeLoadMoreTrigger &#123; public LoadMoreFooterView(Context context) &#123; super(context); &#125; public LoadMoreFooterView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void onLoadMore() &#123; setText("LOADING MORE"); &#125; @Override public void onPrepare() &#123; setText(""); &#125; @Override public void onMove(int yScrolled, boolean isComplete, boolean automatic) &#123; if (!isComplete) &#123; if (yScrolled &lt;= -getHeight()) &#123; setText("RELEASE TO LOAD MORE"); &#125; else &#123; setText("SWIPE TO LOAD MORE"); &#125; &#125; else &#123; setText("LOAD MORE RETURNING"); &#125; &#125; @Override public void onRelease() &#123; setText("LOADING MORE"); &#125; @Override public void onComplete() &#123; setText("COMPLETE"); &#125; @Override public void onReset() &#123; setText(""); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下在Androidstudio中获取数字签名证书的SHA1值]]></title>
    <url>%2FMac%E4%B8%8B%E5%9C%A8Androidstudio%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E7%9A%84SHA1%E5%80%BC%2F</url>
    <content type="text"><![CDATA[总结 获取步骤 AndroidStudio切换到Terminal 输入命令：cd ~/.android 输入命令：keytool -list -v -keystore debug.keystore 输入密钥库口令: android 或者 回车 得到的结果为： 1234567891011121314151617181920212223242526272829***************** WARNING WARNING WARNING ****************** 存储在您的密钥库中的信息的完整性 ** 尚未经过验证! 为了验证其完整性, ** 必须提供密钥库口令。 ****************** WARNING WARNING WARNING *****************密钥库类型: JKS密钥库提供方: SUN您的密钥库包含 1 个条目别名: androiddebugkey创建日期: 2017-6-24条目类型: PrivateKeyEntry证书链长度: 1证书[1]:所有者: C=US, O=Android, CN=Android Debug发布者: C=US, O=Android, CN=Android Debug序列号: 1有效期开始日期: Sat Jun 24 22:49:12 CST 2017, 截止日期: Mon Jun 17 22:49:12 CST 2047证书指纹: MD5: …… SHA1: …… SHA256: …… 签名算法名称: SHA1withRSA 版本: 1*******************************************]]></content>
      <categories>
        <category>Kit</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图开发-鹰眼轨迹]]></title>
    <url>%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91-%E9%B9%B0%E7%9C%BC%E8%BD%A8%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/29ccac3e1e42 存在问题1. 后台service是否存活2. 电量与流量提示3. 坐标系说明 需求概览 围栏：到达指定位置之后通知 鹰眼轨迹：根据行踪绘制轨迹 位置提醒：到达指定位置后提醒。 一、定位方式gps定位、wifi定位、基站（SIM卡）定位 特点：1. gps定位：卫星定位，利用手机gps硬件定位，实现简单，手机本地就能实现定位，不需要和服务端进行交互。在室内或者有遮蔽物的地点无法接收到gps信号。此时利用wifi定位。 gps定位精度很高，几米到十几米，但是耗电严重。 2. wifi定位：在室外既能接收gps信号，也能接收wifi信号。wifi定位的原理是，我们在室外的时候，手机能接收到gps位置信息，也能扫描到WiFi，当手机把gps位置和WiFi传到后端服务器，WiFi和gps位置就建立了映射关系，当手机在室内无法接收到gps时，却能扫描WiFi，手机把WiFi传到服务器查询出对应的gps位置，然后进行计算可以得到位置结果（经纬度），其中映射和计算是很复杂的过程。 WiFi定位精度相对于gps差一点，但是也能到十几米、几十米，也有上百米的误差的，低耗电。 3. 基站定位：当手机无法扫描到WiFi时，只要装了sim卡，就能连接移动或联通等基站，即可用基站定位，定位原理和WiFi大致相同。基站定位需要装了sim卡，并且手机能上网。 wifi定位与基站定位统称为网络定位。 基站定位精度很差，一般都有几百米，上千米的误差。 误差其实和wifi、基站的信号覆盖半径有关，wifi覆盖半径大概100m左右，而基站的覆盖半径就到km级别了。 二、百度地图鹰眼认证认证与不认证： 权限及配额说明： http://lbsyun.baidu.com/index.php?title=android-yingyan/guide/quota 三、百度地图 鹰眼轨迹服务 的使用 参考：http://lbsyun.baidu.com/index.php?title=android-yingyan/guide/buildproject 0. 准备条件01. 获取 账号秘钥账号秘钥 ： http://lbsyun.baidu.com/apiconsole/key 02. 创建 鹰眼服务服务鹰眼服务 ：http://lbsyun.baidu.com/trace/admin/service 1. 下载相关文件http://lbsyun.baidu.com/index.php?title=android-yingyan/sdkandev-download 2. 导入库文件 倒库参考：https://www.cnblogs.com/jiy-for-you/p/6093199.html 注意：使用AndroidStudio 路径 将jar文件拷贝到工程的libs目录下，若使用鹰眼的图像存储功能，需导入bos-android-sdk-1.0.2.jar。 注意：百度鹰眼包中有okhttp，而我的本地项目中也有okhttp，所以冲突，无法构建。此处注意保留一处即可。 导入so文件方式： 1. 将so文件导入到src/main/jniLibs目录下。 2. 将so文件导入到libs目录下。，然后在build.gradle文件中添加： 12345sourceSets &#123; main &#123; jniLibs.srcDir &apos;libs&apos; &#125;&#125; jar包添加完毕之后，需要在gradle文件中进行添加： 3. 配置AndroidManifest.xml文件3.1 声明使用权限1234567891011121314151617181920212223242526&lt;!-- 这个权限用于进行网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;!-- 用于加快GPS首次定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS"/&gt; &lt;!-- 这个权限用于访问GPS定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;!-- 用于读取手机当前的状态--&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; &lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入对象存储BOS数据--&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;!-- 访问网络，网络定位需要上网--&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;!-- SD卡读取权限，用于写入对象存储BOS数据--&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt; &lt;uses-permission android:name="android.permission.READ_LOGS"/&gt; &lt;uses-permission android:name="android.permission.VIBRATE"/&gt; &lt;uses-permission android:name="android.permission.WAKE_LOCK"/&gt; &lt;uses-permission android:name="android.permission.WRITE_SETTINGS"/&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; &lt;!-- 用于Android M及以上系统，申请加入忽略电池优化白名单--&gt; &lt;uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS"/&gt; 3.2 声明&lt;service&gt;组件12345&lt;service android:name="com.baidu.trace.LBSTraceService" android:enabled="true" android:exported="true" android:process=":remote" /&gt; 3.3 设置 AccessKey1234567&lt;application …… &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;AK&quot; /&gt; //key:开发者申请的Key]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对已有文字处理]]></title>
    <url>%2FSpannableString%20%E5%AF%B9%E5%B7%B2%E6%9C%89%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/fan7983377/article/details/51776782参考：http://www.jianshu.com/p/84067ad289d2 关键类：SpannableString 一、一个实例1. 更改颜色12345SpannableString mSpanStartTitle = new SpannableString("点击红色按钮开始录音");//处理 提示文字的 颜色 样式ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor("#C62828"));mSpanStartTitle.setSpan(colorSpan, 2, 4, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mNoticeStartTitle.setText(mSpanStartTitle); 样式结果 2. 更改字体大小123456789//代操作……SpannableString mSpanNoticeTitle = new SpannableString("正在录音中……" + "\n" + "点击停止录音");//处理 提示文字的 大小 样式RelativeSizeSpan sizeSpan01 = new RelativeSizeSpan(0.7f);mSpanNoticeTitle.setSpan(sizeSpan01,7,mSpanNoticeTitle.length(),Spanned.SPAN_INCLUSIVE_INCLUSIVE);//处理 提示文字的 下标 样式SubscriptSpan subscriptSpan = new SubscriptSpan();mSpanNoticeTitle.setSpan(subscriptSpan, 7, mSpanNoticeTitle.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mNoticeRecordingTitle.setText(mSpanNoticeTitle); 样式结果 二、SpannableStringSpannableString和String一样，都是一种字符串类型，同样TextView也可以直接设置SpannableString作为显示文本，不同的是SpannableString可以通过使用其方法setSpan()方法实现字符串各种形式风格的显示,重要的是可以指定设置的区间，也就是为字符串指定下标区间内的子字符串设置格式。 三、SpannableStringBuilder应该有不少开发的小伙伴知道StringBuilder，可以使用append()方法实现字符串拼接，非常方便。同样，SpannableString中也有SpannableStringBuilder，顾名思义，就是实现对，SpannableString的一个拼接效果，同样是append()方法，可以实现各种风格效果的SpannableString拼接，非常实用。 四、重要方法 - setSpan()setSpan(Object what, int start, int end, int flags) what ：设置的格式是什么，可以是前景色、背景色也可以是可点击的文本等等；start表示需要设置格式的子字符串的起始下标end表示终了下标flags属性就有意思了，共有四种属性： Spanned.SPAN_INCLUSIVE_EXCLUSIVE 从起始下标到终了下标，包括起始下标 Spanned.SPAN_INCLUSIVE_INCLUSIVE 从起始下标到终了下标，同时包括起始下标和终了下标 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 从起始下标到终了下标，但都不包括起始下标和终了下标 Spanned.SPAN_EXCLUSIVE_INCLUSIVE 从起始下标到终了下标，包括终了下标 五、Span常用格式1. ForegroundColorSpan，为文本设置前景色，效果和TextView的setTextColor()类似2. BackgroundColorSpan，为文本设置背景色，效果和TextView的setBackground()类3. RelativeSizeSpan，设置文字相对大小，在TextView原有的文字大小的基础上，相对设置文字大小SpannableString spannableString = new SpannableString(&quot;万丈高楼平地起&quot;); RelativeSizeSpan sizeSpan04 = new RelativeSizeSpan(1.8f); spannableString.setSpan(sizeSpan04, 3, 4, Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 4. StrikethroughSpan，为文本设置中划线，也就是常说的删除线SpannableString spannableString = new SpannableString(&quot;为文字设置删除线&quot;); StrikethroughSpan strikethroughSpan = new StrikethroughSpan(); spannableString.setSpan(strikethroughSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 5. UnderlineSpan，为文本设置下划线，具体实现方法如下：SpannableString spannableString = new SpannableString(&quot;为文字设置下划线&quot;); UnderlineSpan underlineSpan = new UnderlineSpan(); spannableString.setSpan(underlineSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 6. SuperscriptSpan，设置上标，具体实现方法如下：SpannableString spannableString = new SpannableString(&quot;为文字设置上标&quot;); SuperscriptSpan superscriptSpan = new SuperscriptSpan(); spannableString.setSpan(superscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 7. SubscriptSpan，设置下标，具体实现方法如下：SpannableString spannableString = new SpannableString(&quot;为文字设置下标&quot;); SubscriptSpan subscriptSpan = new SubscriptSpan(); spannableString.setSpan(subscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); #### 8. StyleSpan，为文字设置风格（粗体、斜体），和TextView属性textStyle类似，实现方法如下： 8. SpannableString spannableString = new SpannableString(“为文字设置粗体、斜体风格”);StyleSpan styleSpan_B = new StyleSpan(Typeface.BOLD); StyleSpan styleSpan_I = new StyleSpan(Typeface.ITALIC); spannableString.setSpan(styleSpan_B, 5, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE); spannableString.setSpan(styleSpan_I, 8, 10, Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setHighlightColor(Color.parseColor(&quot;#36969696&quot;)); textView.setText(spannableString); 9. ImageSpan，设置文本图片SpannableString spannableString = new SpannableString(&quot;在文本中添加表情（表情）&quot;); Drawable drawable = getResources().getDrawable(R.mipmap.a9c); drawable.setBounds(0, 0, 42, 42); ImageSpan imageSpan = new ImageSpan(drawable); spannableString.setSpan(imageSpan, 6, 8, Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 10. ClickableSpan，设置可点击的文本，设置这个属性的文本可以相应用户点击事件，至于点击事件用户可以自定义注意： 使用ClickableSpan的文本如果想真正实现点击作用，必须为TextView设置setMovementMethod()方法，否则没有点击相应，至于setHighlightColor方法则是控制点击是的背景色。 SpannableString spannableString = new SpannableString(&quot;为文字设置点击事件&quot;); MyClickableSpan clickableSpan = new MyClickableSpan(&quot;http://www.jianshu.com/users/dbae9ac95c78&quot;); spannableString.setSpan(clickableSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setMovementMethod(LinkMovementMethod.getInstance()); textView.setHighlightColor(Color.parseColor(&quot;#36969696&quot;)); textView.setText(spannableString); // 自定义点击事件 class MyClickableSpan extends ClickableSpan { private String content; public MyClickableSpan(String content) { this.content = content; } @Override public void updateDrawState(TextPaint ds) { ds.setUnderlineText(false); } @Override public void onClick(View widget) { Intent intent = new Intent(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString(&quot;content&quot;, content); intent.putExtra(&quot;bundle&quot;, bundle); startActivity(intent); } } 11. URLSpan，设置超链接文本URLSpan就是继承自ClickableSpan，就是重写了父类的onClick事件，用系统自带浏览器打开链接。 SpannableString spannableString = new SpannableString(&quot;为文字设置超链接&quot;); URLSpan urlSpan = new URLSpan(&quot;http://www.jianshu.com/users/dbae9ac95c78&quot;); spannableString.setSpan(urlSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setMovementMethod(LinkMovementMethod.getInstance()); textView.setHighlightColor(Color.parseColor(&quot;#36969696&quot;)); textView.setText(spannableString);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>文字处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者(Builder)模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%BB%BA%E9%80%A0%E8%80%85(Builder)%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：《Head First 设计模式》 1. 定义：讲一个复杂对象的构建与他的表示分离，使得不同的构建过程可以创建不同的表示。 2. 建造者模式要点: 在目标类中有一个静态内部类Builder 目标类与静态内部类Builder拥有同样的成员变量 静态内部类Builder提供一个build()或者create()用于创建对应的外部类。该方法内部调用了外部类的一个私有构造方法，该私有构造方法的参数就是静态内部类Builder。 使用特点：链式调用 3. 骨架1234567891011121314151617181920212223242526272829303132333435363738public class Person &#123; /* 声明变量 */ String name; String address; int age; int sex; String job; int phoneNumber; int QQNumber; /** * 构造函数私有化 */ private Person()&#123; &#125; /** * 声明一个 静态类 Builder */ public static class Builder &#123; /* 声明同 person类 一样的变量 */ String name; String address; int age; int sex; String job; int phoneNumber; int QQNumber; &#125;&#125; 4. 一个完整含有建造者（Builder）模式的类此模式的主要实现是在”骨架”的基础上进行填充。 4.1 实现关键 - 1 ：类的私有构建方法1234private Person(Builder builder)&#123; //··· this.sex = builder.sex; &#125; 4.2 实现关键 - 2 ：静态类Builder中的方法返回值 + build()方法。1234567public static class Builder &#123; //··· public Person build()&#123; return new Person(this); &#125;&#125; 4.3 完整的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public class Person &#123; /* 声明变量 */ String name; String address; int age; int sex; String job; int phoneNumber; int QQNumber; /** * 构造函数私有化，通过这一点确保使用 Builder 实现动态构建（组合实现）当前类的实例化。 */ private Person(Builder builder)&#123; this.address = builder.address; this.age = builder.age; this.job = builder.job; this.name = builder.name; this.phoneNumber = builder.phoneNumber; this.QQNumber = builder.QQNumber; this.sex = builder.sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public int getPhoneNumber() &#123; return phoneNumber; &#125; public void setPhoneNumber(int phoneNumber) &#123; this.phoneNumber = phoneNumber; &#125; public int getQQNumber() &#123; return QQNumber; &#125; public void setQQNumber(int QQNumber) &#123; this.QQNumber = QQNumber; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", address='" + address + '\'' + ", age=" + age + ", sex=" + sex + ", job='" + job + '\'' + ", phoneNumber=" + phoneNumber + ", QQNumber=" + QQNumber + '&#125;'; &#125; /** * 声明一个 静态类 Builder * * 通过这个Builder类，动态的构建（组合实现）当前对象的各个属性。 * 特点： * 不需要编写多个构造函数。 */ public static class Builder &#123; /* 声明同 person类 一样的变量 */ String name; String address; int age; int sex; String job; int phoneNumber; int QQNumber; public Builder name(String name)&#123; this.name = name; return this; &#125; public Builder address(String address)&#123; this.address = address; return this; &#125; public Builder age(int age)&#123; this.age = age; return this; &#125; public Builder sex(int sex)&#123; this.sex = sex; return this; &#125; public Builder job(String job)&#123; this.job = job; return this; &#125; public Builder phoneNumber(int phoneNumber)&#123; this.phoneNumber = phoneNumber; return this; &#125; public Builder QQNumber(int QQNumber)&#123; this.QQNumber = QQNumber; return this; &#125; /** * 返回本类的实例化对象，此方法也真正实现当前类的实例化。 * @return 当前对象 */ public Person build()&#123; return new Person(this); &#125; &#125;&#125; 5. 使用建造者（Builder）模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainPerson &#123; public static void main(String[] aegs)&#123; // 构造方式1 Person person = new Person.Builder() .name("张三") .sex(1) .age(24) .build(); System.out.println(person.toString()); // 构造方式2 Person person2 = new Person.Builder() .name("旺旺") .sex(1) .age(12) .address("广东") .phoneNumber(122343423) .build(); System.out.println(person2.toString()); // 构造方式3 Person person3 = new Person.Builder() .name("刘贤") .sex(0) .age(72) .address("HK") .phoneNumber(8989345) .QQNumber(11112232) .job("司机") .build(); System.out.println(person3.toString()); // 构造方式4 Person person4 = new Person.Builder() .name("张倩") .sex(0) .age(22) .address("JP") .phoneNumber(0220330) .QQNumber(1233424) .job("Student") .build(); System.out.println(person4.toString()); &#125; /** * Person&#123;name='张三', address='null', age=24, sex=1, job='null', phoneNumber=0, QQNumber=0&#125; Person&#123;name='旺旺', address='广东', age=12, sex=1, job='null', phoneNumber=122343423, QQNumber=0&#125; Person&#123;name='刘贤', address='HK', age=72, sex=0, job='司机', phoneNumber=8989345, QQNumber=11112232&#125; Person&#123;name='张倩', address='JP', age=22, sex=0, job='Student', phoneNumber=73944, QQNumber=1233424&#125; */&#125; 6. 在Android中的应用 AlertDialog 图片加载库：Picasso]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- TypedArray]]></title>
    <url>%2FView-%E8%87%AA%E5%AE%9A%E4%B9%89%20-%20TypedArray%2F</url>
    <content type="text"><![CDATA[自定义View中的 attrs.xml 文件设置 1. 文件位置： 2. 文件内容（仅供参考）：1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="MyViewGroup"&gt; &lt;attr name="textOneTitle" format="string"/&gt; &lt;attr name="textOneSize" format="integer"/&gt; &lt;attr name="imageSrc" format="reference"/&gt; &lt;attr name="textTwoTitle" format="string"/&gt; &lt;attr name="textTwoSize" format="integer"/&gt; &lt;attr name="textOneVisible" format="boolean"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 3. 属性文件中参数属性的分类： 4. attrs.xml 文件中 format 取值类型1. reference：参考某一资源ID。 属性的定义 1&lt;attr name="imageSrc" format="reference"/&gt; 属性的使用 1cwj:imageSrc="@drawable/maps" 在java中获取数值（2种方式） 12345Drawable imgSrc = array.getDrawable(R.styleable.MyViewGroup_imageSrc);mImageView.setBackground(imgSrc);int imgSrc = array.getResourceId(R.styleable.MyViewGroup_imageSrc,R.drawable.ic_launcher_background);mImageView.setBackgroundResource(imgSrc); 2. color：颜色值。 属性的定义 1&lt;attr name="textOneColor" format="color"/&gt; 属性的使用 1cwj:textOneColor="#ff0000" 在java中获取 123int textOneColor = array.getColor(R.styleable.MyViewGroup_textOneColor, Color.BLACK);mTextView2.setTextColor(textOneColor); 3. boolean：布尔值。 属性的定义 1&lt;attr name="textOneVisible" format="boolean"/&gt; 属性的使用 1cwj:textOneVisible="false" 在java中获取 1234567boolean oneIsShow = array.getBoolean(R.styleable.MyViewGroup_textOneVisible,true);if (oneIsShow) &#123; mTextView1.setVisibility(VISIBLE);&#125; else &#123; mTextView1.setVisibility(INVISIBLE);&#125; 4. dimension：尺寸值。 属性的定义 1&lt;attr name="textOneSize" format="dimension"/&gt; 属性的使用 1cwj:textTwoSize="@dimen/textOneSize2" 在java中获取 123float textOneSize = array.getDimension(R.styleable.MyViewGroup_textOneSize,10);mTextView1.setTextSize(textOneSize); 5. float：浮点值。 属性的定义 1&lt;attr name = "fromAlpha" format = "float" /&gt; 属性的使用 1android:fromAlpha = "1.0" 6. integer：整型值。 属性的定义 1&lt;attr name = "frameDuration" format="integer" /&gt; 属性的使用 1android:frameDuration = "100" 7. string：字符串。 属性的定义 1&lt;attr name="textOneTitle" format="string"/&gt; 属性的使用 1cwj:textOneTitle="大标题" 在java中使用 123String textOneTitle = array.getString(R.styleable.MyViewGroup_textOneTitle);mTextView1.setText(textOneTitle); 8. fraction：百分数。 属性的定义 1&lt;attr name = "pivotY" format = "fraction" /&gt; 属性的使用 1android:pivotY = "300%" 9. enum：枚举值。 属性的定义 1234&lt;attr name="textTwoGravity"&gt; &lt;enum name="top" value="1"/&gt; &lt;enum name="center" value="2"/&gt;&lt;/attr&gt; 属性的使用 1cwj:textTwoGravity="top" 在java中获取 1234567int gracityIndex = array.getInt(R.styleable.MyViewGroup_textTwoGravity, Gravity.CENTER);if (gracityIndex == 1) &#123; mTextView2.setGravity(Gravity.TOP);&#125; else if (gracityIndex == 2) &#123; mTextView2.setGravity(Gravity.CENTER);&#125; 10. flag：位或运算。 属性的定义 123456789101112&lt;attr name="windowSoftInputMode"&gt; &lt;flag name = "stateUnspecified" value = "0" /&gt; &lt;flag name = "stateUnchanged" value = "1" /&gt; &lt;flag name = "stateHidden" value = "2" /&gt; &lt;flag name = "stateAlwaysHidden" value = "3" /&gt; &lt;flag name = "stateVisible" value = "4" /&gt; &lt;flag name = "stateAlwaysVisible" value = "5" /&gt; &lt;flag name = "adjustUnspecified" value = "0x00" /&gt; &lt;flag name = "adjustResize" value = "0x10" /&gt; &lt;flag name = "adjustPan" value = "0x20" /&gt; &lt;flag name = "adjustNothing" value = "0x30" /&gt; &lt;/attr&gt; 属性的使用 1android:windowSoftInputMode = "stateUnspecified | stateUnchanged | stateHidden" 其他 - 组合属性设置： 属性的定义 1&lt;attr name = "background" format = "reference|color" /&gt; 属性的使用 1android:background = "@drawable/图片ID|#00FF00"]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- 组合View]]></title>
    <url>%2FView-%E8%87%AA%E5%AE%9A%E4%B9%89-%20%E7%BB%84%E5%90%88View%2F</url>
    <content type="text"><![CDATA[这次描述的是自定义ViewGroup，这其中既包括完全自定义ViewGroup和组合ViewGroup。 自定义组合ViewGroup1. 创建一个自定义ViewGroup的xml文件1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.zhy.autolayout.AutoRelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/item_single_view" android:layout_width="match_parent" android:layout_height="210px" android:background="@color/login_txt" android:gravity="center"&gt; &lt;ImageView android:id="@+id/item_single_iv" android:layout_width="50px" android:layout_height="50px" android:layout_centerHorizontal="true" android:layout_marginTop="6px" android:src="@drawable/ic_launcher"/&gt; &lt;TextView android:id="@+id/item_single_tv_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@+id/item_single_iv" android:layout_marginTop="16px" android:gravity="center_horizontal" android:text="信息" android:textColor="@color/button_text_color"/&gt; &lt;TextView android:id="@+id/item_single_tv_val" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/item_single_tv_title" android:layout_marginTop="10px" android:gravity="center_horizontal" android:text="1223" android:textColor="@color/button_text_color"/&gt;&lt;/com.zhy.autolayout.AutoRelativeLayout&gt; 2. 创建一个继承自ViewGroup的自定义类。2.1 一个原始的自定义类：123456789101112131415public class MyViewGroup extends LinearLayout &#123; public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125;&#125; 2.2 对自定义组合控件中的子控件进行属性设置使用到的类： TypedArray 使用的文件： attrs.xml 文件 注意： 属性的初始化应该放在相应的构造函数中，例如本自定义ViewGroup中的构造过程应该写在第二个构造函数中，写在第三个构造函数中在使用时则不会显示。 在获取Layout布局文件时，注意参数的设置： View view = LayoutInflater.from(context).inflate(R.layout.my_view_group_layout,this,true); 有时，此处参数设置出错，自定义view的控件将不会显示。 此步编写的步骤为： 获取Layout布局文件 声明 Layout布局文件中的子控件 通过 TypedArray 获取 子控件 中的属性值 为各个子控件设置参数值 实例为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class MyViewGroup extends LinearLayout &#123; private static final String TAG = "MyViewGroup"; /* 2- 声明 xml文件用到的 控件 */ TextView mTextView1,mTextView2; ImageView mImageView; public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); // 1 - 获取自定义的 xml文件 View view = LayoutInflater.from(context).inflate(R.layout.my_view_group_layout,this,true); // 3 - findViewById mTextView1 = view.findViewById(R.id.one_tv); mTextView2 = view.findViewById(R.id.two_tv); mImageView = view.findViewById(R.id.image); // 4 - 通过 TypedArray 获取 attrs文件中的属性值 @SuppressLint("Recycle") TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.MyViewGroup); if (array != null) &#123; String textOneTitle = array.getString(R.styleable.MyViewGroup_textOneTitle); float textOneSize = array.getDimension(R.styleable.MyViewGroup_textOneSize,10); String textTwoTitle = array.getString(R.styleable.MyViewGroup_textTwoTitle); float textTwoSize = array.getDimension(R.styleable.MyViewGroup_textTwoSize,10); //两种方式均可 Drawable imgSrc = array.getDrawable(R.styleable.MyViewGroup_imageSrc); //int imgSrc = array.getResourceId(R.styleable.MyViewGroup_imageSrc,R.drawable.ic_launcher_background); boolean oneIsShow = array.getBoolean(R.styleable.MyViewGroup_textOneVisible,true); int textOneColor = array.getColor(R.styleable.MyViewGroup_textOneColor, Color.BLACK); int gracityIndex = array.getInt(R.styleable.MyViewGroup_textTwoGravity, Gravity.CENTER); array.recycle(); Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; MyViewGroup textOneTitle : " + textOneTitle + ", textOneSize : "+ textOneSize + ", textTwoTitle : " + textTwoTitle + ", textTwoSize : " + textTwoSize); // 5 - 为控件中的各个控件设置参数值 mTextView1.setText(textOneTitle); mTextView2.setText(textTwoTitle); mTextView1.setTextSize(textOneSize); mTextView2.setTextSize(textTwoSize); mTextView2.setTextColor(textOneColor); //控制子控件的显隐性 if (oneIsShow) &#123; mTextView1.setVisibility(VISIBLE); &#125; else &#123; mTextView1.setVisibility(INVISIBLE); &#125; //设置自定义图片的两种方式 mImageView.setBackground(imgSrc); //mImageView.setBackgroundResource(imgSrc); if (gracityIndex == 1) &#123; mTextView2.setGravity(Gravity.TOP); &#125; else if (gracityIndex == 2) &#123; mTextView2.setGravity(Gravity.CENTER); &#125; &#125; &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public void setImageView(Drawable imageViewId) &#123; mImageView.setBackground(imageViewId); &#125; public void setTextView1(String textView1Title) &#123; mTextView1.setText(textView1Title); &#125; public void setTextView2(String textView2Title) &#123; mTextView2.setText(textView2Title); &#125; public void setTextView1Size(int textView1Val) &#123; mTextView1.setTextSize(textView1Val); &#125; public void setTextView2Size(int textView2Val) &#123; mTextView2.setTextSize(textView2Val); &#125; public void setTextView2Gravity(String gravity) &#123; if ("top".equals(gravity)) &#123; mTextView2.setGravity(Gravity.TOP); &#125; else if ("center".equals(gravity)) &#123; mTextView2.setGravity(Gravity.CENTER); &#125; &#125;&#125; 3. 布局文件3.1 在相应的xml文件中调用自定义的ViewGroup类，实现对此类的调用。在这一步中，要想使用自定义view的属性进行数值的设置，首先要声明命名空间： xmlns:cwj=&quot;http://schemas.android.com/apk/res-auto&quot; 实际例子： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:cwj="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.yannischeng.custom_view.view_group.MyViewGroupActivity" android:orientation="vertical"&gt; &lt;com.yannischeng.custom_view.view_group.MyViewGroup cwj:textOneSize="@dimen/textOneSize1" cwj:textOneTitle="大标题" cwj:textTwoSize="@dimen/textOneSize2" cwj:textTwoTitle="具体的详细信息" cwj:imageSrc="@drawable/maps" android:layout_width="match_parent" android:layout_height="56dp"/&gt;&lt;/LinearLayout&gt; 3.2 修改之后布局文件123456789101112&lt;com.yannischeng.custom_view.view_group.MyViewGroup android:id="@+id/my_view_group" cwj:textOneSize="@dimen/textOneSize1" cwj:textOneTitle="大标题" cwj:textTwoSize="@dimen/textOneSize2" cwj:textTwoTitle="具体的详细信息" cwj:imageSrc="@drawable/maps" cwj:textOneVisible="false" cwj:textOneColor="#ff0000" cwj:textTwoGravity="top" android:layout_width="match_parent" android:layout_height="56dp"/&gt; 运行结果为： 4. 在相应的类中像使用其他控件一样使用自定义ViewGroup类的属性。1234567891011121314@BindView(R.id.my_view_group)MyViewGroup mMyViewGroup;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_view_group); ButterKnife.bind(this); mMyViewGroup.setTextView1("标题"); mMyViewGroup.setTextView1Size(14); mMyViewGroup.setTextView2("小标题"); mMyViewGroup.setTextView2Size(10);&#125; 5. 为自定义控件添加响应事件声明一个回调事件接口： 123456public interface ClickListener &#123; void textOneClickListener(View view); void textTwoClickListener(View view);&#125; 在自定义控件中使用： 12345678910111213141516171819202122232425262728293031323334/* 点击事件接口 */ClickListener mClickListener = null;/* 构造方法 */public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); //... mTextView1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mClickListener.textOneClickListener(v); &#125; &#125;); mTextView2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mClickListener.textTwoClickListener(v); &#125; &#125;); &#125;/** * 点击方法声明 */public void setClickListener(ClickListener listener)&#123; mClickListener = listener;&#125; 在Activity中使用 1234567891011mMyViewGroup.setClickListener(new ClickListener() &#123; @Override public void textOneClickListener(View view) &#123; Toast.makeText(MyViewGroupActivity.this, "this is textOneClickListener!", Toast.LENGTH_SHORT).show(); &#125; @Override public void textTwoClickListener(View view) &#123; Toast.makeText(MyViewGroupActivity.this, "this is textTwoClickListener!", Toast.LENGTH_SHORT).show(); &#125;&#125;); 点击左侧写有“标题”的按钮：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权限-FileProvider]]></title>
    <url>%2F%E6%9D%83%E9%99%90-FileProvider%2F</url>
    <content type="text"><![CDATA[问题总结 问题起因：E/FileSource: Failed to open file &apos;/storage/emulated/0/DCIM/Camera/VID_20171121_203344.mp4&apos;. (Permission denied) 这是因为7.0的新的文件权限导致的。文件共享要采用FileProvicer的形式，不能使用之前的file路径来简单表示。 3步解决问题1. file_paths 文件在res/下创建xml/文件夹，然后创建：file_paths文件。 12345&lt;resources xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-files-path name="root_path" path="."/&gt;&lt;/resources&gt; 注意：&lt;paths&gt;元素可包含多个元素。 具体元素的含义： &lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /data/user/0/com.yannischeng.simplemediaplayer/files Context.getFilesDir() + /path/ &lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /data/user/0/com.yannischeng.simplemediaplayer/cache Context.getCacheDir() + /path/ &lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0 Environment.getExternalStorageDirectory() + /path/ &lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0/Android/data/com.yannischeng.simplemediaplayer/files Context.getExternalFilesDir(String) + /path/ &lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0/Android/data/com.yannischeng.simplemediaplayer/cache Context.getExternalCacheDir() + /path/ &lt;root-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于外置SD卡路径。 // /system Environment.getRootDirectory().getAbsolutePath(); 2. 注册FileProvider在AndroidManifest.xml里面注册FileProvider 123456789101112&lt;application ... &lt;provider android:name="android.support.v4.content.FileProvider" &lt;!-- 共享文件的文件根目录，名字可以自定义 --&gt; android:authorities="media.player" &lt;!-- 自定义的权限 --&gt; android:exported="false" &lt;!-- 是否设置为独立进程 --&gt; android:grantUriPermissions="true"&gt; &lt;!-- 是否拥有共享文件的临时权限 --&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt; &lt;/provider&gt; &lt;/application&gt; 3. 使用在java代码中： 1Uri fileURI = FileProvider.getUriForFile(mContext,"media.player",file);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android视频]]></title>
    <url>%2FAndroid%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/10e357946447 基础知识 一、基本概念写在前面：如果在很多专有名字，概念都不熟悉的情况下，想要去阅读播放器源码会是相当困难的事情。 1. Codec编码（encode） 和 解码(decode)。Codec就是一种程序，这种程序可以对视频文件进行编码和解码。 A video codec is an electronic circuit or software that compresses（编码，压缩） or decompresses（解码，解压） digital video. It converts raw (uncompressed) digital video to a compressed format or vice versa. In the context of video compression, “codec” is a concatenation of “encoder” and “decoder”—a device that only compresses is typically called an encoder, and one that only decompresses is a decoder. 视频文件的本质其实就是图片的集合，当一段连续的图片不断的出现在人眼前(一般一个连贯的电影或者动画至少要求一秒24帧，也就是一秒内连续出现24张图片)，肉眼就会“欺骗性”的告诉大脑我们在看一个视频，而不是幻灯片。 图片大小计算：720P 1280 * 720 * 3byte = 2.7M Android在xml中定义颜色格式：#ffffff，三原色：3X4X2 = 24位二进制位 24/8 = 3。 仅仅是60s（1分钟）就有这么大，一部电影岂不……？ 所以通过：Codec程序对这些连续的图片通过一定的算法压缩成体积更小的文件格式 - 编码，压缩。在屏幕上进行播放时，需要显示图片，所以要将图片进行还原 - 解码，解压缩。Codec解码的编解码是分别针对：视频（图片）、音频（声波）。 视频的编解码是一个非常复杂的过程，但是现在有很多的工具及规范： H.265/H.264/H.263 2. Container format file（视频容器文件） - 结构化的文件视频容器文件即：mp4、rmvb、avi。容器：包括了视频(video)数据、(audio)音频数据、文字(Text)数据。结构化：音频、视频、文字数据必须按照一定的规范，放在指定的地方（方便解析）。 元数据 -&gt; Codec程序 -&gt; 视频容器文件 一个典型的“MP4”视频容器文件 Track(轨道)，这是一个专业术语，用来区分不同的音视频/文字数据。最重要的却是这个MetaData（头文件），它包含了很多关于视频的原始数据，比如视频的大小，视频的时长，还有一个索引表，这个索引表包含了不同轨道的起始位置(以字节为单位)，又因为每个轨道会被分成若干块sample(采样，每一块采样都是可以单独被播放器播放的一段数据，以微妙为单位)，metadata也会维护一个细粒度更小的索引表，记录了每一块sample的大小，起始位置，对应视频的时间是多少(以字节为单位)等等的信息。 3. 视频处理流程 原片(Raw Data) -Encode-&gt; 容器文件(container) -process-&gt; 不同分辨率 -服务器-&gt; 客户端使用 二、MP4 解析1. Mp4格式文件的构成MP4是一种格式的规范，是被ISO机构认证的，只要你通过Codec生成了一个mp4文件，那么这个文件的格式必须是按照ISO机构的规矩来。这个规范很好理解，它定义了一个MP4文件里面，哪些数据应该放在什么位置(以字节为单位)，哪些数据的长度是多少。 MP4格式定义：http://xhelmboyx.tripod.com/formats/mp4-layout.txt 任何容器，包括mp4都是类似的结构化文件，只不过不同的格式文件ISO对其有严格的要求，数据的摆放顺序、排列等等不同而已。 2. MP4头文件构成在Meta Data里面，每一个Header，头文件，我们都叫他们Atom Header(不知道咋翻译)。Atom Header分为Leaf Atom 和 Container Atom。前者代表一个连接着字符串信息的头文件，后者是一个包含了若干个子Atom的头文件，他们互相之间是有层级关系的(参考上图)。每次播放器获取了movie atom之后(moov)，会根据层级关系，向下，或者向下读取相关的其他信息。每一个头文件都会对它的子头文件保存位置的引用，所以只要根据mp4文件的规范获取了最顶级的头文件moov,就可以顺势往下读取其他头文件 苹果MP4文档：https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706 mp4的头文件结构： 最重要的信息是采样索引表(Sample Table Atoms).对应图中“stbl ”这个atom header。这个索引表保存了mp4文件所有的采样(sample)与视频时间的对应关系(一般以微秒为单位)，还有包括每个采样的大小，在mp4文件中的起始位置(以自己为单位)。 3. 标准播放器的启动流程3.1 播放器构成： 数据源（source） 读取器（extractor） 加载控制器（load control） 渲染器（trackRenderer） 3.1 播放器播放流程：在播放器可以把数据提交给渲染器之前，播放器需要把必需的头文件全部解析并存入内存，比如之前说的采样索引表。一般播放器在解析完毕后，会构建三个表： 一个存放时间对应采样索引 一个存放采样索引对应在mp4文件中的起始位置(以字节为单位) 一个存放采样索引对应大小(以字节为单位)。 通过表1，我们知道该微秒对应第1个采样（sample），从第一个和第二个表我们知道，第1个采样的数据范围(在mp4文件内)是从第0字节到300（0+300）字节，那么播放器就会去读取这个范围的数据并且放入渲染器中进行渲染。 同时，加载器会基于当前已经缓存的数据，决定是否还需要不停的读取数据进入内存。一般来说每个播放器都有默认的缓存值，也会有一个基准线，只有当缓存足够数据才能放进渲染器进行渲染。 最后同理，当我们拖动滑动控制器(SeekBar)想快进的时候，我们和第一步一样，通过我们想滑动的时间获取采样的索引，再重新开始读取数据。 综上所述，播放器在正式播放视频文件之前，必须要把头文件全部读取并解析(这会是一段非常耗时的程序)，这也是在线视频播放的等待时间的瓶颈。在接下来的章节我会介绍自适应视频播放(Adaptive Streaming)，这个技术的发明使得了分段式mp4文件(Fragmented Mp4)技术得以诞生，大大的减少了在线视频播放的等待时间。 4. 在线视频播放的技术基础(online video streaming)在线视频的播放其实和播放本地视频的区别就是Extractor读取的Source，数据源不一样。 在线播放需要下载数据到内存，再交由Extractor读取分析。但是既然是在线视频播放，我们肯定不能把整个容器文件下载到内存或者硬盘再开始解析播放。我们希望能控制下载的进度，比如我当前在看第10s的视频内容，所以我只想缓存/下载视频内容到第20s的位置。 我们俗称的渐进式下载(Progressive Downloading)就解决了这一难题。 在HTTP请求里面加一个叫RANGE的header，放入起始字节和结束字节，就可以只下载对应部分的数据，这一header的支持也是各种下载软件实现断点下载的基础。每次断网的时候记录下来已经下载的数据的字节数，下次再下载的时候从字节数+1处重新下载并且写入原有文件就可以了。 三、 Android的Media API1. Android平台视频播放历史自带播放器缺点： 很多格式的容器文件不支持，也不支持自适应视频播放(Adaptive Streaming) 应用开发者很难debug播放器，MediaPlayer的代码很多都是Native Method。并不在Java层。 很难做自定义的拓展和设置，比如缓冲的大小，下载进度等等。 安卓4.3之后 release 新的 Media Codec API组，把API组件设计的面向视频播放的更底层概念。 从结构图里看出，原来的MediaPlayer把Extractor，和Codec API全部封锁在了Framework层，应用层完全接触不到。在新的API设计里面，这些都挪到了应用层(其实虽然MediaCodec API，就是编解码API还在Framework，但是应用层可以调用他们) 2. Android Codec API的使用在全新的Media API里面，最最最重要的就是MediaExtractor和MediaCodec这两个类，第一个可以对容器文件进行读取控制，第二个就是对数据进行编解码的API。 MediaExtractor可以从一个URL，获取容器文件的轨道数量、轨道信息(Track)。在确定了轨道信息之后，可以选择想要解码的轨道(只能选择一个，所以音轨和视频轨道需要两个不同MediaExtractor给两个不同MediaCodec解码)，再从该轨道不停的读取数据放入MediaCodec API进行解码。 MediaCodec API则是创建的时候就需要选择Codec的类型。然后编码的时候需要安卓平台显示视频的Surface 一个MediaCodec在创建之后会在内部维护两个对列(Queue),一个是InputQueue，一个是OutputQueue。类似生产者消费者的模式，MediaCodec会不停的从InputQueue获取数据(InputQueue的数据又是又MediaExtractor提供)，解码，再把解码之后的数据放入OutputQueue，再提供给Surface让其视频内容。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[总结：基本动画 与 属性动画 一、概览： Animator : 这是为动画提供基本支持的类的超类，这些动画可以被启动、结束、并添加AnimatorListeners。 Animator的子类 Evaluator. 二、 注意事项两个方法，避免内存泄漏 onAttachedToWindow()：当含有此View的Activity启动时，View的此方法会被调用。 onDetachedFromWindow()：包含此View的Activity在退出或者View被remove时，View的此方法会被调用。 OOM问题避使用帧动画中，因为当图片数量较多且图片较大时，在此种动画中易出现此问题。 View动画问题View动画是对View的影响做动画，并不是真正的改变View的状态，因此有时候会出现动画完成后无法隐藏的情况，调用setVisibility(View.GONE)也没有作用，此时调用：view.clearAnimation()即可清除View动画。 开启硬件加速——动画更流畅1view.setLayerType(View.LAYER_TYPE_SOFTWARE, null); 三、动画分类0. 复杂属性动画 使用 PropertyValuesHolder 来对多个属性同时做动画； 使用 AnimatorSet 来同时管理调配多个动画； PropertyValuesHolder 的进阶使用：使用 PropertyValuesHolder.ofKeyframe() 来把一个属性拆分成多段，执行更加精细的属性动画。 1. 最早的两种 逐帧动画(frame-by-frame animation) 补间动画(tweened animation) 2. 属性动画 ：ValueAnimator（Android3.0） - 某一属性（值）动画属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的，即：ValueAnimator只不过是对值进行了一个平滑的动画过渡。 它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等 补间动画是只能对View对象进行动画操作的。而属性动画就不再受这个限制，它可以对任意对象进行动画操作。 这个类提供了一个简单的计时引擎，用于运行计算动画值的动画并将其设置在目标对象上。所有动画都有一个定时脉冲。它在自定义处理程序中运行，以确保在UI线程上发生属性更改。默认情况下，ValueAnimator使用非线性时间插值，通过AccelerateDecelerateInterpolator类来加速和减速动画。这种行为可以通过调用{@link ValueAnimator＃setInterpolator（TimeInterpolator）}来改变。动画师可以从代码或资源文件创建。这里是一个ValueAnimator资源文件的例子： {@sample development / samples / ApiDemos / res / anim / animator.xml ValueAnimatorResources} 也可以使用{@link PropertyValuesHolder}和 {@link Keyframe}资源标签来创建一个多步骤的动画。 请注意，您可以XMind为每个关键帧指定显式小数值（从0到1），以确定动画在整个持续时间内何时到达该值。或者，您可以关闭分数，关键帧将在总时长内平均分配：{@sample development / samples / ApiDemos / res / anim / value_animator_pvh_kf.xml ValueAnimatorKeyframeResources} （1）ObjectAnimator - ValueAnimator 子类ValueAnimator的这个子类ObjectAnimator为动画目标对象上的属性提供了支持。这个类的构造函数使用参数来定义将被动画的目标对象以及将被动画的属性名称。然后在内部确定适当的设置/获取函数，动画将根据需要调用这些函数来动画属性。 简单使用方式: 1234ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(mTextView01,"rotation",0f,360f);mObjectAnimator.setDuration(2000);mObjectAnimator.setInterpolator(mInterpolator);mObjectAnimator.start(); 1.1 基本使用12345ObjectAnimator animator = ObjectAnimator.ofFloat(view,"progress",0,100);// 2. 用 start() 执行动画animator.setDuration(3000);animator.setInterpolator(new LinearOutSlowInInterpolator());animator.start(); 在自定义View中使用objectAnimator的“属性”：添加setter()/getter()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class CameraFlipBoard extends View &#123; Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); Camera mCamera = new Camera(); Bitmap mBitmap; int degree; ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); public CameraFlipBoard(Context context) &#123; super(context); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //设置自定义动画 &#123; mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.maps); mAnimator.setDuration(2000); mAnimator.setInterpolator(new FastOutLinearInInterpolator()); //无限重复 mAnimator.setRepeatCount(ValueAnimator.INFINITE); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start(); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end(); &#125; //unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问 @SuppressWarnings("unused") public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate(); &#125; public int getDegree() &#123; return degree; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float centerX = getWidth() / 2; float centerY = getHeight() / 2; float cbx = centerX - mBitmap.getWidth() / 2; float cby = centerY - mBitmap.getHeight() / 2; /* 本次要实现的是由图片的中间开始，上半部分不动，下半部分由上往下翻180度。 所以，一张图片要被分成2部分： 上半部分绘制完成之后不动 下半部分则是反向转动180度 */ //上半部分 canvas.save(); canvas.clipRect(0,0,getWidth(),centerY); canvas.drawBitmap(mBitmap, cbx,cby, mPaint); canvas.restore(); /* 未经移动的canvas坐标原点即为camera的坐标原点。 移动的距离要看 具体的bitmap所在的具体位置： 若bitmap在view的坐标原点，则移动bitmap的width/2和height/2即可。 若bitmap不在view的坐标原点，则要根据他们的相对位置进行计算后移动。 */ //下半部分 canvas.save(); if (degree &lt; 90) &#123; canvas.clipRect(0,centerY,getWidth(),getHeight()); &#125; else &#123; canvas.clipRect(0,0,getWidth(),centerY); &#125; mCamera.save(); canvas.translate(centerX,centerY); mCamera.rotateX(degree); mCamera.applyToCanvas(canvas); canvas.translate(-centerX,-centerY); mCamera.restore(); canvas.drawBitmap(mBitmap,cbx,cby,mPaint); canvas.restore(); &#125;&#125; 1.2 组合动画（一个接一个的动画）：AnimatorSet实现组合动画功能主要需要借助AnimatorSet这个类，这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法： after(Animator anim) 将现有动画插入到传入的动画之后执行 after(long delay) 将现有动画延迟指定毫秒后执行 before(Animator anim) 将现有动画插入到传入的动画之前执行 with(Animator anim) 将现有动画和传入的动画同时执行 1234567ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f); ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f); ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(rotate).with(fadeInOut).after(moveIn); animSet.setDuration(5000); animSet.start(); 1234567891011121314151617181920ObjectAnimator animator1 = ObjectAnimator.ofFloat(...); animator1.setInterpolator(new LinearInterpolator()); ObjectAnimator animator2 = ObjectAnimator.ofInt(...); animator2.setInterpolator(new DecelerateInterpolator());AnimatorSet animatorSet = new AnimatorSet(); // 两个动画依次执行,使用 playSequentially()，就可以让两个动画依次播放，而不用为它们设置监听器来手动为他们监管协作。animatorSet.playSequentially(animator1, animator2); animatorSet.start(); // 两个动画同时执行animatorSet.playTogether(animator1, animator2); animatorSet.start();// 使用 AnimatorSet.play(animatorA).with/before/after(animatorB)// 的方式来精确配置各个 Animator 之间的关系animatorSet.play(animator1).with(animator2); animatorSet.play(animator1).before(animator2); animatorSet.play(animator1).after(animator2); animatorSet.start(); 1.3 同一个动画中改变多个属性： PropertyValuesHolder12345PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat("scaleX", 1);PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat("scaleY", 1); PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat("alpha", 1);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3) animator.start(); 1.4 把同一个属性拆分：PropertyValuesHolders.ofKeyframe()12345678910// 在 0% 处开始Keyframe keyframe1 = Keyframe.ofFloat(0, 0); // 时间经过 50% 的时候，动画完成度 100%Keyframe keyframe2 = Keyframe.ofFloat(0.5f, 100); // 时间见过 100% 的时候，动画完成度倒退到 80%，即反弹 20%Keyframe keyframe3 = Keyframe.ofFloat(1, 80); PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe("progress", keyframe1, keyframe2, keyframe3);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder); animator.start(); （2）ViewPropertyAnimator（Android3.1） 该类可以在View对象上自动优化动画选择属性。 如果View对象上只有一个或两个属性被设置为动画，推荐使用ObjectAnimator。由ObjectAnimator调用的属性设置器能够正确地设置属性并使视图无效。 但是，如果同时对多个属性进行动画处理，或者只是想要更方便的语法来为特定的属性设置动画，则ViewPropertyAnimator可能更适合执行此任务。 这个类可以为几个同时动画提供更好的性能，因为它将优化无效调用，只发生一次对于多个属性，而不是每个动画属性独立地导致它自己的失效。而且，使用这个类的语法可能更容易使用，因为调用者只需要告诉View对象哪个属性需要动画。 这个类不是由调用者构造的，而是由View的属性来动画的。调用View.animate()将返回对该视图的相应ViewPropertyAnimator对象的引用。 imageView.animate()中的animate(): 1234567891011public ViewPropertyAnimator animate() &#123; if (mAnimator == null) &#123; mAnimator = new ViewPropertyAnimator(this); &#125; return mAnimator;&#125; ViewPropertyAnimator(View view) &#123; mView = view; view.ensureTransformationInfo();&#125; 2.1 基本功能： rotation scale translation alpha 2.2 使用到的其他相关接口： Animator ： 动画提供基本支持的类的超类 Animator.AnimatorListener ：动画侦听器从动画接收通知。 ValueAnimator.AnimatorUpdateListener ： TimeInterpolator ViewPropertyAnimatorRT 2.3 除了动画之外的价格set方法: ViewPropertyAnimator setDuration(long duration) ViewPropertyAnimator setInterpolator(TimeInterpolator interpolator) ViewPropertyAnimator setListener(Animator.AnimatorListener listener) ViewPropertyAnimator setStartDelay(long startDelay) ViewPropertyAnimator setUpdateListener(ValueAnimator.AnimatorUpdateListener listener) 2.4 ViewPropertyAnimator基本使用，（同一个动画中改变多个属性）1234567imageView.animate().translationX(500f). alpha(0.2f). scaleX(1.5f). scaleY(1.5f). rotation(720). setInterpolator(new AnticipateOvershootInterpolator()). setDuration(3000); 三、 Animator监听器给动画设置监听器，可以在关键时刻得到反馈，从而及时做出合适的操作，例如在动画的属性更新时同步更新其他数据，或者在动画结束后回收资源等 ViewPropertyAnimator ObjectAnimator setListener() addListener() setUpdateListener() addUpdateListener() set[Update]Listener() remove[Update]Listener() addPauseListener() removePauseListener() withStartAction()一次性动画 withEndAction() Animator类当中提供了一个addListener()方法，这个方法接收一个AnimatorListener，我们只需要去实现这个AnimatorListener就可以监听动画的各种事件了。 四、 其他组件1. 插值器 - Interpolator1.1 Interpolator的作用内插器定义动画的变化率。 这可以使基本的动画效果（alpha，缩放，平移，旋转）加速，减速，重复等。 1.2 Interpolator的继承关系 1.3 系统自带效果 Interpolator class Resource ID AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator AccelerateInterpolator @android:anim/accelerate_interpolator AnticipateInterpolator @android:anim/anticipate_interpolator AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator BounceInterpolator @android:anim/bounce_interpolator CycleInterpolator @android:anim/cycle_interpolator DecelerateInterpolator @android:anim/decelerate_interpolator LinearInterpolator @android:anim/linear_interpolator OvershootInterpolator @android:anim/overshoot_interpolator Interpolator class decription AccelerateDecelerateInterpolator 开始和结束缓慢，中间加速 AccelerateInterpolator 开始的时候缓慢，之后开始加速 AnticipateInterpolator 开始的时候向后甩一下，然后向前 AnticipateOvershootInterpolator 开始的时候向后甩一下，然后加速向前甩过终点一点后回到原点 BounceInterpolator 动画结束的时候小距离的时候在终点处弹起 CycleInterpolator 将重复周期的指定数目的动画。变化率遵循正弦模式 DecelerateInterpolator 开始的时候快，结束的时候慢 FastOutLinearInInterpolator 加速运动 FastOutSlowInInterpolator 先加速再减速 LinearInterpolator 以常量速率变化 LinearOutSlowInInterpolator 持续减速 OvershootInterpolator 运动到终点后，冲过终点后再回弹 PathInterpolator 自定义动画完成度 / 时间完成度曲线 2. 计算器 - TypeEvaluator 参考：http://hencoder.com/ui-1-7/ 告诉动画系统如何从初始值过度到结束值 用于ValueAnimator.setEvaluator（TypeEvaluator）函数的接口。 评估者允许开发人员通过允许他们为动画系统不能自动理解和使用的类型提供自定义评估器来为任意属性类型创建动画。 12345678910111213141516public interface TypeEvaluator&lt;T&gt; &#123; /** * 该函数返回对开始和结束值进行线性插值的结果 * 表示开始和结束值之间的比例的“分数”。 计算是一个简单的参数计算：result = x0 + t *（x1 - x0） * 其中 x0 是 startValue ，x1 是 endValue ， t 是 分数 。 * * @参数分数从开始到结束值的分数 * @param startValue起始值。 * @param endValue最终值。 * @return给定的开始值和结束值之间的线性插值 * fraction ：参数fraction非常重要，这个参数用于表示动画的完成度的，我们应该根据它来计算当前动画的值应该是多少。 */ public T evaluate(float fraction, T startValue, T endValue);&#125; 2.1 一个IntEvaluator类代码：123456789/** * 此评估程序可用于在 int 值之间执行类型插值。 */public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 2.2 使用自定义一个Evaluator 1234567891011public class AZEvaluator implements TypeEvaluator&lt;Character&gt; &#123; @Override public Character evaluate(float fraction, Character startValue, Character endValue) &#123; int startInt = (int)startValue; int endInt = (int)endValue; int curInt = (int)(startInt + (fraction *(endInt - startInt))); char result = (char)curInt; return result; &#125;&#125; 1234567891011121314ValueAnimator valueAnimator = ValueAnimator.ofObject(new AZEvaluator(),Character.valueOf('A'),Character.valueOf('Z'));valueAnimator.setDuration(3000);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; char currentChar = (char) animation.getAnimatedValue(); Log.e(TAG, "onAnimationUpdate: " + currentChar ); showChar.setText(String.valueOf(currentChar)); &#125;&#125;);//valueAnimator.setInterpolator(new LinearInterpolator());valueAnimator.setRepeatCount(ValueAnimator.INFINITE);valueAnimator.setRepeatMode(ValueAnimator.REVERSE);valueAnimator.start(); 硬件加速 参考：http://hencoder.com/ui-1-8/ 硬件加速能够让绘制变快，主要有三个原因 本来由 CPU 自己来做的事，分摊给了 GPU 一部分，自然可以提高效率； 相对于 CPU 来说，GPU 自身的设计本来就对于很多常见类型内容的计算（例如简单的圆形、简单的方形）具有优势； 由于绘制流程的不同，硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免了一些重复操作，从而大幅提升绘制效率。 原理在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。大致就像这样： 而在硬件加速开启时，Canvas 的工作方式改变了：它只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。大致是这样： 限制]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画 - Canvas处理与Camera三维变换]]></title>
    <url>%2F%E5%8A%A8%E7%94%BB%20-%20Canvas%E5%A4%84%E7%90%86%E4%B8%8ECamera%E4%B8%89%E7%BB%B4%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[总结 1. Canvas与Camera中不可忽略的两个方法：Canvas对同一个图片对象进行处理时，需要时时注意的两个方法。 save() : 保存 - 处理之前的状态 restore() ：恢复 至 save()状态 2. 动画处理的顺序问题：当 Camera 对素材进行处理时，Canvas 的顺序是 反的。即：两者对于一个图片进行多项操作处理时候，实际处理代码的顺序是 由下向上 的。 3. 裁剪 ClipCanvas中与Clip有关的方法： 共有2类：Path和Rect 3.1 Rect裁剪 - 形状、坐标裁剪canvas.clipRect(left,top,left + 130,top + 150); canvas.drawBitmap(bitmap, left, top, paint); 3.2 Path裁剪 - 路径裁剪//圆形抠图 canvas.save(); canvas.translate(250,500); Path path = new Path(); path.addCircle(100,200,100, Path.Direction.CW); canvas.clipPath(path); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); //心形挖空 canvas.save(); canvas.translate(600,500); Path path1 = new Path(); path1.setFillType(Path.FillType.INVERSE_WINDING); path1.arcTo(50,100,150,200,135,225,false); path1.arcTo(150,100,250,200,180,225,false); path1.lineTo(150,300); path1.close(); canvas.clipPath(path1); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); //心形抠图 canvas.save(); canvas.translate(1000,500); Path path2 = new Path(); path2.setFillType(Path.FillType.EVEN_ODD); path2.arcTo(50,100,150,200,135,225,false); path2.arcTo(150,100,250,200,180,225,false); path2.lineTo(150,300); path2.close(); canvas.clipPath(path2); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); 4. 变换 Canvas，Matrix，Camera4.1 Canvas变换共有4类： scale - 缩放 translate - 平移 skew - 歪曲 rotate - 旋转 他们的使用方式相同，唯一就是参数类型不同。 skew的使用 123456789101112131415161718192021/** * 斜切 */ canvas.save(); canvas.translate(0,200); /** * @param sx在X中歪斜的数量 * @param sy在Y中倾斜的数量 */ canvas.skew(0f,0.5f); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); canvas.save(); canvas.translate(700,400); /** * @param sx在X中歪斜的数量 * @param sy在Y中倾斜的数量 */ canvas.skew(-0.5f,0f); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 4.2 Matrix变换大致使用 Matrix matrix = new Matrix(); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.save(); matrix.postTranslate(0,300); canvas.concat(matrix); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); canvas.translate(0,-300); canvas.save(); matrix.preTranslate(0,-300); canvas.concat(matrix); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 4.3 Camera变换中的使用Canvas和Matrix仅能对图像实现二维效果的是实现，而Camera所在的是空间三维坐标系，能够实现空间变换效果。 4.3.1 初次实现变换123456789101112131415161718Camera camera = new Camera();canvas.translate(100,200);canvas.save();camera.save();camera.rotateX(30);camera.applyToCanvas(canvas);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore();canvas.translate(100,-200);canvas.save();camera.save();camera.rotateY(30);camera.applyToCanvas(canvas);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 很明显可以看到，在空间坐标系中进行camera变换后，得到的效果已经失真。 Android的Camera中的轴是一个控件三维轴：X、Y、Z，3个轴，camera所对应的原点并不是图像的原点，而是三维坐标轴的原点。 所以图像如果想在camera下沿各个轴做&quot;平面（不失真）&quot;的旋转，就要以图像的中心为轴心进行旋转，但是camera不支持设置轴心，所以要通过Canvas进行轴心的再设置。 通过Canvas将图像的中心移动到轴的中心。待旋转结束之后再将图形的轴心移动回之前的位置。 所以，在camera下将图像进行旋转实际的操作步骤是： 1）将图像中心移动至空间坐标系的轴心 2）执行图像的变换 3）恢复图像原来的轴心位置。 通过移动图像的坐标原点后，对图像的X、Y、Z轴分别旋转30度后，三个图像是重合在一起的。即： 他们的轴心是同一个点。 4.3.2 Camera的空间坐标轴注意：和Camera坐标有关的图片均来自“扔物线”的个人视频截图，此处特此声明。 Camera的空间坐标系的旋转方向： 4.3.3 修正之后123456789101112131415161718192021222324252627282930313233343536373839404142//对X轴进行30度旋转//保存变更前的状态camera.save();canvas.save();//通过canva将三维坐标系的轴心移动至图像的原点，恢复到之前的空间状态。canvas.translate(center1X, center1Y);//在camera下将图像沿着x轴旋转30度camera.rotateX(30);//获得在camera下图像的旋转结果，并将结果应用到canvas中.camera.applyToCanvas(canvas);//通过canva将图像的原点移动至三维坐标系的轴心canvas.translate(-center1X, -center1Y);//camera处理结束后，恢复到之前的sava状态camera.restore();//将得到的图像的结果进行绘制。canvas.drawBitmap(bitmap, point1.x, point1.y, paint);//canvas处理结束后，恢复到之前的sava状态canvas.restore();//对Y轴进行30度旋转canvas.translate(400, 0);camera.save();canvas.save();canvas.translate(center1X, center1Y);camera.rotateY(30);camera.applyToCanvas(canvas);canvas.translate(-center1X, -center1Y);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore();//对Z轴进行30度旋转canvas.translate(400, 0);camera.save();canvas.save();canvas.translate(center1X, center1Y);camera.rotateZ(30);camera.applyToCanvas(canvas);canvas.translate(-center1X, -center1Y);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 实际执行过程 在空间坐标轴中的移动过程大致为： 先将图的原点移动到空间坐标系的原点。即代码： canvas.translate(-center1X, -center1Y); 然后执行具体的变换操作，代码：camera.rotateZ(30); 获取变换后的投影 得到投影结果后，再将图像的原点移动到之前的位置。 运行结果 设置虚拟Camera的位置 123DisplayMetrics displayMetrics = getResources().getDisplayMetrics();float newZ = - displayMetrics.density * 6;camera.setLocation(0, 0, newZ); 5. 为自定义中的图像添加 动画5.1 步骤（1）声明ObjectAnimator对象并进行初始化。12int degree;ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); （2）对ObjectAnimator对象进行具体设置123456//设置时长mAnimator.setDuration(2000);//设置插值器mAnimator.setInterpolator(new FastOutLinearInInterpolator());//无限重复mAnimator.setRepeatCount(ValueAnimator.INFINITE); （3）重写相应的方法设置动画的开始和结束1234567891011@Overrideprotected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start();&#125;@Overrideprotected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end();&#125; （4）设置含有degree属性的方法1234567//unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问@SuppressWarnings("unused")public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate();&#125; （5）使用参数1mCamera.rotateX(degree); 5.2 一个完整的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class CameraFlipBoard extends View &#123; Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); Camera mCamera = new Camera(); Bitmap mBitmap; int degree; ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); public CameraFlipBoard(Context context) &#123; super(context); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //设置自定义动画 &#123; mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.maps); mAnimator.setDuration(2000); mAnimator.setInterpolator(new FastOutLinearInInterpolator()); //无限重复 mAnimator.setRepeatCount(ValueAnimator.INFINITE); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start(); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end(); &#125; //unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问 @SuppressWarnings("unused") public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float centerX = getWidth() / 2; float centerY = getHeight() / 2; float cbx = centerX - mBitmap.getWidth() / 2; float cby = centerY - mBitmap.getHeight() / 2; /* 本次要实现的是由图片的中间开始，上半部分不动，下半部分由上往下翻180度。 所以，一张图片要被分成2部分： 上半部分绘制完成之后不动 下半部分则是反向转动180度 */ //上半部分 canvas.save(); canvas.clipRect(0,0,getWidth(),centerY); canvas.drawBitmap(mBitmap, cbx,cby, mPaint); canvas.restore(); /* 未经移动的canvas坐标原点即为camera的坐标原点。 移动的距离要看 具体的bitmap所在的具体位置： 若bitmap在view的坐标原点，则移动bitmap的width/2和height/2即可。 若bitmap不在view的坐标原点，则要根据他们的相对位置进行计算后移动。 */ //下半部分 canvas.save(); if (degree &lt; 90) &#123; canvas.clipRect(0,centerY,getWidth(),getHeight()); &#125; else &#123; canvas.clipRect(0,0,getWidth(),centerY); &#125; mCamera.save(); canvas.translate(centerX,centerY); mCamera.rotateX(degree); mCamera.applyToCanvas(canvas); canvas.translate(-centerX,-centerY); mCamera.restore(); canvas.drawBitmap(mBitmap,cbx,cby,mPaint); canvas.restore(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android7.0新特性-Shortcuts]]></title>
    <url>%2FAndroid7-0%E6%96%B0%E7%89%B9%E6%80%A7-Shortcuts%2F</url>
    <content type="text"><![CDATA[总结 说明如果你的App targets android7.1（API level25）或者更高，你就可以在你的app中定义快捷方式来支持特殊的actions。这些快捷方式可以显示在启动图标上，快捷方式可以在你的app内让用户快速开始使用命令或者推荐任务。Shortcuts是Android7.0的新特性，它的功能就像是类似iphone的3D Touch，选中其中的一条Shortcut后，点击是打开对应的app界面，长按则是将此条Shortcut添加至桌面。 以网易云音乐为例进行展示。 长按带有shorcuts功能的app时，该有的样式。 单个shortcut固定到桌面时的样式。其中大的背景icon是在shortcuts中自己设置的，右下角小的背景icon是app的icon。 实现你也可以在你的app中发布两个不同类型的快捷方式 静态快捷方式被定义在一个资源文件中。因此，你必须等到直到你的app更新后，才能改变“静态快捷方式”中的详情。 动态快捷方式是通过在运行时使用ShortcutManager API来发布的，在运行时，你的app可以发布、更新、和移除。 在你的app中同一时间至多可以发布5个快捷方式（静态和动态结合）。然而不必显示你所创建的每一个。 动态使用到的类 ShortcutManager，ShortcutInfo。其中，ShortcutManager用于管理ShortcutInfo，而ShortcutInfo则是执行具体的创建。 简单的初级实现：manager = getSystemService(ShortcutManager.class); //第一步：ShortcutInfo 对象 ShortcutInfo info = new ShortcutInfo.Builder(this,&quot;id1&quot;) //此条shortcut的icon .setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). //固定到桌面时显示的文字 setShortLabel(&quot;Trinea&quot;). //按住app的icon后此条shortcut在显示时的位置 setRank(1). //按住app的icon后此条shortcut显示的文字 setLongLabel(&quot;打开Trinea主页&quot;). //此条shortcut执行的功能 setIntents(intents). build(); //ShortcutInfo 对象 ShortcutInfo info2 = new ShortcutInfo.Builder(this,&quot;id2&quot;). setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). setShortLabel(&quot;百度&quot;). setRank(2). setLongLabel(&quot;百度一下&quot;). setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.baidu.com/&quot;))). build(); //ShortcutInfo 对象 ShortcutInfo info3 = new ShortcutInfo.Builder(this,&quot;id0&quot;). setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). setShortLabel(&quot;SecondActivity&quot;). setDisabledMessage(&quot;此快捷方式已经被禁用&quot;). setRank(3). setLongLabel(&quot;打开 SecondActivity&quot;). setIntents(intents2). build(); //第二步：整理shortcut对象 dynamicShortcuts.add(info); dynamicShortcuts.add(info2); dynamicShortcuts.add(info3); //第三步：通过manager设置shortcut //manager.addDynamicShortcuts(Arrays.asList(info)); manager.setDynamicShortcuts(dynamicShortcuts); 静态需要的文件AndroidManifest.xml。 在触发Shortcuts的Activity的activity标签配置中，添加meta-data标签。具体为： &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.shortcuts&quot; android:resource=&quot;@xml/my_shortcut&quot;/&gt; &lt;/activity&gt; 其中android:resource指向定义了 shortcuts 的资源文件。 创建一个资源文件，在res/xml/目录下，文件的名字同meta-data自己编写的my_shortcut： 在这个资源文件中使用shortcuts作为根元素，它包含多个shortcut标签列表，每一个shortcut 就是一个`静态快捷方式`。 一个shortcut的具体为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;shortcut android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:shortcutDisabledMessage=&quot;@string/message&quot; android:shortcutId=&quot;static&quot; android:shortcutLongLabel=&quot;@string/longlaber&quot; android:shortcutShortLabel=&quot;@string/shortlaber&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetClass=&quot;com.example.shortcutsmy.SecondActivity&quot; android:targetPackage=&quot;com.example.shortcutsmy&quot; /&gt; &lt;/shortcut&gt; &lt;/shortcuts&gt; 说明 shortcutId表示 shortcut 唯一标识符，相同的 shortcutId 会被覆盖。必须字段。 shortcutShortLabel为将 shortcut 拖动到桌面时显示的名字，官方建议不超过 10 个字符，必须字段。 shortcutLongLabel为 shortcut 列表中每个 shortcut 的名字，不宜过长，如果过长或未设置默认会显示 ShortLabel，官方建议不超过 25 个字符。可选字段。 icon为 shortcut 的 icon，在列表展示和拖动到桌面时显示需要，可选字段。 enabled表示 shortcut 是否可用，false 表示禁用。xml 中这个属性几乎没有被设置为 false 的实际场景，具体原因可见6.7 如何更好的删除(废弃)老的 Shortcut中介绍。 shortcutDisabledMessage为已固定在桌面的 shortcut 被 Disabled 后点击时的 Toast 提示内容。可选字段。 intent为点击 shortcut 时响应的 intent，必须字段。可以添加多个 intent，但点击时不会启动所有 intent，而是启动最后一个 intent，在这个 intent 回退时会启动它前面一个 intent，相当于自动将所有 intent 添加到了堆栈。 intent可设置属性包括：android:action、android:data、android:mimeType、android:targetClass、android:targetPackage，其中android:action为必须属性。至此，一个静态的Shortcut创建结束了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>版本新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- Paint使用详解]]></title>
    <url>%2FView-%E8%87%AA%E5%AE%9A%E4%B9%89-%20Paint%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[参考：http://hencoder.com/ui-1-2/ Paint类的4个enum画笔填充样式 Style123456public static enum Style&#123; FILL(), FILL_AND_STROKE(), STROKE();&#125; 画笔线头样式 Cap123456public static enum Cap&#123; BUTT(), ROUND(), SQUARE();&#125; 两条直线相交后的样式 Join123456public static enum Join&#123; BEVEL(), MITER(), ROUND();&#125; 文字对齐方式 Align123456public static enum Align&#123; CENTER(), LEFT(), RIGHT();&#125; Paint的功能 颜色 效果 绘制文本 初始化 1. 颜色1.1 基本颜色绘制 基本颜色绘制表示：基础颜色的设置，分类的标准就是根据不同颜色设置方式。 Paint 设置颜色的方法：Paint.setColor/ARGB 来设置颜色123paint.setColor(Color.parseColor("#009688")); paint.setColor(Color.BLACK);paint.setARGB(100, 255, 0, 0); Shader 来指定着色方案Shader 中文名是“着色器”。 注意：在设置了 Shader 的情况下， Paint.setColor/ARGB 所设置的颜色就不再起作用。 在Android中并不是直接使用“Shader类”，而是使用它的子类： LinearGradient（线性渐变） RadialGradient（辐射渐变） SweepGradient（扫描渐变） BitmapShader（Bitmap着色） ComposeShader（组合着色） 其中前三者：LinearGradient（线性渐变）, RadialGradient（辐射渐变）, SweepGradient（扫描渐变）同xml绘制图形中有形同的样式。Shader作为一个基类，包含有一个enum类： public enum TileMode { /** * 如果着色器在其原始边界之外绘制，则复制边缘颜色 */ CLAMP (0), /** * 重复着色器的图像水平和垂直 */ REPEAT (1), /** * 复着色器的图像水平和垂直，交替镜像 */ MIRROR (2); TileMode(int nativeInt) { this.nativeInt = nativeInt; } final int nativeInt; } 1 LinearGradient 线性渐变使用： Shader shader = new LinearGradient(100, 100, 500, 500, Color.parseColor(&quot;#E91E63&quot;), Color.parseColor(&quot;#2196F3&quot;), Shader.TileMode.CLAMP); paint.setShader(shader); 此类的构造器 /** * Create a shader that draws a linear gradient along a line. * * @param x0 The x-coordinate for the start of the gradient line * @param y0 The y-coordinate for the start of the gradient line * @param x1 The x-coordinate for the end of the gradient line * @param y1 The y-coordinate for the end of the gradient line * @param colors The colors to be distributed along the gradient line * @param positions May be null. The relative positions [0..1] of * each corresponding color in the colors array. If this is null, * the the colors are distributed evenly along the gradient line. * @param tile The Shader tiling mode */ LinearGradient(float x0, float y0, float x1, float y1, @NonNull @ColorInt int colors[], @Nullable float positions[], @NonNull TileMode tile) 参数： x0 y0 x1 y1：渐变的两个端点的位置 color0 color1“ 是端点的颜色 tile：端点范围之外的着色规则，类型是 TileMode 2 RadialGradient 辐射渐变使用： Shader shader = new RadialGradient(300, 300, 200, Color.parseColor(&quot;#E91E63&quot;), Color.parseColor(&quot;#2196F3&quot;), Shader.TileMode.CLAMP); paint.setShader(shader); 构造方法： RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, TileMode tileMode)。 参数： centerX centerY：辐射中心的坐标 radius：辐射半径 centerColor：辐射中心的颜色 edgeColor：辐射边缘的颜色 tileMode：辐射范围之外的着色模式。 3 SweepGradient 扫描渐变使用： Shader shader = new SweepGradient(300, 300, Color.parseColor(&quot;#E91E63&quot;), Color.parseColor(&quot;#2196F3&quot;)); paint.setShader(shader); 构造方法： SweepGradient(float cx, float cy, int color0, int color1) 参数： cx cy ：扫描的中心 color0：扫描的起始颜色 color1：扫描的终止颜色 4 BitmapShader Bitmap 来着色使用： Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.batman); Shader shader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); paint.setShader(shader); 通过使用：drawCircle() + BitmapShader就可以绘制圆形的 Bitmap，不用 drawBitmap() 了（其他形状同理）。 构造方法： BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY) 参数： bitmap：用来做模板的 Bitmap 对象 tileX：横向的 TileMode tileY：纵向的 TileMode。 5 ComposeShader 混合着色器（两个 Shader 一起使用）使用 // 第一个 Shader：头像的 Bitmap Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.batman); Shader shader1 = new BitmapShader(bitmap1, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 第二个 Shader：从上到下的线性渐变（由透明到黑色） Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.batman_logo); Shader shader2 = new BitmapShader(bitmap2, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // ComposeShader：结合两个 Shader Shader shader = new ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER); paint.setShader(shader); ComposeShader() 在硬件加速下是不支持两个相同类型的 Shader 的，所以这里也需要关闭硬件加速才能看到效果。如何 关闭硬件加速 ? 构造方法： ComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode) 参数： shaderA, shaderB：两个相继使用的 Shader mode: 两个 Shader 的叠加模式，即 shaderA 和 shaderB 应该怎样共同绘制。它的类型是 PorterDuff.Mode 。 PorterDuff.Mode 一共有 17 个，可以分为： Alpha 合成 (Alpha Compositing) 混合 (Blending) 具体使用参考：http://hencoder.com/ui-1-2/ 1.2 setColorFilter(ColorFilter colorFilter) 颜色过滤对每个像素的颜色进行过滤 在设置了对象的基础颜色之后，再对颜色进行设置就是针对“基础颜色”进行设置，不再是停留在对“对象颜色的填充”方面。Paint通过setColorFilter(ColorFilter filter) 方法设置 ColorFilter。 但是 ColorFilter 并不直接使用，而是使用它的子类： LightingColorFilter：模拟简单的光照效果 使用 ColorFilter lightingColorFilter = new LightingColorFilter(0x00ffff, 0x000000); paint.setColorFilter(lightingColorFilter); PorterDuffColorFilter ColorMatrixColorFilter 1.3 setXfermode(Xfermode xfermode)指的是你要绘制的内容和 Canvas 的目标位置的内容应该怎样结合计算出最终的颜色，就是要你以绘制的内容作为源图像，以 View 中已有的内容作为目标图像，选取一个 PorterDuff.Mode 作为绘制内容的颜色处理方案。 注意事项 使用离屏缓冲（Off-screen Buffer） 在绘制之前保存，绘制之后恢复： int saved = canvas.saveLayer(null, null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(rectBitmap, 0, 0, paint); // 画方 paint.setXfermode(xfermode); // 设置 Xfermode canvas.drawBitmap(circleBitmap, 0, 0, paint); // 画圆 paint.setXfermode(null); // 用完及时清除 Xfermode canvas.restoreToCount(saved); 控制好透明区域 2. 效果2.1 setAntiAlias (boolean aa) 抗锯齿效果抗锯齿默认是关闭的，如果需要抗锯齿，需要显式地打开。打开抗锯齿还有一个更方便的方式，可以在初始化的时候就开启抗锯齿： Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); 2.2 setStyle(Paint.Style style) 线条填充效果设置图形是线条风格还是填充风格的，也可以二者并用。 2.3 线条样式效果线条形状的一共有 4 个方法： setStrokeWidth(float width) ：设置线条宽度 setStrokeCap(Paint.Cap cap) ：设置线头的形状。 BUTT 平头 ROUND 圆头 SQUARE 方头 默认为 BUTT。 setStrokeJoin(Paint.Join join) : 设置拐角的形状。 MITER 尖角 BEVEL 平角 ROUND 圆角 默认为 MITER setStrokeMiter(float miter) : 是对于 setStrokeJoin() 的补充，设置 MITER 型拐角的延长线的最大值. 2.4 色彩优化效果 setDither(boolean dither) ：设置图像的抖动。 抖动更多的作用是在图像降低色彩深度绘制时，避免出现大片的色带与色块 paint.setDither(true); setFilterBitmap(boolean filter) ：双线性过滤来绘制 Bitmap。图像在放大绘制的时候会出现马赛克现象，如果开启了双线性过滤，就可以让结果图像显得更加平滑 paint.setFilterBitmap(true); 2.5 setPathEffect(PathEffect effect) 设置轮廓效果使用 PathEffect pathEffect = new DashPathEffect(new float[]{10, 5}, 10); paint.setPathEffect(pathEffect); 共有6 种 PathEffect： (1) CornerPathEffect -- 圆角 (2) DashPathEffect -- 虚线效果 (3) DiscretePathEffect -- 离散路径效果 (4) PathDashPathEffect -- 印章路径效果 (5) ComposePathEffect合并两个特效是有先后顺序的，它会先将第二个参数的PathEffect innerpe的特效作用于路径上，然后再在此加了特效的路径上作用第二个特效。 (6) SumPathEffect是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。 分为两类： 单一效果的 1. CornerPathEffect ：把所有拐角变成圆角 PathEffect pathEffect = new CornerPathEffect(20); paint.setPathEffect(pathEffect); 构造方法 CornerPathEffect(float radius) 的参数 radius 是圆角的半径。使用 //第1组 拐角弧度 Path path = new Path(); path.moveTo(100,200); path.lineTo(400,50); path.lineTo(700,200); path.lineTo(1000,70); canvas.drawPath(path,paintStyle(Color.GREEN,0,null,0)); //画布下移 canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.WHITE,50,null,0)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.YELLOW,100,null,0)); canvas.translate(0,200); private Paint paintStyle(int color, int corner, float[] floats, int phase) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); //设置拐角度数 paint.setPathEffect(new CornerPathEffect(corner)); //设置间断线 if (floats != null) { paint.setPathEffect(new DashPathEffect(floats,phase)); } paint.setStyle(Paint.Style.STROKE); return paint; } - **2. DiscretePathEffect** ：离散路径效果 PathEffect pathEffect = new DiscretePathEffect(20, 5); paint.setPathEffect(pathEffect); 构造方法 DiscretePathEffect(float segmentLength, float deviation) 的两个参数中， segmentLength 是用来拼接的每个线段的长度， deviation 是偏离量。 使用 //第3组 离散 canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.GREEN,2,14)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.WHITE,4,8)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.YELLOW,8,4)); private Paint paintStyle(int color,float someLength, float deviation) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); /** * segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为2的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。 deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。 */ paint.setPathEffect(new DiscretePathEffect(someLength,deviation)); paint.setStyle(Paint.Style.STROKE); return paint; } 3. DashPathEffect ：虚线效果 PathEffect pathEffect = new DiscretePathEffect(20, 5); paint.setPathEffect(pathEffect); 使用 //第2组 间隔线 float[] floats = new float[]{30,10}; float[] floats2 = new float[]{100,30}; float[] floats3 = new float[]{10,30,90,20}; /** * 对于intervals[]数组的有两个限定： 长度必须大于等于2；因为必须有一个实线段和一个空线段来组成虚线。 个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。 对于phase：开始绘制的偏移值 */ canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.GREEN,0,floats,0)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.WHITE,50,floats2,50)); canvas.translate(0,50); canvas.drawPath(path,paintStyle(Color.YELLOW,100,floats3,100)); canvas.translate(0,200); private Paint paintStyle(int color, int corner, float[] floats, int phase) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); //设置拐角度数 paint.setPathEffect(new CornerPathEffect(corner)); //设置间断线 if (floats != null) { paint.setPathEffect(new DashPathEffect(floats,phase)); } paint.setStyle(Paint.Style.STROKE); return paint; } - **4. PathDashPathEffect** ：印章路径效果 Path dashPath = ...; // 使用一个三角形来做 dash PathEffect pathEffect = new PathDashPathEffect(dashPath, 40, 0, PathDashPathEffectStyle.TRANSLATE); paint.setPathEffect(pathEffect); 构造方法 PathDashPathEffect(Path shape, float advance, float phase, PathDashPathEffect.Style style) shape ： 参数是用来绘制的 Path ； advance ：是两个相邻的 shape 段之间的间隔，不过注意，这个间隔是两个 shape 段的起点的间隔，而不是前一个的终点和后一个的起点的距离； phase “和 DashPathEffect 中一样，是虚线的偏移； style ：是用来指定拐弯改变的时候 shape 的转换方式。style 的类型为 PathDashPathEffect.Style ，是一个 enum ，具体有三个值： TRANSLATE：位移 ROTATE：旋转 MORPH：变体 使用 Path mPath = new Path(); mPath.moveTo(0,20); mPath.lineTo(10,0); mPath.lineTo(20,20); mPath.close(); /** *向路径添加一个闭圆轮廓 * Direction:方向 cw:顺时针, ccw:逆时针旋转 * @param x要添加到路径的圆的中心的x坐标 * @param y要添加到路径的圆的中心的y坐标 * @param radius要添加到路径的圆的半径 * @param dir滚动圆圈轮廓的方向 */ mPath.addCircle(0,0,3, Path.Direction.CCW); mPath.addCircle(20,0,3, Path.Direction.CW); canvas.translate(0,80);//通过变形印章来过渡转角 canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,30,12,PathDashPathEffect.Style.MORPH)); canvas.translate(0,80);//通过旋转印章来过渡转角 canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,40,12,PathDashPathEffect.Style.ROTATE)); canvas.translate(0,80);//通过位移来过渡转角 canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,80,12,PathDashPathEffect.Style.TRANSLATE)); private Paint paintStylePashDush(int color, Path shape, float advance, float phase, PathDashPathEffect.Style style) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); /** Path shape:表示印章路径，比如我们下面示例中的三角形加右上角一个点； float advance：表示两个印章路径间的距离,很容易理解，印章间距离越大，间距就越大。 float phase：路径绘制偏移距离，与上面DashPathEffect中的float phase参数意义相同 Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE; Style.ROTATE表示通过旋转印章来过渡转角； Style.MORPH表示通过变形印章来过渡转角； Style.TRANSLATE表示通过位移来过渡转角。 */ paint.setPathEffect(new PathDashPathEffect(shape,advance,phase,style)); paint.setStyle(Paint.Style.STROKE); return paint; } ![](http://oy991qm3u.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-15%2010.44.45.png) 组合效果 5. SumPathEffect ：分别按照两种 PathEffect 分别对目标进行绘制。 PathEffect dashEffect = new DashPathEffect(new float[]{20, 10}, 0); PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new SumPathEffect(dashEffect, discreteEffect); 6. ComposePathEffect ：也是一个组合效果类的 PathEffect 先对目标 Path 使用一个 PathEffect，然后再对这个改变后的 Path 使用另一个 PathEffect。 PathEffect dashEffect = new DashPathEffect(new float[]{20, 10}, 0); PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new ComposePathEffect(dashEffect, discreteEffect); 两者曲别： 第 5 种效果是分别将2种效果都绘制出来，2者都可见。第 6 种效果是县绘制第一种效果，然后在第一种效果上再绘制第二种效果，最终呈现的是：在第一种效果上的第二种效果 使用 canvas.translate(0,250); //通过变形印章来过渡转角 PathDashPathEffect dashPathEffect = new PathDashPathEffect(mPath,40,0,PathDashPathEffect.Style.TRANSLATE); DiscretePathEffect discretePathEffect = new DiscretePathEffect(20,2); canvas.drawPath(path,paintStyleEffectCompose(Color.GREEN,discretePathEffect,dashPathEffect)); canvas.translate(0,140); //通过旋转印章来过渡转角 canvas.drawPath(path,paintStyleEffectSum(Color.GREEN,dashPathEffect,discretePathEffect)); //设置合并两个路径特效效果 private Paint paintStyleEffectCompose(int color, PathEffect effect1, PathEffect effect2) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); paint.setPathEffect(new ComposePathEffect(effect1,effect2)); paint.setStyle(Paint.Style.STROKE); return paint; } //设置合并两个路径特效效果 private Paint paintStyleEffectSum(int color, PathEffect effect1, PathEffect effect2) { Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); paint.setPathEffect(new SumPathEffect(effect1,effect2)); paint.setStyle(Paint.Style.STROKE); return paint; } 注意：PathEffect 在有些情况下不支持硬件加速，需要关闭硬件加速才能正常使用： Canvas.drawLine() 和 Canvas.drawLines() 方法画直线时，setPathEffect() 是不支持硬件加速的； PathDashPathEffect 对硬件加速的支持也有问题，所以当使用 PathDashPathEffect 的时候，最好也把硬件加速关了。 2.6 setShadowLayer(float radius, float dx, float dy, int shadowColor) 在之后的绘制内容下面加一层阴影如果要清除阴影层，使用 clearShadowLayer() 。 注意：在硬件加速开启的情况下， setShadowLayer() 只支持文字的绘制，文字之外的绘制必须关闭硬件加速才能正常绘制阴影。如果 shadowColor 是半透明的，阴影的透明度就使用 shadowColor 自己的透明度；而如果 shadowColor 是不透明的，阴影的透明度就使用 paint 的透明度。 2.7 setMaskFilter(MaskFilter maskfilter)基于整个画面来进行过滤 BlurMaskFilter ：模糊效果 paint.setMaskFilter(new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL)); 构造方法 BlurMaskFilter(float radius, BlurMaskFilter.Blur style) radius： 参数是模糊的范围 style： 是模糊的类型，共有四种： NORMAL: 内外都模糊绘制 SOLID: 内部正常绘制，外部模糊 INNER: 内部模糊，外部不绘制 OUTER: 内部不绘制，外部模糊 EmbossMaskFilter ：浮雕效果 2.8 获取绘制的 Path根据 paint 的设置，计算出绘制 Path 或文字时的 实际 Path。实际 Path ，指的就是 drawPath() 的绘制内容的轮廓，要算上线条宽度和设置的 PathEffect。 getFillPath(src, dst) 会计算出实际 Path，然后把结果保存在 dst 里。 getTextPath(String text, int start, int end, float x, float y, Path path) getTextPath(char[] text, int index, int count, float x, float y, Path path) 文字的绘制虽然使用 Canvas.drawText() 方法，但其实在下层，文字信息全是被转化成图形，对图形进行绘制的。 getTextPath() 方法，获取的就是目标文字所对应的 Path 。这两个方法， getFillPath() 和 getTextPath() ，就是获取绘制的 Path 的方法。之所以把它们归类到「效果」类方法，是因为它们主要是用于图形和文字的装饰效果的位置计算。 3 绘制文本实例公共方法private Paint paintStyle(int color, Paint.Style style){ Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); //设置文字对齐方式，取值：align.CENTER、align.LEFT或align.RIGHT paint.setTextAlign(Paint.Align.LEFT); //设置是否为粗体文字 paint.setFakeBoldText(false); //设置下划线 paint.setUnderlineText(false); //设置字体水平倾斜度，普通斜体字是-0.25 paint.setTextSkewX(/*(float) -0.25*/0f); //设置带有删除线效果 paint.setStrikeThruText(false); //只会将水平方向拉伸，高度不会变 paint.setTextScaleX(0); return paint; } private Paint paintStyleType(int color, Paint.Style style, Typeface typeface){ Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); paint.setTypeface(typeface); return paint; } private Paint paintStyleAlign(int color, Paint.Style style, Paint.Align align){ Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); paint.setTextAlign(align); return paint; } 基础的文字绘制//基线坐标(100,100) //第1个 基线坐标(100,100) canvas.drawText(strs,100,100,paintStyleAlign(Color.BLACK,Paint.Style.FILL, Paint.Align.LEFT)); //绘制基线Y轴 canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); //绘制基线X轴 canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE)); //第2个 canvas.translate(0,150); canvas.drawText(strs,600,100,paintStyleAlign(Color.BLACK,Paint.Style.FILL, Paint.Align.CENTER)); canvas.drawLine(600,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); canvas.drawLine(600,0,600,100,paintStyle(Color.RED,Paint.Style.STROKE)); //第3个 canvas.translate(0,100); canvas.drawText(strs,100,100,paintStyleAlign(Color.BLACK,Paint.Style.STROKE, Paint.Align.LEFT)); canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE)); //第4个 canvas.translate(0,100); canvas.drawText(strs,600,100,paintStyleAlign(Color.BLACK,Paint.Style.STROKE, Paint.Align.RIGHT)); canvas.drawLine(600,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); canvas.drawLine(600,0,600,100,paintStyle(Color.RED,Paint.Style.STROKE)); FontMetrics 字体的各种度量的类/** * 描述给定文本大小字体的各种度量的类。 请记住，Y值增加下降，所以这些值将是正的，测量距离上升的值将是负的 * 注意:在使用FontMetrics时必须为同一个Paint对象,否则,无法获取文字正确的位置关系 */ Paint paint12 = new Paint(); paint12.setAntiAlias(true); paint12.setStrokeWidth(2); paint12.setStyle(Paint.Style.STROKE); paint12.setColor(Color.BLACK); paint12.setTextSize(180); Paint.FontMetrics fontMetrics = paint12.getFontMetrics(); //可绘制的最高高度所在线 float top; //可绘制的最低高度所在线 float bottom; //系统建议的，绘制单个字符时，字符应当的最高高度所在线 float ascent; //系统建议的，绘制单个字符时，字符应当的最低高度所在线 float descent; /** * 建议在文本行之间添加的额外空格。 */ //fontMetrics.leading; top = 100 + fontMetrics.top; bottom = 100 + fontMetrics.bottom; ascent = 100 + fontMetrics.ascent; descent = 100 + fontMetrics.descent; canvas.translate(-90,300); canvas.drawText(strs,100,100,paint12); //绘制的文字基线 paint12.setStrokeWidth(2); canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE)); //可绘制的最高高度所在线 paint12.setColor(Color.RED); paint12.setStrokeWidth(4); canvas.drawLine(100,top,1080,top,paint12); //可绘制的最低高度所在线 paint12.setColor(Color.GREEN); paint12.setStrokeWidth(4); canvas.drawLine(100,bottom,1080,bottom,paint12); //系统建议的，绘制单个字符时，字符应当的最高高度所在线 paint12.setColor(Color.YELLOW); paint12.setStrokeWidth(2); canvas.drawLine(100,ascent,1080,ascent,paint12); //系统建议的，绘制单个字符时，字符应当的最低高度所在线 paint12.setColor(Color.BLACK); paint12.setStrokeWidth(2); canvas.drawLine(100,descent,1080,descent,paint12); //文字所占宽度 float width = paint12.measureText(strs); //文字所占高度 float height = bottom - top; Log.e(TAG, &quot;onDraw width: &quot; + width + &quot;, height : &quot; + height); //绘制文字所占区域的边框 Path pathRect = new Path(); RectF rectF2 = new RectF(100,top,width+100,bottom); paint12.setColor(Color.BLUE); paint12.setStrokeWidth(1); pathRect.addRect(rectF2, Path.Direction.CW); canvas.drawRect(rectF2,paint12); 根据路径绘制文字PathMeasure measure = new PathMeasure(pathRect,false); int length = (int) measure.getLength(); paint12.setTextSize(40); paint12.setColor(Color.RED); canvas.drawText(String.valueOf(length),width,bottom,paint12); //根据路径绘制文字 paint12.setColor(Color.BLACK); paint12.setTextSize(90); canvas.translate(0,200); Path rectPath = new Path(); RectF rectF = new RectF(400,200,1000,800); //顺时针 rectPath.addRect(rectF, Path.Direction.CW); canvas.drawPath(rectPath,paintStyle(Color.RED,Paint.Style.STROKE)); /** * @param hOffset 要添加到文本开始位置的路径上的距离 * @param vOffset（ - ）或以下的距离（+）定位文本的路径 */ paint12.setStyle(Paint.Style.FILL_AND_STROKE); canvas.drawTextOnPath(strs,rectPath,0,0,paint12); paint12.setStyle(Paint.Style.STROKE); canvas.drawTextOnPath(strs,rectPath,20,20,paint12); paint12.setStyle(Paint.Style.STROKE); paint12.setColor(Color.BLUE); canvas.drawTextOnPath(strs,rectPath,-20,-20,paint12); 顺时针 逆时针 4 初始化类这一类方法是用来初始化 Paint 对象，或者是批量设置 Paint 的多个属性的方法。 4.1 reset()重置 Paint 的所有属性为默认值。相当于重新 new 一个，不过性能当然高一些啦。 4.2 set(Paint src)把 src 的所有属性全部复制过来。相当于调用 src 所有的 get 方法，然后调用这个 Paint 的对应的 set 方法来设置它们。 4.3 setFlags(int flags)批量设置 flags。相当于依次调用它们的 set 方法。例如：  paint.setFlags(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG); 这行代码，和下面这两行是等价的： paint.setAntiAlias(true); paint.setDither(true);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- onDraw() 绘制图表]]></title>
    <url>%2FView-%E8%87%AA%E5%AE%9A%E4%B9%89-%20onDraw()%20%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[总结 步骤分析数据的表现形式 坐标系 饼状图 数据准备，获取图表的： 标题 各个数据项的名称 各个数据项的数值 将数据进行封装 在设定item尺寸范围时，需要设定： 规定好起始位置（X轴或Y轴的startValue） 坐标系确定好原点（0，0） 饼状图确定好圆心 各个item之间的间隔（space） 单个item的宽度或高度（比值） 直方图、折线图时平均分配item的高度、宽度； 饼状图时各个数据所占的扇形面积的大小（当前数据所占比例*360）。 有无特殊要求？具体实现标记重点：在自定义图表的实现过程中，尽量使用“对象获取”、“比例化”的数据。 两个图使用的同一个数据类：PhoneData1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class PhoneData &#123; String phoneName; float phoneValue; int phoneColor; public PhoneData(String phoneName, float phoneValue, int phoneColor) &#123; this.phoneName = phoneName; this.phoneValue = phoneValue; this.phoneColor = phoneColor; &#125; public String getPhoneName() &#123; return phoneName; &#125; public void setPhoneName(String phoneName) &#123; this.phoneName = phoneName; &#125; public float getPhoneValue() &#123; return phoneValue; &#125; public void setPhoneValue(float phoneValue) &#123; this.phoneValue = phoneValue; &#125; public int getPhoneColor() &#123; return phoneColor; &#125; public void setPhoneColor(int phoneColor) &#123; this.phoneColor = phoneColor; &#125; @Override public String toString() &#123; return "PhoneData&#123;" + "phoneName='" + phoneName + '\'' + ", phoneValue=" + phoneValue + ", phoneColor=" + phoneColor + '&#125;'; &#125;&#125; 坐标系的实现：一个完整的类，包括注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213/** * 直角坐标系 * * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class Histogram extends View &#123; private static final String TAG = "Histogram"; private String titleName = "直角坐标系"; private List&lt;PhoneData&gt; mPhoneData = null; private float maxVal = 0f; private float totalVal = 0f; private Paint mPaint = null; private DecimalFormat mDecimalFormat; public Histogram(Context context) &#123; super(context); &#125; public Histogram(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public Histogram(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void initData() &#123; mPhoneData = new ArrayList&lt;&gt;(); mPhoneData.add(new PhoneData("HuaWei", 38f, Color.RED)); mPhoneData.add(new PhoneData("Vivo", 23f, Color.BLUE)); mPhoneData.add(new PhoneData("Samsung", 33f, Color.GREEN)); mPhoneData.add(new PhoneData("Oppo", 12f, Color.YELLOW)); mPhoneData.add(new PhoneData("Apple", 41f, Color.MAGENTA)); mPhoneData.add(new PhoneData("XiaoMi", 17f, Color.LTGRAY)); mPhoneData.add(new PhoneData("Pixel2", 6f, Color.DKGRAY)); mPhoneData.add(new PhoneData("HTC", 11f, Color.MAGENTA)); mPhoneData.add(new PhoneData("MOTO", 9f, Color.CYAN)); for (PhoneData item : mPhoneData) &#123; maxVal = Math.max(maxVal, item.getPhoneValue()); totalVal = totalVal + item.getPhoneValue(); &#125; dealMaxVal(maxVal); Log.d(TAG, "(&gt;^ω^&lt;) -&gt; initData maxVal is : " + maxVal + ", totalVal is : " + totalVal); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); mPaint.setColor(Color.BLACK); mDecimalFormat = new DecimalFormat(".00"); &#125; private void dealMaxVal(float maxVal) &#123; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); initData(); mPaint.setStrokeWidth(1); mPaint.setTextSize(56); canvas.drawText(titleName, canvas.getWidth() / 2 - mPaint.measureText(titleName) / 2, canvas.getHeight() * 0.07f, mPaint); mPaint.setColor(Color.BLACK); canvas.translate(canvas.getWidth() * 0.1f, canvas.getHeight() * 0.9f); mPaint.setStrokeWidth(5); //方式：2,两者均可实现绘制 canvas.drawLine(0f, 0f, canvas.getWidth() * 0.8f, 0f, mPaint); canvas.drawLine(0f, 0f, 0f, -canvas.getHeight() * 0.8f, mPaint); //item的宽度和间隔 float itemWidth = canvas.getWidth() * 0.8f / mPhoneData.size() * 0.8f; float itemSpace = canvas.getWidth() * 0.8f / mPhoneData.size() * 0.2f; //绘制直方图 drawRect(canvas, itemSpace, itemWidth, maxVal); //绘制数值文字 drawTextValue(canvas, itemSpace, itemWidth, maxVal); //绘制折线 drawLines(canvas, itemSpace, itemWidth, maxVal); //绘制点 drawPoint(canvas, itemSpace, itemWidth, maxVal); //绘制最高数值参考线 drawKindOfValLine(canvas, itemSpace, itemWidth); &#125; private void drawKindOfValLine(Canvas canvas, float itemSpace, float itemWidth) &#123; int maxValIndex = 0; mPaint.setColor(Color.BLUE); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStrokeWidth(2); float aveVal = totalVal / mPhoneData.size(); for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; if (maxVal == mPhoneData.get(i).getPhoneValue()) &#123; maxValIndex = i; &#125; &#125; //最大值的表示 float valueYMax = -maxVal / maxVal * canvas.getHeight() * 0.7f; String maxStr = mDecimalFormat.format(mPhoneData.get(maxValIndex).getPhoneValue()); canvas.drawLine(0f, valueYMax, maxValIndex * (itemSpace + itemWidth) + (itemSpace + itemWidth / 2), valueYMax, mPaint); canvas.drawText(maxStr, -mPaint.measureText(maxStr) - 10f, valueYMax, mPaint); //平均值的表示 float valueYAve = -aveVal / maxVal * canvas.getHeight() * 0.7f; String aveStr = mDecimalFormat.format(aveVal); canvas.drawLine(0f, valueYAve, canvas.getWidth() * 0.8f, valueYAve, mPaint); canvas.drawText(aveStr, -mPaint.measureText(aveStr) - 10f, valueYAve, mPaint); &#125; private void drawRect(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; float startXY = 0f; mPaint.setTextSize(36); mPaint.setStrokeWidth(1); for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); //绘制X轴文字 - 横向 canvas.drawText(item.getPhoneName(), startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2, 60, mPaint); //绘制X轴文字 - 有一定角度 /* Path path = new Path(); path.moveTo(startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2, 30); path.lineTo(startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2 + 30, 30 + mPaint.measureText(item.getPhoneName())); canvas.drawTextOnPath(item.getPhoneName(),path,0,0,mPaint);*/ //绘制直方图 canvas.drawRect(startXY + itemSpace, -item.getPhoneValue() / maxVal * canvas.getHeight() * 0.7f, startXY + itemSpace + itemWidth, 0, mPaint); //重新绘制item的起始点 startXY += itemSpace + itemWidth; &#125; &#125; private void drawTextValue(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; float startXY = 0f; mPaint.setTextSize(36); mPaint.setStrokeWidth(1); for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); //绘制直方图上方的数值文字 canvas.drawText(String.valueOf(item.getPhoneValue()), startXY + itemSpace + (itemWidth - mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2, -item.getPhoneValue() / maxVal * canvas.getHeight() * 0.7f - 20f, mPaint); //重新绘制item的起始点 startXY += itemSpace + itemWidth; &#125; &#125; private void drawPoint(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(20); mPaint.setStrokeCap(Paint.Cap.ROUND); float startX = itemSpace + itemWidth / 2; float startY = 0f; for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; canvas.drawPoint(startX, startY, mPaint); startX = startX + itemSpace + itemWidth; &#125; &#125; private void drawLines(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(5); float startX = itemSpace + itemWidth / 2; float startY = 0f; float endX = 0f; for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; if (i == 0) &#123; startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; canvas.drawPoint(startX, startY, mPaint); &#125; else &#123; endX = startX + itemSpace + itemWidth; canvas.drawLine(startX, startY, endX, -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f, mPaint); startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; startX = endX; &#125; &#125; &#125;&#125; /* 绘制x，y轴 方式：1 canvas.drawLine(canvas.getWidth() * 0.1f, canvas.getHeight() * 0.9f,canvas.getWidth() * 0.9f,canvas.getHeight() * 0.9f,mPaint); canvas.drawLine(canvas.getWidth() * 0.1f,canvas.getHeight() * 0.9f,canvas.getWidth() * 0.1f,canvas.getHeight() * 0.1f,mPaint); */ 饼状图的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * PieChart 饼状图 * * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class PieChart extends View &#123; private static final String TAG = "PieChart"; private String titleName = "饼状图"; private List&lt;PhoneData&gt; mPhoneData = null; private float maxVal = 0f; private float totalVal = 0f; private Paint mPaint = null; /** * 起始角度 */ private float startAngle; /** * 划过角度 */ private float swepAngle; /** * 划过角度的一半 */ private float halfSwepAngle; /** * 指示文字的标线 X 轴起始点。 */ private float lineStartX; private float lineStartY; private float lineEndX; private float lineEndY; private float radius = 0f; private float divideStart = 90; private float divideEnd = 270; private DecimalFormat decimalFormat; public PieChart(Context context) &#123; super(context); &#125; public PieChart(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public PieChart(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void initData()&#123; mPhoneData = new ArrayList&lt;&gt;(); mPhoneData.add(new PhoneData("HuaWei",38f, Color.RED)); mPhoneData.add(new PhoneData("Vivo",23f,Color.BLUE)); mPhoneData.add(new PhoneData("Samsung",33f,Color.GREEN)); mPhoneData.add(new PhoneData("Oppo",12f,Color.YELLOW)); mPhoneData.add(new PhoneData("Apple",41f,Color.MAGENTA)); mPhoneData.add(new PhoneData("XiaoMi",17f,Color.LTGRAY)); mPhoneData.add(new PhoneData("Pixel2",6f,Color.DKGRAY)); for (PhoneData item : mPhoneData) &#123; maxVal = Math.max(maxVal,item.getPhoneValue()); totalVal = totalVal + item.getPhoneValue(); &#125; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); mPaint.setStrokeWidth(1); mPaint.setColor(Color.BLACK); //构造方法的字符格式这里如果小数不足2位,会以0补足. decimalFormat=new DecimalFormat("######0.00"); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); /* 圆点坐标：(x0,y0) 半径：r 角度：a0 则圆上任一点为：（x1,y1） x1 = x0 + r * cos(ao * 3.14 /180 ) y1 = y0 + r * sin(ao * 3.14 /180 ) */ initData(); mPaint.setTextSize(56); canvas.drawText(titleName,canvas.getWidth()/2 - mPaint.measureText(titleName)/2, canvas.getHeight() * 0.07f,mPaint); //移动画布的原点 canvas.translate(canvas.getWidth() / 2,canvas.getWidth() / 2 - 100f); float length = canvas.getWidth() * 0.25f; RectF rectF = new RectF(-length, -length,length,length); mPaint.setStrokeWidth(5); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStyle(Paint.Style.FILL); mPaint.setTextSize(36); radius = length; for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); swepAngle = item.getPhoneValue() / totalVal * 360f; halfSwepAngle = startAngle + swepAngle / 2; /* * 角度=弧度*180/Math.PI 圆点坐标：(x0,y0) 半径：r 角度：a0 则圆上任一点为：（x1,y1） x1 = x0 + r * cos(ao * 3.14 /180 ) y1 = y0 + r * sin(ao * 3.14 /180 ) */ lineStartX = (float) (radius * Math.cos(halfSwepAngle * Math.PI / 180)); lineStartY = (float) (radius * Math.sin(halfSwepAngle * Math.PI / 180)); lineEndX = (float) ((radius + 50) * Math.cos(halfSwepAngle * Math.PI / 180)); lineEndY = (float) ((radius + 50) * Math.sin(halfSwepAngle * Math.PI / 180)); if (maxVal == item.getPhoneValue()) &#123; //注意先保存当前canvas canvas.save(); canvas.translate(lineStartX * 0.1f, lineStartY * 0.1f); canvas.drawArc(rectF, startAngle, swepAngle - 2f, true, mPaint); canvas.drawLine(lineStartX,lineStartY,lineEndX,lineEndY,mPaint); //绘制各个区域的文字 diffLineLength(canvas, item); //绘制各个区域的数值 diffLineVal(canvas, item); //绘制百分比 //diffPercentage(canvas,item); &#125; else &#123; canvas.drawArc(rectF,startAngle,swepAngle - 2f,true,mPaint); canvas.drawLine(lineStartX,lineStartY,lineEndX,lineEndY,mPaint); diffLineLength(canvas, item); diffLineVal(canvas, item); //diffPercentage(canvas,item); &#125; if (maxVal == item.getPhoneValue()) &#123; // 特殊工作做完之后，再回复之前保存的canvas canvas.restore(); &#125; startAngle += swepAngle; &#125; &#125; private void diffLineLength(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; canvas.drawLine(lineEndX, lineEndY, lineEndX - 100, lineEndY, mPaint); canvas.drawText(item.getPhoneName(), lineEndX - 120 - mPaint.measureText(item.getPhoneName()), lineEndY, mPaint); &#125; else &#123; canvas.drawLine(lineEndX,lineEndY,lineEndX + 100,lineEndY,mPaint); canvas.drawText(item.getPhoneName(),lineEndX + 120,lineEndY,mPaint); &#125; &#125; private void diffLineVal(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; mPaint.setColor(Color.WHITE); canvas.drawText(String.valueOf(item.getPhoneValue()),(lineEndX - (mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2) * 0.5f,(lineEndY) * 0.5f, mPaint); &#125; else &#123; mPaint.setColor(Color.WHITE); canvas.drawText(String.valueOf(item.getPhoneValue()),(lineEndX + (mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2) * 0.5f,(lineEndY) * 0.5f, mPaint); &#125; &#125; private void diffPercentage(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; mPaint.setColor(Color.WHITE); canvas.drawText(decimalFormat.format(item.getPhoneValue() / totalVal *100) + "%",(lineEndX - mPaint.measureText(decimalFormat.format(item.getPhoneValue()))) / 2,(lineEndY) * 0.5f, mPaint); &#125; else &#123; mPaint.setColor(Color.WHITE); canvas.drawText(decimalFormat.format(item.getPhoneValue() / totalVal *100) + "%" ,(lineEndX - mPaint.measureText(decimalFormat.format(item.getPhoneValue()))) / 2,(lineEndY) * 0.5f, mPaint); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《Head First 设计模式》 设计原则：依赖倒置原则要依赖抽象，不要依赖具体类。 这个原则比起“针对接口编程，不针对实现编程”更加强调的是“抽象”。不让高层组件依赖底层组件，而且不论“高层”还是“底层”，两者都依赖“抽象”。 这个模式的学习，首先通过一个自己以前最常见的编码开始（自己在学校编写小项目时曾经真的这么写过 ，好囧啊 ﾍ(;´Д｀ﾍ) ）。 引出问题 这样看可能并不会特别直观，但是只要转换为图形…… 通过这个图形的，我们已经很直观的能看到问题的所在：有点“牵一发而动全身”的意思。这样的编写违背了面向接口编程的原则，而且耦合程度高：一个类与众多的类之间保持着依赖关系。 进行倒置 依赖倒置原则中的“倒置”究竟“倒”在哪里？“倒置”指的是和一般的OO设计思想方式相反，倒置你针对问题进行设计时的思维方式。 如何避免违反依赖倒置原则： 变量不可以持有具体类的引用。 在此例中，使用工厂方法来避免new 不要让类派生自具体的类。 不要覆盖基类中已实现的方法 抽象工厂模式的定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。抽象工厂的任务是定义创建一组产品的接口，接口内的每个方法负责创建一个具体的产品，同时我们利用实现抽象工厂子类来实现这个创建方法。抽象工厂中利用工厂方法实现生产方法是相当自然的做法。 停止于： 2017-11-08 15:10:25 专向：Android高级进阶]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StarUML的使用]]></title>
    <url>%2FStarUML%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[StarUML使用参考：http://blog.csdn.net/eyckwu/article/details/53871841UML学 : http://www.uml.org.cn/oobject/201104212.asp各种图（流程图，思维导图，UML，拓扑图，ER图）简介 ：http://www.cnblogs.com/jiqing9006/p/3344221.html 码云拾遗 明星效应。很简单，在一个领域保持顶尖水平，比在一两个领域保持领先水平和五六个领域保持一般水准都要更有价值、并且收益更好。 有悖常识的真相：让未来更开放的方式，正是专注的去做好一件事情。这个世界上最成功的人，他们在某一领域获得成功之后，可通过经营杠杆进入任何他们想要涉足的领域。而这都得依赖于他们曾极致的专注在做好一件事情上。 正文StarUML是一个韩国人用DELPHI写的UML工具，支持UML2.0。 UML： 静态建模：系统基础和系统固定框架结构，这些图形往往是“静态”的。 类图(Class Diagram)：常用来分析业务概念 用例图(Use Case Diagram)：由参与者、用例以及它们之间的关系构成的 使用参考：https://www.2cto.com/os/201502/377091.html 参与者：是指存在于系统外部并直接与系统交互的人、系统或设备等。 用例：是系统为参与者提供的功能。 用例命名：取一个简单、概括性的名称，一般是带有动作性的名称。 用例表示：用椭圆表示，椭圆下面附有用例的名称、实线箭头，在用例图中用于连接参与者与用例，用例方向指向用例。 用例与用例之间的三种关系： 1. 泛化（generalization）代表一般与特殊的关系 2. 包含（include）关系 3. 扩展（extend）关系 对象图(Object Diagram) 构件图(Component Diagram)：表示组件之间的关系 部署图(Deployment Diagram)：部署软件应用的物理设备信息 2. 动态建模：描述的是某种行为，是“动态”的。 活动图(Activity Diagram)：类似流程图 状态机图(State Machine Diagram) 时序图(Sequence Diagram)：捕捉一段时间范围内多个对象之间的交互信息， 强调信息交互的时间顺序。 通讯图(Communication Diagram) 时间图(Timing Diagram) StarUML使用Mode的选择选择更为具体的图 添加更为丰富的元素 类图的画法概览 如上图是一个类图，下面对每一个图标的内容进行解释（从左到右，从从上到下）。左侧： 标识Class的可见性（默认public） 添加note，进行对类的说明 右侧： 增加类的属性 增加类的行为 添加reception 添加子类 添加父类 添加已有的接口 添加需要的接口 添加关联 添加聚合 添加组合 添加端口 添加组件 具体1. 类图包括：类名 + 属性 + 方法 2. 类图之间的关系1. 泛化（Generalization）： 就是面向对象中的继承，奔驰、宝马、奥迪都继承自汽车类 表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节，直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 2. 实现（interface Realization）：圆圈代表接口 一般接口实现的画法及表示：在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。 3. 依赖（Dependency）： 对象之间最弱的一种关联方式，是临时性的关联，代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。 一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。 在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。 StarUML的使用同下图 4. 关联4.1 一般关联(Association) : 对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。 在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 4.2 聚合关联(Aggregation) : 表示has-a的关系，是一种不稳定的包含关系。 较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。 在类图使用空心的菱形表示，菱形从局部指向整体。 4.3 组合(Composition) : 表示contains-a的关系，是一种强烈的包含关系。 组合类负责被组合类的生命周期，是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。 在类图使用实心的菱形表示，菱形从局部指向整体。 5. 多重性(Multiplicity) :通常在关联、聚合、组合中使用。就是代表有多少个关联对象存在。使用数字..星号（数字）表示。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 Scrapy爬虫框架使用]]></title>
    <url>%2FPython3%20Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Scrapy框架使用指南：http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.htmlScrapy零基础使用：http://www.jb51.net/article/57183.htm 开题问：把网站装进爬虫需要几步？答：四步。 1. 新建项目2. 明确目标3. 制作爬虫4. 存储内容 注意：# coding=utf-8 使用Scrapy爬虫框架时应该添加此条语句表明注释是中文注释 1. 新建项目使用命令新建一个scrapy项目 scrapy startproject projectName 建立项目的文件目录 scrapyproject ├── scrapy.cfg └── scrapyproject ├── __init__.py ├── items.py ├── middlewares.py ├── pipelines.py ├── settings.py └── spiders └── __init__.py 2 directories, 7 files 各个文件的作用： scrapy.cfg ：项目的配置文件 scrapyproject/ ：项目的Python模块，将会从这里引用代码 scrapyproject/items.py ：项目的items文件 scrapyproject/pipelines.py ：项目的pipelines文件 scrapyproject/settings.py ：项目的设置文件 scrapyproject/spiders/ ：具体执行爬虫的目录 2. 明确目标在Scrapy中，items是用来管理抓取内容的容器，有点像Python中的Dict，但是提供了一些额外的保护减少错误。 一般来说，item可以用scrapy.item.Item类来创建，并且用scrapy.item.Field对象来定义属性（可以理解成类似于ORM映射关系，类似于java bean）。 编写Item：修改scrapyproject目录下的items.py4文件，在原本的class后面添加我们自己的class。 import scrapy class PyScrapy1601Item(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() pass class DmozItem(scrapy.Item): node = scrapy.Field() 3. 爬虫实现先爬后取 3.1 爬要建立一个Spider，你必须用scrapy.spider.BaseSpider创建一个子类，并确定三个强制属性： name ：爬虫的识别名称，必须是唯一的。 start_urls ：爬取的URL列表。爬虫从这里开始抓取数据。 parse() ：解析的方法，调用的时候传入从每一个URL传回的Response对象作为唯一参数，负责解析并匹配抓取的数据(解析为item)。 allow_domains ：allow_domains是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页。一个模板： from scrapy.spider import Spider from scrapy.selector import Selector from py_scrapy_16_01.py_scrapy_16_01.items import DmozItem class DmozSpider(Spider): name = &quot;dmoz&quot; allowed_domains = [&quot;dmoztools.net&quot;] start_urls = [ &quot;http://dmoztools.net/Computers/Programming/Languages/Python/&quot;, ] def parse(self, response): sel = Selector(response) sites = sel.xpath(&apos;//div[@class=&quot;browse-node&quot;]/text()&apos;) items2 = [] for node in sites: item = DmozItem() item[&apos;href&apos;] = node.extract() items2.append(item) return items2 进入到 /scrapyproject/scrapyproject下 运行 scrapy crawl dmoz 执行了这条命令发生了啥？首先，Scrapy为爬虫的 start_urls 属性中的每个URL创建了一个scrapy.http.Request 对象 ，并将爬虫的parse() 方法指定为回调函数。然后，这些 Request 被调度并执行，之后通过parse()方法返回 scrapy.http.Response 对象，并反馈给爬虫。 3.2 取爬取整个网页完毕，接下来的就是的取过程了。在基础的爬虫里，这一步可以用正则表达式来抓。在Scrapy里，使用一种叫做 XPath selectors的机制，它基于 XPath表达式。 例子：/html/head/title : 选择HTML文档元素下面的&lt;title&gt;标签。/html/head/title/text() : 选择前面提到的&lt;title&gt; 元素下面的文本内容//td: 选择所有 &lt;td&gt; 元素//div[@class=”mine”] : 选择所有包含 class=&quot;mine&quot; 属性的div标签元素 xpath路径表达式： 表达式 描述 / 从根节点选取 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 更多使用参考 W3C-XPath ：http://www.w3school.com.cn/xpath/index.asp 为了方便使用XPaths，Scrapy提供XPathSelector 类，有2种可以选择: HtmlXPathSelector (HTML数据解析) XmlXPathSelector (XML数据解析) 必须通过一个 Response 对象对他们进行实例化操作，如： sel = Selector(response) Selector对象展示了文档的节点结构。因此，第一个实例化的selector必与根节点或者是整个目录有关 。在Scrapy里面，Selectors 有4种基础的方法： xpath() ：返回一系列的selectors，每一个select表示一个xpath参数表达式选择的节点。 css() ：返回一系列的selectors，每一个select表示一个css参数表达式选择的节点。 extract() ：返回一个unicode字符串，即选中的数据。 re() ：返回一串一个unicode字符串，即使用正则表达式抓取出来的内容。 3.3 xpath()测试在终端输入： scrapy shell http://dmoztools.net/Computers/Programming/Languages/Python/ 在没有报错的情况下，输入 response.headers 得到： 在没有报错的情况下，输入 response.body 得到： 4. 存储内容保存信息的最简单的方法是通过Feed exports，主要有4种：JSON，JSON lines，CSV，XML。我们将结果用最常用的JSON导出，命令如下： scrapy crawl dmoz -o items.json -t json 其中，-o 后面是导出文件名，-t 后面是导出类型。 5. Pycharm中运行爬虫程序错误1. NameError: global name ‘DmozItem’ is not definedFile &quot;/Users/yannischeng/PycharmProjects/First_Python_Project/spiderone/spiderone/spiders/dmoe_spider.py&quot;, line 20, in parse item = DmozItem() NameError: global name &apos;DmozItem&apos; is not defined 解决方案：使用相对导入 from ..items import DmozItem 第一个点(.) 表示当前目录，第二个点表示上一级父目录。这样做还有一个额外的好处就是你可以随意修改你的包的名称，松耦合。 2. Scrapy爬取中文，显示ascii码，如何转变成utf-8正常编码？ 参考：http://www.jianshu.com/p/c03d968ef68b 将爬取到的中文信息存储为json格式的文件时，文字显示就会出现问题，存储为xml时就不会有问题。本要求应该显示的是：摘要，而实际显示的内容为：\&quot;\u6458\u8981 解决方案：使用json包中的json.dumps(dictname,ensure_ascii=False)具体案例使用： item[&apos;node&apos;] = json.dumps(node.extract(), ensure_ascii=False) print(item[&apos;node&apos;]) 摘要: 把系统换到了fedora,记录几个相关的配置 3. scrapy` 的 parse() return 值必须是Request, BaseItem, dict or None，如果返回str报错[scrapy.core.scraper] ERROR: Spider must return Request, BaseItem, dict or None, got &apos;str&apos; in &lt;GET http://www.cnblogs.com/aLittleBitCool/&gt; 4. scrapy爬虫得到的json文件是ascii码问题 参考：http://bbs.fishc.com/thread-85672-1-1.html import json #记得添加这两个库 import codecs class XXXPipeline(object): #XXX就是你建立scrapy工程的名称 def __init__(self): #添加一下初始化方法 self.file = codecs.open(&apos;item.json&apos;, &apos;wb&apos;, encoding=&apos;utf-8&apos;) #item.json指的是你要保存的json格式文件的名称，编码格式一般都是&apos;utf-8&apos; def process_item(self, item, spider): line = json.dumps(dict(item),ensure_ascii=False) + &apos;\n&apos; #这一句会将你每次返回的字典抓取出来,“ensure_ascii=False”这一句话很重要，如果是True的话就是我们保存的\u4e2d\u56fd这种格式了 self.file.write(line) #写入到文件中 return item 将以上内容插入pipelines.py,同时在settings.py中加入 ITEM_PIPELINES = { &apos;panda.pipelines.PandaPipeline&apos;: 300 }]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境下MySQL的安装与使用]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[平台：Mac环境 mysql操作命令参考：http://www.runoob.com/mysql/mysql-tutorial.html 安装 官网下载地址 https://dev.mysql.com/downloads/file/?id=473576 默认安装目录 /usr/local/ 安装时弹出的默认密码，在第一次登录时需要用到： A temporary password is generated for root@localhost: gkct&gt;2Wajv5W 安装完成 登录mysql （连接远程数据库，默认端口号：3306） 远程连接 mysql -h主机地址 -u用户名 －p用户密码 登录mysql （连接本地数据库） mysql -u root -p 输入密码 登录后，修改密码 SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;新密码&apos;); 开启/关闭 - 手动 `系统偏好设置` -&gt; `mysql` 修改mysql编码 查看编码 默认设置： mysql&gt; show variables like &apos;%char%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.01 sec) 修改 在目录：/usr/local/mysql/support-files下找里面有没有my-default.cnf或my.cnf文件. 如果有则直接打开添加: 在[client]在下面添加 default-character-set=utf8 默认字符集为utf8 在[mysqld] 添加 default-character-set=utf8 默认字符集为utf8 设定连接mysql数据库时使用utf8编码，以让mysql数据库为utf8运行 init_connect=&apos;SET NAMES utf8&apos; 若是没有在/etc下新建my.cnf。执行命令： $ cd /etc $ sudo vim my.cnf 将 本文 附录内容粘贴到文件中后，保存退出即可。注意：修改完编码后要 退出之后再次进入 才能生效修改之后的编码设置 mysql&gt; show variables like &apos;%char%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.00 sec) 卸载MySQLsudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* vim /etc/hostconfig (and removed the line MYSQLCOM=-YES-) rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* MySQL操作命令 命令操作参考：http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html命令操作参考：http://blog.csdn.net/qi49125/article/details/77887100 数据库操作 查看版本号 select version(); 查询所有数据库 show database; 使用数据库 use 数据库名称 创建数据库 create database 数据库名 删除数据库 drop database 数据库名 备份数据库外部数据库 导入 登录 mysql -u root -p; 选择数据库 use databaseName; 将外部的.sql文件拖入终端中 source 命令后面，然后回车 source 拖如.sql文件; 内部数据库 导出 在终端中，要进入存储文件的目录，然后再执行导出操作 cd 待存文件的目录 导出MySQL中的所有数据库（结构+数据） mysqldump -u root -p --all-databases &gt; dafadf00.sql; 导出MySQL中的单个数据库（结构+数据） mysqldump -u root -p database_name &gt; sql_name.sql 导出单个数据库中的单张表，导出命令中加了一个表名（结构+数据） mysqldump -u root -p database_name table_name &gt; sql_name.sql 导出数据库的结构 （仅结构） mysqldump -u root -p --add-drop-table temp &gt; /Users/yannischeng/Desktop/outfile_name.sql 导出查询数据结果到指定文件 参考：http://blog.csdn.net/u011677147/article/details/64129606 在做mysql导出数据的时候，遇到的问题如下： ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement mysql 默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。解决方法： 查询mysql 的secure_file_priv配置，使用命令行： show global variables like &apos;%secure%&apos;; 查询结果 secure_file_prive=null -- 限制mysqld 不允许导入导出 secure_file_priv=/tmp/ -- 限制mysqld的导入导出只能发生在/tmp/目录下 secure_file_priv=&apos; &apos; -- 不对mysqld 的导入 导出做限制 更改secure_file_pri的值： /usr/local/mysql/support-files中的my-default.cnf配置文件，就把它复制到/private/etc中，重命名为“my.cnf”，并加入secure_file_priv=&apos;&apos;，重启mysql服务器即可。 使用 into outfile 开始导出： select * from table_name into outfile &apos;/Users/yannischeng/Desktop/NewFile.txt&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\n&apos;; 因为导出的数据会出现一些乱码或者特殊字符，所以使用以上关键字进行转义。 出现问题 ERROR 1 (HY000): Can&apos;t create/write to file &apos;/Users/yannischeng/Desktop/NewFile.txt&apos; (Errcode: 13 - Permission denied 表操作 use 数据库名; 删除表 drop table 表名; 删除表中数据 delete from 表名,……，…… where 表达式; 显示当前数据库的表 show tables; 显示表的数据结构 describe 表名; 或者 desc 表名; 或者 show columns from 表名; 创建表 mysql&gt; create table student( -&gt; id int(4) not null primary key auto_increment, -&gt; name char(20) not null, -&gt; age int(4) not null, -&gt; address char(100), -&gt; other varchar(100) default &quot;null&quot;); rename 修改表名 alter table 旧表名 rename 新表名; 或者 rename table 原表名 新表名; 修改表结构：增（add）、删（drop）、改（modify）、重命名（change）: 可通过after 字段名、first精确控制添加的位置。 add 增加字段 alter table 表名 add 字段名 字段设置 字段位置; modify 修改字段 alter table 表名 modify 字段名 字段设置 字段位置; change 重命名字段 alter table 表名 change 旧字段名 新字段名 字段设置; drop 删除字段 alter table 表名 drop 字段名; 数据操作 增 单条数据 insert into student (,&apos;yannis&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;); 多条数据 insert into student values (13,&apos;tom&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;),(21,&apos;jack&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;); 指定字段插入数据 insert into 表名 (字段名) values (&apos;数值&apos;); 删 delete from 表名 where 条件; 改 update 表名 set name=&apos;marry&apos; where id=13; 查 查询数据完整语法 select [distinct][统计函数] 字段名/* from 数据源 [where 条件子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]; distinct ：去重复 统计函数 ： Count()： 统计分组后的记录数，每一相同的组有多少行记录 Max()： 统计每组最大的值 Min()： 统计每组最小的值 Avg()： 统计每组的平均值 Sum()： 统计每组的和 where ：条件 group by 字段 ：分组。根据某个字段进行分组，相同的放一组，不同的分到不同的组。统计的是数据，不是记录。 having 子句 ：与where子句一样进行条件判断，为什么是group by……having…… 而不是group by……where? 因为：进行数据统计时，是数据进入内存之后，会进行分组 -&gt; 统计 -&gt; having条件判断。而where是针对从磁盘读取数据时进行判断，此刻还没分组，进行统计就判断了。所以错误！ order by 子句 ：order by根据某个字段进行升序或降序排序，基本语法： order by 字段名 [asc/desc]; asc升序 可不写 desc降序 limit 子句 ：是一种限制结果的语句。 1）用来限制数量 2) 限制起始位置 limit 起始位置，长度。分页常用。 内连接，外连接，自然连接，交叉连接 内连接：从左表中取出每一条记录，和右表中所有的记录进行匹配，匹配必须是左表中与右表中某个条件相同，最终会保留结果，否则不保留。基本语法： 左表 [inner] join 右表 on 左表.字段 = 右表.字段; select * from my_student inner join my_class on my_student.C_id = mu_class.id; 左外连接：左表为主，然后每条记录与右表进行连接，不管能不能匹配的上，左表都会保留。能匹配，右表某条记录保留，不能匹配，某条记录置为NULL，最终记录数至少不少于左表已有的记录。基本语法： 左表 left join 右表 on 左表.字段 = 右表.字段; 当前时间： select now(); 附录# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the &quot;--help&quot; option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 init_connect=&apos;SET NAMES utf8 port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect=&apos;SET NAMES utf8&apos; # Don&apos;t listen on a TCP/IP port at all. This can be a security enhancement, # if all processes that need to connect to mysqld run on the same host. # All interaction with mysqld must be made via Unix sockets or named pipes. # Note that using this option without enabling named pipes on Windows # (via the &quot;enable-named-pipe&quot; option) will render mysqld useless! # #skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master&apos;s port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST=&apos;125.564.12.1&apos;, MASTER_PORT=3306, # MASTER_USER=&apos;joe&apos;, MASTER_PASSWORD=&apos;secret&apos;; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables&apos; values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout]]></content>
      <categories>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 16-安装爬虫工具Scrapy]]></title>
    <url>%2FPython3%20%2016-%E5%AE%89%E8%A3%85%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7Scrapy%2F</url>
    <content type="text"><![CDATA[人生苦短，我用python。 安装Scrapy需要使用到：pip（python2）、pip3（python3），由于之前已经安装，此处忽略。 平台：Macpython2 pippython3 pip3 使用pip进行安装注意：安装过程还是比较曲折的 (〒︿〒) sudo pip install scrapy 错误 - 1 ： Found existing installation: six 1.4.1 DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project. Uninstalling six-1.4.1: ... OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-89wTP6-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info&apos; 根据网上得出的解决方案： 重启电脑，按住 option 键，–&gt; 再按 command + r 进入 Recovery模式 –&gt; 工具选择终端输入： csrutil disable 然后 reboot 再次执行 sudo pip install Scrapy 进行安装，结果依然出错。错误 - 2 ： Found existing installation: six 1.4.1 DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project. Uninstalling six-1.4.1: Successfully uninstalled six-1.4.1 Running setup.py install for PyDispatcher ... done Running setup.py install for Twisted ... done 注意： Running setup.py install for PyDispatcher ... done Running setup.py install for Twisted ... done 因为未安装 以上两个，导致 Scrapy未能安装成功。错误描述为： AttributeError: &apos;module&apos; object has no attribute &apos;OP_NO_TLSv1_1&apos; 安装 twisted $ pip install twisted==15.4.0 仍然报错 - 3 ： AttributeError: &apos;module&apos; object has no attribute &apos;OP_NO_TLSv1_1&apos; 更新pyOpenSSl sudo pip install --upgrade pyOpenSSl 最终出现： Successfully uninstalled pyOpenSSL-0.13.1 Successfully installed asn1crypto-0.23.0 cffi-1.11.2 cryptography-2.1.2 enum34-1.1.6 idna-2.6 ipaddress-1.0.18 pyOpenSSl-17.3.0 pycparser-2.18 然后输入： scrapy version 出现结果： Scrapy 1.4.0 安装成功！ 使用pip3进行安装 参考：http://www.jianshu.com/p/d00a19f6c4ed 提示：在使用 pip3 进行安装时，首先应该执行以下步骤： sudo -s pip3 install --ignore-installed six 否则报错： PermissionError: [Errno 13] Permission denied: &apos;/usr/local/Cellar/python3/3.6.1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/six.py&apos; 然后执行： sudo -s pip3 install scrapy 结果： Installing collected packages: cssselect, queuelib, w3lib, PyDispatcher, lxml, parsel, idna, pycparser, cffi, asn1crypto, cryptography, pyOpenSSL, pyasn1, attrs, pyasn1-modules, service-identity, hyperlink, incremental, zope.interface, Automat, constantly, Twisted, scrapy Successfully installed Automat-0.6.0 PyDispatcher-2.0.5 Twisted-17.9.0 asn1crypto-0.23.0 attrs-17.2.0 cffi-1.11.2 constantly-15.1.0 cryptography-2.1.2 cssselect-1.0.1 hyperlink-17.3.1 idna-2.6 incremental-17.5.0 lxml-4.1.0 parsel-1.2.0 pyOpenSSL-17.3.0 pyasn1-0.3.7 pyasn1-modules-0.1.5 pycparser-2.18 queuelib-1.4.2 scrapy-1.4.0 service-identity-17.0.0 w3lib-1.18.0 zope.interface-4.4.3 验证： YannisCheng:source yannischeng$ python3 Python 3.6.1 (default, Apr 4 2017, 09:40:21) [GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.38)] on darwin Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; import scrapy &gt;&gt;&gt; 安装成功]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 使用快人一步2 快捷键]]></title>
    <url>%2FAndroid%20Studio%E4%BD%BF%E7%94%A8%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A52%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[键盘快捷键 快捷键参考：https://developer.android.google.cn/studio/intro/keyboard-shortcuts.htmlAndroid Studio使用指南：https://developer.android.google.cn/studio/projects/android-library.html 常规 说明 Windows/Linux Mac 全部保存 Control + S Command + S 同步 Control + Alt + Y Command + Option + Y 最大化/最小化编辑器 Control + Shift + F12 Control + Command + F12 添加到收藏夹 Alt + Shift + F Option + Shift + F 使用当前配置文件检查当前文件 Alt + Shift + I Option + Shift + I 快速切换模式 Control + （反引号） Control + `（反引号） 打开设置对话框 Control + Alt + S Command + ,（英文逗号） 打开项目结构对话框 Control + Alt + Shift + S Command + ;（英文分号） 在标签和工具窗口之间切换 Control + Tab Control + Tab 在 Studio 内导航和搜索 说明 Windows/Linux Mac 搜索全部内容（包括代码和菜单） 按两次 Shift 按两次 Shift 查找 Control + F Command + F 查找下一个 F3 Command + G 查找上一个 Shift + F3 Command + Shift + G 替换 Control + R Command + R 查找操作 Control + Shift + A Command + Shift + A 按符号名称搜索 Control + Alt + Shift + N Command + Option + O 查找类 Control + N Command + O 查找文件（而不是类） Control + Shift + N Command + Shift + O 在路径中查找 Control + Shift + F Command + Shift + F 打开文件结构弹出式菜单 Control + F12 Command + F12 在打开的编辑器标签之前导航 Alt + 向右/向左箭头 Control + 向右/向左箭头 跳到源代码 F4 / Control + Enter F4 / Command + 向下箭头 在新窗口中打开当前编辑器标签 Shift + F4 Shift + F4 最近打开的文件弹出式菜单 Control + E Command + E 最近编辑的文件弹出式菜单 Control + Shift + E Command + Shift + E 转到上一个编辑位置 Control + Shift + 退格键 Command + Shift + 退格键 关闭活动编辑器标签 Control + F4 Command + W 从工具窗口返回到编辑器窗口 Esc Esc 隐藏活动或上一个活动工具窗口 Shift + Esc Shift + Esc 转到行 Control + G Command + L 打开类型层次结构 Control + H Control + H 打开方法层次结构 Control + Shift + H Command + Shift + H 打开调用层次结构 Control + Alt + H Control + Option + H s 编写代码 说明 Windows/Linux Mac 生成代码（getter、setter、构造函数、hashCode/equals、toString、新文件、新类） Alt + Insert Command + N 替换方法 Control + O Control + O 实现方法 Control + I Control + I 控制语句 (if…else / try…catch / etc.) Control + Alt + T Command + Option + T 删除插入符处的行 Control + Y Command + 退格键 折叠/展开当前代码块 Control + 减号/加号 Command + 减号/加号 折叠/展开所有代码块 Control + Shift + 减号/加号 Command + Shift + 减号/加号 复制当前行或选择 Control + D Command + D 基本代码自动完成 Control + 空格键 Control + 空格键 智能代码自动完成（按预期类型过滤方法和变量列表） Control + Shift + 空格键 Control + Shift + 空格键 完成语句 Control + Shift + Enter Command + Shift + Enter 快速文档查找 Control + Q Control + J 显示选定方法的参数 Control + P Command + P 转到声明（直接） Control + B 或 Control + 点击 Command + B 或 Command + 点击 转到实现 Control + Alt + B Command + Alt + B 转到超类方法/超类 Control + U Command + U 打开快速定义查找 Control + Shift + I Command + Y 切换项目工具窗口的可见性 Alt + 1 Command + 1 切换书签 F11 F3 通过助记切换书签 Control + F11 Option + F3 通过行注释添加注释/取消注释 Control + / Command + / 通过块注释添加注释/取消注释 Control + Shift + / Command + Shift + / 选择连续增加的代码块 Control + W Option + Up 将当前选择退回到上一个状态 Control + Shift + W Option + Down 移动到代码块起始位置 Control + [ Option + Command + [ 移动到代码块结束位置 Control + ] Option + Command + ] 从当前位置选择到代码块起始位置 Control + Shift + [ Option + Command + Shift + [ 从当前位置选择到代码块结束位置 Control + Shift + ] Option + Command + Shift + ] 从当前位置删除到单词结尾 Control + Delete Option + Delete 从当前位置删除到单词开头 Control + 退格键 Option + 退格键 优化导入 Control + Alt + O Control + Option + O 项目快速修复（显示意图操作和快速修复） Alt + Enter Option + Enter 重新格式化代码 Control + Alt + L Command + Option + L 自动缩进行 Control + Alt + I Control + Option + I 缩进/取消缩进行 Tab/Shift + Tab Tab/Shift + Tab 智能行合并 Control + Shift + J Control + Shift + J 智能行拆分 Control + Enter Command + Enter 开始新行 Shift + Enter Shift + Enter 下一个/上一个突出显示的错误 F2 / Shift + F2 F2 / Shift + F2 构建并运行 说明 Windows/Linux Mac 构建 Control + F9 Command + F9 构建并运行 Shift + F10 Control + R 调试 说明 Windows/Linux Mac 调试 Shift + F9 Control + D 跳过 F8 F8 逐步执行 F7 F7 智能逐步执行 Shift + F7 Shift + F7 跳出 Shift + F8 Shift + F8 运行到光标位置 Alt + F9 Option + F9 评估表达式 Alt + F8 Option + F8 继续运行程序 F9 Command + Option + R 切换断点 Control + F8 Command + F8 查看断点 Control + Shift + F8 Command + Shift + F8 重构 说明 Windows/Linux Mac 复制 F5 F5 移动 F6 F6 安全删除 Alt + Delete Command + Delete 重命名 Shift + F6 Shift + F6 更改签名 Control + F6 Command + F6 内联 Control + Alt + N Command + Option + N 提取方法 Control + Alt + M Command + Option + M 提取变量 Control + Alt + V Command + Option + V 提取字段 Control + Alt + F Command + Option + F 提取常量 Control + Alt + C Command + Option + C 提取参数 Control + Alt + P Command + Option + P 版本控制/本地历史记录 说明 Windows/Linux MacOS 将项目提交到 VCS Control + K Command + K 从 VCS 更新项目 Control + T Command + T 查看最近变更 Alt + Shift + C Option + Shift + C 打开 VCS 弹出式菜单 Alt + `（反引号） Control + V]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android资源文件-color]]></title>
    <url>%2FAndroid%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6-color%2F</url>
    <content type="text"><![CDATA[官方参考：https://material.io/guidelines/style/color.html#color-color-palette 16进制透明度 100%-0%123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101100% — FF99% — FC98% — FA97% — F796% — F595% — F294% — F093% — ED92% — EB91% — E890% — E689% — E388% — E087% — DE86% — DB85% — D984% — D683% — D482% — D181% — CF80% — CC79% — C978% — C777% — C476% — C275% — BF74% — BD73% — BA72% — B871% — B570% — B369% — B068% — AD67% — AB66% — A865% — A664% — A363% — A162% — 9E61% — 9C60% — 9959% — 9658% — 9457% — 9156% — 8F55% — 8C54% — 8A53% — 8752% — 8551% — 8250% — 8049% — 7D48% — 7A47% — 7846% — 7545% — 7344% — 7043% — 6E42% — 6B41% — 6940% — 6639% — 6338% — 6137% — 5E36% — 5C35% — 5934% — 5733% — 5432% — 5231% — 4F30% — 4D29% — 4A28% — 4727% — 4526% — 4225% — 4024% — 3D23% — 3B22% — 3821% — 3620% — 3319% — 3018% — 2E17% — 2B16% — 2915% — 2614% — 2413% — 2112% — 1F11% — 1C10% — 1A9% — 178% — 147% — 126% — 0F5% — 0D4% — 0A3% — 082% — 051% — 030% — 00 部分16进制透明度12345678910111213141516171819202122不透明度 16进制值100% FF95% F290% E685% D980% CC75% BF70% B365% A660% 9955% 8C50% 8045% 7340% 6635% 5930% 4D25% 4020% 3315% 2610% 1A5% 0D0% 00 Android Material Design 字体颜色透明度1234567100%: FF87%: DE70%: B354%: 8A50%: 8038%: 6112%: 1F 各个颜色数值黑白1234&lt;!-- 0 Black 黑色 --&gt;&lt;color name="Black"&gt;#000000&lt;/color&gt;&lt;!-- 0 White 白色 --&gt;&lt;color name="White"&gt;#FFFFFF&lt;/color&gt; 灰色1234567891011&lt;!-- 1 Grey 灰色 --&gt;&lt;color name="Grey_50"&gt;#FAFAFA&lt;/color&gt;&lt;color name="Grey_100"&gt;#F5F5F5&lt;/color&gt;&lt;color name="Grey_200"&gt;#EEEEEE&lt;/color&gt;&lt;color name="Grey_300"&gt;#E0E0E0&lt;/color&gt;&lt;color name="Grey_400"&gt;#BDBDBD&lt;/color&gt;&lt;color name="Grey_500_bar"&gt;#9E9E9E&lt;/color&gt;&lt;color name="Grey_600"&gt;#757575&lt;/color&gt;&lt;color name="Grey_700"&gt;#616161&lt;/color&gt;&lt;color name="Grey_800"&gt;#424242&lt;/color&gt;&lt;color name="Grey_900"&gt;#212121&lt;/color&gt; 蓝灰色1234567891011&lt;!-- 2 Blue Grey 蓝灰色--&gt;&lt;color name="Blue_Grey_50"&gt;#FAFAFA&lt;/color&gt;&lt;color name="Blue_Grey_100"&gt;#CFD8DC&lt;/color&gt;&lt;color name="Blue_Grey_200"&gt;#B0BEC5&lt;/color&gt;&lt;color name="Blue_Grey_300"&gt;#90A4AE&lt;/color&gt;&lt;color name="Blue_Grey_400"&gt;#78909C&lt;/color&gt;&lt;color name="Blue_Grey_500_bar"&gt;#607D8B&lt;/color&gt;&lt;color name="Blue_Grey_600"&gt;#546E7A&lt;/color&gt;&lt;color name="Blue_Grey_700"&gt;#455A64&lt;/color&gt;&lt;color name="Blue_Grey_800"&gt;#37474F&lt;/color&gt;&lt;color name="Blue_Grey_900"&gt;#263238&lt;/color&gt; 红色123456789101112131415&lt;!-- 3 Red 红色--&gt;&lt;color name="r_50"&gt;#FFEBEE&lt;/color&gt;&lt;color name="r_100"&gt;#FFCDD2&lt;/color&gt;&lt;color name="r_200"&gt;#EF9A9A&lt;/color&gt;&lt;color name="r_300"&gt;#E57373&lt;/color&gt;&lt;color name="r_400"&gt;#EF5350&lt;/color&gt;&lt;color name="r_500_bar"&gt;#F44336&lt;/color&gt;&lt;color name="r_600"&gt;#E53935&lt;/color&gt;&lt;color name="r_700"&gt;#D32F2F&lt;/color&gt;&lt;color name="r_800"&gt;#C62828&lt;/color&gt;&lt;color name="r_900"&gt;#B71C1C&lt;/color&gt;&lt;color name="r_a100"&gt;#FF8A80&lt;/color&gt;&lt;color name="r_a200"&gt;#FF5252&lt;/color&gt;&lt;color name="r_a400"&gt;#FF1744&lt;/color&gt;&lt;color name="r_a700"&gt;#D50000&lt;/color&gt; 粉色123456789101112131415&lt;!-- 4 Pink 粉色--&gt;&lt;color name="p_50"&gt;#FCE4EC&lt;/color&gt;&lt;color name="p_100"&gt;#F8BBD0&lt;/color&gt;&lt;color name="p_200"&gt;#F48FB1&lt;/color&gt;&lt;color name="p_300"&gt;#F06292&lt;/color&gt;&lt;color name="p_400"&gt;#EC407A&lt;/color&gt;&lt;color name="p_500_bar"&gt;#E91E63&lt;/color&gt;&lt;color name="p_600"&gt;#D81B60&lt;/color&gt;&lt;color name="p_700"&gt;#C2185B&lt;/color&gt;&lt;color name="p_800"&gt;#AD1457&lt;/color&gt;&lt;color name="p_900"&gt;#880E4F&lt;/color&gt;&lt;color name="p_a100"&gt;#FF80AB&lt;/color&gt;&lt;color name="p_a200"&gt;#FF4081&lt;/color&gt;&lt;color name="p_a400"&gt;#F50057&lt;/color&gt;&lt;color name="p_a700"&gt;#C51162&lt;/color&gt; 紫色123456789101112131415&lt;!-- 5 Purple 紫色--&gt;&lt;color name="pur_50"&gt;#F3E5F5&lt;/color&gt;&lt;color name="pur_100"&gt;#E1BEE7&lt;/color&gt;&lt;color name="pur_200"&gt;#CE93D8&lt;/color&gt;&lt;color name="pur_300"&gt;#BA68C8&lt;/color&gt;&lt;color name="pur_400"&gt;#AB47BC&lt;/color&gt;&lt;color name="pur_500_bar"&gt;#9C27B0&lt;/color&gt;&lt;color name="pur_600"&gt;#8E24AA&lt;/color&gt;&lt;color name="pur_700"&gt;#7B1FA2&lt;/color&gt;&lt;color name="pur_800"&gt;#6A1B9A&lt;/color&gt;&lt;color name="pur_900"&gt;#4A148C&lt;/color&gt;&lt;color name="pur_a100"&gt;#EA80FC&lt;/color&gt;&lt;color name="pur_a200"&gt;#E040FB&lt;/color&gt;&lt;color name="pur_a400"&gt;#D500F9&lt;/color&gt;&lt;color name="pur_a700"&gt;#AA00FF&lt;/color&gt; 深紫色123456789101112131415&lt;!-- 6 Deep Purple 深紫色--&gt;&lt;color name="deep_pur_50"&gt;#EDE7F6&lt;/color&gt;&lt;color name="deep_pur_100"&gt;#D1C4E9&lt;/color&gt;&lt;color name="deep_pur_200"&gt;#B39DDB&lt;/color&gt;&lt;color name="deep_pur_300"&gt;#9575CD&lt;/color&gt;&lt;color name="deep_pur_400"&gt;#7E57C2&lt;/color&gt;&lt;color name="deep_pur_500_bar"&gt;#673AB7&lt;/color&gt;&lt;color name="deep_pur_600"&gt;#5E35B1&lt;/color&gt;&lt;color name="deep_pur_700"&gt;#512DA8&lt;/color&gt;&lt;color name="deep_pur_800"&gt;#4527A0&lt;/color&gt;&lt;color name="deep_pur_900"&gt;#311B92&lt;/color&gt;&lt;color name="deep_pur_a100"&gt;#B388FF&lt;/color&gt;&lt;color name="deep_pur_a200"&gt;#7C4DFF&lt;/color&gt;&lt;color name="deep_pur_a400"&gt;#651FFF&lt;/color&gt;&lt;color name="deep_pur_a700"&gt;#6200EA&lt;/color&gt; 靛蓝色123456789101112131415&lt;!-- 7 Indigo 靛蓝色 --&gt;&lt;color name="Indigo_50"&gt;#E8EAF6&lt;/color&gt;&lt;color name="Indigo_100"&gt;#C5CAE9&lt;/color&gt;&lt;color name="Indigo_200"&gt;#9FA8DA&lt;/color&gt;&lt;color name="Indigo_300"&gt;#7986CB&lt;/color&gt;&lt;color name="Indigo_400"&gt;#5C6BC0&lt;/color&gt;&lt;color name="Indigo_500_bar"&gt;#3F51B5&lt;/color&gt;&lt;color name="Indigo_600"&gt;#3949AB&lt;/color&gt;&lt;color name="Indigo_700"&gt;#303F9F&lt;/color&gt;&lt;color name="Indigo_800"&gt;#283593&lt;/color&gt;&lt;color name="Indigo_900"&gt;#1A237E&lt;/color&gt;&lt;color name="Indigo_a100"&gt;#8C9EFF&lt;/color&gt;&lt;color name="Indigo_a200"&gt;#536DFE&lt;/color&gt;&lt;color name="Indigo_a400"&gt;#3D5AFE&lt;/color&gt;&lt;color name="Indigo_a700"&gt;#304FFE&lt;/color&gt; 蓝色123456789101112131415&lt;!-- 8 Blue 蓝色 --&gt;&lt;color name="Blue_50"&gt;#E3F2FD&lt;/color&gt;&lt;color name="Blue_100"&gt;#BBDEFB&lt;/color&gt;&lt;color name="Blue_200"&gt;#90CAF9&lt;/color&gt;&lt;color name="Blue_300"&gt;#64B5F6&lt;/color&gt;&lt;color name="Blue_400"&gt;#42A5F5&lt;/color&gt;&lt;color name="Blue_500_bar"&gt;#2196F3&lt;/color&gt;&lt;color name="Blue_600"&gt;#1E88E5&lt;/color&gt;&lt;color name="Blue_700"&gt;#1976D2&lt;/color&gt;&lt;color name="Blue_800"&gt;#1565C0&lt;/color&gt;&lt;color name="Blue_900"&gt;#0D47A1&lt;/color&gt;&lt;color name="Blue_a100"&gt;#82B1FF&lt;/color&gt;&lt;color name="Blue_a200"&gt;#448AFF&lt;/color&gt;&lt;color name="Blue_a400"&gt;#2979FF&lt;/color&gt;&lt;color name="Blue_a700"&gt;#2962FF&lt;/color&gt; 亮蓝色123456789101112131415&lt;!-- 9 Light Blue 亮蓝色--&gt;&lt;color name="Light_Blue_50"&gt;#E1F5FE&lt;/color&gt;&lt;color name="Light_Blue_100"&gt;#B3E5FC&lt;/color&gt;&lt;color name="Light_Blue_200"&gt;#81D4FA&lt;/color&gt;&lt;color name="Light_Blue_300"&gt;#4FC3F7&lt;/color&gt;&lt;color name="Light_Blue_400"&gt;#29B6F6&lt;/color&gt;&lt;color name="Light_Blue_500_bar"&gt;#03A9F4&lt;/color&gt;&lt;color name="Light_Blue_600"&gt;#039BE5&lt;/color&gt;&lt;color name="Light_Blue_700"&gt;#0288D1&lt;/color&gt;&lt;color name="Light_Blue_800"&gt;#0277BD&lt;/color&gt;&lt;color name="Light_Blue_900"&gt;#01579B&lt;/color&gt;&lt;color name="Light_Blue_a100"&gt;#80D8FF&lt;/color&gt;&lt;color name="Light_Blue_a200"&gt;#40C4FF&lt;/color&gt;&lt;color name="Light_Blue_a400"&gt;#00B0FF&lt;/color&gt;&lt;color name="Light_Blue_a700"&gt;#0091EA&lt;/color&gt; 青色123456789101112131415&lt;!-- 10 Cyan 青色 --&gt;&lt;color name="Cyan_50"&gt;#E0F7FA&lt;/color&gt;&lt;color name="Cyan_100"&gt;#B2EBF2&lt;/color&gt;&lt;color name="Cyan_200"&gt;#80DEEA&lt;/color&gt;&lt;color name="Cyan_300"&gt;#4DD0E1&lt;/color&gt;&lt;color name="Cyan_400"&gt;#26C6DA&lt;/color&gt;&lt;color name="Cyan_500_bar"&gt;#00BCD4&lt;/color&gt;&lt;color name="Cyan_600"&gt;#00ACC1&lt;/color&gt;&lt;color name="Cyan_700"&gt;#0097A7&lt;/color&gt;&lt;color name="Cyan_800"&gt;#00838F&lt;/color&gt;&lt;color name="Cyan_900"&gt;#006064&lt;/color&gt;&lt;color name="Cyan_a100"&gt;#84FFFF&lt;/color&gt;&lt;color name="Cyan_a200"&gt;#18FFFF&lt;/color&gt;&lt;color name="Cyan_a400"&gt;#00E5FF&lt;/color&gt;&lt;color name="Cyan_a700"&gt;#00B8D4&lt;/color&gt; 蓝绿色123456789101112131415&lt;!-- 11 Teal 蓝绿色 --&gt;&lt;color name="Teal_50"&gt;#E0F2F1&lt;/color&gt;&lt;color name="Teal_100"&gt;#B2DFDB&lt;/color&gt;&lt;color name="Teal_200"&gt;#80CBC4&lt;/color&gt;&lt;color name="Teal_300"&gt;#4DB6AC&lt;/color&gt;&lt;color name="Teal_400"&gt;#26A69A&lt;/color&gt;&lt;color name="Teal_500_bar"&gt;#009688&lt;/color&gt;&lt;color name="Teal_600"&gt;#00897B&lt;/color&gt;&lt;color name="Teal_700"&gt;#00796B&lt;/color&gt;&lt;color name="Teal_800"&gt;#00695C&lt;/color&gt;&lt;color name="Teal_900"&gt;#004D40&lt;/color&gt;&lt;color name="Teal_a100"&gt;#A7FFEB&lt;/color&gt;&lt;color name="Teal_a200"&gt;#64FFDA&lt;/color&gt;&lt;color name="Teal_a400"&gt;#1DE9B6&lt;/color&gt;&lt;color name="Teal_a700"&gt;#00BFA5&lt;/color&gt; 绿色123456789101112131415&lt;!-- 12 Green 绿色 --&gt;&lt;color name="Green_50"&gt;#E8F5E9&lt;/color&gt;&lt;color name="Green_100"&gt;#C8E6C9&lt;/color&gt;&lt;color name="Green_200"&gt;#A5D6A7&lt;/color&gt;&lt;color name="Green_300"&gt;#81C784&lt;/color&gt;&lt;color name="Green_400"&gt;#66BB6A&lt;/color&gt;&lt;color name="Green_500_bar"&gt;#4CAF50&lt;/color&gt;&lt;color name="Green_600"&gt;#43A047&lt;/color&gt;&lt;color name="Green_700"&gt;#388E3C&lt;/color&gt;&lt;color name="Green_800"&gt;#2E7D32&lt;/color&gt;&lt;color name="Green_900"&gt;#1B5E20&lt;/color&gt;&lt;color name="Green_a100"&gt;#B9F6CA&lt;/color&gt;&lt;color name="Green_a200"&gt;#69F0AE&lt;/color&gt;&lt;color name="Green_a400"&gt;#00E676&lt;/color&gt;&lt;color name="Green_a700"&gt;#00C853&lt;/color&gt; 亮绿色123456789101112131415&lt;!-- 13 Light Green 亮绿色--&gt;&lt;color name="Light_Green_50"&gt;#F1F8E9&lt;/color&gt;&lt;color name="Light_Green_100"&gt;#DCEDC8&lt;/color&gt;&lt;color name="Light_Green_200"&gt;#C5E1A5&lt;/color&gt;&lt;color name="Light_Green_300"&gt;#AED581&lt;/color&gt;&lt;color name="Light_Green_400"&gt;#9CCC65&lt;/color&gt;&lt;color name="Light_Green_500_bar"&gt;#8BC34A&lt;/color&gt;&lt;color name="Light_Green_600"&gt;#7CB342&lt;/color&gt;&lt;color name="Light_Green_700"&gt;#689F38&lt;/color&gt;&lt;color name="Light_Green_800"&gt;#558B2F&lt;/color&gt;&lt;color name="Light_Green_900"&gt;#33691E&lt;/color&gt;&lt;color name="Light_Green_a100"&gt;#CCFF90&lt;/color&gt;&lt;color name="Light_Green_a200"&gt;#B2FF59&lt;/color&gt;&lt;color name="Light_Green_a400"&gt;#76FF03&lt;/color&gt;&lt;color name="Light_Green_a700"&gt;#64DD17&lt;/color&gt; 酸橙汁饮料123456789101112131415&lt;!-- 14 Lime 酸橙汁饮料 --&gt;&lt;color name="Lime_50"&gt;#F9FBE7&lt;/color&gt;&lt;color name="Lime_100"&gt;#F0F4C3&lt;/color&gt;&lt;color name="Lime_200"&gt;#E6EE9C&lt;/color&gt;&lt;color name="Lime_300"&gt;#DCE775&lt;/color&gt;&lt;color name="Lime_400"&gt;#D4E157&lt;/color&gt;&lt;color name="Lime_500_bar"&gt;#CDDC39&lt;/color&gt;&lt;color name="Lime_600"&gt;#C0CA33&lt;/color&gt;&lt;color name="Lime_700"&gt;#AFB42B&lt;/color&gt;&lt;color name="Lime_800"&gt;#9E9D24&lt;/color&gt;&lt;color name="Lime_900"&gt;#827717&lt;/color&gt;&lt;color name="Lime_a100"&gt;#F4FF81&lt;/color&gt;&lt;color name="Lime_a200"&gt;#EEFF41&lt;/color&gt;&lt;color name="Lime_a400"&gt;#C6FF00&lt;/color&gt;&lt;color name="Lime_a700"&gt;#AEEA00&lt;/color&gt; 黄色123456789101112131415 &lt;!-- 15 Yellow 黄色 --&gt;&lt;color name="Yellow_50"&gt;#FFFDE7&lt;/color&gt;&lt;color name="Yellow_100"&gt;#FFF9C4&lt;/color&gt;&lt;color name="Yellow_200"&gt;#FFF59D&lt;/color&gt;&lt;color name="Yellow_300"&gt;#FFF176&lt;/color&gt;&lt;color name="Yellow_400"&gt;#FFEE58&lt;/color&gt;&lt;color name="Yellow_500_bar"&gt;#FFEB3B&lt;/color&gt;&lt;color name="Yellow_600"&gt;#FDD835&lt;/color&gt;&lt;color name="Yellow_700"&gt;#FBC02D&lt;/color&gt;&lt;color name="Yellow_800"&gt;#F9A825&lt;/color&gt;&lt;color name="Yellow_900"&gt;#F57F17&lt;/color&gt;&lt;color name="Yellow_a100"&gt;#FFFF8D&lt;/color&gt;&lt;color name="Yellow_a200"&gt;#FFFF00&lt;/color&gt;&lt;color name="Yellow_a400"&gt;#FFEA00&lt;/color&gt;&lt;color name="Yellow_a700"&gt;#FFD600&lt;/color&gt; 琥珀色123456789101112131415&lt;!-- 16 Amber 琥珀色--&gt;&lt;color name="Amber_50"&gt;#FFF8E1&lt;/color&gt;&lt;color name="Amber_100"&gt;#FFECB3&lt;/color&gt;&lt;color name="Amber_200"&gt;#FFE082&lt;/color&gt;&lt;color name="Amber_300"&gt;#FFD54F&lt;/color&gt;&lt;color name="Amber_400"&gt;#FFCA28&lt;/color&gt;&lt;color name="Amber500_bar"&gt;#FFC107&lt;/color&gt;&lt;color name="Amber_600"&gt;#FFB300&lt;/color&gt;&lt;color name="Amber_700"&gt;#FFA000&lt;/color&gt;&lt;color name="Amber_800"&gt;#FF8F00&lt;/color&gt;&lt;color name="Amber_900"&gt;#FF6F00&lt;/color&gt;&lt;color name="Amber_a100"&gt;#FFE57F&lt;/color&gt;&lt;color name="Amber_a200"&gt;#FFD740&lt;/color&gt;&lt;color name="Amber_a400"&gt;#FFC400&lt;/color&gt;&lt;color name="Amber_a700"&gt;#FFAB00&lt;/color&gt; 橘黄色123456789101112131415&lt;!-- 17 Orange 橘黄色--&gt;&lt;color name="Orange_50"&gt;#FFF3E0&lt;/color&gt;&lt;color name="Orange_100"&gt;#FFE0B2&lt;/color&gt;&lt;color name="Orange_200"&gt;#FFCC80&lt;/color&gt;&lt;color name="Orange_300"&gt;#FFB74D&lt;/color&gt;&lt;color name="Orange_400"&gt;#FFA726&lt;/color&gt;&lt;color name="Orange_500_bar"&gt;#FF9800&lt;/color&gt;&lt;color name="Orange_600"&gt;#FB8C00&lt;/color&gt;&lt;color name="Orange_700"&gt;#F57C00&lt;/color&gt;&lt;color name="Orange_800"&gt;#EF6C00&lt;/color&gt;&lt;color name="Orange_900"&gt;#E65100&lt;/color&gt;&lt;color name="Orange_a100"&gt;#FFD180&lt;/color&gt;&lt;color name="Orange_a200"&gt;#FFAB40&lt;/color&gt;&lt;color name="Orange_a400"&gt;#FF9100&lt;/color&gt;&lt;color name="Orange_a700"&gt;#FF6D00&lt;/color&gt; 深橘黄色123456789101112131415&lt;!-- 18 Deep Orange 深橘黄色--&gt;&lt;color name="Deep_Orange_50"&gt;#FBE9E7&lt;/color&gt;&lt;color name="Deep_Orange_100"&gt;#FFCCBC&lt;/color&gt;&lt;color name="Deep_Orange_200"&gt;#FFAB91&lt;/color&gt;&lt;color name="Deep_Orange_300"&gt;#FF8A65&lt;/color&gt;&lt;color name="Deep_Orange_400"&gt;#FF7043&lt;/color&gt;&lt;color name="Deep_Orange_500_bar"&gt;#FF5722&lt;/color&gt;&lt;color name="Deep_Orange_600"&gt;#F4511E&lt;/color&gt;&lt;color name="Deep_Orange_700"&gt;#E64A19&lt;/color&gt;&lt;color name="Deep_Orange_800"&gt;#D84315&lt;/color&gt;&lt;color name="Deep_Orange_900"&gt;#BF360C&lt;/color&gt;&lt;color name="Deep_Orange_a100"&gt;#FF9E80&lt;/color&gt;&lt;color name="Deep_Orange_a200"&gt;#FF6E40&lt;/color&gt;&lt;color name="Deep_Orange_a400"&gt;#FF3D00&lt;/color&gt;&lt;color name="Deep_Orange_a700"&gt;#DD2C00&lt;/color&gt; 棕色1234567891011&lt;!-- 19 Brown 棕色--&gt;&lt;color name="Brown_50"&gt;#EFEBE9&lt;/color&gt;&lt;color name="Brown_100"&gt;#D7CCC8&lt;/color&gt;&lt;color name="Brown_200"&gt;#BCAAA4&lt;/color&gt;&lt;color name="Brown_300"&gt;#A1887F&lt;/color&gt;&lt;color name="Brown_400"&gt;#8D6E63&lt;/color&gt;&lt;color name="Brown_500_bar"&gt;#795548&lt;/color&gt;&lt;color name="Brown_600"&gt;#6D4C41&lt;/color&gt;&lt;color name="Brown_700"&gt;#5D4037&lt;/color&gt;&lt;color name="Brown_800"&gt;#4E342E&lt;/color&gt;&lt;color name="Brown_900"&gt;#3E2723&lt;/color&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Sutdio 使用快人一步1 插件配置]]></title>
    <url>%2FAndroid%20Studio%E4%BD%BF%E7%94%A8%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A51%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[今日感悟，写在前面： 放手无关紧要，精于攻坚克难。 一、Android Studio 3.0 - Android Profiler分析器 参考：http://blog.csdn.net/niubitianping/article/details/72617864Android Studio 3.0 新特性：http://blog.csdn.net/niubitianping/article/details/72600923 二、Android Studio 官方用户指南 https://developer.android.google.cn/studio/intro/index.html 三、使用频率最高的3个快捷键： ⌘ + n：各种自动生成。 （control）⌃ + t 各位看官自己瞧瞧： （shift）⇧ + （control）⌃ + （enter） ⏎ 补充快捷键 四、插件插件安装位置：Android Studio -&gt; Preferences -&gt; Plugins。快捷键：⌘ + ,敲出⌘：⌃ + ⌘ + space，之后进行选择 1. 代码规范 - Alibaba Java Coding Guidelines阿里巴巴Java开发规约的插件。安装后在Android Studio显示为：可选择实时监测，也可以关闭检测。 2. 真机无线调试 - Android WiFi ADB通过WIFI连接手机和电脑。数据线插入你的手机，然后点击Connect，显示State = Connect后拔掉数据线即可。 3. 布局文件分组的插件 - folding-plugin图片来自网络 4. View注解绑定 - Android ButterKnife ZeleznyButterKnife是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。快捷键：⌘ + n使用时必须要将光标悬浮于 activity_main之上才能有效。 4.1 控件的点击事件异常时 只是在Java代码中写明了方法，但是并没有在XML代码中使用onClick=&quot;&quot;来描述此方法 在Java代码中只是声明了方法，当时并没有在方法中声明参数：(View view)。如果不写此参数，将会导致在调用方法时，找不到View中的 指定id 值。 4.2 空指针异常： Android Studio3.0之前 在 app模块 的 gradle 编译文件 build.gradle 加入下列代码： apply plugin: &apos;com.neenbedankt.android-apt&apos; 在 app模块 的 gradle 编译文件 build.gradle 中的 dependencies中加入 apt &apos;com.jakewharton:butterknife-compiler:8.0.1&apos; compile &apos;com.jakewharton:butfe:8.0.1&apos; 在 项目 的 gradle 编译文件 build.gradle 文件，在 dependencies 中加入 classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; Android Studio3.0 在 app模块 的 gradle 中的 dependencies中加入 compile &apos;com.jakewharton:butterknife:8.8.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos; 5. 资源文件状态生成 - SelectorChapek for Android通过资源文件命名自动生成Selector文件。 6. ViewHolder代码自动生成 - AndroidCodeGenerator在 res/layout/文件夹下选择你适配器的item layout的布局文件，然后右键，如图所示： 选择其中一项之后，会弹出一个窗口，在这个窗口已经根据item布局文件默认生成了一个适配器类，你所要做的就是根据自己的实际需求进行修改。 7. 自动findViewById() - Prettify据Layout自动生成findViewById。使用方式同ButterKnife快捷键：⌘ + n 后选择 View Variables 或者 View Fields区别： 前者View Variables生成的是私有变量 后者 View Fields生成的是成员变量 8. 自动生成style代码 - Android Styler快捷键：⇧ + ⌘ + d效果如图： 9. 生命周期方法位置排序 - Lifecycle Sorter根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序。快捷键 ⌘ + ⌥ + K 10. 关于Json数据10.1 Json数据 -&gt; java对象 ：GsonFormatGsonFormat是一个快速格式化json数据，自动生成实体类参数的插件。快捷键：⌘ + n 后选择 GsonFormat。 10.2 Java对象 -&gt; json格式数据 ：Java库：Gson 参考：http://blog.csdn.net/oQiHaoGongYuan/article/details/50944755 添加gson库： 首先，在自己的android studio的项目中把gson库添加进来，右键 app 选择 open module settings 选择当前 Module，然后点击 Dependencies,在点击3步中的Library dependency（依赖的库） 在1所指的弹出的收索框中收索gson，然后点击2 所指的收索，然后下面就会出现最新的gson库，点击OK 点击上图OK后，gson库就出现在了dependency中了，这个时候还得点击 2所指的OK（确认）按钮。 最后查看build.gradle中看看gson库有没有添加成功，如下图2所指的地方，现在可以看到google官方的gson库就添加到了项目中来。 使用gson把Java对象转化为Json格式 12Gson gson = new Gson();gson.toJson(对象); 11. Parcelable自动生成 - ParcelableGenerator自动生成Parcelable接口所需的代码。 Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。 而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。 Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。 Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据。 快捷键：⌘ + n 12. Android Material Design 风格图标全集 - Android Material Design Icon Generator通过此库可以获取MD风格的所有图标，更让人惊喜的是：选中的图标会自动生成各种 drawable 文件夹的图标，而且可以自定义颜色，绝对让人惊喜。快捷键：⌥ + ⌘ + m 选择指定图标以及自定义颜色。 13. Android本地数据/数据库浏览器查询、修改第三方库引入：在module的gradle中 debugCompile &apos;com.amitshekhar.android:debug-db:1.0.0&apos; 使用： mac下按住⌘ + 单击即可在浏览器中看到当前App的数据。 14. 色彩管理器 - color-manager这个管理器是一个插件，只要在 Android Studio 安装此插件即可。使用参考：https://github.com/shiraji/color-manager 安装之后的样式： 过滤 功能： 选中此功能后：不显示系统提供的颜色； 未选中时：显示 系统+自定义 颜色。 15. Builder生成器 - innerbuilder这个管理器是一个插件，只要在 Android Studio 安装此插件即可。使用参考：https://github.com/analytically/innerbuilder 官网截图： 五、组合指令1. 自定义组指令快捷键：⌘ + , 后选择 Live TemPlates，如下所示： 单击上图中的+可以添加自定义的组合键选择其中的AndroidLog即可进行自定义设置： 2. 已存在组合指令2.1 Log输出自定义 logt private static final String TAG = &quot;MainActivity &quot;; loge logi logd 2.2 循环 foreach for (:) {} fori for (int i = 0; i &lt; ; i++) {} itar (array) for (int i = 0; i &lt; array.length; i++) { = array[i]; } iten (enum) while (enumeration.hasMoreElements()) { Object nextElement = enumeration.nextElement(); } itit (iterator) while (iterator.hasNext()) { Object next = iterator.next(); } itli (List) for (int i = 0; i &lt; list.size(); i++) { Object o = list.get(i); } 2.3 判定 ifn if (savedInstanceState == null) {} inn if (savedInstanceState != null) {} lazy if (savedInstanceState == null) { savedInstanceState = new Bundle(); } lnst if (savedInstanceState instanceof Object) { Object instanceState = (Object) savedInstanceState; } 2.4 View相关 gone .setVisibility(View.GONE); visible Toast Toast.makeText(this, &quot;&quot;, Toast.LENGTH_SHORT).show(); fbc () findViewById(R.id.); fixme // FIXME: 2017/10/26 todo lhm lhw 2.5 全局 static final 变量 psf public static final psfi public static final int psfs St]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境下Hexo-GitHub-MWeb搭建个人博客]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BHexo-GitHub-MWeb%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[需要的工具：Node.js、Git、Hexo、Coding（自选）、MWeb（自选） 安装Git非重点，自行安装 Node.js非重点，自行安装 Hexo按照此命令进行安装Hexo$ sudo npm install -g hexo 初始化Hexo其中Blog_Hexo为自己建立的目标文件夹。只要是建立自己的任意一个博客，都可使用一下步骤。 $ hexo init Blog_Hexo 在“blog”文件夹中安装npm $ npm install 执行一下命令，查看是否安装成功 $ hexo s 在浏览器中打开：http://localhost:4000 能看到“Hexo”页面表示安装成功： 关联GitHub登录你的Github帐号，新建仓库，名为：用户名.github.io ，此为固定写法。创建之后为： 创建的Hexo文件夹为： cd到Blog_Hexo文件夹下，编辑_config.yml。 注意：_config.yml 文件中的 ：后面要加一个空格 1）若是只将博客上传至GItHub中，编写 deploy: type: git repository: https://github.com/gonghonglou/gonghonglou.github.io.git branch: master 2）若是将博客同时上传至GItHub和Coding中，编写： deploy: type: git repo: github: git@github.com:YannisCheng/YannisCheng.github.io.git,master coding: git@git.coding.net:yannischeng/blog.git,master 在Blog_Hexo文件夹目录下执行生成静态页面命令： $ hexo g 此时若出现如下报错： ERROR Local hexo not found in ~/blog ERROR Try runing: &apos;npm install hexo --save&apos; 则执行命令： npm install hexo --save 若无报错，自行忽略此步骤。再执行配置命令： $ hexo d 执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命： $ npm install hexo-deployer-git --save 若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即 Username for &apos;https:// .github.com&apos;: Password for &apos;https:// .github.com&apos;: hexo deploy命令执行成功后，浏览器中打开网址http:// .github.io 能看到和打开 http://localhost:4000 时一样的页面。 发布cd到Blog_Hexo中，执行如下命令新建文章 hexo new &quot;hello-world&quot; 新的文件建立之后的位置为 编辑之后，在 Blog_Hexo 文件夹中执行如下命令 hexo generate //生成静态页面 hexo deploy //将文章部署到Github 至此，安装环节结束，可以进行基本的使用了。 安装主题NexT主题在Blog_Hexo目录下执行： git clone https://github.com/iissnan/hexo-theme-next themes/next 安装之后的文件位置为： 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 theme: next 修改主题为主题增加标签：hexo new page tags 为主题修改背景：在 \themes\next\layout\_layout.swig文件的&lt;/body&gt;上面添加 &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/ca 具体详细设置参考：https://github.com/hustcc/canvas-nest.js/blob/master/README-zh.md 问题杂集主题相关hexo next5.0主题不显示副标题打开themes/next/source/css/_schemes/Mist/_logo.styl 你会看见.site-subtitle { display: none; }删去或改成你想要的即可 为主题 添加字数统计、阅读时长、友情链接开启设置NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件Blog\themes\next_config.yml中打开wordcount统计功能即可 # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true 若只是打开开关，部署之后会发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等字样。 参考：http://blog.csdn.net/wangxw725/article/details/71602256?utm_source=itdadao&amp;utm_medium=referral 找到Blog\themes\next\layout\_macro\post.swig 文件注意： 在此文中出现 字数统计的配置英文字样时会报错！ 安装统计插件如果没有安装 hexo-wordcount 插件，先安装该插件： npm i --save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： npm install hexo-wordcount@2 --save 安装完成后，重新执行启动服务预览就可以了。 Hexo相关添加分类、标签云、关于等页面以添加分类页面为例，在站点目录下，打开git bash，输入 hexo new page &quot;categories&quot; 之后在站点目录下的source文件夹下，会新增一个categories的文件夹，里面有一个index.md文件，打开如下 --- title: categories date: 2015-12-04 15:37:22 type: &quot;categories&quot; comments: false --- 其中，comments可以设置为false，含义是打开分类页面、评论插件不显示；如要显示则改为true。tags, about页面的创建类似，输入 hexo new page &quot;tags&quot; hexo new page &quot;about&quot; 标签的使用 + 文章模板--- title: Mac环境下Hexo-GitHub-MWeb搭建个人博客 date: 2017-10-22 23:48:37 tags: [Mac,博客] categories: 博客 --- hexo草稿模式 参考：http://blog.csdn.net/wizardforcel/article/details/40684575 草稿模式中的文件不会公开显示，适用于：有些文档非常重要但是又不想公开、又不想删除，此时使用hexo模式最合适。使用 hexo new draft &quot;Android热修复&quot; 执行此命令之后，会在相应目录下生成相关文件：~/HexoBLog/source/_drafts/Android热修复.md。图示： 强行预览草稿更爱配置文件： render _drafts: true 通过服务预览： hexo server --drafts 将草稿转变为正式文章： hexo publish [layout] &lt;filename&gt;]]></content>
      <categories>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的menu文件]]></title>
    <url>%2FAndroid%E7%9A%84menu%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[总结 在Activity中使用menu/** * toolbar menu 的图标点初始化 * @param menu * @return */ @Override public boolean onCreateOptionsMenu(Menu menu) { super.onCreateOptionsMenu(menu); getMenuInflater().inflate(R.menu.tool_bar, menu); return true; } 一个menu文件示例包括：单个item menu，组item menu &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;item android:id=&quot;@+id/choose_day&quot; android:icon=&quot;@drawable/date_choose_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;选择时间范围&quot; app:showAsAction=&quot;always&quot;&gt; &lt;!-- item包含menu表示该menu是item下的子菜单 --&gt; &lt;!--&lt;menu&gt; &amp;lt;!&amp;ndash; 将group中的菜单项放于一个组里面 &amp;ndash;&amp;gt; &lt;group android:id=&quot;@+id/group&quot; android:menuCategory=&quot;secondary&quot; android:visible=&quot;true&quot;&gt; &lt;item android:id=&quot;@+id/today&quot; android:icon=&quot;@drawable/menu_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;今天&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/week&quot; android:icon=&quot;@drawable/menu_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;本周&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;/group&gt; &lt;/menu&gt;--&gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/recorder_voice&quot; android:icon=&quot;@drawable/recoder_selector&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;点击录音&quot; app:showAsAction=&quot;always&quot;&gt; &lt;/item&gt; &lt;/menu&gt; 方法的使用在建立actionbar或是toolbar的时候，都会默认的实现两个方法： onCreateOptionsMenu ： 建立菜单，只在页面加载的时候，运行一次，其后就不在运行了，想改变Menu在这里是不可能的。 onOptionsItemSelected ：对选中的菜单进行操作 Android提供了一个方法叫onPrepareOptionsMenu，它的功能是在每次点击一个Menu的时候，它就改变一次，所以你想要改变Menu的值，就得在这里运行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>menu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义 - Drawable]]></title>
    <url>%2FView-%E8%87%AA%E5%AE%9A%E4%B9%89%20-%20Drawable%2F</url>
    <content type="text"><![CDATA[Android动画参考 ：http://blog.csdn.net/harvic880925/article/details/39996643/各个形状介绍 ：http://blog.csdn.net/yangyahuiguo/article/details/52131658 DrawableDrawable 表示的是一种可以在 Canvas 上进行绘制的抽象的概念。其子类有很多，最常见的颜色和图片都是一种 Drawable。一般使用 XML文件 来描述 Drawable，简单、解耦。 Drawable 特点 子类繁多； 掌握种类繁多的 Drawable 可以作出一些特殊效果的UI。 Drawable 优点 相比自定义View，简单的多； 非图片类型的 Drawable 占用内存较少。 BitmapDrawable 对应：XML文件 中的 &lt;bitmap&gt; 标签 表示的就是一张图片，通过在 XML文件 中进行属性配置，产生不同的效果。 ShapeDrawable 对应：XML文件 中的 &lt;shape&gt; 标签 通过颜色、形状构造图形 示例1. oval：椭圆gradient:表示渐变属性 type 表示渐变的样式 123456789101112131415161718&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -》 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;gradient android:angle="180" android:endColor="@color/Amber_900" android:startColor="@color/Orange_100"/&gt; &lt;!-- 当使用此属性时，过度颜色的背景将被遮盖，只显示当前属性的颜色 --&gt; &lt;!--&lt;solid android:color="@color/Deep_Orange_a700"/&gt;--&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; gradientRadius:和镜像属性结合使用，也是必须要设定的属性。表示镜像半径的大小 1234567891011121314151617&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- sweep 属性正常使用，无需其他条件--&gt; &lt;!-- radial 属性使用需要搭配：gradientRadius属性 ： 效果： 由内而外的扩散--&gt; &lt;gradient android:endColor="@color/Amber_900" android:gradientRadius="100px" android:startColor="@color/Orange_100" android:type="radial"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 12345678910111213141516171819&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -》 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;gradient android:angle="180" android:centerColor="@color/white" android:endColor="@color/Amber_900" android:gradientRadius="200px" android:startColor="@color/Orange_100" android:type="radial"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 1234567891011121314151617181920&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -&gt; 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;!-- android:centerY float。渐变中心的相对Y坐标，在0到1.0之间。 --&gt; &lt;!-- x,y 表示开始颜色 开始的位置--&gt; &lt;gradient android:type="radial" android:gradientRadius="100px" android:centerX="0.3" android:centerY="0.3" android:endColor="@color/Amber_900" android:startColor="@color/Orange_100"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 示例2. ring ：圆环 12345678910111213141516171819&lt;!-- 绘制圆环 --&gt;&lt;!--innerRadius : 内环的半径。一个尺寸值（dip等等）或者一个尺寸资源 --&gt;&lt;!--innerRadiusRatio : Float类型。这个值表示内部环的比例，例如,如果android:innerRadiusRatio = " 5 ",那么内部的半径等于环的宽度除以5。这个值会被android:innerRadius重写。 默认值是9。( innerRaiusRatio=view的宽度/半径) --&gt;&lt;!-- thickness : 环的厚度，是一个尺寸值或尺寸的资源。--&gt;&lt;!-- thicknessRatio : Float类型。厚度的比例。例如,如果android:thicknessRatio= " 2 ",然后厚度等于环的宽度除以2。这个值是被android:innerRadius重写， 默认值是3。(thickenessRatio=View的宽度/环厚度）--&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:innerRadius="120px" android:innerRadiusRatio="9" android:shape="ring" android:thickness="20px" android:thicknessRatio="3" android:useLevel="false"&gt; &lt;gradient android:endColor="#00000000" android:startColor="#ff0000" android:type="sweep"/&gt;&lt;/shape&gt; &lt;shape&gt;标签 中各个属性的介绍1. 形状分类 矩形rectangle 椭圆形oval 线性形状line 环形ring 水波纹ripple 2. ring专有属性android:innerRadius 尺寸，内环的半径。android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的半径，例如，如果:android:innerRadiusRatio=”5”，表示内环半径等于环的宽度除以5，这个值是可以被覆盖的，默认为9. android:thickness 尺寸，环的厚度android:thicknessRatio浮点型，以环的宽度比率来表示环的厚度，例如，如果android:thicknessRatio=”2”，那么环的厚度就等于环的宽度除以2。这个值是可以被android:thickness覆盖的，默认值是3.android:useLevel boolean值，如果当做是LevelListDrawable使用时值为true，否则为false. 3. 一个xml文件 6个元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!-- 1- 圆角 android:radius 整型 半径 android:topLeftRadius 整型 左上角半径 android:topRightRadius 整型 右上角半径 android:bottomLeftRadius 整型 左下角半径 android:bottomRightRadius 整型 右下角半径 --&gt; &lt;corners android:radius="8dp" android:topLeftRadius="5dp" android:topRightRadius="15dp" android:bottomLeftRadius="20dp" android:bottomRightRadius="25dp" /&gt; &lt;!-- 2- 渐变色 android:startColor 颜色值 起始颜色 android:endColor 颜色值 结束颜色 android:centerColor 整型 渐变中间颜色，即开始颜色与结束颜色之间的颜色 android:angle 整型 渐变角度(PS：当angle=0时，渐变色是从左向右。 然后逆时针方向转，当angle=90时为从下往上。angle必须为45的整数倍) android:type ["linear" | "radial" | "sweep"] 渐变类型(取值：linear、radial、sweep) linear 线性渐变，这是默认设置 radial 放射性渐变，以开始色为中心。 sweep 扫描线式的渐变。 android:useLevel ["true" | "false"] 如果要使用LevelListDrawable对象，就要设置为true。设置为true无渐变。false有渐变色 android:gradientRadius 整型 渐变色半径.当 android:type="radial" 时才使用。单独使用 android:type="radial"会报错。 android:centerX 整型 渐变中心X点坐标的相对位置 android:centerY 整型 渐变中心Y点坐标的相对位置 --&gt; &lt;gradient android:startColor="#FFFF0000" android:endColor="#80FF00FF" android:angle="45" /&gt; &lt;!-- 3- 内”边距"，即内容与边的距离 android:left 整型 左内边距 android:top 整型 上内边距 android:right 整型 右内边距 android:bottom 整型 下内边距 --&gt; &lt;padding android:left="10dp" android:top="10dp" android:right="10dp" android:bottom="10dp" /&gt; &lt;!-- 4- ”大小" android:width 整型 宽度 android:height 整型 高度 --&gt; &lt;size android:width="600dp" /&gt; &lt;!-- 5- ”内部填充" android:color 颜色值 填充颜色 --&gt; &lt;solid android:color="#ffff9d77" /&gt; &lt;!-- 6- ”描边" android:width 整型 描边的宽度 android:color 颜色值 描边的颜色 android:dashWidth 整型 表示描边的样式是虚线的宽度， 值为0时，表示为实线。值大于0则为虚线。 android:dashGap 整型 表示描边为虚线时，虚线之间的间隔 即“ - - - - ” --&gt; &lt;stroke android:width="2dp" android:color="#dcdcdc" /&gt;&lt;/shape&gt; LayerDrawable 层次绘制 参考：http://blog.csdn.net/lihenair/article/details/50111231 对应： &lt;layer-list&gt;标签 表示一种层次化的 Drawable 集合，类似 PS 软件中的 图层 概念，下面的图层遮挡上面的图层。 原理图解 &lt;layer_list&gt; : 将多个“图片”或 多种效果的shape 按照顺序层叠起来 示例01 1234567891011121314151617181920212223242526&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;!-- 底层--&gt;&lt;!-- 此处的位置数值表示：相对于顶层的位置偏移--&gt; &lt;item android:top="10px" android:left="10px"&gt; &lt;shape&gt; &lt;solid android:color="#bbb" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width="1px" android:color="#ccc" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 顶层--&gt; &lt;!-- 此处的位置数值表示：相对于底层的位置偏移--&gt; &lt;item android:bottom="10px" android:right="10px"&gt; &lt;shape&gt; &lt;solid android:color="#ffffff" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width="0.3px" android:color="#ddd" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; 示例02：在我们的例子中，当按钮被按下时，我们取消了阴影来产生反馈效果。 123456789101112131415161718192021222324252627282930313233&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;layer-list&gt; &lt;item android:left="4dp" android:top="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#ff58bb52" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;!-- SHADOW LAYER --&gt; &lt;item android:left="4dp" android:top="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#66000000" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- CONTENT LAYER --&gt; &lt;item android:bottom="4dp" android:right="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#ff58bb52" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; StateListDrawable这个类所达到的效果其实就是，我们常用的：在 res/drawable/目录下编写的 各种 xxx_selector xml文件。 对应：&lt;selector&gt; 标签 表示的也是 Drawable 的集合，是不同事件状态的下的 Drawable 集合]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 15-I/O]]></title>
    <url>%2FPython3%20%2015-I%3AO%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 关于Open()源码文档打开文件并返回流。失败时提高IOError。 文件是一个文本或字节串，给出要打开的文件的名称（如果文件不在当前工作目录中的路径）或要包装的文件的整数文件描述符。 （如果给出了一个文件描述符，则当返回的I / O对象关闭时，它将被关闭，除非closefd设置为False。）mode是一个可选字符串，用于指定文件打开的方式。它默认为&apos;r&apos;，这意味着在文本模式下打开阅读。其他常见的值是“w”用于写入（截断文件已存在），“x”用于创建和写入新文件，“a”用于附加（在某些Unix系统上，这意味着所有写入都附加到无论当前查找位置如何，文件的结尾）。在文本模式下，如果未指定编码，则使用的编码与平台相关：调用locale.getpreferredencoding（False）以获取当前语言环境编码。 （用于读取和写入原始字节使用二进制模式并保留编码未指定。）可用的模式有： &apos;r&apos;开放阅读（默认） &apos;w&apos;打开写入，首先截断文件 &apos;x&apos;创建一个新文件并将其打开以进行写入 &apos;a&apos;开放写作，如果文件存在，则附加到文件末尾 &apos;b&apos;二进制模式 &apos;t&apos;文字模式（默认） &apos;+&apos;打开一个磁盘文件进行更新（读写） &apos;U&apos;通用换行模式（弃用） 默认模式为“rt”（打开阅读文本）。对于二进制随机访问，模式&apos;w + b&apos;打开并将文件截断为0字节，而&apos;r + b&apos;打开文件而不截断。如果文件已经存在，&apos;x&apos;模式意味着&apos;w&apos;并引发一个`FileExistsError`。 Python区分以二进制和文本模式打开的文件，即使底层操作系统没有。文件以二进制模式打开（将&apos;b&apos;追加到模式参数）返回内容作为字节对象而不进行任何解码。在文本模式（默认情况下，或在模式参数附加了&apos;t&apos;）时，文件的内容将返回为字符串，首先使用平台相关编码对字节进行了解码，如果给出，则使用指定的编码。 &apos;U&apos;模式已被弃用，并会在将来的Python版本中引发异常。它对Python 3没有影响。使用换行来控制通用换行符模式。缓冲是用于设置缓冲策略的可选整数。通过0以切换缓冲（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），整数&gt; 1表示固定大小的块缓冲区的大小。当没有给出缓冲参数时，默认缓冲策略的工作原理如下： *二进制文件以固定大小的块进行缓冲;使用启发式方法来选择缓冲区的大小，试图确定底层设备的“块大小”并落回到“io.DEFAULT_BUFFER_SIZE”上。在许多系统上，缓冲区通常为4096或8192字节长。 *“交互式”文本文件（其中isatty（）返回True的文件）使用行缓冲。其他文本文件使用上述针对二进制文件的策略。 encoding是用于对文件进行解码或编码的编码名称。这只能在文本模式下使用。默认编码是平台依赖的，但是Python可以支持任何编码。有关支持的编码列表，请参阅编解码器模块。 errors是一个可选的字符串，指定如何处理编码错误 - 此参数不应在二进制模式下使用。如果存在编码错误（默认值为None）具有相同的效果，则通过&apos;strict&apos;来引发ValueError异常，或者通过&apos;ignore&apos;忽略错误。 （请注意，忽略编码错误可能导致数据丢失。）有关编码错误字符串的列表，请参阅codecs.register的文档或运行&apos;help（codecs.Codec）&apos;。 换行符控制通用换行符的工作原理（仅适用于文本模式）。它可以是无，&apos;&apos;，&apos;\ n&apos;，&apos;\ r&apos;和&apos;\ r \ n&apos;。它的工作原理如下： *输入时，如果换行符为None，则启用通用换行符模式。输入中的行可以&apos;\ n&apos;，&apos;\ r&apos;或&apos;\ r \ n&apos;结尾，并将它们转换为&apos;\ n&apos;，然后返回给调用者。如果是&apos;&apos;，则启用通用换行模式，但是行结束将返回给未经翻译的调用者。如果它具有任何其他合法值，则输入行仅由给定终止 2017年07月21日09:44:52 暂停]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 14-调试]]></title>
    <url>%2FPython3%20%2014-%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 几个方法说明 .print()打印用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。 assert断言凡是用print()来辅助查看的地方，都可以用断言assert来替代。代码示例： 1234567def foo(s): n = int(s) assert n != 0, 'n is zero!' return 10 / ndef main(): foo('0') 在程序中使用assert和print()相比也好不到哪去。但是：启动Python解释器时可以用-O参数来关闭assert 1$ python3 -O err.py 关闭后，你可以把所有的assert语句当成pass来看。 logging日志把print()替换为logging是第3种方式，和assert比，logging不但会抛出错误，而且可以输出到文件。注意：导入logging包之后，应在添加配置语句logging.basicConfig(level=logging.INFO)代码示例 1234567891011121314151617181920212223242526272829303132333435363738import logging# logging.basicConfig(level=logging.INFO)# 配置日志信息logging.basicConfig(level=logging.DEBUG, format='%(asctime)-8s %(name)-8s %(levelname)-8s %(message)s - [%(filename)s:%(lineno)s]', datefmt='%Y-%m-%d %H:%M:%S', filename='myapp.log', filemode='w')# 定义一个Handler打印INFO及以上级别的日志到sys.stderrconsole = logging.StreamHandler()console.setLevel(logging.DEBUG)# 设置控制台日志打印格式formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')console.setFormatter(formatter)# 将定义好的console日志handler添加到root loggerlogging.getLogger('').addHandler(console)"""测试logging"""s = '0'n = int(s)logging.info('n = %d' % n)print(10 / n)'''结果输出INFO:root:n = 0Traceback (most recent call last): File "/Users/yannischeng/PycharmProjects/First_Python_Project/py_obj_end_12/TestObj.py", line 69, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero''''''输出到文件中的信息：2017-07-20 09:57:51 root INFO n = 0 - [LogSet.py:27]''' 优点 允许你指定记录信息的级别，有debug，info，warning，error等几个级别。 通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。 参考 logging的配置参考：http://blog.csdn.net/naiveloafer/article/details/7630903 Format编写 Format Description %(name)s Name of the logger (logging channel). %(levelno)s |Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).%(levelname)s |Text logging level for the message (‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’).%(pathname)s |Full pathname of the source file where the logging call was issued (if available).%(filename)s | Filename portion of pathname.%(module)s | Module (name portion of filename).%(funcName)s | Name of function containing the logging call.%(lineno)d | Source line number where the logging call was issued (if available).%(created)f | Time when the LogRecord was created (as returned by time.time()).%(relativeCreated)d | Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.%(asctime)s |Human-readable time when the LogRecord was created. By default this is of the form “2003-07-08 16:49:45,896” (the numbers after the comma are millisecond portion of the time).%(msecs)d | Millisecond portion of the time when the LogRecord was created.%(thread)d | Thread ID (if available).%(threadName)s | Thread name (if available).%(process)d | Process ID (if available).%(message)s | The logged message, computed as msg % args. basicConfig()编写 对日志记录系统进行基本配置： 如果根记录器已经具有处理程序，则此函数不起作用配置。这是一个方便的方法，供简单的脚本使用做一次性配置的日志记录包。 默认行为是创建一个写入的StreamHandler sys.stderr，使用BASIC_FORMAT格式字符串设置格式化程序，和将处理程序添加到根记录器。 可以指定一些可选的关键字参数，这可以改变默认行为。 Optional Keyword Description filename 指定使用指定的FileHandler进行创建文件名，而不是一个StreamHandler。 filemode | 指定打开文件的方式，如果指定了filename（如果filemode未指定，则默认为&apos;a&apos;）。 format | 为处理程序使用指定的格式字符串。 datefmt | 使用指定的日期/时间格式。 style | 如果指定了格式字符串，请使用此字符串指定格式字符串的类型（可能的值&apos;％&apos;，&apos;{&apos;，&apos;$&apos;，for ％-formatting，：meth：`str.format`和：class：`string.Template` - 默认为&apos;％&apos;）。 level | 将根记录器级别设置为指定级别。 stream | 使用指定的流来初始化StreamHandler。注意该参数与“filename”不兼容 - 如果同时使用存在，“流”被忽略。 handlers | 如果指定，这应该是已经创建的迭代处理程序，将被添加到根处理程序。任何处理程序在没有格式化程序分配的列表中分配在此函数中创建的格式化程序。 请注意： 可以指定使用open（filename，mode）创建的流而不是传递文件名和模式。但是应该记住StreamHandler并不关闭它的流（因为它可能使用sys.stdout或sys.stderr），而FileHandler关闭其流当处理程序关闭时。 .调试器pdb – 有了PyCharm目前不考虑此种方式启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 14-单元测试]]></title>
    <url>%2FPython3%20%2014-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python “测试驱动开发”（TDD：Test-Driven Development）– 单元测试 是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 在pycharm中创建单元测试 创建参考：http://blog.csdn.net/u013088062/article/details/50183789一个案例：http://www.cnblogs.com/iamjqy/p/7155315.html 具体创建过程参考python文件夹的.png图片。 选中待要编写测试代码的类名 –&gt; 右键 选择 Go To –&gt; Test Object 单元测试实现待测试类代码12345678910111213141516class MyDict(dict): def __init__(self, **kwargs): super().__init__(**kwargs) def __getattr__(self, item): try: return self[item] except KeyError: raise AttributeError(r"'MyDict' object has no attribute '%s'" % item) def __setattr__(self, key, value): self[key] = value def add(self, m, n): print("%d + %d = %d" % (m, n, (m+n))) 单元测试类代码123456789101112131415161718192021222324from unittest import TestCasefrom py_unittext_14.MyDict import MyDictclass TestMyDict(TestCase): # setUp与tearDown # 这两个方法会分别在每调用一个测试方法的前后分别被执行。 # setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码 def setUp(self): print('setUp...') def tearDown(self): print('tearDown...') def test_add(self): d = MyDict(name='程文佳', age='24', city='Tianjin') self.assertEqual(d.name, '程文佳') self.assertEqual(d['name'], '程文佳') print(d.name) def test_add2(self): d = MyDict(name='程文佳', age='24', city='Tianjin') d.add(3, 4) 测试结果1234567891011setUp...程文佳tearDown...setUp...3 + 4 = 7tearDown...Ran 2 tests in 0.002sOK 小结 单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。 单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。 单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。 单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 11-面向对象+枚举]]></title>
    <url>%2FPython3%20%2011-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python Python中Enum枚举的实现：http://www.cnblogs.com/codingmylife/archive/2013/05/31/3110656.html 定义常量的一般方法：定义变量推荐的方法为：将枚举类型定义一个class类型。每个常量都是class的唯一实例python提供了Enum来实现枚举功能 12345678910111213141516171819202122232425262728293031323334353637# 实现方式1from enum import EnumWeek = Enum('WeekInfo', ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'))# 实现方式2from enum import Enum, unique# @unique装饰器检查保证没有重复值@uniqueclass MyEnum02(Enum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sta = 6# 遍历Enumfor name, value in Week.__members__.items(): print(name, value, m.value)print(Week.Mon.value) # 1"""Mon WeekInfo.Mon 1Tue WeekInfo.Tue 2Wed WeekInfo.Wed 3Thu WeekInfo.Thu 4Fri WeekInfo.Fri 5Sat WeekInfo.Sat 6Sun WeekInfo.Sun 7"""# 使用MyEnum02print(MyEnum02(1)) # MyEnum02.Mon]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 12-面向对象+元类]]></title>
    <url>%2FPython3%20%2012-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 静态语言和动态语言最大的不同，就是函数和类的定义。不是编译时定义的，而是运行时动态编译的。 关键字：type(), metaclass 一般的class创建123456789101112131415class Hello(object): def hello(self): print('Hello World !')from py_obj_end_12.Hello import Hello"""导入Hello类后的测试"""h = Hello()print(h.hello()) # Hello World !# 查看实例h所属的类型，是class Helloprint(type(h)) # &lt;class 'py_obj_end_12.Hello.Hello'&gt;# 查看Hello所属的类型，是 type 类型print(type(Hello)) # &lt;class 'type'&gt; 使用type()来动态创建类type 是什么？为什么 Hello 会是 type 类型的？ 因为Python是动态语言，所以class的定义是运行时动态创建的，而创建class使用的就是type()函数 type()函数既可以返回一个对象的类型，又可以创建出新的类型。 通过type()创建class和直接写class是完全一样的。 因为python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 正常情况下，我们使用class Xxx创建一个类。但是，因为type()函数允许我们动态的将类创建出来。 动态语言本身支持处于运行期的程序动态创建一个类。这和Java的静态语言不同。 type()使用：http://www.cnblogs.com/ccorz/p/6120783.html type(name, bases, dict) 返回一个新的type对象. 基本上是 class 语句的动态形式. 参数: name , 字符串, 制定要构造类的名字, 赋给新对象的 __name__ 属性; bases，一个tuple，指定新类型的所有基类，赋给新对象的__bases__ 属性; dict， 字典类型，作为新类的名字空间，赋给新对象的__dict__ 属性 12345678910111213141516171819# 用type()函数创建Hello类# 1.定义一个函数。即：类的方法def say(self): print('Hello, World 2!')# 2.创建一个class Hello2。type()函数中传入的参数：# 1）class类名，2）继承的父类集合，3）class的方法名与函数的绑定，此处即：将函数say()绑定至方法名hello上# 其实class定义一个类主要也是这3个主要组成部分：类名、继承类、方法# Hello2是一个以名为"Hello22"的类的引用。这个名为"Hello22"的类以object为基类,类中有一个say()函数Hello2 = type('Hello22', (object,), dict(say=say))# 3.为类绑定一个变量Hello2.name = 'cwj'# 测试h2 = Hello2()print(h2.say()) # Hello, World 2!print(h2.name) # cwj metaclass使用metaclass来控制类的创建行为]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 13-错误+测试+调试]]></title>
    <url>%2FPython3%20%2013-%E9%94%99%E8%AF%AF%2B%E6%B5%8B%E8%AF%95%2B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 错误12345678try: """ 可能出错的代码块 """except ZeroDivisionError as e: print('except:', e)finally: print('finally...') 错误特点 Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。 使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，即：不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。比如函数main()调用foo()，foo()调用bar()，结果bar()出错了。这时，只要main()捕获到了就可以处理bar()中的错误。 记录错误 捕获错误，把错误堆栈打印出来，分析错误原因，同时，让程序继续执行下去而不是使得程序被结束。 使用方法 12345678import logging# 同样是出错，但程序打印完错误信息后会继续执行，并正常退出.# 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。try: bar('0')except Exception as e: logging.exception(e) 抛出错误 因为错误是class。捕获一个错误就是捕获到该class的一个实例。 既可以使用python的内置函数抛出错误，也可以自己编写函数抛出错误。 使用关键字raise抛出一个错误实例 代码示例 1234567891011121314151617181920# 编写自定义异常类class FooError(ValueError): passdef foo(s): n = int(s) if n==0: raise FooError('invalid value: %s' % s) return 10 / n# 调用自定义的异常类foo('0')# 报的错误Traceback (most recent call last): File "err_throw.py", line 11, in &lt;module&gt; foo('0') File "err_throw.py", line 8, in foo raise FooError('invalid value: %s' % s)__main__.FooError: invalid value: 0]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 10-面向对象+定制对象]]></title>
    <url>%2FPython3%20%2010-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E5%AE%9A%E5%88%B6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 在编写一个基础类的基础上，为其重写某些魔法方法。 python其他内置魔法方法： https://docs.python.org/3/reference/datamodel.html#special-method-nameshttp://www.cnblogs.com/simayixin/archive/2011/05/04/2036295.htmlpython常用魔法方法的实现：http://www.cnblogs.com/scolia/p/5690210.html 魔法方法有：-1.__new__()：对象的创建，是一个静态方法，第一个参数是cls。(不可能是self，因为对象还没创建，哪来的self)—提示单例模式与此有关。0.__init__()：对象的初始化， 是一个实例方法，第一个参数是self。1.__slots__()：约束要绑定的临时变量2.__len__()：让类作用于len()3.__str__()：类似于java中的toString()，返回用户看到的字符串4.__repe__()：返回开发者看到的字符串5.__iter__()：将一个类被用于for...in循环中，返回一个迭代对象6.__getitem__()：像list那样按照下标取出元素，要在其中处理slice切片、step步长7.__getattr__()：当调用不存在的属性时，Python解释器会试图调用__getattr__(self, &#39;attr&#39;)来尝试获得属性。只有在没有找到属性的情况下，才调用__getattr__，已有的属性将不会在__getattr__中查找。而且，实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。8.__call__() __iter__() 配合 __next__()使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person(object): # 构造方法 def __init__(self, name): self._name = name self.a, self.sum = 1, 0 # 使本类可以迭代 def __iter__(self): return self # 具体的迭代方法，此方法的实现是关键 def __next__(self): self.sum = self.sum + self.a if self.sum &gt; 10: raise StopIteration return self.sum # 重写 toString()方法 def __str__(self): return 'Person name is ' + self._name __repr__ = __str__ '''测试'''person = Person("cwj")# 重写 __str__() 之后的效果print(Person("cwj")) # Person name is cwjprint(person) # Person name is cwjprint(isinstance(person, Iterator)) # Trueprint(isinstance(person, Iterable)) # Truel = []# 遍历Person序列，此时Person是一个Iteratorfor n in person: l.append(n) print(n)# 将一个类遍历后得到的结果赋值给l序列print(l) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'''12345678910''' __getitme__()配合__setitme__()使用12345678910111213141516171819class DictDemo(object): def __init__(self): self.dict = &#123;&#125; def __getitem__(self, item): if item in self.dict: return self.dict[item] else: return '不存在' def __setitem__(self, key, value): self.dict[key] = value '''测试'''dictD = DictDemo()dictD['1'] = 'cwj'dictD.__setitem__('1','234')print(dictD.__getitem__('1')) # 234print(dictD['2']) # 不存在 一个实现迭代、容器的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112'''Animal类 自定义魔法函数'''from pip._vendor.requests.packages.urllib3.connectionpool import xrange'''创建一个模拟字典的类，这个类的内部维护了两个列表，key 负责储存键，value 负责储存值，两个列表通过索引的一一对应，从而达到模拟字典的目的'''class Animal(object): def __init__(self, key, value): self.key = [] self.value = [] self.key.append(key) self.value.append(value) self.__index = 0 # __len__方法，按照协议，这个方法应该返回容器的长度 def __len__(self): return len(self.key) # __getitem__方法。这个方法会在a['scolia']时，调用a.__getitem__('scolia')。 # 也就是说这个方法定义了元素的获取. # 先找到 key 列表中建的索引，然后用索引去 value 列表中找对应的元素，然后将其返回 def __getitem__(self, item): if item in self.key: return self.value[self.key.index(item)] else: return '不存在' # __setitem__(self, key, value)方法定义了 a['scolia'] = 'good' 这种操作时的行为， # 此时将会调用a.__setitem__('scolia', 'good') 因为是绑定方法，所以self是自动传递的 def __setitem__(self, key, value): if key not in self.key: self.key.append(key) self.value.append(value) else: __index = self.key.index(key) self.value[__index] = value # __delitem__(self, key)方法定义了del a['scolia'] 这类操作时候的行为， # 里面的‘scolia’就作为参数传进去 def __delitem__(self, key): if key in self.key: __index = self.key.index(key) del self.key[__index] del self.value[__index] else: return "key值不存在" '''只有实现里以上四个方法，就可以当做可变容器来使用了。''' # __str__ 是对应于 str() 函数，在类的表示中会继续讨论，这里是为了 print 语句好看才加进去的， # 因为print语句默认就是调用str()函数 def __str__(self): l = [] for index in xrange(len(self.key)): __key = self.key[index] __value = self.value[index] result = __key,__value l.append(result) return str(l) # 实现一个__iter__方法，这个方法负责返回一个迭代器 def __iter__(self): return self # 内部实现了next（python3.x为__next__）方法，真正负责迭代的实现。 # 当迭代器内的元素用尽之后，任何的进一步调用都之后触发 StopIteration 异常 # 一般会在一个类里同时实现这两种方法（即是可迭代对象又是迭代器），此时__iter__方法只要返回self就足够的了 def __next__(self): if self.__index == len(self.key): self.__index = 0 raise StopIteration() else: __key = self.key[self.__index] __value = self.value[self.__index] result = __key, __value self.__index += 1 return result # __contains__实现了成员判断，这里我们更关心value列表中的数据，所以判断的是value列表。 # 该方法要求返回布尔值。 def __contains__(self, item): if item in self.value: return True else: return False # __reversed__(self)方法返回一个倒序后的副本，这里体现了有序性 def __reversed__(self): __result = self.value __result.reverse() return __result'''实际测试'''m = Animal('1', 'cwj')print(m) # [('1', 'cwj')]print(m.__len__()) # 1m['2'] = 'ddd'm['3'] = 'qwe'm['2'] = 'lkj'print(m) # [('1', 'cwj'), ('2', 'lkj'), ('3', 'qwe')]print(m.__len__()) # 3del m['3']print(m) # [('1', 'cwj'), ('2', 'lkj')]print(m.__len__()) # 2print(reversed(m)) # ['lkj', 'cwj']print('cwj' in m) # True 类的切片操作 参考：http://www.cnblogs.com/scolia/p/5690210.html 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Slices(object): def __init__(self, x): self._x = x self._index = -1 ''' # __getitem__()实现支持for循环 def __getitem__(self, item): if isinstance(self._x, list): self._index += 1 return self._x[self._index] else: raise '参数类型错误' ''' def __getitem__(self, item): # print(item.start, item.stop, item.step) # 1 2 1 # return item # slice(1, 2, 1) if isinstance(item, slice): return self._x[item.start:item.stop:item.step]'''测试Slices类''''''s = Slices([1, 2, 3, 4])for n in s: print(n)'''1234'''s2 = Slices('1234')for n in s2: print(n)'''s3 = Slices([1, 2, 3, 4, 5])# 当直接返回item参数时的结果# print(s3[1:4:1]) # slice(1, 2, 1)print(s3[1:4:1]) # [2, 3, 4]print(s3[-4:-2]) # [2, 3]print(s3[-3:-1]) # [3, 4]print(s3[-5:]) # [1, 2, 3, 4, 5]print(s3[:]) # [1, 2, 3, 4, 5]print(s3[-1::-1]) # [5, 4, 3, 2, 1]print(s3[-1:]) # [5]``` ## `__getattr__()`正常情况下，当我们调用类的`方法`或`属性`时，如果不存在，就会报错。如：```pythonAttributeError: 'Student' object has no attribute 'score' 要避免这个错误，Python有一个机制：写一个__getattr__()方法，动态返回一个属性。当调用不存在的属性时，比如color，Python解释器会试图调用__getattr__(self, &#39;color&#39;)来尝试获得属性，这样我们就有机会返回color的值 123456789101112131415# 返回不存在的属性与函数# 作用：可以针对完全动态的情况作调用def __getattr__(self, item): # 返回未定义的属性 if item == 'color': return '您真是 666 啊 ~ 这个属性都鞥猜到' elif item == 'address': return '哈哈哈' # 返回未定义的函数 elif item == 'add': return lambda: 100 else: # 注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None # 要让class只响应特定的几个属性,要按照约定，抛出AttributeError错误 raise AttributeError('\'Student\' object has no attribute \'%s\'' % item) __call__()与__getattr__()组合实现URL中的链式(chain)调用在python中，函数其实是一个对象。如： 12345&gt;&gt;&gt; f = abs&gt;&gt;&gt; f.__name__'abs'&gt;&gt;&gt; f(-123)123 由于 f 可以被调用，所以，f 被称为可调用对象。所有的函数都是可调用对象。一个类的实例对象想要变成一个可调用的对象，只需要实现一个魔法方法__call__()。 可调用对象与一般对象 可调用对象：obj.name(‘source’).age。即：既可以使用.调用属性或方法，也可以使用obj()以一种函数样式使用此对象。此时调用obj(arg1,arg2,....)就等价于obj.__call__(self,arg1,arg2,...) 一般对象：obj.name。即：只能使用.调用属性或方法。 因为__call__()魔法方法的加入，因此python的函数与对象之间的概念被模糊了 URL中的链式调用，这样无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变，代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344'''URLChain类'''class URLChain(object): def __init__(self, path = ''): self.__path = path def __getattr__(self, item): # 实现参考：https://zhidao.baidu.com/question/1865282935722979707.html # 返回一个 URLChain 对象，这个时候里面的path就是''+'/'+'api'='/api'，此时self = /api print('\'self.__path is\' :' + self.__path + ' , \'item is\' : ' + item + ' ， 之前self为：', self) # 即：上一个 '%s/%s' 的数值代替：构造函数中 path = ''中 '' 的具体数值，相当于重新构造了一个对象， # 在即将的调用的返回值中表示参数self.__path的值, 新传入的参数赋值给item return URLChain('%s/%s' % (self.__path, item)) def __str__(self): return self.__path __repr__ = __str__ # 将此类的实例对象变成一个可调用的对象 def __call__(self, path): print('__call__ 之前self is : ', self) print('__call__ path is : ' + path) return URLChain('%s/%s' % (self.__path, path))'''调用URLChian类'''chain = URLChain()print(chain.api.server.user.friends)''''self.__path is' : , 'item is' : api ， 之前self为： 'self.__path is' :/api , 'item is' : server ， 之前self为： /api'self.__path is' :/api/server , 'item is' : user ， 之前self为： /api/server'self.__path is' :/api/server/user , 'item is' : friends ， 之前self为： /api/server/user/api/server/user/friends'''# 当执行 ('cwj') 这一个参数时调用的是 URLChian的 __call__()print(chain.api.server('cwj').friends)''''self.__path is' : , 'item is' : api ， 之前self为： 'self.__path is' :/api , 'item is' : server ， 之前self为： /api__call__ 之前self is : /api/server__call__ path is : cwj'self.__path is' :/api/server/cwj , 'item is' : friends ， 之前self为： /api/server/cwj/api/server/cwj/friends''' callable()的使用：判断一个变量是函数还是对象代码示例 1234# 判断一个对象是否能被调用，能被调用的对象就是一个Callable对象,函数和自定义的带有__call__()的类实例对象返回值是True：print(callable(chain)) # True URLChian实现了__call__()魔法方法print(callable(dictD)) # Falseprint(callable(abs)) # True]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 09-面向对象]]></title>
    <url>%2FPython3%20%2009-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 类的模板123456789101112131415161718192021222324252627'''类模板'''class Student(object): def __init__(self, name, age, city): self.name = name self.age = age self.__city = city def print_info(self): print('self is : ', self) # self is : &lt;py_class.Student.Student object at 0x10c92c400&gt; # print(student) 得到的结果为：&lt;py_class.Student.Student object at 0x10c92c400&gt; print('class is : ', self.__class__) # class is : &lt;class 'py_class.Student.Student'&gt; print('%s, %d, %s' % (self.name, self.age, self.__city)) def get_age(self): if self.age == 20: print('age is ', self.age) elif self.age &gt; 20: print('too old') else: print('too young') def get_city(self): return self.__city def set_city(self, city): self.__city = city 属性 1.类属性：像是Student类中的name就是类属性 2.实例属性：像是下文中的student.__city就是实例属性 类中变量及函数的命名规范 以__开始，并以__ 双下划线 结束的是python中的特殊变量，特殊变量是可以直接访问的，不是private变量 class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的.通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类 __init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去 在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。 self指向的类的实力对象。由： 12print('self is : ', self) # self is : &lt;py_class.Student.Student object at 0x10c92c400&gt;print(student) # &lt;py_class.Student.Student object at 0x10c92c400&gt; 可以看出，self和student的 内存地址 是一样的。代码示例 123456789'''调用'''# 创建实例对象student = Student('cwj',24, 'tianjin')student.print_info() # cwj, 24, tianjinstudent.get_age() # too old# 访问属性student.age = 19student.name = 'ddd' 访问限制虽然有访问限制的命名方式，但是Python本身没有任何机制阻止你干坏事，一切全靠自觉。 两个下划线开头的变量，声明为类内部的私有变量，不能在类的外部直接使用或访问：在变量前面添加__，即：__name。在类内部的方法中使用时 self.__private_attrs。 两个下划线开头的方法，声明为类内部的私有方法。不能在类地外部调用，在类的内部调用 self.__private_methods. 单下划线开头表示的protected类型的变量，只允许本身及其子类进行访问。 类的方法在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数代码示例: 123456789101112131415161718192021 # 此行代码貌似修改了 Student 类中的 __city 属性,实际这是为student添加了一个属性。 student.__city = 'beijing' # 而且输出结果也显示；__city 属性 的值也变成了：beijing print(student.__city) # beijing # 但是，当我们通过类自身的get()获取属性值时，发现还是之前初始化时的属性值。即：tianjin print(student.get_city()) # tianjin print(hasattr(student, 'name')) # True # 删除临时添加的 __city 属性 # del student.__city# print(student.__city) # AttributeError: 'Student' object has no attribute '__city' # 当我们通过类自身的set()方法修改 __city 属性值时，通过get()得到的属性值是修改之后的。 student.set_city('hk') print(student.get_city()) # hk # 由此可以得出：此时的 student.__city 与 student.set_city() 中的 __city 并不是同一个属性 # student.__city 中的 __city 是student的一个新的同名属性 student.print_info() # ddd, 19, hk Python内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串，即：注释 __name__: 类名 __module__: 类定义所在的模块（类的全名是__main__.className，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 代码示例 123456789101112131415# 由 类 进行调用 __dict__print(Student.__dict__) # &#123;'__module__': 'py_class.Student', '__init__': &lt;function Student.__init__ at 0x100ccf8c8&gt;, 'print_info': &lt;function Student.print_info at 0x100ccf950&gt;, 'get_age': &lt;function Student.get_age at 0x100ccf9d8&gt;, 'get_city': &lt;function Student.get_city at 0x100ccfa60&gt;, 'set_city': &lt;function Student.set_city at 0x100ccfae8&gt;, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None&#125;# 由 对象 调用 __dict__ 方法类似于：java中的toString()print(student.__dict__) # &#123;'name': 'ddd', 'age': 19, '_Student__city': 'hk', '__city': 'beijing'&#125;print(student.__doc__) # None# 由 类 进行调用print(Student.__name__) # Studentprint(student.__module__) # py_class.Student# 由 类 进行调用print(Student.__bases__) # (&lt;class 'object'&gt;,) python对象的销毁垃圾回收 —— 引用计数 + 循环引用 引用计数法。当跟踪变量对象的引用计数变为0时，它将会被回收。但不是立即被回收，而是由‘解释器’在适当的时机将其回收。 循环引用。当两个对象相互引用，但是没有其他的变量引用他们。此时循环垃圾回收器将会工作。 代码示例 1del student.__city 继承支持多继承父类的构造器（__init__(self)）不会被自动调用，需要在子类中亲自专门调用python总是先在本类中查找调用的方法，找不到才会去父类中继续寻找 几个基础的重载方法 1.__init__(self,[]) 构造方法 2.__del__(self) 删除一个对象，dell obj 3.__repr__(self) 转化为供解释器读取的形式 4.__str__(self) 将值转化为始于人阅读的形式 5.__cmp__(self,x) 对象比较 代码示例 父类 123456789101112131415161718192021222324252627'''父类 1 ''' class Animal(object): def __init__(self, name, age): self.__name = name self.__age = age def get_name(self): return self.__name def get_age(self): return self.__age def set_name(self, name): self.__name = name def set_age(self, age): self.__age = age def run(self): print('Animal is running') '''父类 2''' class Pet(object): def play(self): print(self.__name + " is very good !") 子类 1234567891011121314151617181920212223242526272829303132333435363738from py_class.Animal import Animalfrom py_class.Pet import Pet# 多继承class Pig(Animal, Pet): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print('pig is running very slowly...')from py_class.Animal import Animal# 单继承class Dog(Animal): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print(self.__name + ' is running')from py_class.Animal import Animal# 单继承class Cat(Animal): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print(self.__name + 'is running') 测试类 123456789101112131415161718from py_class.Animal import Animalfrom py_class.Dog import Dogfrom py_class.Cat import Catfrom py_class.PIg import Pigdog = Dog('wangwang', 1)dog.run()cat = Cat('miaomiao', 1)cat.run()pig = Pig('big pig', 100)pig.run() # pig is running very slowly...# pig.play() # big pig is very good !print(isinstance(cat, Animal)) # Trueprint(isinstance(cat, Cat)) # True'''由此可见，cat变量既是Cat类型，也是Animal类型''' 多态代码示例 1234567891011121314151617181920212223242526''' 多态的实现方式 1 类似于java这种静态语言的实现，必须传入Animal类型或其子类 # 多态的使用 将 父类 作为参数def run_test(animal): animal.run()'''''' 多态的实现方式 2 属于python的动态语言实现' 这种方式实现的结果与 方式 1 完全一样 原理： 不一定要传入Animal类型，只要保证传入的对象一个run()方法就可以了. 例如：传递的对象为ints，这不是Animal的任何一个子类，只要将赋予run()方法就足以。 动态语言的'鸭子类型'： 它并不要求严格的继承体系，一个对象只要"看起来像鸭子，走起路来像鸭子"，那么它就是鸭子。'''def run_test(ints): ints.run()# 多态的使用 实际参数为具体的子类，得到的结果为各个子类的具体表现run_test(Animal('Animal', 1)) # Animal is runningrun_test(Dog('Dog', 1)) # Dog is runningrun_test(Cat('Cat', 1)) # Catis runningrun_test(Pig('Cat', 1)) # pig is running very slowly... 获取对象信息 getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 12345678910111213141516171819202122232425262728'''isinstance() 查看一个变量的继承关系'''print(isinstance(cat, Animal)) # Trueprint(isinstance(cat, Cat)) # Trueprint(isinstance(pig, Animal)) # Trueprint(isinstance(pig, Pet)) # Trueprint(isinstance(pig, Pig)) # True''' type() 当使用继承关系时，使用type()不能一直向上得到他们的父类， 因此，对于有 继承关系 的类来说不合适'''print(type(123)) # &lt;class 'int'&gt;print(type(dog)) # &lt;class 'py_class.Dog.Dog'&gt;def compare(obj1, obj2): if type(obj1) == type(obj2): print(type(obj1) == type(obj2)) print(str(obj1) + '==' + str(obj2)) else: print(type(obj1) == type(obj2)) # False print(str(obj1) + '!=' + str(obj2))compare(dog, cat)'''获取一个对象所有的属性和方法'''print(dir(dog))# ['_Dog__age', '_Dog__name', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'get_age', 'get_name', 'run', 'set_age', 'set_name']]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 09-面向对象+临时变量、方法+@property+多继承]]></title>
    <url>%2FPython3%20%2009-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%2B%40property%2B%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 绑定临时变量和临时函数 – 不限定参数使用python语言`动态语言`这一特性。 绑定临时变量 为实例对象绑定临时变量 123456# 动态的将 new_name 属性绑定至 实例 中dog.new_name = 'new cwj'print(dog.new_name) # new cwj# 删除临时添加的 new_name 属性del dog.new_name 为类绑定临时变量 123456789# 动态的将 new_name_2 属性绑定至 Dog类 中Dog.new_name_2 = 'new cwj 2'print(dog.new_name_2) # new cwj 2dog2 = Dog('wangwang', 1)print(dog2.new_name_2) # new cwj 2'''可以看到 dog 与 dog2 两个实例都具有 new_name_2 属性，由此可见 new_name_2 属性已经动态的添加至Dog类中''' 绑定临时函数 为实例对象绑定临时函数 12345678910111213141516171819202122232425from types import MethodTypedef set_color(self, color): self.color = color# 给实例绑定一个方法dog.set_color = MethodType(set_color, dog)# 通过这个方法为临时的color赋值dog.set_color('red')# set_color()这个方法是临时赋给dog变量的，而不是赋给dog2的# dog2.set_color('green') # AttributeError: 'Dog' object has no attribute 'set_color'# 输出临时参数color的值print(dog.color) # red# 删除临时方法，删除此方法的同时，也删除了此方法内的历史变量del dog.set_color# 删除临时参数# del dog.color# 当删除临时方法后，此方法将不再能使用# dog.set_color('green') # AttributeError: 'Dog' object has no attribute 'set_color' 为类绑定临时函数 1234567891011121314151617# 定义一个临时的方法def set_color2(self, color): self.color = color# 将临时定义的方法绑定给 Dog这个类Dog.set_color2 = set_color2# Dog类的两个变量dog和dog2分别调用set_color2()dog.set_color2('blue')dog2.set_color2('black')# 测试临时函数是否对临时变量赋值成功print(dog2.color) # blackprint(dog.color) # blue# 删除临时的方法del Dog.set_color2 绑定临时变量和临时函数 – 限定参数 __slots__变量`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的. 除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__` 代码示例 12345678910111213141516171819202122'''声明Pet类'''class Pet(object): ''' 使用一个特殊的变量 __slots__，这个变量可以限制外部为Pet类添加的属性。 例如此处，只允许外部为Pet类添加 name 和 age 两个属性 ''' __slots__ = ('name2', 'age')'''调用Pet类'''pet = Pet()pet.name2 = 'big pig'pet.age = 2# 通过 __slots__ 变量的声明，color不允许被定义# pet.color = 'yellow' # AttributeError: 'Pet' object has no attribute 'color'# print(Pet.__doc__) # 输出注释print(pet.name2) # big pigprint(pet.age) # 2# pig 实例对象不能调用临时变量 name2，因为 __slots__变量定义的参数名称之能限定在它所在的类中，对子类不起作用# print(pig.name2) # AttributeError: name2 @property的使用既能检查参数，又可以`用类似属性`这样简单的方式来`访问类的变量` 实现 关键字：@property,@参数名.setter 代码示例 - Pet类 12345678910111213141516171819'''Pet类'''class Pet(object): def play(self): print(self.__name + " is very good !") '''@property的使用''' # 此处的 color 为 此类对外界声明的一个变量，即：是一个变量名 # 此方法相当于 get_color() @property def color(self): return self._color # 此方法相当于 set_color(self, color) @color.setter def color(self, color): if not isinstance(color, str): raise ValueError('input a str') self._color = color 代码示例 - 调用 123456# 错误的写法，验证对于参数的检验# pet.color = 123 # ValueError: input a strpet2 = Pet()# 为Pet类的color属性设置具体的参数pet2.color = 'grew'print(pet2.color) # grew 多继承在设计类的继承关系时，通常，主线都是单一继承下来的，如果需要“混入”额外的功能，通过多重继承就可以实现，一个类在继承了一个类的基础上，再次继承另一个类。这种设计通常称之为`MixIn`。 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 如： 12class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 08-模块]]></title>
    <url>%2FPython3%20%2008-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python Python所有的内置函数：https://docs.python.org/3/library/functions.html 定义在`python`中一个`.py`文件就是一个模块(Module) 优点 提高代码的可维护性 代码的复用性 避免函数名和变量名的冲突 为避免模块名命名冲突，引入了包(每一个包目录下都有一个文件：__init__.py。这个文件是必须存在的，否则python回将这个目录当成普通的目录，而不是一个python包。这个文件可以是空文件，也可以有代码。因为__init__.py本身就是一个模块(mycompany)) 模板1234567891011121314151617#!/usr/bin/env python3# _*_ coding:utf-8 _*_# 当前模块的文档注释，任何模块代码的第一行字符串都视为该模块文档的注释'A test module'# 使用'__author__'变量将作者的名字写入此模块__author__ = 'Yannis Cheng''''以上为python模块的标准文件模板''''''注意到这两行代码：'''if __name__=='__main__': test()'''当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。''' 安装第三方模块在Python中，安装第三方模块，是通过包管理工具`pip`完成的。 在Mac或者Linux下可能会并存`Python 3.X`和`Python 2.X`，此时的命令应该为`pip3` 函数&amp;变量 作用域 公开public：可以被直接引用，如’abs‘等。类似__name__这样的变量是特殊变量可以被直接引用。自己定义的变量一般不使用这种变量名。 非公开：_abc，__aabc python中并没有一种方法可以完全限制访问private函数访问，但是从编程习惯中不应该引用private函数或变量]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 06-闭包+匿名+装饰器+偏函数]]></title>
    <url>%2FPython3%20%2006-%E9%97%AD%E5%8C%85%2B%E5%8C%BF%E5%90%8D%2B%E8%A3%85%E9%A5%B0%E5%99%A8%2B%E5%81%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 参考：http://www.cnblogs.com/vamei/archive/2012/12/15/2772451.html 闭包闭包是函数式编程的重要语法结构，python是以`函数对象`为基础的，python一切皆对象。函数这一语法结构也是一个对象。 定义解释 在一个内部函数里，对在外部作用域的（非全局）变量进行引用，那么内部函数就认为是闭包closure ‘闭包’是‘词法闭包’的简称，是指应用了自由变量的函数。这个被引用的自由变量的将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 ‘闭包’是由函数和其他相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 ‘python’中的闭包：一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。而这个函数B就叫做闭包，在调用函数A时传递的参数就是自由变量。 闭包实际上就是一个简化的类，它提高了代码的复用性 闭包函数代码示例 123456789101112'''闭包示例代码inner_func就是一个闭包函数，它引用自由变量name。name就是inner_func()的环境变量'''def func01(name): def inner_func(age): print('name: ', name, 'age: ', age) return inner_funcbb = func01('cwj')bb(25) # name: cwj age: 25 关于闭包函数的使用问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152'''错误的闭包函数 1 闭包函数中， 闭包中的变量m不会修改外部函数中m的值。'''def foo(): m = 0 def fool(): m = 11 print(m) print(m) # 0 fool() # 11 print(m) # 0print(foo())'''错误的闭包函数 2 '''def foo2(): a = 1 def fool2(): # a = a +1 # UnboundLocalError: local variable 'a' referenced before assignment return a # 1 return fool2ccc = foo2() # 此时：ccc = fool2，ccc只是获得到了一个对象print(ccc()) # 此时：ccc = fool2(), ccc获取到的是一个实例flist = []for i in range(3): # 编写 1 # def foo3(x): def foo3(x, y = i): # 编写 1 的输出 # print(x + i) print(x + y) flist.append(foo3)for f in flist: f(2)'''编写 1 的运行结果为：444结果是4,4,4。这是因为当把函数加入flist列表里时，python还没有给i赋值，只有当执行时，再去找i的值是什么，这时在第一个for循环结束以后，i的值是2，所以以上代码的执行结果是4,4,4.编写 2 的运行结果为：234在程序里面经常会出现这类的循环语句，Python的问题就在于，当循环结束以后，循环体中的临时变量i不会销毁，而是继续存在于执行环境中。还有一个python的现象是，python的函数只有在执行时，才会去找函数体里的变量的值''' 闭包的作用 参考：http://www.jb51.net/article/54498.htm 闭包主要在函数开发中使用 当闭包函数执行完毕后，仍然能够保持住当前的运行环境 闭包可以根据外部作用域的局部变量来得到不同的结果 引用：闭包与并行运算 闭包有效的减少了函数所需定义的参数数目。这对于并行运算来说有重要的意义。在并行运算的环境下，我们可以让每台电脑负责一个函数，然后将一台电脑的输出和下一台电脑的输入串联起来。最终，我们像流水线一样工作，从串联的电脑集群一端输入数据，从另一端输出数据。这样的情境最适合只有一个参数输入的函数。闭包就可以实现这一目的。 并行运算正称为一个热点。这也是函数式编程又热起来的一个重要原因。函数式编程早在1950年代就已经存在，但应用并不广泛。然而，我们上面描述的流水线式的工作并行集群过程，正适合函数式编程。由于函数式编程这一天然优势，越来越多的语言也开始加入对函数式编程范式的支持。 匿名函数定义 匿名函数由关键字lambda表示。:前面的参数名表示函数的参数，:后面的表达式表示为函数执行具体操作的表达式。 ####特点 python对匿名函数的支持有限，只能在一些简单的情况下使用匿名函数 匿名函数有个数限制，只能有一个表达式，不用写return，返回值就是该表达式的结果。 代码示例 1234'''匿名函数的使用 - 1'''print(list(map(lambda x: x*x, [1, 2, 3, 4]))) # [1, 4, 9, 16]'''匿名函数的使用 - 2''' 装饰器定义在代码运行期间动态增加功能的方式，称之为“装饰器(decorator)” 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192'''原函数def now(): print('2017-07-16')now() # 2017-07-16''''''定义一个 now() 的 装饰器函数 log()'''def log(func_origin): def add_func(*args, **kwargs): print('call %s()' % func_origin.__name__) # 因为log()是一个decorator，所以接受一个函数作为参数，并返回一个函数。 # 返回原函数所具有的功能 return func_origin(*args, **kwargs) return add_func'''使用 装饰器函数 log()'''@log# @log 等价于 now = log(now)def now(): print('2017-07-16')'''调用被装饰器装饰的函数now()'''now()'''运行结果：call now()2017-07-16释义：由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。''''''需要传入参数的decorator, 即：3层嵌套'''def log2(text): def decorator(func): def wrap(*args, **kwargs): print('%s %s()' % (text, func.__name__)) # return func(*args, **kwargs) return func() # 输出结果中有：2017-07-16 # return func # 输出结果中没有：2017-07-16 return wrap return decorator'''3层嵌套的使用'''#@log2('execute')# @log2 等价于 now2 = log2('execute')(now2)def now2(): print('2017-07-16')now2 = log2('execute')(now2)now2()'''运行结果：def now():print('2017-07-16')''''''函数也是对象，它有__name__等属性，但经过decorator装饰之后的函数，它们的__name__已经从原来的'now2'变成了wrap'''print(now2.__name__) # wrapdef log3(text): def decorator3(func3): @functools.wraps(func3) # 词条语句等价于 # wrap3.__name__ = func3.__name__ # 需要把原始函数的__name__等属性复制到wrap3()函数中，否则，有些依赖函数签名的代码执行就会出错。 def wrap3(*args, **kwargs): print('%s %s()' % (text, func3.__name__)) # return func3() func3() return wrap3 return decorator3@log3('execute')def now3(): print('2017-07-16')now3()print('now3 name is : ', now3.__name__)'''运行结果execute now3()2017-07-16now3 name is : now3''' 偏函数定义当函数的参数个数太多，需要简化时，使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 代码示例 12345int2 = functools.partial(int, base=2)#等价于def int2(x, base=2): return int(x, base) functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 05-函数式编程-高阶函数]]></title>
    <url>%2FPython3%20%2005-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ `Python`对函数式编程提供部分支持。由于`Python`允许使用变量，因此，`Python`不是纯函数式编程语言。 函数与变量互指代码示例 12345x = abs # 函数名其实也是一个变量，变量之间是可以互指。print(x(-10)) # 10。此时，x就是一个求'绝对值'的函数abs = 10print(abs) # 10print(abs(10)) # TypeError: 'int' object is not callable。此时的abs已经不是一个函数，而是一个值为10的变量。 高阶函数将函数作为参数传入另一个函数，这样的函数被称为高阶函数。 代码示例 12345def high_func(z, y, f): return f(z) + f(y)# 将函数abs作为一个参数指向变量fprint(high_func(-1, -3, abs)) # 4 高阶函数 - map() map接收两个参数：一个是函数，另一个是Iterable， map函数的意义是：将传入的函数依次作用于每一个序列的每一个元素，并将结果作为新的Iterator返回 1234567891011121314151617181920212223242526272829303132333435363738def func(x): return x * x'''通过一行代码实现：序列中的每一个元素进行取平方运算，将结果作为list序列输出'''print(list(map(func, [1, 2, 3, 4, 5]))) # [1, 4, 9, 16, 25]v = map(func, [1, 2, 3, 4, 5])print(isinstance(v, Iterator)) # Trueprint(isinstance(v, Iterable)) # Trueprint(isinstance('abc', Iterator)) # False'''使用 next() 输出Iterator类型的对象 修改前'''# while True:# print(next(v))'''1StopIteration491625''''''修改后'''while True: try: print(next(v)) except StopIteration: break'''1491625''' 高阶函数 - reduce() 参数：两个参数。函数名，序列 作用：将结果继续和序列的下一元素做函数名指定的运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ls = [1, 2, 3, 4, 5]def fun_add(x, y): return x + yprint(reduce(fun_add, ls)) # 15.# 将序列 ls 中的数变成组合成一个整数def func_int(x, y): return x * 10 + yprint(reduce(func_int, ls)) # 12345def func_str(s): # 将字符串转换为int类型。根据`键`取对应的`值` return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s]# 将str类型变为int类型print(reduce(func_int, list(map(func_str, '1234567')))) # 1234567# 将以上方法编写为一个str类型转int的方法def func_str_to_int(s): def f_int(x, y): return x * 10 + y def f_str(ss): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[ss] return reduce(f_int, map(f_str, s))print(func_str_to_int('11223344')) # 11223344'''测试，将不规则的输入按照指定的要求输出。如：'AsdA' 'asdS' 输出后的结果为：'Asda', 'Asds' '''def func_rule(s): # if isinstance(s, str): if isinstance(s, list): def func_to_up(ss): return ss[0].upper() + ss[1::].lower() return list(map(func_to_up, s)) else: print('输入的参数类型有误！') return '-1'L1 = ['adam', 'LISA', 'barT']print(func_rule(L1)) # ['Adam', 'Lisa', 'Bart']'''求乘积'''ll = [3, 5, 7, 9]def prod(lll): def xx(x, y): return x * y return reduce(xx, lll)print(prod(ll)) # 945 高阶函数 - filter() 作用：过滤函数. True保留序列中的元素，False删除序列中的元素 1234567lf = [1, 2, 3, 4, 5]# 过滤一个序列中的偶数def func_odd(n): return n % 2 == 1print(list(filter(func_odd, lf))) # [1, 3, 5] 高阶函数 - sorted() 排序算法 1234567891011121314151617181920212223# 对list类型的数据排序ls01 = [1, -9, 10, 5, 23, -3]print(sorted(ls01)) # [-9, -3, 1, 5, 10, 23]# 高阶函数使用 按照绝对值进行排序print(sorted(ls01, key = abs)) # [1, -3, 5, -9, 10, 23]ls02 = ['asd', 'ffgd', 'fhfgh', 'werr', 'bnbm']# 高阶函数使用 对 字符串 进行排序 根据小写字母排序print(sorted(ls02, key=str.lower)) # ['asd', 'bnbm', 'ffgd', 'fhfgh', 'werr']# 高阶函数使用 对 字符串 进行排序 根据大写字母排序--实现方式1print(sorted(ls02, key=str.lower, reverse=True)) # ['werr', 'fhfgh', 'ffgd', 'bnbm', 'asd']L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]'''根据学生的名字排序'''print(sorted(L)) # [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]'''根据学生的成绩排序'''print(sorted(L, key=itemgetter(1))) # [('Bart', 66), ('Bob', 75), ('Lisa', 88), ('Adam', 92)] itemgetter()的使用 参考：http://www.cnblogs.com/zhoufankui/p/6274172.html operator.itemgetter函数用于获取对象指定的下标数据。如根据学生成绩排序的方法使用中：获取序列中tuple元素下标为1的数据 operator.itemgetter函数获取的不是数值，而是重新定义了一个函数，通过将该函数作用于对象上才能获取数据，如：将数值赋值给key 特点：itmegetter()中的参数可以不按照数字大小的顺序来填入，可以使用2，1这样的顺序，表示 先获取 下标为2的数据值，再获取下标为1的数据的值。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 04-迭代器]]></title>
    <url>%2FPython3%20%2004-%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 能够使用for循环的数据类型有以下几种： 集合：list、tuple、set、dict 构建类型generator，带yield的generator function 字符串类型：str 复习：可以使用isinstance()判断一个对象是否是Iterable对象。需要导包：from collections import Iterable 1isinstance)(x, Iterable) 迭代器可以被`next()`函数调用并不断返回下一个值的对象称为——迭代器（`Iterator`） 判断一个对象是否为迭代器 1isinstance(x, Iterator) 代码示例 123456789101112131415'''判断是否 可迭代'''print(isinstance((x for x in range(1, 10)), Iterator)) # 构建类型 Trueprint(isinstance([1, 2], Iterable)) # list类型 Trueprint(isinstance((1, 2), Iterable)) # tuple类型 Trueprint(isinstance(&#123;1, 2&#125;, Iterable)) # set类型 Trueprint(isinstance(&#123;'1': 'A', '2': 'B'&#125;, Iterable)) # dict类型 Trueprint(isinstance('ABC', Iterable)) # str类型 rue'''判断是否为 迭代器 对象'''print(isinstance((x for x in range(1, 10)), Iterator)) # 构建类型 Trueprint(isinstance([1, 2], Iterator)) # list类型 Falseprint(isinstance((1, 2), Iterator)) # tuple类型 Falseprint(isinstance(&#123;1, 2&#125;, Iterator)) # set类型 Falseprint(isinstance(&#123;'1': 'A', '2': 'B'&#125;, Iterator)) # dict类型 Falseprint(isinstance('ABC', Iterator)) # str类型 False]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 05-函数式编程-函数作为返回值]]></title>
    <url>%2FPython3%20%2005-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445'''求和运算'''def add_sum(*args): add = 0 for n in args: add = add + n return addprint(add_sum(1, 2, 3, 4, 5)) # 15'''将函数 -实例- 作为返回值'''def add_sum_func(*args): def my_sum(): add = 0 for n in args: add = add + n return add return my_sum()'''将函数 -对象- 作为返回值'''def add_sum_func_02(*args): def my_sum(): add = 0 for n in args: add = add + n return add return my_sum# 调用 add_sum_func()时，返回的不是函数求和的结果，而是求和函数本身，就是延迟了函数结果的实现print(add_sum_func(1, 2, 3, 4, 5)) # 15new_f = add_sum_func(1, 2, 3, 4, 5)print(new_f) # 15# print(new_f()) # TypeError: 'int' object is not callableprint(add_sum_func_02(1, 2, 3, 4, 5)) # &lt;function add_sum_func_02.&lt;locals&gt;.my_sum at 0x1021ef8c8&gt;new_f = add_sum_func_02(1, 2, 3, 4, 5)print(new_f) # &lt;function add_sum_func_02.&lt;locals&gt;.my_sum at 0x1021ef8c8&gt;print(new_f()) # 15'''释义'''''' 函数add_sum_func()与add_sum_func_02()的区别除了函数名字上有区别，在其函数内部只有一点不同，即返回值： 一个是：return my_sum()。带()表示返回的是 函数的数值，即：结果值。 另一个是：return my_sum。不带()表示返回的是 函数本身，即：函数所在内存的地址。 通过查看输出的结果可以清晰的对比出两者的不同。''']]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-参数类型]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 默认参数必须指向 不可变对象。 因为不变对象一旦创建，对象内部的数据就 不能修改，这样就减少了由于修改数据导致的错误。 此外，由于对象不变，多任务环境下同时读取对象 不需要加锁，同时读一点问题都没有。 函数参数的5种类型 1.必选参数2.默认参数3.可变参数4.关键字参数5.命名关键字参数组合参数注意： 函数参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 必选参数代码示例 1234def fun(num): print(num*num)fun(10) #100 默认参数代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041##默认参数示例 1: tag = 2,为默认参数def fun2(num, tag = 2): s = 1 while tag &gt; 0: tag = tag - 1 s = s * num return sprint(fun2(5)) #25print(fun2(5,3)) #125#默认参数示例 2def fun3(name, age = 6, city = 'beijing'): print("name is %s" % name) print("age is %d" % age) print("city is %s" % city)fun3('cwj')'''name is cwjage is 6city is beijing '''#默认参数在赋值时要注明： 参数名称fun3('cwj', age = 9)'''name is cwjage is 9city is beijing'''fun3('cwj', city='tinajin')'''name is cwjage is 6city is tinajin''' 可变参数可变参数（个数可变），其本质是 `tuple`集合，由函数返回的结果可以看出 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个`tuple` 代码示例 12345678910111213141516171819202122def fun4(*numbers): sum = 0 for num in numbers: sum = sum + num * num print(sum)fun4(2,3,4) #29'''*l表示把l这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见'''l = [2,3,4]fun4(*l) #29'''*t表示把t这个tuple的所有元素作为可变参数传进去。这种写法相当有用，而且很常见'''t = (2,3,4)fun4(*t) #29e#可变参数个数为0fun4() #0 关键字参数关键字参数本质 dict（实际参数为 键值对 即可） 而关键字参数允许你传入0个或任意个含 参数名的参数 ，这些关键字参数在函数 内部 自动组装为一个 dict。 12345678910111213141516171819202122232425262728293031323334353637383940414243def fun5(name, age, **keyWord): print('fun5-----') print("name is : ", name) print("age is : %d" % age) print("address is : ", keyWord)#传入1个关键字参数fun5('cwj', 24, address='tianjin')'''name is : cwjage is : 24address is : &#123;'address': 'tianjin'&#125;'''#传入多个关键字参数fun5('cwj', 24, address='beijing', weather='hot')'''name is : cwjage is : 24address is : &#123;'address': 'beijing', 'weather': 'hot'&#125;'''#传入0个参数fun5('cwj', 24)'''name is : cwjage is : 24address is : &#123;&#125;'''#在有现成dict类型的情况下#此处是将d这个dict类型对象的所有 key-value 用关键字参数导入到函数的**keyWord参数中，keyWord获得的是d的一份拷贝，对keyWord的改变将不会影响到函数外的d本身。d = &#123;'address': 'beijing', 'wether':'hot'&#125;fun5('cwj', 24,**d)name is : cwjage is : 24address is : &#123;'address': 'beijing', 'wether': 'hot'&#125; 命名关键字此种参数是用来 限制关键字参数 的名字，就是仅接受 已经命名的形参 的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455'''表示方法1：*，参数名1，参数名2'''def fun6(name, age, *, address, wethear): print('fun6-----') print("name is : ", name) print('age is : %d' % age) print('address is : %s' % address) print('wether is : ', wethear)fun6('cwj', 26, address='tianjin', wethear='hot')'''name is : cwjage is : 26address is : tianjinwether is : hot''''''表示方法2，若函数中已经含有一个'可变参数'，则之后的参数不需要在添加 * 符号'''def fun7(name, age, *keyWord, city, wether): print('fun7-----') print('name is : ', name) print('age is : ', age) print('keuWord is : ', keyWord) print('city is : ', city) print('wether is : ', wether)fun7('cwj', 24, 'xian', city='tianjin', wether='windy')'''name is : cwjage is : 24keuWord is : ('xian',)city is : tianjinwether is : windy''''''表示方法3：设置有默认值的命名关键字参数'''def fun8(name, *, city='beijng',wether): print(name, city, wether)fun8('cwj',wether='hot')'''cwj beijng hot'''def fun9(name): passfun9('cwj') 组合参数代码示例 12345678910111213141516171819202122232425262728293031# 参数 必须参数，可选参数，可变参数，关键字参数def fun10(name, age=19, *key_word, **city): print(name, age, key_word, city)# 参数 必须参数，可选参数，可变参数，命名关键字参数def fun11(name, age=19, *key_word, city, weather): print(name, age, *key_word, city, weather)# 参数 必须参数，可选参数，命名关键字参数def fun12(name, age=8, *, city, weather): print(name, age, city, weather)# 参数 可选参数，可变参数，命名关键字参数def fun13(age=23, *l_num, **key_word): print(age, l_num, key_word)l = [1, 2, 3]fun10('cwj', 24, *l) # cwj 24 (1, 2, 3) &#123;&#125;fun10('cwj', 24, *l, city='beijing') # cwj 24 (1, 2, 3) &#123;'city': 'beijing'&#125;fun11('cwj', 24, *l, city='tianjin', weather='hot') # cwj 24 1 2 3 tianjin hotfun12('cwj', age=24, city='xian', weather='very hot') # cwj 24 xian very hotfun12('cwj', 0, city='beijing', weather='windy') # cwj 0 beijing windyfun13(24, *l, fa='sss') # 24 (1, 2, 3) &#123;'fa': 'sss'&#125;]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-返回值]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 在python交互环境中，使用本地文件自己定义的函数进入到文件所在的目录下后，将HelloWorld文件中的my_abs方法导入到交互环境中： from HelloWorld import my_abs Hello World 输出的是中文my_abs(-12)12 为系统函数建立别名12a = absprint(a(-90)) #90 空函数 - passpass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码 能运行起来。这样的函数适用于在上下文中，保持 整体逻辑思路 的通畅。 代码示例 12def nop(): pass 除了在函数体内使用之外，在其他语句中也可以使用：代码示例 12if age &gt;= 18: pass 函数参数检查 - isinstance()当我们自定义的函数传入了不恰当的参数时，python的函数能够检测出错误的参数，而我们自定义的函数则不能。当报错时，提示的错误信息和系统内置的函数提示的错误信息也不一样。我们应该完善我们自己定义的函数，使用isinstance()方法 代码示例 1234567891011def my_abs_good(x): # if not isinstance(x,(int, float)): raise TypeError('输入的参数类型异常') if x &gt; 0: return x else: return -xprint(my_abs_good(-2)) #2print(my_abs_good('a')) #TypeError: 输入的参数类型异常 判断一个数据类型是否为可迭代对象代码示例 123s = 'ABC'print(isinstance(s, Iterable)) # Trueprint(isinstance(123, Iterable)) # False 自定义函数的返回值 多个返回值 的本质是一个：tuple对象。只有一个返回值时，默认不显示() 多返回值 代码示例 123456789101112131415161718192021222324252627282930313233def getXY(x, y, step, angle = 0): nx = x + step * math.cos(angle) ny = y - step * math.cos(angle) #返回两个值 return nx, ny# 1x, y = getXY(10,20,100)print(x, y) #110.0 -80.0# 2x, y = (110.0, -80.0)print(x, y) #110.0 -80.0# 3z = getXY(10,20,100)print(z) #(110.0, -80.0)# 4z2 = (10)print(z2) #10'''比较 #1，#2，#3, #4 可以得出，函数的返回值其实是一个tuple对象,当返回值只有1个时，回省略掉()'''print(getXY(10,20,100)) #(110.0, -80.0)x, y, z = (10, 20, 100)print(x, y, z) #10 20 100print(x) #10'''在声明多个变量的同时，也将tuple对象的值对应的赋值给变量，很神奇！''' 没有返回值 return None 代码示例 12def noRetuen(): print('aaaa') 返回值小结 定义函数时，需要确定 函数名 和 参数个数； 如果有必要，可以先对参数的 数据类型 做检查； 函数体内部可以用 return 随时返回函数结果； 函数执行完毕也 没有return语句 时，自动 return None。 函数可以同时返回 多个值，但其实就是一个 tuple。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-生成器+切片]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E7%94%9F%E6%88%90%E5%99%A8%2B%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 高级特性——(slice)切片，表示为[::] 切片语法：[1:4:2] 数字’1’ 表示开始的索引位置 数字’4’ 表示结束的索引位置 数字’2’ 表示间隔的索引数 补充于：2017年07月18日16:29:53 Python序列切片操作：http://developer.51cto.com/art/201304/389771.htm 切片的方向与位置 对于序列结构数据来说，索引和步长都具有正负两个值任意一个序列结构数据的索引范围为: -len(consequence) 到 len(consequence)-1 范围内的连续整数。step 步长：默认为1，步长值不能为0。切片过程:从第1个想要的对象开始，到第1个不想要的对象结束 说明 正索引默认位置 负索引默认位置 序列方向说明 左 –&gt; 右 左 &lt;– 右 序列第一个元素位置 0 -len(consequence) 序列末元素位置 len(consequence)－1 -1 切片方向代码示例 12345678s3 = [1,2,3,4,5]print(s3[1:4:1]) # [2, 3, 4]print(s3[-4:-2]) # [2, 3]print(s3[-3:-1]) # [3, 4]print(s3[-5:]) # [1, 2, 3, 4, 5]print(s3[:]) # [1, 2, 3, 4, 5]print(s3[-1::-1]) # [5, 4, 3, 2, 1]print(s3[-1:]) # [5] range语法range(start, stop, step) 参考：http://www.nowamagic.net/academy/detail/1302446 根据start和stop确定范围，根据step设定步长 range与xrange 两者都能用于for循环中range 与 xrange 用法上完全相同，不同点是，产生的结果类型不同 range 产生的结果是 list xrange 产生的结果是 生成器 代码示例 123456789101112'''这两个输出的结果都是一样的，实际上有很多不同，''''''range会直接生成一个list对象'''&gt;&gt;&gt; range(5)[0, 1, 2, 3, 4]'''而xrange则不会直接生成一个list，而是每次调用返回其中的一个值'''&gt;&gt;&gt; xrange(5)xrange(5)&gt;&gt;&gt; list(xrange(5))[0, 1, 2, 3, 4]'''要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。''' 函数range的使用12345678910111213141516'''表示从1开始，到10之前（不包括10'''l = range(1, 10)'''从0开始（0可以省略），生成10个数'''ll = range(10)'''从0开始，生成10个数，公差为2（相邻的数之间间隔为2）'''lll = range(0, 10, 2)'''根据range的规则，生成指定的序列'''print(l) # range(1, 10)print(ll) # range(0, 10)print(list(l)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]print(list(ll)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]print(list(lll)) # [0, 2, 4, 6, 8]'''从缩影0开始，去之后索引+2对应的具体数值'''print(list(lll)[::2]) # [0, 4, 8] 使用range进行求和 123456sum = 0numbers = range(1, 10)for i in numbers: sum += iprint(sum)'''45''' 对list使用切片1234567891011l = ['cwj', 'serr', 'bob', 'jack']'''取3个元素 使用方法 切片（slice）,是指：取出一个范围内的元素''''''从索引0开始，直到3为止，但是不包括索引3，实际的取得索引为0，1，2 如果索引是从0开始的，0可以省略'''print(l[0:3]) # ['cwj', 'serr', 'bob']print(l[:3]) # ['cwj', 'serr', 'bob']'''倒着取出元素'''print(l[-3:]) # ['serr', 'bob', 'jack']print(l[0:-3]) # ['cwj'] 对str使用切片1234s = 'cwj, cwj, cwj, cwj'sp = s[::]print(sp) # cwj, cwj, cwj, cwjprint(sp[0:4:2]) # cj 对dict使用切片 – dict不适用与切片123print("对dict使用切片")d = &#123;'cwj': 150, 'zh': 145, 'ww': 234, 'cwj': 200&#125;# print(d[1:3]) # TypeError: unhashable type: 'slice' 对tuple使用切片1234567891011121314print(range(8)) # range(0, 8)ll5 = range(8) # range(0, 8)print(ll5)t = tuple(ll5)print(t) # (0, 1, 2, 3, 4, 5, 6, 7)lls = t[::]print('将 t序列 复制后的结果为：')print(lls)'''将 t序列 复制后的结果为：(0, 1, 2, 3, 4, 5, 6, 7)注意： tuple执行切片以后仍是一个tuple''' 对set使用切片1234s = set(lls)print(s) # &#123;0, 1, 2, 3, 4, 5, 6, 7&#125; 是set类型的数据spl = t[::]print(spl) # (0, 1, 2, 3, 4, 5, 6, 7) 使用range后是tuple类型的数据 迭代器 for 的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768s = 'ABC'for c in s: print(c)'''使用下标循环'''l = [1, 2, 3, 4]for i, value in enumerate(l): print(i, value)'''0 11 22 33 4'''for i, ch in enumerate(s): print(i, ch)'''0 A1 B2 C'''d = &#123;'A': 123, 'B': 456&#125;print(d) # &#123;'A': 123, 'B': 456&#125;for i, dict0 in enumerate(d): print(i, d.items())'''0 A1 B'''ls = [(1, 1), (2, 2), (3, 3)]for x, y in ls: print(x, y)'''1 12 23 3''''''列表生成器'''for x in range(1, 10): print(x * x)'''149162536496481''''''生成的序列后，进行计算'''print([x * x for x in range(1, 9)]) # [1, 4, 9, 16, 25, 36, 49, 64]'''生成序列后，新进行取余数预算，然后进行相乘运算'''print([x*x for x in range(1, 10) if x % 2 == 0]) # [4, 16, 36, 64]'''遍历两个字符串进行 排列组合'''print([m + n for m in 'ABC' for n in '123']) # ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']'''将dict类型的数据转换为 序列'''d = &#123;'A': 1, 'B': 2, 'C': 3&#125;print([k + ' = ' + str(v) for k, v in d.items()]) # 'A = 1', 'B = 2', 'C = 3'] yield关键字 定义generator函数的另一中方式： 当一个函数中含有关键字 yield时，这个函数就不在是一个普通的函数，而是一个generator函数 带有yield关键字的generator函数，执行流程与普通函数不同： - 普通函数：执行到return或者函数的最后一句时，退出函数。 - 带有yield关键字的generator函数，调用next()函数时执行操作，遇到yield()函数时，退出返回。当 再次执行此函数时从上次返回yield语句处继续执行 运行含有yield关键字的函数 123456789101112131415161718192021222324252627282930313233343536def p_yield(): print('step_01') yield 1 print('step_02') yield 2 print('step_03') yield 3# 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：o = p_yield()next(o) # step_01next(o) # step_02next(o) # step_03# next(o) # StopIterationdef fib(max): n, a, b = 0, 0, 1 #l = [] while n &lt; max: '''方法1 返回值：1 \n 2 \n 3 \n 4 \n 5''' # print(b) ''' 方法2 返回值：[1, 1, 2, 3, 5] 函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List来保存中间结果，而是通过 iterable 对象来迭代。 ''' #l.append(b) '''方法3 返回值：1 \n 1 \n 2 \n 3 \n 5. 使用yield关键字，使得生成的值为一个generator对象,而不是使用list占用大量的内存''' yield b a, b = b, a + b n = n + 1 #return l# print(fib(5)) yield关键字的使用 参考：https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/ yield关键字 使得一个普通的函数变成一个generator函数。Python解释器会将其视为一个generator，当for循环fib（5）函数的返回值时，实际调用的是iterable对象。 一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用， 但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。 虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值， 不仅代码简洁，而且执行流程异常清晰 12for n in fib(5): print(n) 区分：fib与fib(5) fib：是一个generator function 好比于：类的定义 fib(5)：是调用 fib 后返回的一个generator对象 好比于：类的实例化]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-数据-序列]]></title>
    <url>%2FPython3%20%2002-%E6%95%B0%E6%8D%AE-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 通过print()结果来区分各种序列类型 []是list ()是tuple {}是set {key:value, ...}是dict 说明：在序列声明时： list使用[] tuple与set使用()。其中声明set值时用到set关键字，以区分tuple dict使用{} set使用set() 关于集合–list和tuple list是python内置的、是有序的、可随时添加、删除其中元素的数据类型。通过[]来包裹内容 tuple是有序、”指向不可变“的另一种集合，称为”元组“。通过()来包裹内容 list使用print()后打印的结果为：`[]`` set使用print()后打印的结果为：{} 序列相加相同数据类型序列之间可以相加，不同数据类型序列不能相加 1.list 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051nameList = ['张三', '李四', '王五']print(nameList) #['张三', '李四', '王五']#增 方式-1：追加,只能添加到集合的末尾nameList.append('赵六')print(nameList) #['张三', '李四', '王五', '赵六']#增 方式-2：插入。参数1，添加的位置；参数2，插入的内容nameList.insert(1,'钱七')print(nameList) #['张三', '钱七', '李四', '王五', '赵六']#删nameList.pop(1)print(nameList) #['张三', '李四', '王五', '赵六']#删，无参数情况下默认删除最后一个元素nameList.pop()print(nameList) #['张三', '李四', '王五']#改 根据指定的下标，替换元素nameList[0] = '孙八'print(nameList) #['孙八', '李四', '王五']#查 输出集合的长度print(len(nameList)) #3#查 输出指定位置的元素 方式-1：从前向后，正序print(nameList[1]) #李四#查 输出指定位置的元素 方式-2：从后向前，倒序print(nameList[-1]) #王五#查 循环遍历，方式-1 forfor nameSingle in nameList: print(nameSingle)'''孙八李四王五'''#查 循环遍历，方式-2 whilecount = len(nameList)while count &gt; 0: print(nameList[(-count)]) count = count-1'''孙八李四王五''' 2.tuple 代码示例 123456789101112131415161718tupleValue = (1,2)#空的tupletupleValue01 = ()#只有1个元素的tuple定义时必须加一个逗号·,·，来消除歧义。若不加，则定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号。tupleValue02 = (1,)#一个“可变的”tuple：变的不是tuple的元素，而是其中的list的元素#tuple一开始指向的list并没有改成别的list，所以所谓的“不变”是说，tuple的每个元素，指向永远不变。# 即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！t = ('a', 'b', ['A', 'B'])print(t[2][0])print(t[2][1])'''AB''' 关于dict和set dict dict在其他语言中称为map，其存储的值是 无序 的，使用的键-值对（key-value）存储,用{}来包裹内容。 dict使用print()后打印的结果为：{‘mac’: 999999, ‘hp’: 777777, ‘ASUS’: 46567} dict默认是去重复的 注意: dict的key必须是不可变对象。 特点：和list相比 1.查询速度快 2.内存占用量大 dict代码示例 1234567891011121314151617181920d = &#123;'mac':999999, 'hp':777777, 'ASUS':46567&#125;#查print(d['mac']) #999999#改d['mac'] = 90000print(d['mac']) #90000#判断dict中是否存在当前的键 方法-1print('mac' in d) #Trueprint('lenvol' in d) #False#判断dict中是否存在当前的键 方法-2print(d.get('mac')) #90000print(d.get('lenvol')) #None#删d.pop('mac')print(d) #&#123;'hp': 777777, 'ASUS': 46567&#125; set set是 list的精简版，去掉其重复的元素，而且只存储key值，不存储value值。即set内部是无重复元素的。 set 不能放入 可变对象.因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素” set使用print()后显示的结果是：{} set中到的参数只能放一个。 注意: dict的key必须是不可变对象。 特点：和list相比 1.查询速度快 2.内存占用量大 set代码示例 12345678910111213141516171819202122l = [1,5,1,1,2,2,3,3,4,5]print(l) #[1, 5, 1, 1, 2, 2, 3, 3, 4, 5]print(len(l)) #10s = set(l)print(s) #&#123;1, 2, 3, 4, 5&#125;print(len(s)) #5s.add(7)print(s) #&#123;1, 2, 3, 4, 5, 7&#125;print(len(s)) #6s.remove(7)print(s) #&#123;1, 2, 3, 4, 5&#125;print(len(s)) #5s2 = set([4,5,6,7,8,9])#交集print((s &amp; s2)) #&#123;4, 5&#125;#并集print((s | s2)) #&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; 解释“不可变对象”代码示例 12345678910111213141516171819a = 'abc'print(a)print(a.replace('a','A'))print(a)'''abcAbcabc'''b = a.replace('a','A')print(b)print(a)print(b)'''AbcabcAbc''' 由上面的代码可以看出：在调用了变量a的replace()之后，立即输出变量a的值，此时变量a的值是修改后的，但是在次输出a的值时，还是原来的内容，即：变量a的内容最终并没有被修改。 那为什么立即输出a修改后的内容时是变化的呢？ 当我们把修改后a的值赋给变量b时，不管输出多少次b变量的值，其内容一直是不变的。也就是说：变量b存储的是一个新的内容，即一个新的str类型的对象。而这个新的str类型的对象是在变量a所指的对象的基础上修改之后的新对象。 结论就是：不可变对象修改后得到的对象是一个新的对象，而原有的对象保持不变 条件判断elif是else if的缩写，完全可以有多个elif 代码示例 1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环 1.for A in AList. 将‘AList集合’中的每一个元素赋值到‘变量A’中2.while n。只要条件’n‘满足，就将‘AList集合’中的每一个元素取出并赋值到变量中 for ... in ... while 遍历主要是使用: for in代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 ls = [1, 2, 3, 4, 5, 6, 7, 8, 9] sum02 = 0 for item in ls: print(item) sum02 = sum02 + item print(sum02) ''' 1 2 3 4 5 6 7 8 9 45 ''' d = &#123;'cwj': 150, 'zh': 145, 'ww': 234, 'cwj': 200&#125; print(d) # &#123;'cwj': 150, 'zh': 145, 'ww': 234&#125; print(len(d)) # 3 print(d.keys()) # dict_keys(['cwj', 'zh', 'ww']) dlk = list(d.keys()) print(dlk) # ['cwj', 'zh', 'ww'] dlks = set(dlk) print(dlks) # &#123;'zh', 'ww', 'cwj'&#125; dtk = tuple(d.keys()) print(dtk) # ('cwj', 'zh', 'ww') '''遍历方式 1''' for (key, value) in d.items(): print(key, value) ''' cwj 200 zh 145 ww 234 ''' '''遍历方式 2''' for key in d: print('dict[%s]\'s value is : ' % key, d[key]) ''' dict[cwj]'s value is : 200 dict[zh]'s value is : 145 dict[ww]'s value is : 234 ''' '''遍历方式 3 ，遍历到指定的key时，修改其元素''' for key in d.keys(): print(key) print(d[key]) if key == 'cwj': d[key] = 500 print('ok cwj,your grade has changed!') print(d) ''' cwj 200 ok cwj,your grade has changed! zh 145 ww 234 &#123;'cwj': 500, 'zh': 145, 'ww': 234&#125;''' 几个内置函数代码示例 1234567891011121314151617ll = [1, 2, 3, 4]ll2 = [5, 6, 7, 8]ll3 = [1, 2, 3, 4, 5, 6, 7, 8]ll4 = [2, 7, 4, 5, 0, 1, 9, 1]print(ll * 2) # [1, 2, 3, 4, 1, 2, 3, 4]print(ll + ll2) # [1, 2, 3, 4, 5, 6, 7, 8]# 不能相减# print(ll3 - ll2)# 成员资格# 检测 1 是否在 ll2序列 中， 使用 in 关键字返回值# 为：True or Falseprint(1 in ll2) # False# 获得序列中的最大值print(max(ll3)) # 8print(min(ll4)) # 0]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux/Unix系统文件结构]]></title>
    <url>%2FLinux%3AUnix%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[总结 /bin系统有很多放置执行档的目录，但/bin比较特殊。 因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 /etc系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop /etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。 /etc/X11/ ：与XWindow有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 /lib系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /mediamedia是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 /opt这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 /root系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 /sbinLinux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srvsrv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 /tmp这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下： /lost+found这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 根目录下与开机过程有关的目录1234567除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 /usr 的意义与内容：依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。 /usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： /usr/X11R6/为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。/usr/bin/绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var 的意义与内容：如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。 /var/cache/应用程序本身运作过程中会产生的一些暂存档 /var/lib/程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。四. 目录树(directory tree) :在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 01-基础-基本数据类型]]></title>
    <url>%2FPython3%20%2001-%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python Python是一种计算机编程语言，使用Unicode编码，支持多语言(动态语言，因为变量本身不固定)。 是一种解释性语言在运行 .py 文件时需要通过 解释器 进行解释然后显示呢结果。 区分大小写 参考网站：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 Python代码创建方式 1.在 终端环境 中编写 2.在 文件 中编写 方式 1：在终端环境下 输入 python 进入python交互模式，在&gt;&gt;&gt;后名编写代码： 12300 + 100400 输入 exit() 退出python模式。 方式 2：在文件中 直接在文件中编写代码，然后打开终端进入文件所在目录，运行： 1python 文件名.py 语法1、采用缩进方式（4个空格） 2、大小写敏感，例如：`True`, `False`, `None` 注释 # coding=utf-8 使用Scrapy爬虫框架时应该添加此条语句表明注释是中文注释 # 单行注释 &#39;&#39;&#39; &#39;&#39;&#39;多行注释 符号 ：作用 :结尾表示时，缩进的语句视为代码块,如： 1234if ooo: XXXelse: XXX 字符串编码 参考：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000 ASCII、Unicode和UTF-8的关系在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。所以你看到很多网页的源码上会有类似的信息，表示该网页正是用的UTF-8编码 Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言 数据类型和变量 整数 浮点型 字符串 布尔值 空值 变量 常量 列表 字典 自定义数据类型 整数1，-1，0x123。 整数的除法在Python中有两种：/和//。 其中/表示除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数 1print(13/5) #2.6 另一种除法//称为地板除，两个整数的除法仍然是整数: 1print(13//5) #2 浮点型1.2， 1.23e9, 12.3e8， 1.23e-8 字符串（！此处划重点！） 字符串类型是str。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示。 使用 &#39; &#39; 或者 &quot; &quot; 表示的任意字符。其中包括 “‘”的用法 &quot;I&apos;m OK&quot; 既有&#39;又有&quot;的表示方法 I’m “OK”的用法： &apos;I \&apos;m \&quot;OK\&quot;&apos; 即：需要显示的特殊字符或者需要转义的字符用 \ 表示。 如果不需要转义当前字符，则可以使用 r&#39;&#39; 表示 &#39;&#39;内部不需要转义的字符，例如： 1print(r'"I\'m \"OK\""') 结果为： &quot;I\&apos;m \&quot;OK\&quot;&quot; 在&#39;&#39;&#39; &#39;&#39;&#39; 内可以不使用\n换行符而直接表示多行内容 123print('''line1line2line3''') 结果为： 123line1line2line3 布尔值 注意True和False的大小写，而且布尔值可以用and、or和not运算 测试代码： 123456789101112131415161718print(3 &gt; 2) #Trueprint(3 &lt; 2) #Falseif 3 &gt; 2 and 4 &lt; 5: print("3 &gt; 2")else: print("3 &lt; 2") #3 &gt; 2if 3 &gt; 2 or 4 &gt; 5: print("3 &gt; 2")else: print("3 &lt; 2") #3 &gt; 2if not 4 &lt; 5: print("3 &gt; 2")else: print((not 4 &lt; 5)) #False print("3 &lt; 2") #3 &lt; 2 空值 空值是用None表示的（注意大小写），但是None不能理解为0。 变量 Python与其他不同的是它的变量的类型是通过被赋予的值得类型决定的，即： 后者决定前者的类型。 Python的变量只是一个名字而已，数值内容及其类型才是重点，决定了变量名的实际意义。 变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错,例如Java是静态语言. 12345678a = 123print(a) #123a = "a是个变量名"print(a) #a是个变量名a = Trueprint(a) #Trueb = aprint(b) #True 常量 在Python中，通常用全部大写的变量名表示常量，全部大写的变量名表示常量只是一个习惯上的用法。 格式化输出 格式化输出字符串 – 同C语言，格式化与实际数据之间通过%连接 使用%，%运算符就是用来格式化字符串的，其中 %s 表示替换字符串，%d 表示替换整数，%f 表示替换浮点型%x 表示16进制 代码示例 12345678910name = input('请输入你的名字：') #请输入你的名字：yannisprint('Hello, %s ,你好啊~' % name) #Hello, yannis ,你好啊~age = input("请输入你的年龄： ")print("你的年龄为 %d，确认：%d" % (12,12)) #你的年龄为 12，确认：12#在不确定使用何种类型的数据时，用%s即可print('age is : %s; Gener: %s' % (32,False)) #age is : 32; Gener: False#字符串里面的%是一个普通字符时,需要转义，用%%来表示一个%print('增长率为：%d%%' % 7) #增长率为：7% 一个计算成绩比率的小代码 12345678910111213141516grade1 = input("请输入去年的成绩：")grade2 = input("请输入今年的成绩："#此处将str类型的grade1转换为int的10进制类型，参数：grade1表示待转换的数据，参数：10，表示进制num = int(grade1,10) - int(grade2,10)#此处将int类型的num转换为str类型print('num is : ' + str(num))print('abs is : %d' % abs(num))#将结果转换为float类型mPercent = float(((abs(num))/int(grade1,10))*100)print('mPercent is : ' + str(mPercent))#格式化输出结果print('成绩变化率为：%.2f%%' % mPercent)]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2FActivity%2F</url>
    <content type="text"><![CDATA[Activity总结 1. Activity生命周期图1.1. 典型生命周期用户参与的情况下，Activity所经过的生命周期。 1.1.1. 生命周期分析 onCreate() 表示Activity正在被创建，可以进行一些初始化的操作。 onRestart() 表示Activity正在重新启动。从不可见变为可见时，此方法就会被调用。若当前Activity执行 onPause() 和 onStop() 方法后，再次回到此Activity时，此方法将会被调用。 onStart() 表示此Activity即将被启动，即将开始时。此时Activity已经可见，但是还在后台，无法和用户交互。 onResume() 表示Activity已经可见，并且出现在前台。 onPause() 表示Activity正在停止。 onStop() 表示Activity即将停止。可以做一些回收工作，不能太耗时。 onDestroy() 表示Activity即将被销毁。可以做一些回收、资源释放操作。 1.1.2. 声明周期执行过程 第一次启动 onCreate() -&gt; onStart() -&gt; onResume() 当用户打开新的Activity时或者回退到桌面时，调用 onPause() -&gt; onStop() 当再次打开原Activity时，调用 onRestart()-&gt; onStart() -&gt; onResume() 回退桌面时，调用 onPause() -&gt; onStop() -&gt; onDestroy() 1.1.3. 说明当从当前的Activity A 打开Activity B时，Activity A将先执行 onPause() 方法，然后 Activity B 才执行 第一次启动时调用的声明周期方法。即：旧Activity先 onPause() ， 新Activity再启动。新Activity再启动后，旧Activity执行 onStop() 方法 1.2. 异常生命周期Activity被系统回收或者由于当前设备的Configuration发生改变而导致的Activity被销毁重建。 1.2.1 系统配置发生改变导致Activity被杀死并被重建在这种状态下的生命周期： 意外时： Activity -&gt; onSaveInstanceState() -&gt; onDestroy() onSaveInstanceState()用来保存当前Activity状态，此方法将会在 onStop() 之前被调用。 重建时： Activity -&gt; onCreate() -&gt; onRestoreInstanceState() 1.2.2 内存不足导致 低优先级Activity 被杀死 优先级问题 前台Activity： 与用户进行交互的Activity，优先级最高 可见非前台Activity： 当前Activity弹出了一个对话框，原Activity虽可见，但是用户无法进行交互。 后台Activity： 优先级最低 如果一个进程中没有四大组件在执行，那么这个进程将会很快的被杀死。 2. Activity 启动模式2.1. 启动模式 - 4种：使用： 1android:launchMode=&quot;standard&quot; standard：标准模式。 对应Activity的 Flags ：FLAG_ACTIVITY_NEW_TASK 当搭配FLAG_ACTIVITY_CLEAR_TOP时，连同此Activity在内的Activity都要一同出栈。 每次启动一个Activity都会创建一个新的实例，不论这个实例是否已经存在。此模式下的Activity会默认进入启动它的Activity的所属栈中。 singleTop：栈顶（top）复用（single）模式。 对应Activity的 Flags ：FLAG_ACTIVITY_SINGLE_TOP 如果新Activity已经位于任务栈顶，那么此Activity将不会被重新创建，同时它的 onNewIntent() 将会被调用。 示例：1：若A为栈底，C为栈顶，当ABC时，在此模式下启动C时，则仍为ABC。2：若A为栈底，B为栈顶，当ACB时，在此模式下启动C时，任务栈为：ACBC。 singTask：栈内复用模式。 默认具 Activity的 Flags ：FLAG_ACTIVITY_CLEAR_TOP 。此 Flags 表示：它标记的Activity，当它启动时，在同一任务栈中的所有位与此Activity之上的Activity都要出栈。 如：之前栈内为：ABCD，当调用B后，栈内的情况变为：AB。 只要Activity在一个栈中存在，那么多次启动此Activity将不会重新创建该实例。默认具有 clearTop 功能 创建过程，若： 1：启动 Activity A 时，若不存在A所需的任务栈，那么创建一个任务栈，然后创建 Activity A 的实例，将A实例压入任务栈中。 2：启动 Activity A 时，若存在A所需的的任务栈，看栈中是否存在 Activity A 实例，若存在，将其调到栈顶，并调用 onNewIntent() ；若不存在，创建A的实例，将其压入A所需的栈中。 singleInstance：单实例模式，加强版 singleTask。 在 singleTask 原有的特点基础之上，还加强了一点：设置了此模式的 Activity 只能单独的位于一个任务栈中。 2.2. IntentFilter 匹配规则启动Activity分为两种：显式 + 隐式。如果二者同时存在的话以 显式 为主。 2.2.1 隐式调用隐式调用需要 Intent 能够匹配目标组件中的 IntentFilter 中的过滤信息。 只有一个 Intent 同时匹配这3个类别时，才能启动Activity，否则无法启动Activity。 一个Intent可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应Activity。 action匹配规则： 是一个字符串，系统预定义，可自定义一些。要求Intent中的action存在且必须和过滤中规则中的一个action相同。 categoryn匹配规则： 是一个字符串，系统预定义一些，可自定义。Intent中如果出现了category，那么不管有几个category，对于每一个category来说，它必须是过滤规则中已经存在的category。 注意：Intent不设置category也可以匹配。原因是系统在调用 startActivity() 或 startActivityForResult() 时会默认为Intent添加 android.intent.category.DEFAULT这个category。 所以，为了我们的Activity能够接受 隐式 调用，必须在 intent-filter 中指定以上这个category。 data 2.2.2 入口Activity，缺一不可1234&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&lt;/intent-filter&gt; 2.2.3 判断是否有Activity能够匹配 隐式 Intent。12public abstract List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent, @ResolveInfoFlags int flags);public abstract ResolveInfo resolveActivity(Intent intent, @ResolveInfoFlags int flags);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- Canvas + Paint + Path]]></title>
    <url>%2FView-%E8%87%AA%E5%AE%9A%E4%B9%89-%20Canvas%20%2B%20Paint%20%2B%20Path%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/d2c7a837265e关于Paint资料非常丰富：http://www.jianshu.com/p/420da0f6e279非常系统的知识：http://hencoder.com/ui-1-1/ 前言 自己一直在学习许多技术大牛的技术博客，看他们是如何学习Android源码，看他们是如何分析当下流行、火热的技术以及框架的使用，可以说是他们的无私奉献、共享精神一直在支持着像我这样渴望学到更多，渴望技术升级的初学者。正所谓“穷则独善其身，达则兼济天下”。一直想着，如果自己有一天能够达到让自己满意的高度，也会将这样的方式继续传递，技术因为通过共享、传递才能得以实现其对社会的价值。 之前自己也学习过自定义View，也写过示例，在项目中也应用过，可都是写较为简单的。而自己写的随手笔记因为条理性、技术点太低（所以不敢称为技术博客），总是使自己不满意，也没有很好的传承下来。最近换了工作而且手头也比较闲，也是一个新的开始。所以秉着好记性不如烂笔头、博客记录成长的信条，将自己的所学、所悟记录下来。 基本自定义View的3个关键点 布局 绘制 触摸反馈 Android坐标系图片来自网络，忘记出处，如有侵权请联系我。 4个级别 Canvas Canvas.drawXXX()是自定义绘制的基本操作。可以绘制几何图形、文字、图片，在+Paint的常用方法。 裁剪范围（很酷的效果） 几何变换（很酷的效果） Paint ：Paint的使用 Path ：轮廓,路径 Canvas的使用 Canvas是“画布”的意思，拥有“绘制”的功能。 1. Canvas的使用需要4个基本元素： 一个Bitmap用于保存像素 一个Canvas来承载绘图调用（写入到位图） 一个绘图的基本元素（例如Rect，Path，文本，位图） 一支Paint（描述颜色和样式） 2. Canvas有两个构造方法： Canvas()：创建一个空的Canvas对象 Canvas(Bitmap bitmap)：用指定的位图构造一个Canvas对象 3. 常用绘制方法： translate()：画布移动 drawARGB()：用指定ARGB颜色填充画布上面的位图 drawRGB()：用指定RGB颜色填充画布上面的位图 drawColor()：用指定颜色填充画布上面的位图 drawArc()：画圆弧 startAngle：表示开始的角度sweepAngle：表示角度范围useCenter：表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。 1234567891011RectF rectF = new RectF(DensityUtil.dip2px(context, 100), DensityUtil.dip2px(context, 100), DensityUtil.dip2px(context, 220), DensityUtil.dip2px(context, 180));paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF, 0, 80, false, paint);paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF, -10, -80, true, paint);paint.setStyle(Paint.Style.FILL);canvas.drawArc(rectF, -100, -80, true, paint);paint.setStyle(Paint.Style.FILL);canvas.drawArc(rectF, -190, -80,false,paint); drawBitmap()：画位图 drawPicture() drawCircle() ：画圆 drawLine()：画直线 drawLines()：折线 drawOval()：画椭圆 drawRect()：画矩形 drawRoundRect()：画圆角矩形 drawPoint()：画点 drawPoints()：画一组点pts : 这个数组是点的坐标，每两个成一对offset : 表示跳过数组的前几个数再开始记坐标count : 表示一共要绘制几个点 1234567891011121314151617181920//圆点和方点的切换使用 paint.setStrokeCap(cap)：`ROUND` 是圆点，`BUTT` 或 `SQUARE` 是方点this.paint.setStrokeCap(Paint.Cap.ROUND);this.paint.setAntiAlias(true);this.paint.setStyle(Paint.Style.FILL);this.paint.setStrokeWidth(50);this.paint.setStrokeCap(Paint.Cap.ROUND);canvas.drawPoint(canvas.getWidth() / 2 - 200, canvas.getHeight() / 2, paint);paint.setStrokeCap(Paint.Cap.SQUARE);canvas.drawPoint(canvas.getWidth() / 2 + 200, canvas.getHeight() / 2, paint);paint.setStrokeCap(Paint.Cap.ROUND);this.paint.setStrokeWidth(10);float[] points = &#123;20,20, 50,50, 80,80,100,100,130,130,170,170,210,210,240,240,&#125;;canvas.translate(100,100);canvas.drawPoints(points,paint);canvas.translate(0,300);canvas.drawPoints(points,3,10,paint); drawPath()：画路径组合。这个方法是通过描述路径的方式来绘制图形的，它的 path 参数就是用来描述图形路径的对象 12345path.arcTo(canvas.getWidth() / 2 - 200, 380, canvas.getWidth() / 2, 580, 135, 225, false);path.arcTo(canvas.getWidth() / 2, 380, canvas.getWidth() / 2 + 200, 580, 180, 225, false);path.lineTo(canvas.getWidth() / 2, 720);path.close();canvas.drawPath(path, paint); 角度和划过度数 1234567RectF rectF1 = new RectF(200,100,300,200);paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF1, 135, 225, true, paint);paint.setStyle(Paint.Style.STROKE);canvas.translate(100,0);canvas.drawArc(rectF1, 180, 225, true, paint); drawText()：画文本 drawTextOnPath()：根据路径画文本 drawPosText()：指定单个文字位置 arcTo(): 将指定的弧添加到路径作为新的轮廓。 Paint的使用画笔 1. Paint有3个构造方法：1.Paint():用默认设置创建一个Paint对象2.Paint(int flags):用特殊标记创建一个Paint对象3.Paint(Paint paint):用指定Paint对象的参数初始化一个新的Paint对象 ##2. 常用方法 reset() ：清空path的所有数据，但是不会清空FillType rewind() ：清除FillType及数据等，但会保留数据结构。这样可以快速重用，提高一定的性能 setARGB(int a, int r, int g, int b) : 画笔颜色 setColor(int color) : 画笔颜色 setAntiAlias(boolean aa)： 是否抗锯齿 setAlpha(int a) ：设置画笔透明度 setStrokeWidth(float width) ：画笔的粗细(线条的宽度) setXfermode(Xfermode xfermode) ：设置图像重叠时的处理方式 - 16种 setFillType()：2个图形重合的模式.类似前面讲解的xfermode,只有4个值：WINDING//默认值，取两个图形相交；EVEN_ODD//取不相交的部分；INVERSE_WINDING//反转相交；INVERSE_EVEN_ODD//反转不相交部分 setShader(Shader shader) ：设置着色器 setPathEffect(PathEffect effect) ：设置或者清除路径效果 - 6种 setShader(Shader shader) ：设置图像效果，可以绘制出各种渐变效果 setShadowLayer(float radius ,float dx,float dy,int color)：在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 setStrokeCap(Paint.Cap cap)：设置线冒样式(线头的装饰画法)，取值有: Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) setStrokeJoin(Paint.Join join)：设置线段连接处样式(折线的拐角装饰画法)，取值有：Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线) setStyle(Paint.Style style) 设置画笔样式”，画笔样式有三种: (1)Paint.Style.FILL：默认值，用这种风格绘制的几何图与文本将被填充，它画出来的是实心图 (2)Paint.Style.STROKE：用这种风格绘制的几何图与文本将被画出外边框，它画出来的是空心图 (3)Paint.Style.FILL_AND_STROKE：用这种风格绘制的几何图与文本将被填充并被画出外边框 3.设置“文字/字体“外观 setTextSize(float textSize) ：设置文字大小” setFakeBoldText(boolean fakeBoldText)：设置是否为粗体文字 setStrikeThruText(boolean strikeThruText) ：设置带有删除线效果 setUnderlineText(boolean underlineText) ：设置下划线 setTextAlign(Paint.Align align) ：设置开始绘图点位置,文本对齐方式 setTextScaleX(float scaleX) ：水平拉伸设置 setTextSkewX(float skewX) ：设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 setTypeface() ：置字体样式:Typeface.NORMAL - 正常体;Typeface.BOLD - 粗体;Typeface.ITALIC - 斜体;Typeface.BOLD_ITALIC - 粗斜体 4.字体样式(Typeface) create(String familyName, int style) ：直接通过指定字体名来加载系统中自带的文字样式 create(Typeface family, int style) ：通过其它Typeface变量来构建文字样式 createFromAsset(AssetManager mgr, String path) ：通过从Asset中获取外部字体来显示字体样式 createFromFile(String path) ：直接从路径创建 createFromFile(File path) ：从外部路径来创建字体样式 defaultFromStyle(int style) ：创建默认字体5. 字体设置 在assets目录下新建fonts目录，把ttf字体文件放到这。 程序中调用： 123456//得到AssetManagerAssetManager mgr=getAssets();//根据路径得到Typeface，注意"ttf文件命名不能使用中文,否则可能无法加载。Typeface tf=Typeface.createFromAsset(mgr, "fonts/ttf.ttf");//设置字体样式tv.setTypeface(tf); 6.文字所占的区域（范围）的设定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 注意:在使用FontMetrics时必须为同一个Paint对象,否则,无法获取文字正确的位置关系 */Paint paint12 = new Paint();paint12.setAntiAlias(true);paint12.setStrokeWidth(1);paint12.setStyle(Paint.Style.STROKE);paint12.setColor(Color.BLACK);paint12.setTextSize(100);Paint.FontMetrics fontMetrics = paint12.getFontMetrics();//可绘制的最高高度所在线float top;//可绘制的最低高度所在线float bottom;//系统建议的，绘制单个字符时，字符应当的最高高度所在线float ascent;//系统建议的，绘制单个字符时，字符应当的最低高度所在线float descent;/** * 建议在文本行之间添加的额外空格。 *///fontMetrics.leadingtop = 100 + fontMetrics.top;bottom = 100 + fontMetrics.bottom;ascent = 100 + fontMetrics.ascent;descent = 100 + fontMetrics.descent;//绘制文字canvas.drawText(strs,100,100,paint12);//------------------------令人惊喜的分割线---------------------canvas.translate(0,200);canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE));canvas.drawLine(100,top,1080,top,paint12);//可绘制的最高高度所在线canvas.drawLine(100,bottom,1080,bottom,paint12);//可绘制的最低高度所在线canvas.drawLine(100,ascent,1080,ascent,paint12);//系统建议的，绘制单个字符时，字符应当的最高高度所在线canvas.drawLine(100,descent,1080,descent,paint12);//系统建议的，绘制单个字符时，字符应当的最低高度所在线canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE));float width = paint12.measureText(strs);//获取文字所占宽度float height = bottom - top;//获取文字所占高度Log.e(TAG, "onDraw width: " + width + ", height : " + height);//绘制文字所占区域的边框Path rectPath = new Path();RectF rectF2 = new RectF(100,top,width+100,bottom);//绘制文字paint12.setColor(Color.GREEN);canvas.drawRect(rectF2,paint12); Path1. 常用方法 moveTo() ：设定起始点 lineTo() ：画条直线(连续使用此方法,将会画出连续的线) close() ：封闭图形 addRect() ：矩形路径（使用此方法时首先绘制一个矩形,后续addXXX()使用类似） addRoundRect() ：绘制圆角矩形路径 addCircle() ：绘制原型路径 addCircle() ：绘制椭圆路径 addArc() ：绘制一段弧形路径 quadTo() ：绘制”贝塞尔曲线” 有4个方法 参数说明 Path.Direction有两个值： Path.Direction.CCW：是counter-clockwise缩写，指创建”逆时针”方向的矩形路径； Path.Direction.CW：是clockwise的缩写，指创建”顺时针”方向的矩形路径； 2. PathMeasure类的使用 参考:http://blog.csdn.net/cquwentao/article/details/51436852 (1) 123//path：需要测量的path//forceClosed：是否关闭pathpublic PathMeasure(Path path, boolean forceClosed) (2) 12//这里就是指定需要测量的path，同上。public void setPath(Path path, boolean forceClosed) (3) 123//返回当前path的"总"长度。PathMeasure pathMeasure = new PathMeasure(path, false);float length = pathMeasure.getLength(); (4) 123456public boolean getPosTan(float distance, float pos[], float tan[])//返回值是boolean，如过path为空，则返回false传入参数有三个： distance：传入距离起点的距离。 pos[]:意思是position，分别对应点的x，y坐标 tan[]：这个值比较难以理解。我们下面讲解下这个值的意义。 Path 有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算。 直接描述路径。1. 添加子图形 ：addXxx()添加的完整封闭图形（除了 addPath() ） 2. 画线（直线或曲线）：xxxTo() lineTo(float x, float y) / rLineTo(float x, float y) ：画直线 lineTo(x, y) 的参数是绝对坐标，而 rLineTo(x, y) 的参数是相对当前位置的相对坐标 （前缀 r 指的就是 relatively 「相对地」)。 所谓当前位置，即最后一次调用画 Path 的方法的终点位置。初始值为原点 (0, 0)。 quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2) ：画二次贝塞尔曲线 cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) ：画三次贝塞尔曲线 moveTo(float x, float y) / rMoveTo(float x, float y) ：移动到目标位置 设置图形起点。 1234paint.setStyle(Style.STROKE); path.lineTo(50, 50); // 斜线 path.moveTo(150, 50); // 移动 path.lineTo(150, 0); // 竖线 画弧形 arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(RectF oval, float startAngle, float sweepAngle) orceMoveTo ：绘制是要 抬一下笔移动过去，还是 直接拖着笔过去，区别在于是否留下移动的痕迹。 1234path.moveTo(100,0);path.lineTo(100,100);path.arcTo(100,100,300,300,-90,90,true);canvas.drawPath(path,paint); 1234path.moveTo(100,0);path.lineTo(100,100);path.arcTo(100,100,300,300,-90,90,false);canvas.drawPath(path,paint); addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) addArc(RectF oval, float startAngle, float sweepAngle) addArc() 只是一个直接使用了 forceMoveTo = true 的简化版 arcTo() 。 close() ：封闭当前子图形 当需要填充图形时（即 Paint.Style 为 FILL 或 FILL_AND_STROKE），Path 会自动封闭子图形。 辅助的设置或计算Path.setFillType(Path.FillType ft) 设置填充方式。 使用参考：http://hencoder.com/ui-1-1/ 3. 获取随机Path方法12345678910private Path getPath()&#123; Path path = new Path(); // 定义路径的起点 path.moveTo(0, 0); // 定义路径的各个点 for (int i = 0; i &lt;= 40; i++) &#123; path.lineTo(i*35, (float) (Math.random() * 150)); &#125; return path; &#125; Color：Android系统中颜色的常用表示方法有以下3种： int color = Color.BLUE; int color = Color.argb(150,200,0,100); 在xml文件中定义颜色； 1. 常用颜色： 方法 描述 Color.BLACK 黑色 Color.GREEN 绿色 Color.BLUE 蓝色 Color.LTGRAY 浅灰色 Color.CYAN 青绿色 Color.MAGENTA 红紫色 Color.DKGRAY 灰黑色 Color.RED 红色 Color.YELLOW 黄色 Color.TRANSPARENT 透明 Color.GRAY 灰色 Color.WHITE 白色 2. ColorFilter类的使用 参考:http://blog.csdn.net/cquwentao/article/details/51396466 ColorFilter主要用来处理颜色有3个子类: ColorMatrixColorFilter：颜色矩阵 LightingColorFilter：亮度 PorterDuffColorFilter：颜色的混合模式 2.1. ColorMatrixColorFilter这个类主要是使用matrix对颜色做运算，矩阵的形态如下： &quot;R&quot; &quot;G&quot; &quot;B&quot; &quot;A&quot; &quot;Red通道&quot; a[0] a[1] a[2] a[3] a[4] &quot;Green通道&quot; a[5] a[6] a[7] a[8] a[9] &quot;Blue通道&quot; a[10] a[11] a[12] a[13] a[14] &quot;Alpha通道&quot; a[15] a[16] a[17] a[18] a[19] RGB色彩和Alpha的终值计算方法如下： “Red通道” 终值 = a[0] srcR + a[1] srcG + a[2] srcB + a[3] srcA + a[4] “Green通道”终值 = a[5] srcR + a[6] srcG + a[7] srcB + a[8] srcA + a[9] “Blue通道” 终值 = a[10] srcR + a[11] srcG + a[12] srcB + a[13] srcA + a[14] “Alpha通道”终值 = a[15] srcR + a[16] srcG + a[17] srcB + a[18] srcA + a[19] “备注” srcR为原图Red通道值，srcG为原图Green通道值，srcB为原图Blue通道值，srcA为原图Alpha通道值。每个通道的源值和终值都在0到255的范围内。即使计算结果大于255或小于0，值都将被限制在0到255的范围内。 使用示例 1234567private final static float[] MATRIX = new float[] &#123; 0.5f, 0, 0, 0, 0, 0, 0.5f, 0, 0, 0, 0, 0, 0.5f, 0, 0, 0, 0, 0, 1, 0 &#125;; 2.2. LightingColorFilterLightingColorFilter是上面ColorMatrixColorFilter的一个简化版本，构造函数也比较简单构造函数 123public LightingColorFilter(int mul, int add) //mul代表multiply,也就是乘法 //add代表加法，也就是颜色偏移量 使用示例 12345Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(), R.drawable.home);canvas.drawBitmap(bitmap, 100, 0, paint);LightingColorFilter filter = new LightingColorFilter(0x888888, 0x000000);paint.setColorFilter(filter);canvas.drawBitmap(bitmap, 100, 500, paint); 计算方法 color = color mul／２５５+ add (计算结果大于等于255都指定为255)其中”color”可以为RGB三种通道中的”一种”，mul和add分别为通道对应的值。假设R通道的值就为R=R0x88/0xff+0 0x88/0xff肯定是小于1的，所以颜色变暗了。add的值越”大”,画面越”亮”. 2.3. PorterDuffColorFilter构造函数 123public PorterDuffColorFilter(int srcColor, PorterDuff.Mode mode) //srcColor源颜色， //mode是色彩的混合模式. 重绘方法1234567891011121314151617/*** 重绘方法* 在某个时候调用 onDraw（android.graphics.Canvas)* 这必须从UI线程调用。 要从非UI线程调用则调用 postInvalidate()*/public void invalidate() &#123; invalidate(true);&#125;/** *这是invalidate（）工作实际发生的地方。 一个完整的invalidate（）会导致绘图缓存无效，但是可以使用invalidateCache设置为false来调用此函数，以便在不需要该过程的情况下跳过该无效步骤。 * * @param invalidateCache此视图的绘图缓存是否也应该被无效。对于完全无效，这通常是正确的，但如果视图的内容或维度未更改，则可能会设置为false。 */void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考《Head First 设计模式》 参考：http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html 设计原则：封装变化多用组合，少用继承开闭原则 定义：装饰模式又名包装(Wrapper)模式。装饰者模式动态地将责任添加到对象上，是继承关系的一个替代方案。 描述： 装饰着可以在所委托装饰着的行为之前或者之后添加自己的行为，已达到特定的目的。 通过使用不同的具体装饰类以及这些装饰类的组合，可以创造出很多不同行为的组合。 装饰着与组件组合时，就是在加入新的行为，新的行为是由组合对象得来的。 如何封装的更好：装饰着模式（Decorator） + 工厂模式（Factory） + 生成器模式（Builder） 装饰模式中的角色有： 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 抽象装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为。行为来自装饰着和基础组件，或与其他装饰着之间的组合关系。 实际应用：java的I/O流 装饰者模式的缺点 ： 产生大量的类。 类型问题。某一个对象依赖特定类型的类型。 采用装饰着实例化组件时，将会增加代码复杂度，不但需要实例化组件，还有把组件包装进装饰者中。 示例：组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 饮料抽象类 */public abstract class Drink &#123; String describtion = "Drink"; int price = 0; /** * 打印 描述 */ public String getDescribtion()&#123; return describtion; &#125; /** * 行为：输出价格 */ public abstract int printPrice();&#125;/** * 具体牛奶饮料类 */public class MilkDrink extends Drink &#123; public MilkDrink()&#123; price = 11; describtion = "MilkDrink " + String.valueOf(price); &#125; @Override public int printPrice() &#123; return price; &#125;&#125;/** * 具体茶饮料类 */public class TeaDrink extends Drink &#123; public TeaDrink()&#123; price = 12; describtion = "TeaDrink " + String.valueOf(price); &#125; @Override public int printPrice() &#123; return price; &#125;&#125; 装饰者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 抽象 装饰者 */public abstract class CondimentDecorator extends Drink&#123; int condimentPrice= 0; public abstract int printPrice();&#125;/** * 抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为 */public class HoneyDecorator extends CondimentDecorator &#123; Drink mDrink; public HoneyDecorator(Drink drink)&#123; this.mDrink = drink; condimentPrice = 10; &#125; @Override public String getDescribtion() &#123; return "HoneyDecorator " + String.valueOf(condimentPrice) + " " + mDrink.getDescribtion(); &#125; @Override public int printPrice() &#123; return condimentPrice + mDrink.printPrice(); &#125;&#125;public class MochaDecorator extends CondimentDecorator &#123; Drink mDrink; /** * 使用抽象基类，践行 "开闭原则"：对扩展开放，对修改关闭 * @param drink 基类 */ public MochaDecorator(Drink drink)&#123; this.mDrink = drink; condimentPrice = 5; &#125; /** * 输出当前组合 */ public String getDescribtion()&#123; return "MochaDecorator " + String.valueOf(condimentPrice) + " " + mDrink.getDescribtion(); &#125; /** * 组合得到新的行为 * @return 当前组合价格 */ @Override public int printPrice() &#123; return condimentPrice + mDrink.printPrice(); &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132public class DecoratorMain &#123; public static void main(String[] args)&#123; //只有一个底料的茶饮料 Drink teaDrink = new TeaDrink(); System.out.println(teaDrink.getDescribtion()); System.out.println(teaDrink.printPrice()); /** * TeaDrink 12 * 12 */ //茶饮料 + 蜂蜜 //抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为 Drink honeyDecorator = new HoneyDecorator(teaDrink); System.out.println(honeyDecorator.getDescribtion()); System.out.println(honeyDecorator.printPrice()); /** * HoneyDecorator 10 + TeaDrink 12 * 22 */ //茶饮料 + 蜂蜜 + 摩卡 Drink mochaDecorator = new MochaDecorator(honeyDecorator); System.out.println(mochaDecorator.getDescribtion()); System.out.println(mochaDecorator.printPrice()); /** * MochaDecorator 5 + HoneyDecorator 10 + TeaDrink 12 * 27 */ &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《Head First 设计模式》 参考：http://blog.csdn.net/self_study/article/details/51628486 代理模式的角色：Subject：抽象主题类 该类的主要职责是声明真实主题与代理的共同接口方法，该类既可以是一个抽象类，也可以是一个接口； RealSubjct：真实主题类 该类也称为被委托类或被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户端则通过代理类间接地调用真实主题类中定义的方法； ProxySubject：代理类 该类也称为委托类或代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中对应的接口方法，以此起到代理的作用； Client：客户类 即使用代理类的部分。 代码描述创建一个抽象主题类 public abstract class MyObject { //代理与实际主题的共同方法 public abstract void operate(); } 真实主题 public class RealObject extends MyObject { @Override public void operate() { System.out.println(&quot;这是来自RealObject的方法处理&quot;); } } 代理主题 public class ProxyObject extends MyObject { private RealObject realObject; //在此类中调用真实的主题，因为是代理主题“代理”真实主题中的方法，需要用到真实主题的引用 public ProxyObject(RealObject realObject) { this.realObject = realObject; } @Override public void operate() { System.out.println(&quot;在处理“RealObject”之前，处理代理模式中自己的方法处理&quot;); //在此处调用真实主题中的同名方法。 realObject.operate(); System.out.println(&quot;在处理“RealObject”之后，处理代理模式中自己的方法处理&quot;); } } 测试 public class Proxy_DesignPattern { public static void main(String[] args){ ProxyObject proxyObject = new ProxyObject(new RealObject()); proxyObject.operate(); } } /** * 输出结果： * 在处理“RealObject”之前，处理代理模式中自己的方法处理 这是来自RealObject的方法处理 在处理“RealObject”之后，处理代理模式中自己的方法处理 */ 代理模式根据实际使用的场景也可以分为以下几种：远程代理（Remote Proxy） 为某个在不同的内存地址空间的对象提供局部代理，使系统可以将 Server 部分的实现隐藏，以便 Client 可以不必考虑 Server 的存在，类似于 C/S 模式（主要拦截并控制远程方法的调用，做代理防火墙之类的）； 虚拟代理（Virtual Proxy） 使用一个代理对象标识一个十分耗资源的对象，并在真正需要时才创建，实现一个延迟加载的机制； 保护代理（Protection Proxy） 使用代理控制对原始对象的访问，该类型的代理通常被用于原始对象有不同访问权限的情况； 智能引用（Smart Proxy） 在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数； 写时拷贝（克隆）代理（Copy-on-write Proxy） 其实是虚拟代理的一个分支，提供了拷贝大对象的时候只有在对象真正变化后才会进行拷贝（克隆）的操作，即延迟拷贝。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考《Head First 设计模式》 参考：http://blog.csdn.net/sbsujjbcy/article/details/49302717 定义：用原型模式的实例创建对象的实例，同过拷贝这些原型模式的实例创建新的对象。 优点及适用场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 注意事项： 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。 深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝例如： prototype.list = (ArrayList) this.list.clone(); 示例//实现“原型模式”第一步：实现Cloneable接口 public class Person implements Cloneable{ private String name; private String address; private int age; private int height; private ArrayList&lt;String&gt; hobbies; public Person(String name, String address, int age, int height, ArrayList&lt;String&gt; hobbies) { this.name = name; this.address = address; this.age = age; this.height = height; this.hobbies = hobbies; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public ArrayList&lt;String&gt; getHobbies() { return hobbies; } public void setHobbies(ArrayList&lt;String&gt; hobbies) { this.hobbies = hobbies; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, height=&quot; + height + &quot;, hobbies=&quot; + hobbies + &apos;}&apos;; } //实现“原型模式”第二步：重写clone（） @Override protected Object clone() throws CloneNotSupportedException { Person person = (Person) super.clone(); person.name = this.name; person.address = this.address; person.age = this.age; person.height = this.height; //person.hobbies = this.hobbies; //此处使用使用深拷贝 person.hobbies = (ArrayList&lt;String&gt;) this.hobbies.clone(); return person; } } 使用 public class Prototype_DesignPattern { public static void main(String[] args){ ArrayList&lt;String&gt; hobbies = new ArrayList&lt;String&gt;(); hobbies.add(&quot;游泳&quot;); hobbies.add(&quot;足球&quot;); hobbies.add(&quot;自行车&quot;); Person person0 = new Person(&quot;张三&quot;,&quot;北京&quot;,24,177,hobbies); System.out.println(&quot;person0 is &quot; + person0.toString()); //原型模式的使用 try { Person person1 = (Person) person0.clone(); person1.setName(&quot;王哇&quot;); hobbies.remove(&quot;足球&quot;); person1.setHobbies(hobbies); System.out.println(&quot;person1 is &quot; + person1.toString()); Person person2 = (Person) person0.clone(); person2.setAge(44); System.out.println(&quot;person2 is &quot; + person2.toString()); } catch (CloneNotSupportedException e) { e.printStackTrace(); } System.out.println(&quot;person0 is &quot; + person0.toString()); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《Head First 设计模式》 OO基础 ：抽象OO原则 ：封装变化、针对接口编程、松耦合（多用组合，少用继承）观察者模式 ：在对象之间定义一对多的依赖，当一个对象的状态改变，其他对象都会收到通知并自动改变。 被观察者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public interface WeatherSet &#123; void register(WeatherOberver oberver); void unRegister(WeatherOberver oberver); void upData(WeatherData weatherData);&#125;/** * 主题（被观察者） */public class WeatherSetI implements WeatherSet&#123; List&lt;WeatherOberver&gt; oberverList; /** * 初始化存储观察者的集合 * 模块间的依赖应该是通过 抽象来实现的 */ public WeatherSetI() &#123; this.oberverList = new ArrayList&lt;WeatherOberver&gt;(); &#125; /** * 注册 * @param oberver 观察者 */ public void register(WeatherOberver oberver)&#123; if (oberverList.contains(oberver)) &#123; System.out.println("注意 : " + oberver.getClass().getName() + " 当前订阅者已经存在，无需订阅"); &#125; else &#123; oberverList.add(oberver); &#125; &#125; /** * 取消注册 * @param oberver 观察者 */ public void unRegister(WeatherOberver oberver)&#123; System.out.println("注意：" + oberver.getClass().getName() + " 已经不再订阅该消息，bye~bye~"); oberverList.remove(oberver); &#125; /** * 数据更新 * @param weatherData 数据Bean类 * * 设计原则：“不要打电话给我，我打电话给你”（上层调用下层，下层不调用上层） */ public void upData(WeatherData weatherData)&#123; System.out.println("注意：当前有 " + oberverList.size() + " 位订阅了该消息！"); for (WeatherOberver item : oberverList) &#123; item.getData(weatherData); &#125; &#125;&#125;/*** 数据Bean类*/public class WeatherData &#123; int temp; int pressure; public WeatherData(int temp, int pressure) &#123; this.temp = temp; this.pressure = pressure; &#125; public int getTemp() &#123; return temp; &#125; public void setTemp(int temp) &#123; this.temp = temp; &#125; public int getPressure() &#123; return pressure; &#125; public void setPressure(int pressure) &#123; this.pressure = pressure; &#125; @Override public String toString() &#123; return "WeatherData&#123;" + "temp=" + temp + ", pressure=" + pressure + '&#125;'; &#125;&#125; 观察者123456789101112131415161718192021222324252627282930313233/** * 观察者 接口 */public interface WeatherOberver &#123; /** * 数据更新行为 * @param weatherData 数据Bean类 */ void getData(WeatherData weatherData);&#125; public class WangObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("WangObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125;public class ZhangObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("ZhangObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125;public class LiObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("LiObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125; 应用public class OberverMain { public static void main(String[] args){ WeatherOberver oberverWang = new WangObserver(); WeatherOberver oberverLi = new LiObserver(); WeatherOberver oberverZhang = new ZhangObserver(); WeatherSetI set = new WeatherSetI(); set.register(oberverWang); set.register(oberverLi); set.register(oberverZhang); set.upData(new WeatherData(12, 45)); /** * 注意：当前有 3 位订阅了该消息！ WangObserver get data temp is : 12, pressure is : 45 LiObserver get data temp is : 12, pressure is : 45 ZhangObserver get data temp is : 12, pressure is : 45 */ System.out.println(); set.unRegister(oberverLi); set.upData(new WeatherData(32, 100)); /** * 注意：observer.LiObserver 已经不再订阅该消息，bye~bye~ 注意：当前有 2 位订阅了该消息！ WangObserver get data temp is : 32, pressure is : 100 ZhangObserver get data temp is : 32, pressure is : 100 */ System.out.println(); set.register(oberverZhang); set.upData(new WeatherData(33, 97)); /** * 注意 : observer.ZhangObserver 当前订阅者已经存在，无需订阅 注意：当前有 2 位订阅了该消息！ WangObserver get data temp is : 33, pressure is : 97 ZhangObserver get data temp is : 33, pressure is : 97 */ } } 实例 Android的广播机制。 我们平时使用本地广播主要就是下面四个方法: LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this); localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter); localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver); localBroadcastManager.sendBroadcast(Intent intent) 调用registerReceiver方法注册广播，调用unregisterReceiver方法取消注册，之后直接使用sendBroadcast发送广播，发送广播之后，注册的广播会收到对应的广播信息，这就是典型的观察者模式 EventBus。 观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件： EventBus.getDefault().register(Object subscriber); EventBus.getDefault().unregister(Object subscriber); EventBus.getDefault().post(Object event); RxJava。 创建一个被观察者： Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; sub) { sub.onNext(&quot;Hello, world!&quot;); sub.onCompleted(); } } ); 创建一个观察者，也就是订阅者： Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() { @Override public void onNext(String s) { System.out.println(s); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { } }; 观察者进行事件的订阅 myObservable.subscribe(mySubscriber);]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式与原则]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[参考《Head First 设计模式》 参考：http://blog.csdn.net/self_study/article/details/51234377 Pattern：模式PrinciPle：原则 设计模式不会直接进入你的“代码”中，而是先进入你的“大脑”中。 在设计模式中，所谓的实现一个接口“并不一定表示写一个类，并利用implement关键词实现某个java接口”。而是泛指“实现某个超类型（可以是接口或是类）的某个方法”。 设计模式： 设计模式是历经验证的OO(Object Oriented)设计经验，不是被发明的，是被发现的。 设计是一门艺术，总是有许多可取舍的地方。 如果找不到合适的设计模式，采用一些 设计原则 也是相当不错的。 好的OO系统设计必须是：可维护、可扩充、可复用的。 ６大设计原则：1. OCP**（Open Closed Principle）- 开闭原则：what 编写代码应该：面向扩展开放，对修改关闭。 尽量不要通过修改现有代码来满足需求。How 要利用扩展来适应变更。 接口 &gt; 抽象 &gt; 具体类。 针对接口编程，而不是针对实现。 多用组合，少用继承。 2. SRP（Single Responsibility Principle）- 单一职责原则：what 一个类、一个方法只做一件事（越简单的越可靠）。how 一个类应该只有一个引起变化的原因。避免潜在错误。 3. LSP（Liskov Substitution Principle）- 里氏替换原则：what 所有引用基类的地方都能透明的使用子类的对象。how 子类必须完全实现父类的方法。 子类可以拥有自己的属性和方法。 子类覆盖或实现父类方法时参数范围可以扩大。 子类覆盖或实现父类方法时返回值范围可以缩小。 4. DIP（Dependence Inversion Principle）- 依赖倒置原则：what 模块间的依赖应该通过抽象发生，具体类之间不应该有依赖关系。 接口或者抽象不依赖于实现类，否则就失去了抽象接口的意义。 实现 依赖于 接口或者抽象，即：底层依赖于高层。how 针对接口编程，而不是针对实现。 别打电话给我，我打电话给你（观察者模式）。 5. ISP（Interface Segregation Principle） - 接口隔离原则：what 使用接口时应该建立单一的接口，不应该建立过于臃肿的接口。 接口应该 “专” 而非 “多”，即：提供独立单一的接口。 6. LKP（Least Knowledge Principle） - 最少知识原则/迪米特法则 ( LOD )：what 一个对象应该对 “其他对象”有最少的了解。how 一个类对于另一个类而言，尽量减少“public”，对外只提供一个简洁的访问 自己的方法。 具体分类 1. 观察者模式 （有趣的事情发生了，可千万别错过！）定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 2. 装饰者模式 动态的将责任附加到对象上，若要扩展功能，装饰者模式提供了比“继承”更有弹性的替代方案。 3. 简单工厂模式 不是一个真正的模式，但是同“抽象工厂模式”和“工厂方法模式”一样，被用于封装创建对象的代码。 4. 抽象工厂模式 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 5. 工厂方法模式 定义了一个创建对象的接口，但由子类决定实例化的类是哪一个。工厂方法模式让类把实例化推迟到子类。 6. 单例模式 确保一个类只有一个实例，并提供一个全局的访问点。 7. 命令模式 将“请求”封装成对象，以便使用不同的请求、队列、或者日志来参数化其他对象。命令模式也支持可撤销的操作。 8. 适配器模式 将一个类的接口转换为期望的另一个接口，让原本接口不兼容的类可以兼容。 9. 模板模式 定义一个算法的骨架，将算法中的某些步骤延迟到子类中具体实现。使得子类在不改变算法结构的情况下，重新定义算法中的某些步骤。 10. 代理模式 - 保护 为另一个对象提供一个替身或占位符以访问这个对象，是基于访问权控制对对象的访问。 11. 代理模式 - 虚拟 作为创建开销大的对象的代表，虚拟代理经常是直到我们真正需要一个对象时才创建真正的对象。当对象在创建前和创建中时，由虚拟代理来扮演真正对象的替身，待真正对象创建后，虚拟代理就会将请求直接给真正的对象。 12. 代理模式 - 远程 好比远程对象的本地代表。 13. 迭代器模式 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露器内部的表示。 14. 组合模式 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合模式能让客户以一致的方式处理个别对象及组合对象。 15. 外观模式 提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。外观模式不仅简化一个接口，而且将客户以组件的一个子系统中解耦。 16. 策略模式 定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 17. 状态模式 允许对象在内部状态改变时改变它的行为，使对象看起来好像修改了它的类。 使用设计模式的好处 使用模式名称和其他人员进行开发或者开发团队沟通时，彼此之间交流的不只是模式名称，而是一整套模式背后所象征的质量、特性、约束。 思路清晰：他人能更清晰的了解你对设计的想法，团队之间对于设计的看法不会轻易产生误解。 宏观：使用设计模式谈论软件系统，能让你保持在“设计层次”，不会被纠缠于“对象”与“类”这种琐碎的实现细节上。 大家对设计模式都有深入的了解，更易提升自身水平。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《Head First 设计模式》- 单例模式 概念单例模式是一种对象创建模式，其用于产生一种具体的对象实例，确保系统中的一个类有且只有一个对象实例。 单例模式特点： 构造函数私有化，防止外部调用构造函数进行实例化。 必须定义一个静态函数获得该单例。 处理好线程同步问题。 实现方式1：饿汉模式只要在加载类的时候，这个类的实例就会被加载，所以被称为饿汉模式。 特点： 空间换时间，类加载慢（在加载类的同时，需要加载类的对象），但是获取对象的速度快，线程安全。 无法对instance实例实施懒加载。 无法实行懒加载的局限性为：譬如 SinglePattern 实例的创建是依赖参数或者配置文件的，在 getInstance()之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 123456789101112public class SinglePattern &#123; //饿汉模式 private static final SinglePattern singlePattern = new SinglePattern(); private SinglePattern() &#123; &#125; public static SinglePattern getInstance() &#123; return singlePattern; &#125;&#125; 2：懒汉模式 参考：https://blog.csdn.net/nsw911439370/article/details/50456231 类加载速度快（类加载时，不创建实例），但运行时加载对象慢（只有在外部第一次调用时才去创建对象。）。 特点：时间换空间，延迟加载。 synchronized关键字： synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。 写法-1：线程安全12345678910111213141516public class SinglePattern &#123; private static SinglePattern singlePattern = null; private SinglePattern() &#123; &#125; // synchronized 同步 public static synchronized SinglePattern getInstane() &#123; if (singlePattern == null) &#123; singlePattern = new SinglePattern(); &#125; return singlePattern; &#125;&#125; 这种实现方法是在获取实例的方法上添加了一个synchronized关键字，能够保证多线程下实例对象的唯一性。但是这样做有一个缺点就是当有其他的线程要去访问这个方法时，总要先拿到锁，才能执行方法里面的代码。若此实例已经创建，那么这个等待是费时的。于是修改为方法-2。 写法-2：双重检验锁12345678910111213141516171819202122public class SinglePattern &#123; private volatile static SinglePattern singlePattern = null; private SinglePattern() &#123; &#125; public static SinglePattern getInstance() &#123; // 先检查实例是否存在，如果不存在才进入下面的同步块 if (singlePattern == null) &#123; // 同步快，线程安全的创建实例 synchronized (SinglePattern.class) &#123; // 再次检查实例是否存在，如果不存在，才真正的创建实例 if (singlePattern == null) &#123; singlePattern = new SinglePattern(); &#125; &#125; &#125; return singlePattern; &#125;&#125; 在写法-2中使用了volatile关键字： volatile是轻量级的synchronized，保证了共享变量的可见性，可见性的意思是：当一个线程修改一个共享变量的数值时，另一个线程能够读到这个修改的值，确保共享变量能够准确和一致的更新。 使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。 使用了volatile关键字的原因： 如果不适用volatitle关键字，它是有问题。主要在于instance = new Singleton();，在 JVM 中这句话大概做了下面 3 件事情。 1231：给 instance 分配内存2：调用 Singleton 的构造函数来初始化成员变量3：将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用就会报错。 关于 2次空判定 与 synchronized 第一次判空：是为了提高运行效率，这种提高效率是在实例已经初始化的前提下。如果实例已经初始化了，每次调用此方时都要通过 synchronized 关键字进行阻塞，效率肯定不高；如果没有初始化，则是正好发挥了 synchronized 关键字的用处。 synchronized 关键字是为了防止多个线程同时调用 getInstance() 时，各个线程均初始化一次实例。 第二次判空：此处的判空条件是不能被省略掉的。如果没有此次判空，那么当 线程A 和 线程B 均通过第一次非空判定后，线程A先获取锁，初始化了实例，之后释放锁，然后线程B获取锁，线程B也进行了实例初始化。这样一来，实例化了2个实例。如果存在此次判定：当线程A释放对象锁后，线程B获取对象锁后，通过二次非空判定后，将不会在执行实例初始化。 3. 静态内部类特点： 这种写法使用JVM本身机制：单例的实例被声明成 static 和 final 变量保证了线程安全；由于 SingleInstance 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷； 123456789101112131415161718public class Singleton &#123; private Singleton() &#123; &#125; public static class SingleInstance&#123; private static final Singleton SINGLETON = new Singleton(); &#125; public static final Singleton getInstance()&#123; return SingleInstance.SINGLETON; &#125;&#125;``` ## 4. 枚举类&gt; 参考：https://blog.csdn.net/gavin_dyson/article/details/70832185 public enum Singleton{ INSTANCE; private Singleton(){ System.out.println(“哈哈哈”); }}123456789**特点：**因为其功能完整、使用简洁、无偿地提供了序列化机制、在面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点，**单元素的枚举类型**被作者认为**是实现Singleton的最佳方法****说明：**其实`Enum`就是一个普通的类，它继承自`java.lang.Enum`类代码中的： public enum Singleton{ INSTANCE;}12就是： public final class Singleton extends Enum { public static final Singleton INSTANCE; public static Singleton[] values(); public static Singleton valueOf(String s); static {};}``` INSTANCE 被声明为 static 的，虚拟机会保证一个类的() 方法在多线程环境中被正确的加锁、同步。所以，枚举实现是在实例化时是线程安全。 enum是一个类，这也是我们可以用enum作为一个类来实现单例的基础。enum类也不能够被继承，在反编译中，我们会发现该类是final。而且enum有且仅有private的构造器，防止外部的额外构造，这恰好和单例模式吻合，也为保证单例性做了一个铺垫。用enum实现Singleton能做到线程安全，保证单例。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Ubuntu 桌面使用命令]]></title>
    <url>%2FLinux-Ubuntu%20%E6%A1%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令使用参考 桌面环境：super ： 长按显示启动器快捷信息 super + 数字 ： 启动指定的应用 super + D ： 显示桌面 super + w : 所有窗口平铺 super + s : 显示所有的工作区 super + t : 打开回收站 alt + prt ： 对窗口截图 ctrl + h ： 显示隐藏文件.h开头 shift + prt ： 选取截图 shift + ctrl + T : 桌面打开终端（在同一窗口下，新的标签页） ctrl + w : 关闭应用 super + c : 搜索图片 super + v : 搜索视屏 super + a : 搜索应用 super + f : 搜索文件和文件夹 super + m : 搜索音乐 终端运行命令(简洁版) 2016年12月19日10:40:37 软件更新 apt-get update 安装 apt-get install 软件名称 卸载 apt-get remove 软件名称 其他清屏 clear vim编辑 vim（vim filename） 组添加组 groupadd 组名 删除组 groupdel 组名 更改组信息 groupmod 组名 显示当前用户所属组 groups 用户查询历史登录 last [用户名] 切换用户 su 用户名 退出切换的用户 exit 相关文件 etc/group, etc/passwd, etc/shadow 查看当前用户 w/who 添加用户 useradd 用户名 删除用户 suerdel 用户名 更改用户信息 usermod 添加用户到组中 useradd -G 组名 用户名 （G:附加组，用户将创建一个与自己同名的组） useradd -g 组名 用户名 （g：表示用户所加入的主组） 用户修改密码 passwd 用户名 查询id值 id 将用户添加至已存在的组中 usermod -a -G 组名 用户名 更改用户主要所在组 usermod -g 组名 用户名 文件pwd 查看当前目录 cat （从第一行开始显示）查看文件内容 cat [-nTAEv] tac （从最后一行开始显示） nl （显示时输出行号） nl [-b{ a, t}n{ln,rn,rz}w ] more （分页显示） space 向下翻一页 enter 向下翻一行 q 立即退出 :f 立刻显示当前文件名及当前行数 /字符串 在当前显示内容中，向下查询【字符串】 less（同more，可以向前翻页） /字符串 向上查询 ？字符串 向下查询 n 重复前一个查询 N 反向重复前一个查询 q 离开 pagedown 向下翻页 pageuP 向上翻页 head （仅显示头几行） head [-n number] 文件 tail（仅显示尾几行） tail [-n number] 文件 od （以2进制的方式读取档案） 目录与文件查看 ls [-aAdfFhilrRSt] 目录名 （可以使用×作为匹配符）ls [--color={none,auto,always}] 目录名 ls [--full-time{mtime,ctime,atime}] 目录名 ll == ls -l ls -a （显示隐藏文件及目录） pwd -P （返回真实目录，非连接目录） 路径切换 cd 文件路径cd - (返回上一个工作目录) cd ~ （home目录） cd .. (返回上层文件) cd ../目录 （同一层目录中前往其他目录） cd ~用户名 （进入此用户的home目录） 创建文件vim 文件名 （方式1） touch 文件名(空) （方式2） echo “输入内容” &gt; 文件名.后缀 （方式3） echo “输入内容” &gt;&gt; 文件名.后缀 （方式3: 追加到文件末尾） sed (在某一行添加) 修改文件时间+创建文件touch(空) 时间分类mtime:内容变更时间； ctime：状态时间； atime：接收时间 touch [-mcadt] 创建目录 mkdirmkdir [-mp] 目录名 （m：权限，p：自动建立多层目录） 删除目录 rmdirrmdir [-p] 目录名 （p：当前目录包含多个目录，删除时连同自身删除）仅能删除空目录 rm -rf 目录名 （删除非空目录） 慎用 更改组 chgrpchgrp [-R] 组名 文件 （R：文件夹递归） 更改拥有者 chownchown [-R] 用户名 文件 chown [-R] 用户名：组名 文件 获取文件名basename 目录 获取目录dirname 目录 文件预设权限 umaskumask [-S] (查看权限预设) 022:表示被‘拿掉的权限’,即：u,g-w,o-w umask 002 （设置权限） 权限的分类基本属性 + 隐藏属性 + 特别S属性 更改权限属性 chmodchmod [-R] 777 文件名 chmod [-R] u=(+/-)rwx,g=(+/-)rwx,o=(+/-)rwx 文件名 设定隐藏属性 chattrchattr [+-=][ASacdistu] 文件或目录名 (最常用a，i) chattr +a：表示在原有参数的基础上，追加参数-append，表示只能向文件中添加数据，不能删除,多用于日志。 chattr +i：表示文件不能被删除，改名，设定链接关系，同时不能写入，追加内容。 显示隐藏属性 lsattrlsattr [-aR] 文件或目录名 SUID,SGID,SBIT 设定4：SUID（使用在非目录上） 2：SGID（目录与文件均可） 1：SBIT（使用在非文件上） e.g. chmod 4755 文件名 结果为：-rwsr-xr-x 文件的类型 filefile 文件路径 文件查询whereis/locate（通过数据库查询,所以在查询前最好更新数据书库，updatedb文件） which find不推荐使用（伤硬盘：原理是在硬盘上查找，耗时）使用×匹配文件 which [-a] 文件 whereis [-bmsu] 文件或目录 locate 文件名 复制cp 源文件路径 新文件路径 （复制，建立快捷方式，新旧比对，复制目录） cp [-adfilprsu] cp 源1，源2…… 目录 移动mv （移动，更名 ） mv [-fiu] mv 原文件名 新文件名 mv 文件1，文件2 目录名 删除 rmrm [-rfi] 目录或文件 (若文件名中含有-，则用‘./’或者‘空格--空格’) 更新 2017年02月04日 星期六 18时34分42秒 查看磁盘空间大小命令 主要命令：df 详细命令：df -hl : 查看磁盘剩余空间（效果同 df -H） df -h : 查看每个根路径的分区大小 du -sh : [目录名] 返回该目录的大小 du -sm : [文件夹] 返回该文件夹总M数 fdisk -l : 查看硬盘分区 查看ip地址ifconfig 查看端口号主要命令 ： netstat 查看所有的服务端口: netstat -a 查看所有的服务端口，显示pid号 netstat -ap 查看某一（**）端口，则可以结合grep命令： netstat -ap | grep ** 如查看**端口，： lsof -i:** 若要停止使用这个端口的程序，使用kill +对应的pid kill pid 还有一个比较好用的命令，查看**端口： netstat -lnp | grep ** 查看端口号和运行程序： netstat -atunp | more 查看进程所用端口： netstat -tlnp|grep ** 卸载已经安装的软件命令： dpkg -l | grep appName apt-get remove appName 更新grep命令 参考：http://www.lai18.com/content/24612942.html 命令： 是linux中的搜索工具。可以用在搜索条件“过滤”。 用法： grep [选项] PATTERN 参数说明： [options] -c：只输出匹配行的计数。 -i：不区分大 小写(只适用于单字符)。 -h：查询多文件时不显示文件名。 -l：查询多文件时只输出包含匹配字符的文件名。 -n：显示匹配行及行号。 -s：不显示不存在或无匹配文本的错误信息。 -v：排除，不显示过滤的字符串的行；显示不包含匹配文本的所有行。 -E ：过滤多个字符串。 -o ：输出精确匹配的字符而不是默认的整行。 -f ：指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 Context control： -B 除了显示匹配的一行之外，并显示该行之前的num行 -A 除了显示匹配的一行之外，并显示该行之后的num行 -C 除了显示匹配的一行之外，并显示该行之前后各num行 grep &quot;String&quot; -B 10 test.txt #显示匹配的String行和String的前10行。 pattern正则表达式主要参数： \：忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 $: 匹配正则表达式的结束行。 \&lt;：从匹配正则表达 式的行开始。 \&gt;：到匹配正则表达式的行结束。 [ ]：单个字符，如 [Gg]rep 匹配Grep和grep。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求。 [^]：匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。 x\{m\}：重复字符x，m次，如：&apos;0\{5\}&apos;匹配包含5个0的行。 x\{m,\}：重复字符x,至少m次，如：&apos;0\{5,\}&apos;匹配至少有5个0的行。 x\{m,n\}：重复字符x，至少m次，不多于n次，如：&apos;0\{5,10\}&apos;匹配5 -- 10个0的行。 .：所有的单个字符。 *：有字符，长度可以为0。 更新tree命令安装 tree1234brew install tree``` **解决 `tree` 不能显示 中文 问题：** tree -N ``` 参数说明-1. 清单选项 参数 说明 -a 列出所有文件 -d 仅列出目录。 -l 遵循像目录这样的符号链接。 -f 打印每个文件的完整路径前缀。 -x 仅保留在当前文件系统上。 -L level 层级目录。 -R 达到最高等级时重新运行树。 -P pattern 仅列出与给定模式相匹配的文件。 -I pattern 不要列出与给定模式匹配的文件。 –ignore-case 模式匹配时忽略大小写。 –matchdirs 在-P模式匹配中包含目录名称。 –noreport 关闭树列表末尾的文件/目录计数。 –charset X 使用字符集X作为终端/ HTML和缩进行输出。 –filelimit＃ 不要下载超过＃个文件的dirs。 –timefmt 根据格式打印和格式化时间。 -o filename 输出到文件而不是标准输出 -2. 文件选项 参数 说明 -q 将不可打印的字符打印为’？’ -N 按原样打印不可打印的字符。 -Q 用双引号引用文件名。 -p 打印每个文件的保护。 -u 显示文件所有者或UID号码。 -g 显示文件组所有者或GID号码。 -s 打印每个文件的字节大小。 -h 以更易读的方式打印尺寸。 –si 像-h，但在国际单位中使用（幂数为1000）。 -D 打印上次修改日期或（-c）状态更改。 -F 附加’/‘，’=’，’*’，’@’，’ ‘或’&gt;’按照ls -F –inodes 打印每个文件的inode编号 –device 打印每个文件所属的设备ID号 -3. 排序选项 参数 说明 -v 按文本字母数字排序文件。 -t 按上次修改时间对文件进行排序。 -c 按上次状态更改时间对文件进行排序。 -U 保留文件未排序。 -r 反转排序的顺序。 –dirsfirst 列出文件之前的目录（-U禁用）。 - sort X 选择排序：名称，版本，大小，mtime，ctime。 -4. 图形选项 参数 说明 -i 不要打印缩进线。 -A 打印ANSI线图形缩进线。 -S 使用CP437（控制台）图形缩进线打印。 -n 始终关闭着色（-C覆盖）。 -C 总是打开彩色。 -5. XML / HTML / JSON选项 参数 说明 -X 打印树的XML表示。 -J 打印出树的JSON表示。 -H baseHREF 以baseHREF作为顶层目录打印HTML格式。 -T 字符串用字符串替换默认的HTML标题和H1标题。 –nolinks 关闭HTML输出中的超链接。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Vim 命令]]></title>
    <url>%2FLinux-Vim%20%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Vim使用总结 vim命令vi有3个模式：插入模式、命令模式、低行模式。插入模式：在此模式下可以输入字符，按ESC将回到命令模式。 命令模式：可以移动光标、删除字符等。 低行模式：可以保存文件、退出vi、设置vi、查找等功能(低行模式也可以看作是命令模式里的)。 打开文件、保存、关闭文件（vi命令模式下使用）vi filename //打开filename文件,文件名称可以不存在 :w //保存文件 :w filename //保存至filename文件 :q //退出编辑器，如果文件已修改请使用下面的命令 :q! //退出编辑器，且不保存 :wq //退出编辑器，且保存文件 :wq! //强制保存内容退出 3.插入文本或行（vi命令模式下使用，执行下面命令后将进入插入模式，按ESC键可退出插入模式）a //在当前光标位置的右边添加文本 A //在当前行的末尾位置添加文本 i //在当前光标位置的左边添加文本 I //在当前行的开始处添加文本(非空字符的行首) O //在当前行的上面新建一行 o //在当前行的下面新建一行 R //替换(覆盖)当前光标位置及后面的若干文本 J //合并光标所在行及下一行为一行(依然在命令模式) 移动光标（vi命令模式下使用）&lt;1&gt;、使用上下左右方向键 &lt;2&gt;、命令模式下： h 向左、l 向右、j 向下 、k 向上。 Backspace 向左、空格键 向右、Enter 移动到下一行首、- 移动到上一行首。 &lt;3&gt; $ 跳至行末，0 跳至行首 删除、恢复字符或行（vi命令模式下使用）x //删除当前字符 nx //删除从光标开始的n个字符 dd //删除当前行 ndd //向下删除当前行在内的n行 d&lt;enter&gt; //删除光标所在行及下一行(共计删除2行) u //撤销上一步操作 U //撤销对当前行的所有操作 搜索（vi命令模式下使用）/vpser //向光标下搜索vpser字符串 ?vpser //向光标上搜索vpser字符串 n //向下搜索前一个搜素动作 N //向上搜索前一个搜索动作 跳至指定行（vi命令模式下使用）n //跳n行 n+ //向下跳n行 n- //向上跳n行 G //跳至文件的底部 gg //跳至文件顶部 设置行号（vi命令模式下使用）:set nu //显示行号 :set nonu //取消显示行号 复制、粘贴（vi命令模式下使用）yy //将当前行复制到缓存区，也可以用 &quot;ayy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。 nyy //将当前行向下n行复制到缓冲区，也可以用 &quot;anyy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。 yw //复制从光标开始到词尾的字符。 nyw //复制从光标开始的n个单词。 y^ //复制从光标到行首的内容。 y$ //复制从光标到行尾的内容。 p //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用&quot;ap 进行粘贴。 P //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用&quot;aP 进行粘贴。 替换（vi命令模式下使用）:s/old/new //用new替换行中首次出现的old :s/old/new/g //用new替换行中所有的old :n,m s/old/new/g //用new替换从n到m行里所有的old :%s/old/new/g //用new替换当前文件里所有的old 编辑其他文件:e otherfilename //编辑文件名为otherfilename的文件。 修改文件格式:set fileformat=unix //将文件修改为unix格式，如win下面的文本文件在linux下会出现^M。 总结：当如果不知道自己处在什么模式时可以按: 2次Esc键 即可回到命令模式，会有最后提醒一点： 注意大小写！！！ Linux中vim编辑注意事项 2016年12月17日21:47:04 Ctrl s： 暂停该终端 Ctrl q： 让终端继续运行 Ctrl c： 中止当前正在执行的程序。 Ctrl d： 相当于exit命令，退出当前会话。 Ctrl z： 将当前运行的程序放到后台运行。与运行时加&amp;类似。 Tab键自动补全命令。 Linux中Terminal快捷键的使用 2017年 01月 09日 星期一 22:21:36 CST 文件：shift + ctrl + T： 新标签页打开新的终端 shift + ctrl + N： 新的窗口打开新的终端 alt + w : 关闭终端 alt + Q : 关闭全部终端 编辑：ctrl + C ： 复制 ctrl + V ： 粘贴 查看：F11 ： 全屏 ctrl + = : 放大 ctrl + - ： 缩小 ctrl + 0 ： 正常大小 查找：ctrl + F ： 查找 ctrl + G ： 查找下一个 ctrl + H ： 查找上一个 ctrl + J ： 清除高亮查找 标签页：ctrl + pgup : 向上翻页 ctrl + pgdn : 向下翻页 shift + ctrl + pgup ： 标签内容移动之左侧标签 shift + ctrl + pgdn ： 标签内容移动之右侧标签 alt +数字 ： 切换至指定的标签页]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Ubuntu16.04安装记录]]></title>
    <url>%2FLinux-Ubuntu16.04%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[以下省略“sudo”命令表示是在root权限下运行的 ubuntu16.04使用参考网址 Linux使用设置 &gt;&gt;网页 http://m.blog.csdn.net/article/details?id=51049513 Linux命令大全 &gt;&gt;网页 http://www.runoob.com/linux/linux-command-manual.html Linux命令大全–支持在线搜寻 http://man.linuxde.net/ 文档手册中心 –ChinaUnix &gt;&gt;网页 http://man.chinaunix.net/ Linux Kernel –ChinaUnix &gt;&gt;网页 http://man.chinaunix.net/tech/lyceum/linuxK/tlk.html Linux Git使用 &gt;&gt;网页 http://v.youku.com/v_show/id_XNzgwOTk0NDQw.html?f=22842023&amp;spm=a2hzp.8244740.0.0&amp;from=y1.7-1.1 以下省略“sudo”命令表示是在root权限下运行的 root登录 先设定一个root的密码： sudo passwd root root 登陆： su root cp -p /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak vi /etc/lightdm/lightdm.conf 在lightdm.conf最后增加一行： greeter-show-manual-login=true 重启后，即可用root登入。 系统没有声音Ubuntu在root用户下，为了安全考虑默认关闭系统的声音。 将root加到pulse和pulse-access组： usermod -a -G pulse-access root gpasswd -a root pulse gpasswd -a root pulse-access 编辑/etc/default/pulseaudio文件 cp -p /etc/default/pulseaudio/etc/default/pulseaudio.bak vim /etc/default/pulseaudio 修改以下两处 PULSEAUDIO_SYSTEM_START=1 DISALLOW_MODULE_LOADING=0 改为1和0，表示允许运行在system环境，允许动态加载模块。 重启计算机 有声音但在“系统设置”中无法调节声音： 运行： gedit /root/.profile 在文件的最后添加： pulseaudio --start --log-target=syslog 当在“系统设置”中出现“伪声音”时，且无法实际调节声音时： apt install pavucontrol pavucontrol 系统正常耳机没有声音 参考网址：http://www.linuxdiyf.com/linux/25529.html 终端运行 alsamixer 按M键把关闭的都大开（关闭的都显示的是MM），然后调节到合适的位置，白色为宜 最后一项Independ显示为ON表示耳机和音箱只能有一个有声音，按M键关闭则表示耳机和音箱可以同时有声音 （–未进行测试–） 若耳机还是没声音，可是试着运行 gedit /etc/modprobe.d/alsa-base.conf 在最后一行加入 #enable headphoneoptions snd-hda-intel power_save=10 power_save_controller=N model=6stack-dig 然后运行 apt-get remove alsa-base 然后重启 shutdown -r now 重启后运行 apt-get install alsa-base ubuntu16.04系统字体变成方框问题进入到字体的目录下/usr/share/fonts/，输入下面的命令： cd /usr/share/fonts/ 制作ubuntu16.04app启动图标 2016年12月15日15:40:42 在文件所在目录下新建一个Studio.desktop文件,并用gedit打开,然后将下面的内容复制进去并修改. [Desktop Entry] Name=应用的名称 Type=Application（不改） Icon=你的AndroidStudio解压目录的绝对路径/android-studio/bin/studio.png Exec=sh 你的AndroidStudio解压目录的绝对路径/android-studio/bin/studio.sh 保存退出(注意：每一行后面都不能有空格,否则失败) 右键该文件–&gt;属性–&gt;权限–&gt;选择“允许作为程序执行文件”,此时发现图标变了,双击打开App 安装ADB 2017年01月30日 星期一 15时57分56秒 参考： http://www.itdadao.com/articles/c15a299707p0.html http://www.jianshu.com/p/8768e5bccfa8 若apt-get install 失败： sudo add-apt-repository ppa:phablet-team/tools (原始ppa更好) sudo apt-get update sudo apt-get install android-tools-adb 出现异常： E: 无法获得锁 /var/lib/dpkg/lock – open (11: 资源临时不可用) E: 无法对管理目录(/var/lib/dpkg/)加锁，是不是另一个包管理程序在使用它？ 解决办法： 删除有问题的文件 安装 JDK + Eclipse + Apache Tomcat 2016年12月14日15:32:34以下省略“sudo”命令表示是在root权限下运行的 JDK8 （下载地址） http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz 在所在的文件夹目录下，可以直接打开terminal，跳过以下两句操作，直接进行环境配置 cd /Downloads tar -zxvf jdk-8u101-linux-x64.tar.gz 3.配置环境变量 gedit /etc/profile 在文件末尾添加以下内容： export JAVA_HOME=/home/lt/Java/jdk1.8.0_101(你的Jdk目录) export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 更新文件（必须执行） source /etc/profile notice！若在终端中出现:程序 ‘javac’ 已包含在下列软件包中： update-alternatives --install /usr/bin/javac javac /root/文档/jdk1.8.0_112/bin/javac 300 update-alternatives --install /usr/bin/java java /root/文档/jdk1.8.0_112/bin/java 300 Eclipse（eclipse安装工具） （下载地址） https://www.eclipse.org/downloads/download.php?file=/oomph/epp/neon/R/eclipse-inst-linux64.tar.gz 解压 tar -zxcf eclipse-inst-linux64.tar.gz 进入解后目录下,双击eclipse.inst运行安装程序 若有安装错误执行 mkdir jre cd jre ln -s （你的JDK目录/bin bin） Tomcat9 （下载地址） http://tomcat.apache.org/download-90.cgi 在所在的文件夹目录下，可以直接打开terminal，跳过以下两句操作，直接进行环境配置 cd Downloads/ unzip apache-tomcat-9.0.0.M9.zip 配置环境变量： export CATLINA_HOME=/home/lt/Java/apache-tomcat-9.0.0.M9（文件所在路径） sourse /etc/profile 安装MySQL+WorkBrench 2016年12月15日15:54:09 以下省略“sudo”命令表示是在root权限下运行的 ubuntu16.04安装mysql5.7未用sudo apt-get update未用sudo apt-get upgrade apt-get install mysql-server mysql-client apt-get install libmysqlclient-dev 自动安装会装上5.7的client端，中间会弹出提示框输入root的密码 安装完成之后检查是否成功。socket处于 listen 状态则表示安装成功 netstat -tap | grep mysql 未用sudo groupadd mysql未用sudo useradd -r -g mysql mysql 修改密码 未用sudo /usr/bin/mysqladmin -u root password 登陆mysql数据库可以通过如下命令： mysql -u root -p -u 用户名， -p 用户密码，输入后提示输入密码，此时输入密码就可以登录到mysql 安装客户端apt-get install mysql-workbench 安装RabbitVCS 2017年02月06日 星期一 14时04分24秒参考：http://blog.csdn.net/catshitone/article/details/48022315 注： 安装完毕后，注销LogOut，重新登录，在文件夹和文件夹内点击鼠标右键就用RabbitVCS操作工具了。 如果不能正常运行则输入： sudo apt-get install python-nautilus python-configobj python-gtk2 python-glade2 python-svn python-dbus python-dulwich subversion meld 再次更新软件包库： sudo apt-get update 注销LogOut，重新登录即可。 安装Terminator 2017年02月06日 星期一 15时53分34秒参考： http://www.jianshu.com/p/cee2de32ca28 安装： apt-get install terminator 卸载： apt-get remove terminator 快捷键(自定义之后的): 水平分割终端 : Ctrl+O 垂直分割终端 : Ctrl+E 搜索 : Ctrl+F 复制 : Ctrl+C 粘贴 : Ctrl+V clear屏幕 : Ctrl+G 关闭当前终端 : Ctrl+W 退出当前窗口 : Ctrl+Q 变化当前窗口位置 ：super+R 全屏状态 : F11 在垂直分割的终端中将分割条向右移动 :Ctrl+Right 在垂直分割的终端中将分割条向左移动 :Ctrl+Left 隐藏/显示滚动条 :Ctrl+Shift+S 配置文件（可参考）： [global_config] handle_size = -3 enabled_plugins = CustomCommandsMenu, LaunchpadCodeURLHandler, APTURLHandler, LaunchpadBugURLHandler title_transmit_fg_color = &quot;#000000&quot; suppress_multiple_term_dialog = True title_transmit_bg_color = &quot;#3e3838&quot; inactive_color_offset = 1.0 [keybindings] [profiles] [[default]] palette = &quot;#000000:#5a8e1c:#2d5f5f:#cdcd00:#1e90ff:#cd00cd:#00cdcd:#e5e5e5:#4c4c4c:#868e09:#00ff00:#ffff00:#4682b4:#ff00ff:#00ffff:#ffffff&quot; background_image = &quot;&quot; background_darkness = 0.68 scrollback_lines = 3000 background_type = transparent use_system_font = scroll_background = False show_titlebar = False cursor_shape = ibeam font = Liberation Mono 12 background_color = &quot;#0e2424&quot; foreground_color = &quot;#e8e8e8&quot; [layouts] [[default]] [[[child1]]] type = Terminal parent = window0 profile = default [[[window0]]] type = Window parent = &quot;&quot; size = 925, 570 [plugins] ubuntu安装Wine 参考：http://www.ubuntukylin.com/ukylin/forum.php?mod=viewthread&amp;tid=27068 安装源 sudo add-apt-repository ppa:wine/wine-builds sudo apt-get update 安装wine apt-get install wine1.8 卸载wine 1).卸载wine主程序，在终端里输入： sudo apt-get remove --purge wine 2).然后删除wine的目录文件： rm -r ~/.wine 3).卸载残留不用的软件包： sudo apt-get autoremove 终端中输入wine，检测是否安装完成 ubuntu安装WebStorm 2017年02月16日 星期四 12时31分00秒 参考：https://quanru.github.io/2016/04/17/%E4%BD%BF%E7%94%A8%20Linux%20%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91Web%E5%89%8D%E7%AB%AF/webstorm使用快捷键参考： http://blog.csdn.net/zghekuiwu/article/details/54382145 https://github.com/damao/Intellij-IDEA-F2E#%E6%B3%A8%E5%86%8C 下载： http://www.jetbrains.com/webstorm/index.html 解压下载的 gz 包，在bin/下运行： ./webstorm.sh WebStorm 默认情况下是需要收费的，可以申请为开源项目的贡献者来获得 licenses。 安装完成后，在 File - Settings - Plugins，选择需要安装的插件，例如 AngularJS、Markdown 等。 在 File - Settings - Directories 下，通过 Add content Root 来设置我们的项目路径 在 File - Settings - JavaScript - Libraries 下，勾选想要支持的库，建议全部勾上（如 NodeJS）。 在 File - Settings - Editor - Colors &amp; Fonts - Font 下，选择自己想要的主题， 然后 Save as… 保存自己想要的主题名称，设置字体为Ubuntu Mono， 字体设置为 16（貌似有点小，相当于 Eclipse 下的 12） 在 File - Settings - Appearance 下，勾选 Show line numbers 选项。 破解方式：选择line server 方式，输入： http://idea.iteblog.com/key.php 安装ubuntu主题 2016年12月15日14:54:25 安装主题管理工具： apt-get install unity-tweak-tool 安装主题 apt-add-repository ppa:numix/ppa apt-get update apt-get install numix-icon-theme-circle //安装图标 apt-get install numix-gtk-theme //安装主题 安装docky（Mac桌面下方的启动器） 参考网址：http://www.aichengxu.com/view/992905参考网址：http://www.noobslab.com/2014/11/mbuntu-macbuntu-1410-transformation.html install docky add-apt-repository ppa:docky-core/ppa apt-get update apt-get install docky apt-get remove docky docky 安装XX-Net 2017年02月04日 星期六 17时17分36秒 安装xx-net 安装firefox或者chrome 设置： 系统设置 --&gt; 网络 --&gt; 网络代理 --&gt; 方法：自动 配置：http://127.0.0.1:8086/proxy.pac 全局配置 重点： 此项目来自GitHub，可以直接clone到本地 需要使用到Google AppID，以此进行服务器部署，以达到真正上网的目的 使用host科学上网2016年12月15日16:04:07使用host文件进行翻墙 参考链接：https://laod.cn/hosts/2016-google-hosts.html 安装sbulime text32017年 01月 28日 星期六 15:05:31 CST 安装参考： http://www.cnblogs.com/unflynaomi/p/5704293.html 汉化，中文输入问题参考： http://blog.csdn.net/u013453604/article/details/48002127 汉化，无法输入中文资源： http://download.csdn.net/detail/u013453604/9049633 不能输入中文问题参考： http://www.cnblogs.com/mo-wang/p/5120484.html（步骤不全，修改的内容全面） http://www.liuqianfei.com/article/3e51f07d254b464995b0f4c94cc1d69c（步骤全面） 配置java，python，markdown： http://www.jianshu.com/p/58bf9e4d5b32 安装步骤： sudo add-apt-repository ppa:webupd8team/sublime-text-3 sudo apt-get update sudo apt-get install sublime-text-installer 安装：python3 apt install python3-pip 卸载 sublime text 命令： sudo apt-get remove sublime-text-installer 启动sublime text3 在terminal终端中输入：subl 打开指定的文件： subl 文件名 解决sublime无法输入中文的问题在进行所有操作时首先进行依赖包的安装：代码依赖于 gtk 2.0，编译 c 需要安装 build-essential。 sudo apt-get install build-essential libgtk2.0-dev 如果路径中含有空格，你必须使用双引号将路径括起来： $ subl &amp;quot;~/Documents/test/my test file.txt&amp;quot; 解决无法输入中文问题 - 2017年03月12日 星期日 15时17分24秒 参考：http://www.jianshu.com/p/03a9092c73e2亲测有效！ 解决事件输入问题 参考：https://my.oschina.net/antsky/blog/491146 WPS字体缺失 下载缺失的字体文件，然后复制到Linux系统中的/usr/share/fonts文件夹中。 国外下载地址：https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip 国内下载地址：https://pan.baidu.com/s/1eS6xIzosudo cp * /usr/share/fonts 执行以下命令,生成字体的索引信息： sudo mkfontscale sudo mkfontdir 运行fc-cache命令更新字体缓存。 sudo fc-cache 重启wps即可，字体缺失的提示不再出现。 WPS不能输入中文问题 参考:http://forum.ubuntu.org.cn/viewtopic.php?f=48&amp;t=476937原因：环境变量未正确设置，以上可以直接针对wps设置。 解决办法,终端输入: gedit /usr/bin/wps 在此文件中输入一下内容,#!/bin/bash之后: export XMODIFIERS=&quot;@im=fcitx&quot; export QT_IM_MODULE=&quot;fcitx&quot; 安装WeChat 2016年12月13日22:43:53 安装linux微信： 下载地址:https://github.com/geeeeeeeeek/electronic-wechat/releases apt-get install git git clone https://github.com/geeeeeeeeek/electronic-wechat.git cd electronic-wechat apt-get install npm apt-get install nodejs-legacy npm install &amp;&amp; npm start 官方推荐的安装方法： To clone and run this repository you’ll need Git and Node.js (which comes with npm) installed on your computer. From your command line: Clone this repository git clone https://github.com/geeeeeeeeek/electronic-wechat.git# Go into the repositorycd electronic-wechat# Install dependencies and run the app npm install &amp;&amp; npm start To pack into an app, simply type one of these: npm run build:osx npm run build:linux]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Alias 的使用]]></title>
    <url>%2FLinux-Alias%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[所有命令均在ubuntu16.04环境下完成，在不同环境下可能会有差异 alias介绍alias用于自定义快捷命令，避免总是使用相同的，重复的，冗长的命令来执行操作 alias的用法1.添加新的自定义快捷方式 alias 自定义新名字=&quot;操作命令&quot; 示例：将进入文档目录的命令定义为 cdd 新命令 alias cdd=&quot;cd /root/文档/&quot; 2.删除自定义的快捷方式： unalias 自定义新名字 示例：删除 cdd 新命令 unalias cdd 3.查询自定义快捷方式： alias alias的存储注： 若不保存在文件中，则只能在当前的`terminal`中使用,只有保存到文件中后才能供以后继续使用 来自～/.bashrc文档的介绍 Alias definitions.You may want to put all your additions into a separate file like ~/.bash_aliases, instead of adding them here directly. See /usr/share/doc/bash-doc/examples in the bash-doc package. 使用以下方式，将自定义的快捷键存入系统已有文件中。此文件位于/root/下: vim ~/.bashrc 使用以下方式，将自定义的快捷键存入”指定”的新文件中。此文件位于/root/下: vim ~/.bash_aliases 注： 对于以上两中方式，必须使用： source ~/.bash_aliases 命令更新文件，否则自定义快捷键将不会被找到，无法起作用。 个人快捷命令组合： ls 查询字段释义：http://blog.csdn.net/sjzs5590/article/details/8254527更多详细使用参考：用户目录下的 .bash_profile # Alias alias ll=&apos;ls -lh -G&apos; alias la=&quot;ls -lah -G&quot; # 显示size alias lls=&apos;ls -lSGh&apos; alias las=&quot;ls -laSGh&quot; # 显示行号 alias lln=&apos;ls -lh | nl&apos; alias lan=&quot;ls -lah | nl&quot; alias llns=&apos;ls -lSh | nl&apos; alias lans=&quot;ls -laSh | nl&quot; alias grep=&apos;grep --color&apos; # Hexo alias ohb=&apos;open &quot;/Users/yannischeng/Documents/HexoBLog&quot;&apos; alias ohbs=&apos;open &quot;/Users/yannischeng/Documents/HexoBLog/source/_posts&quot;&apos; alias chbl=&apos;cd &quot;/Users/yannischeng/Documents/HexoBLog&quot;&apos; alias chbsl=&apos;cd &quot;/Users/yannischeng/Documents/HexoBLog/source/_posts&quot;&apos; # python project alias opp=&apos;open /Users/yannischeng/PycharmProjects/First_Python_Project&apos; alias cppl=&apos;cd /Users/yannischeng/PycharmProjects/First_Python_Project&apos; # .bash_profile alias sup=&apos;source .bash_profile&apos; alias oup=&apos;open /Users/yannischeng/.bash_profile&apos; alias cupl=&apos;cd /Users/yannischeng/&apos; # open app alias om=&apos;open /Applications/MWeb.app&apos; alias oas=&apos;open /Applications/&quot;Android Studio&quot;.app&apos; alias osb=&apos;open /Applications/&quot;Sublime Text&quot;.app&apos; alias ogc=&apos;open /Applications/&quot;Google Chrome&quot;.app&apos; alias opc=&apos;open /Applications/PyCharm.app&apos; alias owc=&apos;open /Applications/WeChat.app&apos; alias od=&apos;open /Applications/Dictionary.app&apos; alias owm=&apos;open /Applications/NeteaseMusic.app&apos; # login mysql alias lms=&apos;mysql -u root -p&apos; # mytree alias mtree=&quot;find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos;&quot;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
