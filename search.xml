<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac环境下MySQL的安装与使用]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[平台：Mac环境 mysql操作命令参考：http://www.runoob.com/mysql/mysql-tutorial.html 安装 官网下载地址 https://dev.mysql.com/downloads/file/?id=473576 默认安装目录 /usr/local/ 安装时弹出的默认密码，在第一次登录时需要用到： A temporary password is generated for root@localhost: gkct&gt;2Wajv5W 安装完成 登录mysql （连接远程数据库，默认端口号：3306） 远程连接 mysql -h主机地址 -u用户名 －p用户密码 登录mysql （连接本地数据库） mysql -u root -p 输入密码 登录后，修改密码 SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;新密码&apos;); 开启/关闭 - 手动 系统偏好设置 -&gt; mysql 修改mysql编码 查看编码 默认设置： mysql&gt; show variables like &apos;%char%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.01 sec) 修改 在目录：/usr/local/mysql/support-files下找里面有没有my-default.cnf或my.cnf文件. 如果有则直接打开添加: 在[client]在下面添加 default-character-set=utf8 默认字符集为utf8 在[mysqld] 添加 default-character-set=utf8 默认字符集为utf8 设定连接mysql数据库时使用utf8编码，以让mysql数据库为utf8运行 init_connect=&apos;SET NAMES utf8&apos; 若是没有在/etc下新建my.cnf。执行命令： $ cd /etc $ sudo vim my.cnf 将 本文 附录内容粘贴到文件中后，保存退出即可。注意：修改完编码后要 退出之后再次进入 才能生效修改之后的编码设置 mysql&gt; show variables like &apos;%char%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.00 sec) 卸载MySQLsudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* vim /etc/hostconfig (and removed the line MYSQLCOM=-YES-) rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* MySQL操作命令 命令操作参考：http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html命令操作参考：http://blog.csdn.net/qi49125/article/details/77887100 数据库操作查看版本号select version(); 查询所有数据库show database; 使用数据库use 数据库名称 创建数据库create database 数据库名 删除数据库drop database 数据库名 备份数据库外部数据库 导入登录 mysql -u root -p; 选择数据库 use databaseName; 将外部的.sql文件拖入终端中 source 命令后面，然后回车 source 拖如.sql文件; 内部数据库 导出在终端中，要进入存储文件的目录，然后再执行导出操作 cd 待存文件的目录 导出MySQL中的所有数据库（结构+数据）mysqldump -u root -p --all-databases &gt; dafadf00.sql; 导出MySQL中的单个数据库（结构+数据）mysqldump -u root -p database_name &gt; sql_name.sql 导出单个数据库中的单张表，导出命令中加了一个表名（结构+数据）mysqldump -u root -p database_name table_name &gt; sql_name.sql 导出数据库的结构 （仅结构）mysqldump -u root -p --add-drop-table temp &gt; /Users/yannischeng/Desktop/outfile_name.sql 导出查询数据结果到指定文件 参考：http://blog.csdn.net/u011677147/article/details/64129606 在做mysql导出数据的时候，遇到的问题如下： ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement mysql 默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。解决方法： 查询mysql 的secure_file_priv配置，使用命令行： show global variables like &apos;%secure%&apos;; 查询结果 secure_file_prive=null -- 限制mysqld 不允许导入导出 secure_file_priv=/tmp/ -- 限制mysqld的导入导出只能发生在/tmp/目录下 secure_file_priv=&apos; &apos; -- 不对mysqld 的导入 导出做限制 更改secure_file_pri的值：/usr/local/mysql/support-files中的my-default.cnf配置文件，就把它复制到/private/etc中，重命名为“my.cnf”，并加入secure_file_priv=’’，重启mysql服务器即可。 使用 into outfile 开始导出： select * from table_name into outfile &apos;/Users/yannischeng/Desktop/NewFile.txt&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\n&apos;; 因为导出的数据会出现一些乱码或者特殊字符，所以使用以上关键字进行转义。 出现问题 ERROR 1 (HY000): Can&apos;t create/write to file &apos;/Users/yannischeng/Desktop/NewFile.txt&apos; (Errcode: 13 - Permission denied 表操作use 数据库名; 删除表drop table 表名; 删除表中数据delete from 表名,……，…… where 表达式; 显示当前数据库的表show tables; 显示表的数据结构describe 表名; 或者 desc 表名; 或者 show columns from 表名; 创建表mysql&gt; create table student( -&gt; id int(4) not null primary key auto_increment, -&gt; name char(20) not null, -&gt; age int(4) not null, -&gt; address char(100), -&gt; other varchar(100) default &quot;null&quot;); rename 修改表名alter table 旧表名 rename 新表名; 或者 rename table 原表名 新表名; 修改表结构：增（add）、删（drop）、改（modify）、重命名（change）可通过after 字段名、first精确控制添加的位置。 add 增加字段alter table 表名 add 字段名 字段设置 字段位置; modify 修改字段alter table 表名 modify 字段名 字段设置 字段位置; change 重命名字段alter table 表名 change 旧字段名 新字段名 字段设置; drop 删除字段alter table 表名 drop 字段名; 数据操作增单条数据 insert into student (,&apos;yannis&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;); 多条数据 insert into student values (13,&apos;tom&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;),(21,&apos;jack&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;); 指定字段插入数据 insert into 表名 (字段名) values (&apos;数值&apos;); 删delete from 表名 where 条件; 改update 表名 set name=&apos;marry&apos; where id=13; 查查询数据完整语法 select [distinct][统计函数] 字段名/* from 数据源 [where 条件子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]; distinct ：去重复 统计函数 ： Count()： 统计分组后的记录数，每一相同的组有多少行记录 Max()： 统计每组最大的值 Min()： 统计每组最小的值 Avg()： 统计每组的平均值 Sum()： 统计每组的和 where ：条件 group by 字段 ：分组。根据某个字段进行分组，相同的放一组，不同的分到不同的组。统计的是数据，不是记录。 having 子句 ：与where子句一样进行条件判断，为什么是group by……having…… 而不是group by……where? 因为：进行数据统计时，是数据进入内存之后，会进行分组 -&gt; 统计 -&gt; having条件判断。而where是针对从磁盘读取数据时进行判断，此刻还没分组，进行统计就判断了。所以错误！ order by 子句 ：order by根据某个字段进行升序或降序排序，基本语法： order by 字段名 [asc/desc]; asc升序 可不写 desc降序 limit 子句 ：是一种限制结果的语句。 1）用来限制数量 2) 限制起始位置 limit 起始位置，长度。分页常用。 内连接，外连接，自然连接，交叉连接 内连接：从左表中取出每一条记录，和右表中所有的记录进行匹配，匹配必须是左表中与右表中某个条件相同，最终会保留结果，否则不保留。基本语法： 左表 [inner] join 右表 on 左表.字段 = 右表.字段; select * from my_student inner join my_class on my_student.C_id = mu_class.id; 左外连接：左表为主，然后每条记录与右表进行连接，不管能不能匹配的上，左表都会保留。能匹配，右表某条记录保留，不能匹配，某条记录置为NULL，最终记录数至少不少于左表已有的记录。基本语法： 左表 left join 右表 on 左表.字段 = 右表.字段; 当前时间：select now(); 附录# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the &quot;--help&quot; option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 init_connect=&apos;SET NAMES utf8 port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect=&apos;SET NAMES utf8&apos; # Don&apos;t listen on a TCP/IP port at all. This can be a security enhancement, # if all processes that need to connect to mysqld run on the same host. # All interaction with mysqld must be made via Unix sockets or named pipes. # Note that using this option without enabling named pipes on Windows # (via the &quot;enable-named-pipe&quot; option) will render mysqld useless! # #skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master&apos;s port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST=&apos;125.564.12.1&apos;, MASTER_PORT=3306, # MASTER_USER=&apos;joe&apos;, MASTER_PASSWORD=&apos;secret&apos;; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables&apos; values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 16-安装爬虫工具Scrapy]]></title>
    <url>%2FPython3%20%2016-%E5%AE%89%E8%A3%85%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7Scrapy%2F</url>
    <content type="text"><![CDATA[python的学习在今天又开始了：人生苦短，我用python。安装Scrapy需要使用到：pip（python2）、pip3（python3），由于之前已经安装，此处忽略。 平台：Macpython2 pippython3 pip3 使用pip进行安装注意：安装过程还是比较曲折的 (〒︿〒) sudo pip install scrapy 错误 - 1 ： Found existing installation: six 1.4.1 DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project. Uninstalling six-1.4.1: ... OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-89wTP6-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info&apos; 根据网上得出的解决方案： 重启电脑，按住 option 键，–&gt; 再按 command + r 进入 Recovery模式 –&gt; 工具选择终端输入： csrutil disable 然后 reboot 再次执行 sudo pip install Scrapy 进行安装，结果依然出错。错误 - 2 ： Found existing installation: six 1.4.1 DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project. Uninstalling six-1.4.1: Successfully uninstalled six-1.4.1 Running setup.py install for PyDispatcher ... done Running setup.py install for Twisted ... done 注意： Running setup.py install for PyDispatcher ... done Running setup.py install for Twisted ... done 因为未安装 以上两个，导致 Scrapy未能安装成功。错误描述为： AttributeError: &apos;module&apos; object has no attribute &apos;OP_NO_TLSv1_1&apos; 安装 twisted $ pip install twisted==15.4.0 仍然报错 - 3 ： AttributeError: &apos;module&apos; object has no attribute &apos;OP_NO_TLSv1_1&apos; 更新pyOpenSSl sudo pip install --upgrade pyOpenSSl 最终出现： Successfully uninstalled pyOpenSSL-0.13.1 Successfully installed asn1crypto-0.23.0 cffi-1.11.2 cryptography-2.1.2 enum34-1.1.6 idna-2.6 ipaddress-1.0.18 pyOpenSSl-17.3.0 pycparser-2.18 然后输入： scrapy version 出现结果： Scrapy 1.4.0 安装成功！ 使用pip3进行安装 参考：http://www.jianshu.com/p/d00a19f6c4ed 提示：在使用 pip3 进行安装时，首先应该执行以下步骤： sudo -s pip3 install --ignore-installed six 否则报错： PermissionError: [Errno 13] Permission denied: &apos;/usr/local/Cellar/python3/3.6.1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/six.py&apos; 然后执行： sudo -s pip3 install scrapy 结果： Installing collected packages: cssselect, queuelib, w3lib, PyDispatcher, lxml, parsel, idna, pycparser, cffi, asn1crypto, cryptography, pyOpenSSL, pyasn1, attrs, pyasn1-modules, service-identity, hyperlink, incremental, zope.interface, Automat, constantly, Twisted, scrapy Successfully installed Automat-0.6.0 PyDispatcher-2.0.5 Twisted-17.9.0 asn1crypto-0.23.0 attrs-17.2.0 cffi-1.11.2 constantly-15.1.0 cryptography-2.1.2 cssselect-1.0.1 hyperlink-17.3.1 idna-2.6 incremental-17.5.0 lxml-4.1.0 parsel-1.2.0 pyOpenSSL-17.3.0 pyasn1-0.3.7 pyasn1-modules-0.1.5 pycparser-2.18 queuelib-1.4.2 scrapy-1.4.0 service-identity-17.0.0 w3lib-1.18.0 zope.interface-4.4.3 验证： YannisCheng:source yannischeng$ python3 Python 3.6.1 (default, Apr 4 2017, 09:40:21) [GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.38)] on darwin Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; import scrapy &gt;&gt;&gt; 安装成功]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 快捷键]]></title>
    <url>%2FAndroid-Studio%E4%BD%BF%E7%94%A8%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A52%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[键盘快捷键 快捷键参考：https://developer.android.google.cn/studio/intro/keyboard-shortcuts.htmlAndroid Studio使用指南：https://developer.android.google.cn/studio/projects/android-library.html 常规 说明 Windows/Linux Mac 全部保存 Control + S Command + S 同步 Control + Alt + Y Command + Option + Y 最大化/最小化编辑器 Control + Shift + F12 Control + Command + F12 添加到收藏夹 Alt + Shift + F Option + Shift + F 使用当前配置文件检查当前文件 Alt + Shift + I Option + Shift + I 快速切换模式 Control + （反引号） Control + `（反引号） 打开设置对话框 Control + Alt + S Command + ,（英文逗号） 打开项目结构对话框 Control + Alt + Shift + S Command + ;（英文分号） 在标签和工具窗口之间切换 Control + Tab Control + Tab 在 Studio 内导航和搜索 说明 Windows/Linux Mac 搜索全部内容（包括代码和菜单） 按两次 Shift 按两次 Shift 查找 Control + F Command + F 查找下一个 F3 Command + G 查找上一个 Shift + F3 Command + Shift + G 替换 Control + R Command + R 查找操作 Control + Shift + A Command + Shift + A 按符号名称搜索 Control + Alt + Shift + N Command + Option + O 查找类 Control + N Command + O 查找文件（而不是类） Control + Shift + N Command + Shift + O 在路径中查找 Control + Shift + F Command + Shift + F 打开文件结构弹出式菜单 Control + F12 Command + F12 在打开的编辑器标签之前导航 Alt + 向右/向左箭头 Control + 向右/向左箭头 跳到源代码 F4 / Control + Enter F4 / Command + 向下箭头 在新窗口中打开当前编辑器标签 Shift + F4 Shift + F4 最近打开的文件弹出式菜单 Control + E Command + E 最近编辑的文件弹出式菜单 Control + Shift + E Command + Shift + E 转到上一个编辑位置 Control + Shift + 退格键 Command + Shift + 退格键 关闭活动编辑器标签 Control + F4 Command + W 从工具窗口返回到编辑器窗口 Esc Esc 隐藏活动或上一个活动工具窗口 Shift + Esc Shift + Esc 转到行 Control + G Command + L 打开类型层次结构 Control + H Control + H 打开方法层次结构 Control + Shift + H Command + Shift + H 打开调用层次结构 Control + Alt + H Control + Option + H s 编写代码 说明 Windows/Linux Mac 生成代码（getter、setter、构造函数、hashCode/equals、toString、新文件、新类） Alt + Insert Command + N 替换方法 Control + O Control + O 实现方法 Control + I Control + I 控制语句 (if…else / try…catch / etc.) Control + Alt + T Command + Option + T 删除插入符处的行 Control + Y Command + 退格键 折叠/展开当前代码块 Control + 减号/加号 Command + 减号/加号 折叠/展开所有代码块 Control + Shift + 减号/加号 Command + Shift + 减号/加号 复制当前行或选择 Control + D Command + D 基本代码自动完成 Control + 空格键 Control + 空格键 智能代码自动完成（按预期类型过滤方法和变量列表） Control + Shift + 空格键 Control + Shift + 空格键 完成语句 Control + Shift + Enter Command + Shift + Enter 快速文档查找 Control + Q Control + J 显示选定方法的参数 Control + P Command + P 转到声明（直接） Control + B 或 Control + 点击 Command + B 或 Command + 点击 转到实现 Control + Alt + B Command + Alt + B 转到超类方法/超类 Control + U Command + U 打开快速定义查找 Control + Shift + I Command + Y 切换项目工具窗口的可见性 Alt + 1 Command + 1 切换书签 F11 F3 通过助记切换书签 Control + F11 Option + F3 通过行注释添加注释/取消注释 Control + / Command + / 通过块注释添加注释/取消注释 Control + Shift + / Command + Shift + / 选择连续增加的代码块 Control + W Option + Up 将当前选择退回到上一个状态 Control + Shift + W Option + Down 移动到代码块起始位置 Control + [ Option + Command + [ 移动到代码块结束位置 Control + ] Option + Command + ] 从当前位置选择到代码块起始位置 Control + Shift + [ Option + Command + Shift + [ 从当前位置选择到代码块结束位置 Control + Shift + ] Option + Command + Shift + ] 从当前位置删除到单词结尾 Control + Delete Option + Delete 从当前位置删除到单词开头 Control + 退格键 Option + 退格键 优化导入 Control + Alt + O Control + Option + O 项目快速修复（显示意图操作和快速修复） Alt + Enter Option + Enter 重新格式化代码 Control + Alt + L Command + Option + L 自动缩进行 Control + Alt + I Control + Option + I 缩进/取消缩进行 Tab/Shift + Tab Tab/Shift + Tab 智能行合并 Control + Shift + J Control + Shift + J 智能行拆分 Control + Enter Command + Enter 开始新行 Shift + Enter Shift + Enter 下一个/上一个突出显示的错误 F2 / Shift + F2 F2 / Shift + F2 构建并运行 说明 Windows/Linux Mac 构建 Control + F9 Command + F9 构建并运行 Shift + F10 Control + R 调试 说明 Windows/Linux Mac 调试 Shift + F9 Control + D 跳过 F8 F8 逐步执行 F7 F7 智能逐步执行 Shift + F7 Shift + F7 跳出 Shift + F8 Shift + F8 运行到光标位置 Alt + F9 Option + F9 评估表达式 Alt + F8 Option + F8 继续运行程序 F9 Command + Option + R 切换断点 Control + F8 Command + F8 查看断点 Control + Shift + F8 Command + Shift + F8 重构 说明 Windows/Linux Mac 复制 F5 F5 移动 F6 F6 安全删除 Alt + Delete Command + Delete 重命名 Shift + F6 Shift + F6 更改签名 Control + F6 Command + F6 内联 Control + Alt + N Command + Option + N 提取方法 Control + Alt + M Command + Option + M 提取变量 Control + Alt + V Command + Option + V 提取字段 Control + Alt + F Command + Option + F 提取常量 Control + Alt + C Command + Option + C 提取参数 Control + Alt + P Command + Option + P 版本控制/本地历史记录 说明 Windows/Linux MacOS 将项目提交到 VCS Control + K Command + K 从 VCS 更新项目 Control + T Command + T 查看最近变更 Alt + Shift + C Option + Shift + C 打开 VCS 弹出式菜单 Alt + `（反引号） Control + V]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android资源文件-color]]></title>
    <url>%2FAndroid%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6-color%2F</url>
    <content type="text"><![CDATA[官方参考：https://material.io/guidelines/style/color.html#color-color-palette 1234&lt;!-- 0 Black 黑色 --&gt;&lt;color name="Black"&gt;#000000&lt;/color&gt;&lt;!-- 0 White 白色 --&gt;&lt;color name="White"&gt;#FFFFFF&lt;/color&gt; 1234567891011&lt;!-- 1 Grey 灰色 --&gt;&lt;color name="Grey_50"&gt;#FAFAFA&lt;/color&gt;&lt;color name="Grey_100"&gt;#F5F5F5&lt;/color&gt;&lt;color name="Grey_200"&gt;#EEEEEE&lt;/color&gt;&lt;color name="Grey_300"&gt;#E0E0E0&lt;/color&gt;&lt;color name="Grey_400"&gt;#BDBDBD&lt;/color&gt;&lt;color name="Grey_500_bar"&gt;#9E9E9E&lt;/color&gt;&lt;color name="Grey_600"&gt;#757575&lt;/color&gt;&lt;color name="Grey_700"&gt;#616161&lt;/color&gt;&lt;color name="Grey_800"&gt;#424242&lt;/color&gt;&lt;color name="Grey_900"&gt;#212121&lt;/color&gt; 1234567891011&lt;!-- 2 Blue Grey 蓝灰色--&gt;&lt;color name="Blue_Grey_50"&gt;#FAFAFA&lt;/color&gt;&lt;color name="Blue_Grey_100"&gt;#CFD8DC&lt;/color&gt;&lt;color name="Blue_Grey_200"&gt;#B0BEC5&lt;/color&gt;&lt;color name="Blue_Grey_300"&gt;#90A4AE&lt;/color&gt;&lt;color name="Blue_Grey_400"&gt;#78909C&lt;/color&gt;&lt;color name="Blue_Grey_500_bar"&gt;#607D8B&lt;/color&gt;&lt;color name="Blue_Grey_600"&gt;#546E7A&lt;/color&gt;&lt;color name="Blue_Grey_700"&gt;#455A64&lt;/color&gt;&lt;color name="Blue_Grey_800"&gt;#37474F&lt;/color&gt;&lt;color name="Blue_Grey_900"&gt;#263238&lt;/color&gt; 123456789101112131415&lt;!-- 3 Red 红色--&gt;&lt;color name="r_50"&gt;#FFEBEE&lt;/color&gt;&lt;color name="r_100"&gt;#FFCDD2&lt;/color&gt;&lt;color name="r_200"&gt;#EF9A9A&lt;/color&gt;&lt;color name="r_300"&gt;#E57373&lt;/color&gt;&lt;color name="r_400"&gt;#EF5350&lt;/color&gt;&lt;color name="r_500_bar"&gt;#F44336&lt;/color&gt;&lt;color name="r_600"&gt;#E53935&lt;/color&gt;&lt;color name="r_700"&gt;#D32F2F&lt;/color&gt;&lt;color name="r_800"&gt;#C62828&lt;/color&gt;&lt;color name="r_900"&gt;#B71C1C&lt;/color&gt;&lt;color name="r_a100"&gt;#FF8A80&lt;/color&gt;&lt;color name="r_a200"&gt;#FF5252&lt;/color&gt;&lt;color name="r_a400"&gt;#FF1744&lt;/color&gt;&lt;color name="r_a700"&gt;#D50000&lt;/color&gt; 123456789101112131415&lt;!-- 4 Pink 粉色--&gt;&lt;color name="p_50"&gt;#FCE4EC&lt;/color&gt;&lt;color name="p_100"&gt;#F8BBD0&lt;/color&gt;&lt;color name="p_200"&gt;#F48FB1&lt;/color&gt;&lt;color name="p_300"&gt;#F06292&lt;/color&gt;&lt;color name="p_400"&gt;#EC407A&lt;/color&gt;&lt;color name="p_500_bar"&gt;#E91E63&lt;/color&gt;&lt;color name="p_600"&gt;#D81B60&lt;/color&gt;&lt;color name="p_700"&gt;#C2185B&lt;/color&gt;&lt;color name="p_800"&gt;#AD1457&lt;/color&gt;&lt;color name="p_900"&gt;#880E4F&lt;/color&gt;&lt;color name="p_a100"&gt;#FF80AB&lt;/color&gt;&lt;color name="p_a200"&gt;#FF4081&lt;/color&gt;&lt;color name="p_a400"&gt;#F50057&lt;/color&gt;&lt;color name="p_a700"&gt;#C51162&lt;/color&gt; 123456789101112131415&lt;!-- 5 Purple 紫色--&gt;&lt;color name="pur_50"&gt;#F3E5F5&lt;/color&gt;&lt;color name="pur_100"&gt;#E1BEE7&lt;/color&gt;&lt;color name="pur_200"&gt;#CE93D8&lt;/color&gt;&lt;color name="pur_300"&gt;#BA68C8&lt;/color&gt;&lt;color name="pur_400"&gt;#AB47BC&lt;/color&gt;&lt;color name="pur_500_bar"&gt;#9C27B0&lt;/color&gt;&lt;color name="pur_600"&gt;#8E24AA&lt;/color&gt;&lt;color name="pur_700"&gt;#7B1FA2&lt;/color&gt;&lt;color name="pur_800"&gt;#6A1B9A&lt;/color&gt;&lt;color name="pur_900"&gt;#4A148C&lt;/color&gt;&lt;color name="pur_a100"&gt;#EA80FC&lt;/color&gt;&lt;color name="pur_a200"&gt;#E040FB&lt;/color&gt;&lt;color name="pur_a400"&gt;#D500F9&lt;/color&gt;&lt;color name="pur_a700"&gt;#AA00FF&lt;/color&gt; 123456789101112131415&lt;!-- 6 Deep Purple 深紫色--&gt;&lt;color name="deep_pur_50"&gt;#EDE7F6&lt;/color&gt;&lt;color name="deep_pur_100"&gt;#D1C4E9&lt;/color&gt;&lt;color name="deep_pur_200"&gt;#B39DDB&lt;/color&gt;&lt;color name="deep_pur_300"&gt;#9575CD&lt;/color&gt;&lt;color name="deep_pur_400"&gt;#7E57C2&lt;/color&gt;&lt;color name="deep_pur_500_bar"&gt;#673AB7&lt;/color&gt;&lt;color name="deep_pur_600"&gt;#5E35B1&lt;/color&gt;&lt;color name="deep_pur_700"&gt;#512DA8&lt;/color&gt;&lt;color name="deep_pur_800"&gt;#4527A0&lt;/color&gt;&lt;color name="deep_pur_900"&gt;#311B92&lt;/color&gt;&lt;color name="deep_pur_a100"&gt;#B388FF&lt;/color&gt;&lt;color name="deep_pur_a200"&gt;#7C4DFF&lt;/color&gt;&lt;color name="deep_pur_a400"&gt;#651FFF&lt;/color&gt;&lt;color name="deep_pur_a700"&gt;#6200EA&lt;/color&gt; 123456789101112131415&lt;!-- 7 Indigo 靛蓝色 --&gt;&lt;color name="Indigo_50"&gt;#E8EAF6&lt;/color&gt;&lt;color name="Indigo_100"&gt;#C5CAE9&lt;/color&gt;&lt;color name="Indigo_200"&gt;#9FA8DA&lt;/color&gt;&lt;color name="Indigo_300"&gt;#7986CB&lt;/color&gt;&lt;color name="Indigo_400"&gt;#5C6BC0&lt;/color&gt;&lt;color name="Indigo_500_bar"&gt;#3F51B5&lt;/color&gt;&lt;color name="Indigo_600"&gt;#3949AB&lt;/color&gt;&lt;color name="Indigo_700"&gt;#303F9F&lt;/color&gt;&lt;color name="Indigo_800"&gt;#283593&lt;/color&gt;&lt;color name="Indigo_900"&gt;#1A237E&lt;/color&gt;&lt;color name="Indigo_a100"&gt;#8C9EFF&lt;/color&gt;&lt;color name="Indigo_a200"&gt;#536DFE&lt;/color&gt;&lt;color name="Indigo_a400"&gt;#3D5AFE&lt;/color&gt;&lt;color name="Indigo_a700"&gt;#304FFE&lt;/color&gt; 123456789101112131415&lt;!-- 8 Blue 蓝色 --&gt;&lt;color name="Blue_50"&gt;#E3F2FD&lt;/color&gt;&lt;color name="Blue_100"&gt;#BBDEFB&lt;/color&gt;&lt;color name="Blue_200"&gt;#90CAF9&lt;/color&gt;&lt;color name="Blue_300"&gt;#64B5F6&lt;/color&gt;&lt;color name="Blue_400"&gt;#42A5F5&lt;/color&gt;&lt;color name="Blue_500_bar"&gt;#2196F3&lt;/color&gt;&lt;color name="Blue_600"&gt;#1E88E5&lt;/color&gt;&lt;color name="Blue_700"&gt;#1976D2&lt;/color&gt;&lt;color name="Blue_800"&gt;#1565C0&lt;/color&gt;&lt;color name="Blue_900"&gt;#0D47A1&lt;/color&gt;&lt;color name="Blue_a100"&gt;#82B1FF&lt;/color&gt;&lt;color name="Blue_a200"&gt;#448AFF&lt;/color&gt;&lt;color name="Blue_a400"&gt;#2979FF&lt;/color&gt;&lt;color name="Blue_a700"&gt;#2962FF&lt;/color&gt; 123456789101112131415&lt;!-- 9 Light Blue 亮蓝色--&gt;&lt;color name="Light_Blue_50"&gt;#E1F5FE&lt;/color&gt;&lt;color name="Light_Blue_100"&gt;#B3E5FC&lt;/color&gt;&lt;color name="Light_Blue_200"&gt;#81D4FA&lt;/color&gt;&lt;color name="Light_Blue_300"&gt;#4FC3F7&lt;/color&gt;&lt;color name="Light_Blue_400"&gt;#29B6F6&lt;/color&gt;&lt;color name="Light_Blue_500_bar"&gt;#03A9F4&lt;/color&gt;&lt;color name="Light_Blue_600"&gt;#039BE5&lt;/color&gt;&lt;color name="Light_Blue_700"&gt;#0288D1&lt;/color&gt;&lt;color name="Light_Blue_800"&gt;#0277BD&lt;/color&gt;&lt;color name="Light_Blue_900"&gt;#01579B&lt;/color&gt;&lt;color name="Light_Blue_a100"&gt;#80D8FF&lt;/color&gt;&lt;color name="Light_Blue_a200"&gt;#40C4FF&lt;/color&gt;&lt;color name="Light_Blue_a400"&gt;#00B0FF&lt;/color&gt;&lt;color name="Light_Blue_a700"&gt;#0091EA&lt;/color&gt; 123456789101112131415&lt;!-- 10 Cyan 青色 --&gt;&lt;color name="Cyan_50"&gt;#E0F7FA&lt;/color&gt;&lt;color name="Cyan_100"&gt;#B2EBF2&lt;/color&gt;&lt;color name="Cyan_200"&gt;#80DEEA&lt;/color&gt;&lt;color name="Cyan_300"&gt;#4DD0E1&lt;/color&gt;&lt;color name="Cyan_400"&gt;#26C6DA&lt;/color&gt;&lt;color name="Cyan_500_bar"&gt;#00BCD4&lt;/color&gt;&lt;color name="Cyan_600"&gt;#00ACC1&lt;/color&gt;&lt;color name="Cyan_700"&gt;#0097A7&lt;/color&gt;&lt;color name="Cyan_800"&gt;#00838F&lt;/color&gt;&lt;color name="Cyan_900"&gt;#006064&lt;/color&gt;&lt;color name="Cyan_a100"&gt;#84FFFF&lt;/color&gt;&lt;color name="Cyan_a200"&gt;#18FFFF&lt;/color&gt;&lt;color name="Cyan_a400"&gt;#00E5FF&lt;/color&gt;&lt;color name="Cyan_a700"&gt;#00B8D4&lt;/color&gt; 123456789101112131415&lt;!-- 11 Teal 蓝绿色 --&gt;&lt;color name="Teal_50"&gt;#E0F2F1&lt;/color&gt;&lt;color name="Teal_100"&gt;#B2DFDB&lt;/color&gt;&lt;color name="Teal_200"&gt;#80CBC4&lt;/color&gt;&lt;color name="Teal_300"&gt;#4DB6AC&lt;/color&gt;&lt;color name="Teal_400"&gt;#26A69A&lt;/color&gt;&lt;color name="Teal_500_bar"&gt;#009688&lt;/color&gt;&lt;color name="Teal_600"&gt;#00897B&lt;/color&gt;&lt;color name="Teal_700"&gt;#00796B&lt;/color&gt;&lt;color name="Teal_800"&gt;#00695C&lt;/color&gt;&lt;color name="Teal_900"&gt;#004D40&lt;/color&gt;&lt;color name="Teal_a100"&gt;#A7FFEB&lt;/color&gt;&lt;color name="Teal_a200"&gt;#64FFDA&lt;/color&gt;&lt;color name="Teal_a400"&gt;#1DE9B6&lt;/color&gt;&lt;color name="Teal_a700"&gt;#00BFA5&lt;/color&gt; 123456789101112131415&lt;!-- 12 Green 绿色 --&gt;&lt;color name="Green_50"&gt;#E8F5E9&lt;/color&gt;&lt;color name="Green_100"&gt;#C8E6C9&lt;/color&gt;&lt;color name="Green_200"&gt;#A5D6A7&lt;/color&gt;&lt;color name="Green_300"&gt;#81C784&lt;/color&gt;&lt;color name="Green_400"&gt;#66BB6A&lt;/color&gt;&lt;color name="Green_500_bar"&gt;#4CAF50&lt;/color&gt;&lt;color name="Green_600"&gt;#43A047&lt;/color&gt;&lt;color name="Green_700"&gt;#388E3C&lt;/color&gt;&lt;color name="Green_800"&gt;#2E7D32&lt;/color&gt;&lt;color name="Green_900"&gt;#1B5E20&lt;/color&gt;&lt;color name="Green_a100"&gt;#B9F6CA&lt;/color&gt;&lt;color name="Green_a200"&gt;#69F0AE&lt;/color&gt;&lt;color name="Green_a400"&gt;#00E676&lt;/color&gt;&lt;color name="Green_a700"&gt;#00C853&lt;/color&gt; 123456789101112131415&lt;!-- 13 Light Green 亮绿色--&gt;&lt;color name="Light_Green_50"&gt;#F1F8E9&lt;/color&gt;&lt;color name="Light_Green_100"&gt;#DCEDC8&lt;/color&gt;&lt;color name="Light_Green_200"&gt;#C5E1A5&lt;/color&gt;&lt;color name="Light_Green_300"&gt;#AED581&lt;/color&gt;&lt;color name="Light_Green_400"&gt;#9CCC65&lt;/color&gt;&lt;color name="Light_Green_500_bar"&gt;#8BC34A&lt;/color&gt;&lt;color name="Light_Green_600"&gt;#7CB342&lt;/color&gt;&lt;color name="Light_Green_700"&gt;#689F38&lt;/color&gt;&lt;color name="Light_Green_800"&gt;#558B2F&lt;/color&gt;&lt;color name="Light_Green_900"&gt;#33691E&lt;/color&gt;&lt;color name="Light_Green_a100"&gt;#CCFF90&lt;/color&gt;&lt;color name="Light_Green_a200"&gt;#B2FF59&lt;/color&gt;&lt;color name="Light_Green_a400"&gt;#76FF03&lt;/color&gt;&lt;color name="Light_Green_a700"&gt;#64DD17&lt;/color&gt; 123456789101112131415&lt;!-- 14 Lime 酸橙汁饮料 --&gt;&lt;color name="Lime_50"&gt;#F9FBE7&lt;/color&gt;&lt;color name="Lime_100"&gt;#F0F4C3&lt;/color&gt;&lt;color name="Lime_200"&gt;#E6EE9C&lt;/color&gt;&lt;color name="Lime_300"&gt;#DCE775&lt;/color&gt;&lt;color name="Lime_400"&gt;#D4E157&lt;/color&gt;&lt;color name="Lime_500_bar"&gt;#CDDC39&lt;/color&gt;&lt;color name="Lime_600"&gt;#C0CA33&lt;/color&gt;&lt;color name="Lime_700"&gt;#AFB42B&lt;/color&gt;&lt;color name="Lime_800"&gt;#9E9D24&lt;/color&gt;&lt;color name="Lime_900"&gt;#827717&lt;/color&gt;&lt;color name="Lime_a100"&gt;#F4FF81&lt;/color&gt;&lt;color name="Lime_a200"&gt;#EEFF41&lt;/color&gt;&lt;color name="Lime_a400"&gt;#C6FF00&lt;/color&gt;&lt;color name="Lime_a700"&gt;#AEEA00&lt;/color&gt; 123456789101112131415 &lt;!-- 15 Yellow 黄色 --&gt;&lt;color name="Yellow_50"&gt;#FFFDE7&lt;/color&gt;&lt;color name="Yellow_100"&gt;#FFF9C4&lt;/color&gt;&lt;color name="Yellow_200"&gt;#FFF59D&lt;/color&gt;&lt;color name="Yellow_300"&gt;#FFF176&lt;/color&gt;&lt;color name="Yellow_400"&gt;#FFEE58&lt;/color&gt;&lt;color name="Yellow_500_bar"&gt;#FFEB3B&lt;/color&gt;&lt;color name="Yellow_600"&gt;#FDD835&lt;/color&gt;&lt;color name="Yellow_700"&gt;#FBC02D&lt;/color&gt;&lt;color name="Yellow_800"&gt;#F9A825&lt;/color&gt;&lt;color name="Yellow_900"&gt;#F57F17&lt;/color&gt;&lt;color name="Yellow_a100"&gt;#FFFF8D&lt;/color&gt;&lt;color name="Yellow_a200"&gt;#FFFF00&lt;/color&gt;&lt;color name="Yellow_a400"&gt;#FFEA00&lt;/color&gt;&lt;color name="Yellow_a700"&gt;#FFD600&lt;/color&gt; 123456789101112131415&lt;!-- 16 Amber 琥珀色--&gt;&lt;color name="Amber_50"&gt;#FFF8E1&lt;/color&gt;&lt;color name="Amber_100"&gt;#FFECB3&lt;/color&gt;&lt;color name="Amber_200"&gt;#FFE082&lt;/color&gt;&lt;color name="Amber_300"&gt;#FFD54F&lt;/color&gt;&lt;color name="Amber_400"&gt;#FFCA28&lt;/color&gt;&lt;color name="Amber500_bar"&gt;#FFC107&lt;/color&gt;&lt;color name="Amber_600"&gt;#FFB300&lt;/color&gt;&lt;color name="Amber_700"&gt;#FFA000&lt;/color&gt;&lt;color name="Amber_800"&gt;#FF8F00&lt;/color&gt;&lt;color name="Amber_900"&gt;#FF6F00&lt;/color&gt;&lt;color name="Amber_a100"&gt;#FFE57F&lt;/color&gt;&lt;color name="Amber_a200"&gt;#FFD740&lt;/color&gt;&lt;color name="Amber_a400"&gt;#FFC400&lt;/color&gt;&lt;color name="Amber_a700"&gt;#FFAB00&lt;/color&gt; 123456789101112131415&lt;!-- 17 Orange 橘黄色--&gt;&lt;color name="Orange_50"&gt;#FFF3E0&lt;/color&gt;&lt;color name="Orange_100"&gt;#FFE0B2&lt;/color&gt;&lt;color name="Orange_200"&gt;#FFCC80&lt;/color&gt;&lt;color name="Orange_300"&gt;#FFB74D&lt;/color&gt;&lt;color name="Orange_400"&gt;#FFA726&lt;/color&gt;&lt;color name="Orange_500_bar"&gt;#FF9800&lt;/color&gt;&lt;color name="Orange_600"&gt;#FB8C00&lt;/color&gt;&lt;color name="Orange_700"&gt;#F57C00&lt;/color&gt;&lt;color name="Orange_800"&gt;#EF6C00&lt;/color&gt;&lt;color name="Orange_900"&gt;#E65100&lt;/color&gt;&lt;color name="Orange_a100"&gt;#FFD180&lt;/color&gt;&lt;color name="Orange_a200"&gt;#FFAB40&lt;/color&gt;&lt;color name="Orange_a400"&gt;#FF9100&lt;/color&gt;&lt;color name="Orange_a700"&gt;#FF6D00&lt;/color&gt; 123456789101112131415&lt;!-- 18 Deep Orange 深橘黄色--&gt;&lt;color name="Deep_Orange_50"&gt;#FBE9E7&lt;/color&gt;&lt;color name="Deep_Orange_100"&gt;#FFCCBC&lt;/color&gt;&lt;color name="Deep_Orange_200"&gt;#FFAB91&lt;/color&gt;&lt;color name="Deep_Orange_300"&gt;#FF8A65&lt;/color&gt;&lt;color name="Deep_Orange_400"&gt;#FF7043&lt;/color&gt;&lt;color name="Deep_Orange_500_bar"&gt;#FF5722&lt;/color&gt;&lt;color name="Deep_Orange_600"&gt;#F4511E&lt;/color&gt;&lt;color name="Deep_Orange_700"&gt;#E64A19&lt;/color&gt;&lt;color name="Deep_Orange_800"&gt;#D84315&lt;/color&gt;&lt;color name="Deep_Orange_900"&gt;#BF360C&lt;/color&gt;&lt;color name="Deep_Orange_a100"&gt;#FF9E80&lt;/color&gt;&lt;color name="Deep_Orange_a200"&gt;#FF6E40&lt;/color&gt;&lt;color name="Deep_Orange_a400"&gt;#FF3D00&lt;/color&gt;&lt;color name="Deep_Orange_a700"&gt;#DD2C00&lt;/color&gt; 1234567891011&lt;!-- 19 Brown 棕色--&gt;&lt;color name="Brown_50"&gt;#EFEBE9&lt;/color&gt;&lt;color name="Brown_100"&gt;#D7CCC8&lt;/color&gt;&lt;color name="Brown_200"&gt;#BCAAA4&lt;/color&gt;&lt;color name="Brown_300"&gt;#A1887F&lt;/color&gt;&lt;color name="Brown_400"&gt;#8D6E63&lt;/color&gt;&lt;color name="Brown_500_bar"&gt;#795548&lt;/color&gt;&lt;color name="Brown_600"&gt;#6D4C41&lt;/color&gt;&lt;color name="Brown_700"&gt;#5D4037&lt;/color&gt;&lt;color name="Brown_800"&gt;#4E342E&lt;/color&gt;&lt;color name="Brown_900"&gt;#3E2723&lt;/color&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>资源文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Sutdio 使用快人一步]]></title>
    <url>%2FAndroid%20Studio%E4%BD%BF%E7%94%A8%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A51%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[今日感悟，写在前面： 放手无关紧要，精于攻坚克难。 Android Studio 3.0 - Android Profiler分析器 参考：http://blog.csdn.net/niubitianping/article/details/72617864Android Studio 3.0 新特性：http://blog.csdn.net/niubitianping/article/details/72600923 Android Studio 官方用户指南 https://developer.android.google.cn/studio/intro/index.html 使用频率最高的3个快捷键： ⌘ + n：各种自动生成。 （control）⌃ + t 各位看官自己瞧瞧： （shift）⇧ + （control）⌃ + （enter） ⏎ 补充快捷键 插件插件安装位置：Android Studio -&gt; Preferences -&gt; Plugins。快捷键：⌘ + ,敲出⌘：⌃ + ⌘ + space，之后进行选择 代码规范 - Alibaba Java Coding Guidelines阿里巴巴Java开发规约的插件。安装后在Android Studio显示为：可选择实时监测，也可以关闭检测。 真机无线调试 - Android WiFi ADB通过WIFI连接手机和电脑。数据线插入你的手机，然后点击Connect，显示State = Connect后拔掉数据线即可。 布局文件分组的插件 - folding-plugin图片来自网络 View注解绑定 - Android ButterKnife ZeleznyButterKnife是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。快捷键：⌘ + n使用时必须要将光标悬浮于 activity_main之上才能有效。 资源文件状态生成 - SelectorChapek for Android通过资源文件命名自动生成Selector文件。 控件的点击事件异常时 只是在Java代码中写明了方法，但是并没有在XML代码中使用onClick=&quot;&quot;来描述此方法 在Java代码中只是声明了方法，当时并没有在方法中声明参数：(View view)。如果不写此参数，将会导致在调用方法时，找不到View中的 指定id 值。 空指针异常： Android Studio2.3 参考：http://blog.csdn.net/blueamertj/article/details/51517191 在 app模块 的 gradle 编译文件 build.gradle 加入下列代码： apply plugin: &apos;com.neenbedankt.android-apt&apos; 在 app模块 的 gradle 编译文件 build.gradle 中的 dependencies中加入 apt &apos;com.jakewharton:butterknife-compiler:8.0.1&apos; compile &apos;com.jakewharton:butfe:8.0.1&apos; 在 项目 的 gradle 编译文件 build.gradle 文件，在 dependencies 中加入 classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; Android Studio3.0 参考：http://blog.csdn.net/pjingying/article/details/71975805?utm_source=itdadao&amp;utm_medium=referral 在 app模块 的 gradle 编译文件 build.gradle 中的 dependencies中加入 annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos; ViewHolder代码自动生成 - AndroidCodeGenerator在 res/layout/文件夹下选择你适配器的item layout的布局文件，然后右键，如图所示： 选择其中一项之后，会弹出一个窗口，在这个窗口已经根据item布局文件默认生成了一个适配器类，你所要做的就是根据自己的实际需求进行修改。 自动findViewById() - Prettify据Layout自动生成findViewById。使用方式同ButterKnife快捷键：⌘ + n 后选择 View Variables 或者 View Fields区别： 前者View Variables生成的是私有变量 后者 View Fields生成的是成员变量 自动生成style代码 - Android Styler快捷键：⇧ + ⌘ + d效果如图： 生命周期方法位置排序 - Lifecycle Sorter根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序。快捷键 ⌘ + ⌥ + K Json数据格式化 - GsonFormatGsonFormat是一个快速格式化json数据，自动生成实体类参数的插件。快捷键：⌘ + n 后选择 GsonFormat。 Parcelable自动生成 - ParcelableGenerator自动生成Parcelable接口所需的代码。 Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。 而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。 Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。 Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据。 快捷键：⌘ + n Android Material Design 风格图标全集 - Android Material Design Icon Generator通过此库可以获取MD风格的所有图标，更让人惊喜的是：选中的图标会自动生成各种 drawable 文件夹的图标，而且可以自定义颜色，绝对让人惊喜。快捷键：⌥ + ⌘ + m 选择指定图标以及自定义颜色。 组合指令自定义组指令快捷键：⌘ + , 后选择 Live TemPlates，如下所示： 单击上图中的+可以添加自定义的组合键选择其中的AndroidLog即可进行自定义设置： 已存在组合指令Log输出自定义 logt private static final String TAG = &quot;MainActivity &quot;; loge logi logd 循环 foreach for (: ) { } fori for (int i = 0; i &lt; ; i++) { } itar (array) for (int i = 0; i &lt; array.length; i++) { = array[i]; } iten (enum) while (enumeration.hasMoreElements()) { Object nextElement = enumeration.nextElement(); } itit (iterator) while (iterator.hasNext()) { Object next = iterator.next(); } itli (List) for (int i = 0; i &lt; list.size(); i++) { Object o = list.get(i); } 判定 ifn if (savedInstanceState == null) { } inn if (savedInstanceState != null) { } lazy if (savedInstanceState == null) { savedInstanceState = new Bundle(); } lnst if (savedInstanceState instanceof Object) { Object instanceState = (Object) savedInstanceState; } View相关 gone .setVisibility(View.GONE); visible Toast Toast.makeText(this, &quot;&quot;, Toast.LENGTH_SHORT).show(); fbc () findViewById(R.id.); fixme // FIXME: 2017/10/26 todo lhm lhw 全局 static final 变量 psf public static final psfi public static final int psfs St]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HHKB 键位组合]]></title>
    <url>%2FHHKB%20%E9%94%AE%E4%BD%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[Mac环境下的键位组合 键位组合 效果 键位组合 效果 Shift + Option + Q Œ Option + Q œ W „ W ∑ E ´ E R ‰ R ® T ˇ T † Y Á Y ¥ U ¨ U I ˆ I O Ø O ø P ∏ P π A Å A å D Î D ∂ F Ï F ƒ G ˝ G © H Ó H ˙ J Ô J ∆ K  K ˚ L Ò L ¬ Z ¸ Z Ω X ˛ X ≈ C Ç C ç V ◊ V √ B ı B ∫ N ˜ N M Â M µ 1 ⁄ 1 ¡ 2 € 2 ™ 3 ‹ 3 £ 4 › 4 ¢ 5 ﬁ 5 ∞ 6 ﬂ 6 § 7 ‡ 7 ¶ 8 ° 8 • 9 · 9 ª 0 ‚ 0 º - — - – = = = ≠ \ » \ « ` ` ` [ ” [ “ ] ’ ] ‘ ; Ú ; … ‘ Æ ‘ æ , ¯ , ≤ . ˘ . ≥ / ¿ / ÷÷]]></content>
      <categories>
        <category>外设</category>
      </categories>
      <tags>
        <tag>外设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境下Hexo-GitHub-MWeb搭建个人博客]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BHexo-GitHub-MWeb%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[需要的工具：Node.js、Git、Hexo、Coding（自选）、MWeb（自选） 安装Git非重点，自行安装 Node.js非重点，自行安装 Hexo按照此命令进行安装Hexo$ sudo npm install -g hexo 初始化Hexo其中Blog_Hexo为自己建立的目标文件夹。只要是建立自己的任意一个博客，都可使用一下步骤。 $ hexo init Blog_Hexo 在“blog”文件夹中安装npm $ npm install 执行一下命令，查看是否安装成功 $ hexo s 在浏览器中打开：http://localhost:4000 能看到“Hexo”页面表示安装成功： 关联GitHub登录你的Github帐号，新建仓库，名为：用户名.github.io ，此为固定写法。创建之后为： 创建的Hexo文件夹为： cd到Blog_Hexo文件夹下，编辑_config.yml。注意：_config.yml 文件中的 ：后面要加一个空格 1）若是只将博客上传至GItHub中，编写 deploy: type: git repository: https://github.com/gonghonglou/gonghonglou.github.io.git branch: master 2）若是将博客同时上传至GItHub和Coding中，编写： deploy: type: git repo: github: git@github.com:YannisCheng/YannisCheng.github.io.git,master coding: git@git.coding.net:yannischeng/blog.git,master 在Blog_Hexo文件夹目录下执行生成静态页面命令： $ hexo g 此时若出现如下报错： ERROR Local hexo not found in ~/blog ERROR Try runing: &apos;npm install hexo --save&apos; 则执行命令： npm install hexo --save 若无报错，自行忽略此步骤。再执行配置命令： $ hexo d 执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命： $ npm install hexo-deployer-git --save 若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即 Username for &apos;https:// .github.com&apos;: Password for &apos;https:// .github.com&apos;: hexo deploy命令执行成功后，浏览器中打开网址http:// .github.io 能看到和打开 http://localhost:4000 时一样的页面。 发布cd到Blog_Hexo中，执行如下命令新建文章 hexo new &quot;hello-world&quot; 新的文件建立之后的位置为 编辑之后，在 Blog_Hexo 文件夹中执行如下命令 hexo generate //生成静态页面 hexo deploy //将文章部署到Github 至此，安装环节结束，可以进行基本的使用了。 安装主题NexT主题在Blog_Hexo目录下执行： git clone https://github.com/iissnan/hexo-theme-next themes/next 安装之后的文件位置为： 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 theme: next 修改主题为主题增加标签：hexo new page tags 为主题修改背景：在 \themes\next\layout\_layout.swig文件的&lt;/body&gt;上面添加 &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/ca 具体详细设置参考：https://github.com/hustcc/canvas-nest.js/blob/master/README-zh.md 问题杂集主题相关hexo next5.0主题不显示副标题打开themes/next/source/css/_schemes/Mist/_logo.styl 你会看见.site-subtitle { display: none; }删去或改成你想要的即可 为主题 添加字数统计、阅读时长、友情链接开启设置NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件Blog\themes\next_config.yml中打开wordcount统计功能即可 # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true 若只是打开开关，部署之后会发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等字样。 参考：http://blog.csdn.net/wangxw725/article/details/71602256?utm_source=itdadao&amp;utm_medium=referral 找到Blog\themes\next\layout\_macro\post.swig 文件注意： 在此文中出现 字数统计的配置英文字样时会报错！ 安装统计插件如果没有安装 hexo-wordcount 插件，先安装该插件： npm i --save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： npm install hexo-wordcount@2 --save 安装完成后，重新执行启动服务预览就可以了。 Hexo相关添加分类、标签云、关于等页面以添加分类页面为例，在站点目录下，打开git bash，输入 hexo new page &quot;categories&quot; 之后在站点目录下的source文件夹下，会新增一个categories的文件夹，里面有一个index.md文件，打开如下 --- title: categories date: 2015-12-04 15:37:22 type: &quot;categories&quot; comments: false --- 其中，comments可以设置为false，含义是打开分类页面、评论插件不显示；如要显示则改为true。tags, about页面的创建类似，输入 hexo new page &quot;tags&quot; hexo new page &quot;about&quot; 标签的使用 + 文章模板--- title: Mac环境下Hexo-GitHub-MWeb搭建个人博客 date: 2017-10-22 23:48:37 tags: [Mac,博客] categories: 博客 --- hexo草稿模式 参考：http://blog.csdn.net/wizardforcel/article/details/40684575 草稿模式中的文件不会公开显示，适用于：有些文档非常重要但是又不想公开、又不想删除，此时使用hexo模式最合适。使用 hexo new draft &quot;Android热修复&quot; 执行此命令之后，会在相应目录下生成相关文件：~/HexoBLog/source/_drafts/Android热修复.md。图示： 强行预览草稿更爱配置文件： render _drafts: true 通过服务预览： hexo server --drafts 将草稿转变为正式文章： hexo publish [layout] &lt;filename&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《代码整洁之道 clean code》笔记 - 1]]></title>
    <url>%2F%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20clean%20code%E3%80%8B%E7%AC%94%E8%AE%B0%20-%201%2F</url>
    <content type="text"><![CDATA[第1章 整洁代码读此书有两种原因：1.你是个程序员 2.你想成为更好的程序员 基础价值谜题：开发期限压力的来源——混乱的代码。 谜题的答案就是：始终尽可能保持代码的整洁。 如何写出整洁的代码：遵循“小技巧” + “代码感” 编程的时间花费：读：写 = 10：1 通过读旧代码 -&gt; 写出新代码 修改代码的原则：“让营地比你来的时候更干净” —— 童子军军规 “整洁代码”的各种定义：（1）C++发明者：优雅+高效 代码逻辑直接了当，使得缺陷难以隐藏； 尽量减少依赖关系，使之便于维护； 依据某种分层战略完善错误处理代码； 性能调制最优，使得他人无法修改； 整洁的代码只做好一件事。 （2）《面向对象分析与设计》作者： 从不隐藏设计者的意图，干净利落的抽象+直截了当的控制语句 （3）Eclipse教父，OTI公司创始人： 小代码块，越小越好 —— “单一职能原则”； 便于他人进行增补和修改； 单元+验收测试； 有意义的命名，见字知意 —— “字面编程”； 只提供一种做一件事的途径+尽量减少依赖关系，明确的定义+提供清晰、尽量少的API （4）《修改代码的艺术》作者： 整洁的代码总是看起来像是某位特别在意他的人写的，几乎没有改进的余地。代码的作者什么都想到了，若是企图改进它，只能是回到原点。 （5）《极限编程实施》作者： 能通过所有测试； 没有重复代码； 体现系统中的全部设计理念； 包括尽量少的实体、比如：类、方法、函数等。 对象功能太多，就要将对象进行细分；方法功能太多，就要进行“方法抽取” （6）WiKi发明者，在意代码者的教父： 若每个代码块都能让你感到深合己意，那就是简洁的代码； 如果代码让编程语言看起来就像是专门为解决那个问题而存在的，那么就可以称之为漂亮的代码。 减少重复的代码 + 提高表达力 + 提早构建简单抽象]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>代码整洁之道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 15-I/O]]></title>
    <url>%2FPython3%20%2015-I%3AO%2F</url>
    <content type="text"><![CDATA[关于Open()源码文档打开文件并返回流。失败时提高IOError。 文件是一个文本或字节串，给出要打开的文件的名称（如果文件不在当前工作目录中的路径）或要包装的文件的整数文件描述符。 （如果给出了一个文件描述符，则当返回的I / O对象关闭时，它将被关闭，除非closefd设置为False。）mode是一个可选字符串，用于指定文件打开的方式。它默认为&apos;r&apos;，这意味着在文本模式下打开阅读。其他常见的值是“w”用于写入（截断文件已存在），“x”用于创建和写入新文件，“a”用于附加（在某些Unix系统上，这意味着所有写入都附加到无论当前查找位置如何，文件的结尾）。在文本模式下，如果未指定编码，则使用的编码与平台相关：调用locale.getpreferredencoding（False）以获取当前语言环境编码。 （用于读取和写入原始字节使用二进制模式并保留编码未指定。）可用的模式有： &apos;r&apos;开放阅读（默认） &apos;w&apos;打开写入，首先截断文件 &apos;x&apos;创建一个新文件并将其打开以进行写入 &apos;a&apos;开放写作，如果文件存在，则附加到文件末尾 &apos;b&apos;二进制模式 &apos;t&apos;文字模式（默认） &apos;+&apos;打开一个磁盘文件进行更新（读写） &apos;U&apos;通用换行模式（弃用） 默认模式为“rt”（打开阅读文本）。对于二进制随机访问，模式&apos;w + b&apos;打开并将文件截断为0字节，而&apos;r + b&apos;打开文件而不截断。如果文件已经存在，&apos;x&apos;模式意味着&apos;w&apos;并引发一个`FileExistsError`。 Python区分以二进制和文本模式打开的文件，即使底层操作系统没有。文件以二进制模式打开（将&apos;b&apos;追加到模式参数）返回内容作为字节对象而不进行任何解码。在文本模式（默认情况下，或在模式参数附加了&apos;t&apos;）时，文件的内容将返回为字符串，首先使用平台相关编码对字节进行了解码，如果给出，则使用指定的编码。 &apos;U&apos;模式已被弃用，并会在将来的Python版本中引发异常。它对Python 3没有影响。使用换行来控制通用换行符模式。缓冲是用于设置缓冲策略的可选整数。通过0以切换缓冲（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），整数&gt; 1表示固定大小的块缓冲区的大小。当没有给出缓冲参数时，默认缓冲策略的工作原理如下： *二进制文件以固定大小的块进行缓冲;使用启发式方法来选择缓冲区的大小，试图确定底层设备的“块大小”并落回到“io.DEFAULT_BUFFER_SIZE”上。在许多系统上，缓冲区通常为4096或8192字节长。 *“交互式”文本文件（其中isatty（）返回True的文件）使用行缓冲。其他文本文件使用上述针对二进制文件的策略。 encoding是用于对文件进行解码或编码的编码名称。这只能在文本模式下使用。默认编码是平台依赖的，但是Python可以支持任何编码。有关支持的编码列表，请参阅编解码器模块。 errors是一个可选的字符串，指定如何处理编码错误 - 此参数不应在二进制模式下使用。如果存在编码错误（默认值为None）具有相同的效果，则通过&apos;strict&apos;来引发ValueError异常，或者通过&apos;ignore&apos;忽略错误。 （请注意，忽略编码错误可能导致数据丢失。）有关编码错误字符串的列表，请参阅codecs.register的文档或运行&apos;help（codecs.Codec）&apos;。 换行符控制通用换行符的工作原理（仅适用于文本模式）。它可以是无，&apos;&apos;，&apos;\ n&apos;，&apos;\ r&apos;和&apos;\ r \ n&apos;。它的工作原理如下： *输入时，如果换行符为None，则启用通用换行符模式。输入中的行可以&apos;\ n&apos;，&apos;\ r&apos;或&apos;\ r \ n&apos;结尾，并将它们转换为&apos;\ n&apos;，然后返回给调用者。如果是&apos;&apos;，则启用通用换行模式，但是行结束将返回给未经翻译的调用者。如果它具有任何其他合法值，则输入行仅由给定终止 2017年07月21日09:44:52 暂停]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 14-调试]]></title>
    <url>%2FPython3%20%2014-%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[方法 .print()打印用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。 assert断言凡是用print()来辅助查看的地方，都可以用断言assert来替代。代码示例： 1234567def foo(s): n = int(s) assert n != 0, 'n is zero!' return 10 / ndef main(): foo('0') 在程序中使用assert和print()相比也好不到哪去。但是：启动Python解释器时可以用-O参数来关闭assert 1$ python3 -O err.py 关闭后，你可以把所有的assert语句当成pass来看。 logging日志把print()替换为logging是第3种方式，和assert比，logging不但会抛出错误，而且可以输出到文件。注意：导入logging包之后，应在添加配置语句logging.basicConfig(level=logging.INFO)代码示例 1234567891011121314151617181920212223242526272829303132333435363738import logging# logging.basicConfig(level=logging.INFO)# 配置日志信息logging.basicConfig(level=logging.DEBUG, format='%(asctime)-8s %(name)-8s %(levelname)-8s %(message)s - [%(filename)s:%(lineno)s]', datefmt='%Y-%m-%d %H:%M:%S', filename='myapp.log', filemode='w')# 定义一个Handler打印INFO及以上级别的日志到sys.stderrconsole = logging.StreamHandler()console.setLevel(logging.DEBUG)# 设置控制台日志打印格式formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')console.setFormatter(formatter)# 将定义好的console日志handler添加到root loggerlogging.getLogger('').addHandler(console)"""测试logging"""s = '0'n = int(s)logging.info('n = %d' % n)print(10 / n)'''结果输出INFO:root:n = 0Traceback (most recent call last): File "/Users/yannischeng/PycharmProjects/First_Python_Project/py_obj_end_12/TestObj.py", line 69, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero''''''输出到文件中的信息：2017-07-20 09:57:51 root INFO n = 0 - [LogSet.py:27]''' 优点 允许你指定记录信息的级别，有debug，info，warning，error等几个级别。 通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。 参考 logging的配置参考：http://blog.csdn.net/naiveloafer/article/details/7630903 Format编写 Format Description %(name)s Name of the logger (logging channel). %(levelno)s |Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).%(levelname)s |Text logging level for the message (‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’).%(pathname)s |Full pathname of the source file where the logging call was issued (if available).%(filename)s | Filename portion of pathname.%(module)s | Module (name portion of filename).%(funcName)s | Name of function containing the logging call.%(lineno)d | Source line number where the logging call was issued (if available).%(created)f | Time when the LogRecord was created (as returned by time.time()).%(relativeCreated)d | Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.%(asctime)s |Human-readable time when the LogRecord was created. By default this is of the form “2003-07-08 16:49:45,896” (the numbers after the comma are millisecond portion of the time).%(msecs)d | Millisecond portion of the time when the LogRecord was created.%(thread)d | Thread ID (if available).%(threadName)s | Thread name (if available).%(process)d | Process ID (if available).%(message)s | The logged message, computed as msg % args. basicConfig()编写 对日志记录系统进行基本配置： 如果根记录器已经具有处理程序，则此函数不起作用配置。这是一个方便的方法，供简单的脚本使用做一次性配置的日志记录包。 默认行为是创建一个写入的StreamHandler sys.stderr，使用BASIC_FORMAT格式字符串设置格式化程序，和将处理程序添加到根记录器。 可以指定一些可选的关键字参数，这可以改变默认行为。 Optional Keyword Description filename 指定使用指定的FileHandler进行创建文件名，而不是一个StreamHandler。 filemode | 指定打开文件的方式，如果指定了filename（如果filemode未指定，则默认为&apos;a&apos;）。 format | 为处理程序使用指定的格式字符串。 datefmt | 使用指定的日期/时间格式。 style | 如果指定了格式字符串，请使用此字符串指定格式字符串的类型（可能的值&apos;％&apos;，&apos;{&apos;，&apos;$&apos;，for ％-formatting，：meth：`str.format`和：class：`string.Template` - 默认为&apos;％&apos;）。 level | 将根记录器级别设置为指定级别。 stream | 使用指定的流来初始化StreamHandler。注意该参数与“filename”不兼容 - 如果同时使用存在，“流”被忽略。 handlers | 如果指定，这应该是已经创建的迭代处理程序，将被添加到根处理程序。任何处理程序在没有格式化程序分配的列表中分配在此函数中创建的格式化程序。 请注意： 可以指定使用open（filename，mode）创建的流而不是传递文件名和模式。但是应该记住StreamHandler并不关闭它的流（因为它可能使用sys.stdout或sys.stderr），而FileHandler关闭其流当处理程序关闭时。 .调试器pdb – 有了PyCharm目前不考虑此种方式启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 14-单元测试]]></title>
    <url>%2FPython3%20%2014-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[“测试驱动开发”（TDD：Test-Driven Development）– 单元测试 是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 在pycharm中创建单元测试 创建参考：http://blog.csdn.net/u013088062/article/details/50183789一个案例：http://www.cnblogs.com/iamjqy/p/7155315.html 具体创建过程参考python文件夹的.png图片。 选中待要编写测试代码的类名 –&gt; 右键 选择 Go To –&gt; Test Object 单元测试实现待测试类代码12345678910111213141516class MyDict(dict): def __init__(self, **kwargs): super().__init__(**kwargs) def __getattr__(self, item): try: return self[item] except KeyError: raise AttributeError(r"'MyDict' object has no attribute '%s'" % item) def __setattr__(self, key, value): self[key] = value def add(self, m, n): print("%d + %d = %d" % (m, n, (m+n))) 单元测试类代码123456789101112131415161718192021222324from unittest import TestCasefrom py_unittext_14.MyDict import MyDictclass TestMyDict(TestCase): # setUp与tearDown # 这两个方法会分别在每调用一个测试方法的前后分别被执行。 # setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码 def setUp(self): print('setUp...') def tearDown(self): print('tearDown...') def test_add(self): d = MyDict(name='程文佳', age='24', city='Tianjin') self.assertEqual(d.name, '程文佳') self.assertEqual(d['name'], '程文佳') print(d.name) def test_add2(self): d = MyDict(name='程文佳', age='24', city='Tianjin') d.add(3, 4) 测试结果1234567891011setUp...程文佳tearDown...setUp...3 + 4 = 7tearDown...Ran 2 tests in 0.002sOK 小结 单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。 单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。 单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。 单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 13-错误+测试+调试]]></title>
    <url>%2FPython3%20%2013-%E9%94%99%E8%AF%AF%2B%E6%B5%8B%E8%AF%95%2B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[错误12345678try: """ 可能出错的代码块 """except ZeroDivisionError as e: print('except:', e)finally: print('finally...') 错误特点 Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。 使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，即：不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。比如函数main()调用foo()，foo()调用bar()，结果bar()出错了。这时，只要main()捕获到了就可以处理bar()中的错误。 记录错误 捕获错误，把错误堆栈打印出来，分析错误原因，同时，让程序继续执行下去而不是使得程序被结束。 使用方法 12345678import logging# 同样是出错，但程序打印完错误信息后会继续执行，并正常退出.# 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。try: bar('0')except Exception as e: logging.exception(e) 抛出错误 因为错误是class。捕获一个错误就是捕获到该class的一个实例。 既可以使用python的内置函数抛出错误，也可以自己编写函数抛出错误。 使用关键字raise抛出一个错误实例 代码示例 1234567891011121314151617181920# 编写自定义异常类class FooError(ValueError): passdef foo(s): n = int(s) if n==0: raise FooError('invalid value: %s' % s) return 10 / n# 调用自定义的异常类foo('0')# 报的错误Traceback (most recent call last): File "err_throw.py", line 11, in &lt;module&gt; foo('0') File "err_throw.py", line 8, in foo raise FooError('invalid value: %s' % s)__main__.FooError: invalid value: 0]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 12-面向对象+元类]]></title>
    <url>%2FPython3%20%2012-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[静态语言和动态语言最大的不同，就是函数和类的定义。不是编译时定义的，而是运行时动态编译的。 关键字：type(), metaclass 一般的class创建123456789101112131415class Hello(object): def hello(self): print('Hello World !')from py_obj_end_12.Hello import Hello"""导入Hello类后的测试"""h = Hello()print(h.hello()) # Hello World !# 查看实例h所属的类型，是class Helloprint(type(h)) # &lt;class 'py_obj_end_12.Hello.Hello'&gt;# 查看Hello所属的类型，是 type 类型print(type(Hello)) # &lt;class 'type'&gt; 使用type()来动态创建类type 是什么？为什么 Hello 会是 type 类型的？ 因为Python是动态语言，所以class的定义是运行时动态创建的，而创建class使用的就是type()函数 type()函数既可以返回一个对象的类型，又可以创建出新的类型。 通过type()创建class和直接写class是完全一样的。 因为python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 正常情况下，我们使用class Xxx创建一个类。但是，因为type()函数允许我们动态的将类创建出来。 动态语言本身支持处于运行期的程序动态创建一个类。这和Java的静态语言不同。 type()使用：http://www.cnblogs.com/ccorz/p/6120783.html type(name, bases, dict) 返回一个新的type对象. 基本上是 class 语句的动态形式. 参数: name , 字符串, 制定要构造类的名字, 赋给新对象的 __name__ 属性; bases，一个tuple，指定新类型的所有基类，赋给新对象的__bases__ 属性; dict， 字典类型，作为新类的名字空间，赋给新对象的__dict__ 属性 12345678910111213141516171819# 用type()函数创建Hello类# 1.定义一个函数。即：类的方法def say(self): print('Hello, World 2!')# 2.创建一个class Hello2。type()函数中传入的参数：# 1）class类名，2）继承的父类集合，3）class的方法名与函数的绑定，此处即：将函数say()绑定至方法名hello上# 其实class定义一个类主要也是这3个主要组成部分：类名、继承类、方法# Hello2是一个以名为"Hello22"的类的引用。这个名为"Hello22"的类以object为基类,类中有一个say()函数Hello2 = type('Hello22', (object,), dict(say=say))# 3.为类绑定一个变量Hello2.name = 'cwj'# 测试h2 = Hello2()print(h2.say()) # Hello, World 2!print(h2.name) # cwj metaclass使用metaclass来控制类的创建行为]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 11-面向对象+枚举]]></title>
    <url>%2FPython3%20%2011-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[Python中Enum枚举的实现：http://www.cnblogs.com/codingmylife/archive/2013/05/31/3110656.html 定义常量的一般方法：定义变量推荐的方法为：将枚举类型定义一个class类型。每个常量都是class的唯一实例python提供了Enum来实现枚举功能 12345678910111213141516171819202122232425262728293031323334353637# 实现方式1from enum import EnumWeek = Enum('WeekInfo', ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'))# 实现方式2from enum import Enum, unique# @unique装饰器检查保证没有重复值@uniqueclass MyEnum02(Enum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sta = 6# 遍历Enumfor name, value in Week.__members__.items(): print(name, value, m.value)print(Week.Mon.value) # 1"""Mon WeekInfo.Mon 1Tue WeekInfo.Tue 2Wed WeekInfo.Wed 3Thu WeekInfo.Thu 4Fri WeekInfo.Fri 5Sat WeekInfo.Sat 6Sun WeekInfo.Sun 7"""# 使用MyEnum02print(MyEnum02(1)) # MyEnum02.Mon]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 10-面向对象+定制对象]]></title>
    <url>%2FPython3%20%2010-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E5%AE%9A%E5%88%B6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在编写一个基础类的基础上，为其重写某些魔法方法。 python其他内置魔法方法： https://docs.python.org/3/reference/datamodel.html#special-method-nameshttp://www.cnblogs.com/simayixin/archive/2011/05/04/2036295.htmlpython常用魔法方法的实现：http://www.cnblogs.com/scolia/p/5690210.html 魔法方法有：-1.__new__()：对象的创建，是一个静态方法，第一个参数是cls。(不可能是self，因为对象还没创建，哪来的self)—提示单例模式与此有关。0.__init__()：对象的初始化， 是一个实例方法，第一个参数是self。1.__slots__()：约束要绑定的临时变量2.__len__()：让类作用于len()3.__str__()：类似于java中的toString()，返回用户看到的字符串4.__repe__()：返回开发者看到的字符串5.__iter__()：将一个类被用于for...in循环中，返回一个迭代对象6.__getitem__()：像list那样按照下标取出元素，要在其中处理slice切片、step步长7.__getattr__()：当调用不存在的属性时，Python解释器会试图调用__getattr__(self, &#39;attr&#39;)来尝试获得属性。只有在没有找到属性的情况下，才调用__getattr__，已有的属性将不会在__getattr__中查找。而且，实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。8.__call__() __iter__() 配合 __next__()使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person(object): # 构造方法 def __init__(self, name): self._name = name self.a, self.sum = 1, 0 # 使本类可以迭代 def __iter__(self): return self # 具体的迭代方法，此方法的实现是关键 def __next__(self): self.sum = self.sum + self.a if self.sum &gt; 10: raise StopIteration return self.sum # 重写 toString()方法 def __str__(self): return 'Person name is ' + self._name __repr__ = __str__ '''测试'''person = Person("cwj")# 重写 __str__() 之后的效果print(Person("cwj")) # Person name is cwjprint(person) # Person name is cwjprint(isinstance(person, Iterator)) # Trueprint(isinstance(person, Iterable)) # Truel = []# 遍历Person序列，此时Person是一个Iteratorfor n in person: l.append(n) print(n)# 将一个类遍历后得到的结果赋值给l序列print(l) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'''12345678910''' __getitme__()配合__setitme__()使用12345678910111213141516171819class DictDemo(object): def __init__(self): self.dict = &#123;&#125; def __getitem__(self, item): if item in self.dict: return self.dict[item] else: return '不存在' def __setitem__(self, key, value): self.dict[key] = value '''测试'''dictD = DictDemo()dictD['1'] = 'cwj'dictD.__setitem__('1','234')print(dictD.__getitem__('1')) # 234print(dictD['2']) # 不存在 一个实现迭代、容器的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112'''Animal类 自定义魔法函数'''from pip._vendor.requests.packages.urllib3.connectionpool import xrange'''创建一个模拟字典的类，这个类的内部维护了两个列表，key 负责储存键，value 负责储存值，两个列表通过索引的一一对应，从而达到模拟字典的目的'''class Animal(object): def __init__(self, key, value): self.key = [] self.value = [] self.key.append(key) self.value.append(value) self.__index = 0 # __len__方法，按照协议，这个方法应该返回容器的长度 def __len__(self): return len(self.key) # __getitem__方法。这个方法会在a['scolia']时，调用a.__getitem__('scolia')。 # 也就是说这个方法定义了元素的获取. # 先找到 key 列表中建的索引，然后用索引去 value 列表中找对应的元素，然后将其返回 def __getitem__(self, item): if item in self.key: return self.value[self.key.index(item)] else: return '不存在' # __setitem__(self, key, value)方法定义了 a['scolia'] = 'good' 这种操作时的行为， # 此时将会调用a.__setitem__('scolia', 'good') 因为是绑定方法，所以self是自动传递的 def __setitem__(self, key, value): if key not in self.key: self.key.append(key) self.value.append(value) else: __index = self.key.index(key) self.value[__index] = value # __delitem__(self, key)方法定义了del a['scolia'] 这类操作时候的行为， # 里面的‘scolia’就作为参数传进去 def __delitem__(self, key): if key in self.key: __index = self.key.index(key) del self.key[__index] del self.value[__index] else: return "key值不存在" '''只有实现里以上四个方法，就可以当做可变容器来使用了。''' # __str__ 是对应于 str() 函数，在类的表示中会继续讨论，这里是为了 print 语句好看才加进去的， # 因为print语句默认就是调用str()函数 def __str__(self): l = [] for index in xrange(len(self.key)): __key = self.key[index] __value = self.value[index] result = __key,__value l.append(result) return str(l) # 实现一个__iter__方法，这个方法负责返回一个迭代器 def __iter__(self): return self # 内部实现了next（python3.x为__next__）方法，真正负责迭代的实现。 # 当迭代器内的元素用尽之后，任何的进一步调用都之后触发 StopIteration 异常 # 一般会在一个类里同时实现这两种方法（即是可迭代对象又是迭代器），此时__iter__方法只要返回self就足够的了 def __next__(self): if self.__index == len(self.key): self.__index = 0 raise StopIteration() else: __key = self.key[self.__index] __value = self.value[self.__index] result = __key, __value self.__index += 1 return result # __contains__实现了成员判断，这里我们更关心value列表中的数据，所以判断的是value列表。 # 该方法要求返回布尔值。 def __contains__(self, item): if item in self.value: return True else: return False # __reversed__(self)方法返回一个倒序后的副本，这里体现了有序性 def __reversed__(self): __result = self.value __result.reverse() return __result'''实际测试'''m = Animal('1', 'cwj')print(m) # [('1', 'cwj')]print(m.__len__()) # 1m['2'] = 'ddd'm['3'] = 'qwe'm['2'] = 'lkj'print(m) # [('1', 'cwj'), ('2', 'lkj'), ('3', 'qwe')]print(m.__len__()) # 3del m['3']print(m) # [('1', 'cwj'), ('2', 'lkj')]print(m.__len__()) # 2print(reversed(m)) # ['lkj', 'cwj']print('cwj' in m) # True 类的切片操作 参考：http://www.cnblogs.com/scolia/p/5690210.html 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Slices(object): def __init__(self, x): self._x = x self._index = -1 ''' # __getitem__()实现支持for循环 def __getitem__(self, item): if isinstance(self._x, list): self._index += 1 return self._x[self._index] else: raise '参数类型错误' ''' def __getitem__(self, item): # print(item.start, item.stop, item.step) # 1 2 1 # return item # slice(1, 2, 1) if isinstance(item, slice): return self._x[item.start:item.stop:item.step]'''测试Slices类''''''s = Slices([1, 2, 3, 4])for n in s: print(n)'''1234'''s2 = Slices('1234')for n in s2: print(n)'''s3 = Slices([1, 2, 3, 4, 5])# 当直接返回item参数时的结果# print(s3[1:4:1]) # slice(1, 2, 1)print(s3[1:4:1]) # [2, 3, 4]print(s3[-4:-2]) # [2, 3]print(s3[-3:-1]) # [3, 4]print(s3[-5:]) # [1, 2, 3, 4, 5]print(s3[:]) # [1, 2, 3, 4, 5]print(s3[-1::-1]) # [5, 4, 3, 2, 1]print(s3[-1:]) # [5]``` ## `__getattr__()`正常情况下，当我们调用类的`方法`或`属性`时，如果不存在，就会报错。如：```pythonAttributeError: 'Student' object has no attribute 'score' 要避免这个错误，Python有一个机制：写一个__getattr__()方法，动态返回一个属性。当调用不存在的属性时，比如color，Python解释器会试图调用__getattr__(self, &#39;color&#39;)来尝试获得属性，这样我们就有机会返回color的值 123456789101112131415# 返回不存在的属性与函数# 作用：可以针对完全动态的情况作调用def __getattr__(self, item): # 返回未定义的属性 if item == 'color': return '您真是 666 啊 ~ 这个属性都鞥猜到' elif item == 'address': return '哈哈哈' # 返回未定义的函数 elif item == 'add': return lambda: 100 else: # 注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None # 要让class只响应特定的几个属性,要按照约定，抛出AttributeError错误 raise AttributeError('\'Student\' object has no attribute \'%s\'' % item) __call__()与__getattr__()组合实现URL中的链式(chain)调用在python中，函数其实是一个对象。如： 12345&gt;&gt;&gt; f = abs&gt;&gt;&gt; f.__name__'abs'&gt;&gt;&gt; f(-123)123 由于 f 可以被调用，所以，f 被称为可调用对象。所有的函数都是可调用对象。一个类的实例对象想要变成一个可调用的对象，只需要实现一个魔法方法__call__()。 可调用对象与一般对象 可调用对象：obj.name(‘source’).age。即：既可以使用.调用属性或方法，也可以使用obj()以一种函数样式使用此对象。此时调用obj(arg1,arg2,....)就等价于obj.__call__(self,arg1,arg2,...) 一般对象：obj.name。即：只能使用.调用属性或方法。 因为__call__()魔法方法的加入，因此python的函数与对象之间的概念被模糊了 URL中的链式调用，这样无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变，代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344'''URLChain类'''class URLChain(object): def __init__(self, path = ''): self.__path = path def __getattr__(self, item): # 实现参考：https://zhidao.baidu.com/question/1865282935722979707.html # 返回一个 URLChain 对象，这个时候里面的path就是''+'/'+'api'='/api'，此时self = /api print('\'self.__path is\' :' + self.__path + ' , \'item is\' : ' + item + ' ， 之前self为：', self) # 即：上一个 '%s/%s' 的数值代替：构造函数中 path = ''中 '' 的具体数值，相当于重新构造了一个对象， # 在即将的调用的返回值中表示参数self.__path的值, 新传入的参数赋值给item return URLChain('%s/%s' % (self.__path, item)) def __str__(self): return self.__path __repr__ = __str__ # 将此类的实例对象变成一个可调用的对象 def __call__(self, path): print('__call__ 之前self is : ', self) print('__call__ path is : ' + path) return URLChain('%s/%s' % (self.__path, path))'''调用URLChian类'''chain = URLChain()print(chain.api.server.user.friends)''''self.__path is' : , 'item is' : api ， 之前self为： 'self.__path is' :/api , 'item is' : server ， 之前self为： /api'self.__path is' :/api/server , 'item is' : user ， 之前self为： /api/server'self.__path is' :/api/server/user , 'item is' : friends ， 之前self为： /api/server/user/api/server/user/friends'''# 当执行 ('cwj') 这一个参数时调用的是 URLChian的 __call__()print(chain.api.server('cwj').friends)''''self.__path is' : , 'item is' : api ， 之前self为： 'self.__path is' :/api , 'item is' : server ， 之前self为： /api__call__ 之前self is : /api/server__call__ path is : cwj'self.__path is' :/api/server/cwj , 'item is' : friends ， 之前self为： /api/server/cwj/api/server/cwj/friends''' callable()的使用：判断一个变量是函数还是对象代码示例 1234# 判断一个对象是否能被调用，能被调用的对象就是一个Callable对象,函数和自定义的带有__call__()的类实例对象返回值是True：print(callable(chain)) # True URLChian实现了__call__()魔法方法print(callable(dictD)) # Falseprint(callable(abs)) # True]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 09-面向对象]]></title>
    <url>%2FPython3%20%2009-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类的模板123456789101112131415161718192021222324252627'''类模板'''class Student(object): def __init__(self, name, age, city): self.name = name self.age = age self.__city = city def print_info(self): print('self is : ', self) # self is : &lt;py_class.Student.Student object at 0x10c92c400&gt; # print(student) 得到的结果为：&lt;py_class.Student.Student object at 0x10c92c400&gt; print('class is : ', self.__class__) # class is : &lt;class 'py_class.Student.Student'&gt; print('%s, %d, %s' % (self.name, self.age, self.__city)) def get_age(self): if self.age == 20: print('age is ', self.age) elif self.age &gt; 20: print('too old') else: print('too young') def get_city(self): return self.__city def set_city(self, city): self.__city = city 属性 1.类属性：像是Student类中的name就是类属性 2.实例属性：像是下文中的student.__city就是实例属性 类中变量及函数的命名规范 以__开始，并以__ 双下划线 结束的是python中的特殊变量，特殊变量是可以直接访问的，不是private变量 class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的.通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类 __init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去 在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。 self指向的类的实力对象。由： 12print('self is : ', self) # self is : &lt;py_class.Student.Student object at 0x10c92c400&gt;print(student) # &lt;py_class.Student.Student object at 0x10c92c400&gt; 可以看出，self和student的 内存地址 是一样的。代码示例 123456789'''调用'''# 创建实例对象student = Student('cwj',24, 'tianjin')student.print_info() # cwj, 24, tianjinstudent.get_age() # too old# 访问属性student.age = 19student.name = 'ddd' 访问限制虽然有访问限制的命名方式，但是Python本身没有任何机制阻止你干坏事，一切全靠自觉。 两个下划线开头的变量，声明为类内部的私有变量，不能在类的外部直接使用或访问：在变量前面添加__，即：__name。在类内部的方法中使用时 self.__private_attrs。 两个下划线开头的方法，声明为类内部的私有方法。不能在类地外部调用，在类的内部调用 self.__private_methods. 单下划线开头表示的protected类型的变量，只允许本身及其子类进行访问。 类的方法在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数代码示例: 123456789101112131415161718192021 # 此行代码貌似修改了 Student 类中的 __city 属性,实际这是为student添加了一个属性。 student.__city = 'beijing' # 而且输出结果也显示；__city 属性 的值也变成了：beijing print(student.__city) # beijing # 但是，当我们通过类自身的get()获取属性值时，发现还是之前初始化时的属性值。即：tianjin print(student.get_city()) # tianjin print(hasattr(student, 'name')) # True # 删除临时添加的 __city 属性 # del student.__city# print(student.__city) # AttributeError: 'Student' object has no attribute '__city' # 当我们通过类自身的set()方法修改 __city 属性值时，通过get()得到的属性值是修改之后的。 student.set_city('hk') print(student.get_city()) # hk # 由此可以得出：此时的 student.__city 与 student.set_city() 中的 __city 并不是同一个属性 # student.__city 中的 __city 是student的一个新的同名属性 student.print_info() # ddd, 19, hk Python内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串，即：注释 __name__: 类名 __module__: 类定义所在的模块（类的全名是__main__.className，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 代码示例 123456789101112131415# 由 类 进行调用 __dict__print(Student.__dict__) # &#123;'__module__': 'py_class.Student', '__init__': &lt;function Student.__init__ at 0x100ccf8c8&gt;, 'print_info': &lt;function Student.print_info at 0x100ccf950&gt;, 'get_age': &lt;function Student.get_age at 0x100ccf9d8&gt;, 'get_city': &lt;function Student.get_city at 0x100ccfa60&gt;, 'set_city': &lt;function Student.set_city at 0x100ccfae8&gt;, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None&#125;# 由 对象 调用 __dict__ 方法类似于：java中的toString()print(student.__dict__) # &#123;'name': 'ddd', 'age': 19, '_Student__city': 'hk', '__city': 'beijing'&#125;print(student.__doc__) # None# 由 类 进行调用print(Student.__name__) # Studentprint(student.__module__) # py_class.Student# 由 类 进行调用print(Student.__bases__) # (&lt;class 'object'&gt;,) python对象的销毁垃圾回收 —— 引用计数 + 循环引用 引用计数法。当跟踪变量对象的引用计数变为0时，它将会被回收。但不是立即被回收，而是由‘解释器’在适当的时机将其回收。 循环引用。当两个对象相互引用，但是没有其他的变量引用他们。此时循环垃圾回收器将会工作。 代码示例 1del student.__city 继承支持多继承父类的构造器（__init__(self)）不会被自动调用，需要在子类中亲自专门调用python总是先在本类中查找调用的方法，找不到才会去父类中继续寻找 几个基础的重载方法 1.__init__(self,[]) 构造方法 2.__del__(self) 删除一个对象，dell obj 3.__repr__(self) 转化为供解释器读取的形式 4.__str__(self) 将值转化为始于人阅读的形式 5.__cmp__(self,x) 对象比较 代码示例 父类 123456789101112131415161718192021222324252627'''父类 1 ''' class Animal(object): def __init__(self, name, age): self.__name = name self.__age = age def get_name(self): return self.__name def get_age(self): return self.__age def set_name(self, name): self.__name = name def set_age(self, age): self.__age = age def run(self): print('Animal is running') '''父类 2''' class Pet(object): def play(self): print(self.__name + " is very good !") 子类 1234567891011121314151617181920212223242526272829303132333435363738from py_class.Animal import Animalfrom py_class.Pet import Pet# 多继承class Pig(Animal, Pet): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print('pig is running very slowly...')from py_class.Animal import Animal# 单继承class Dog(Animal): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print(self.__name + ' is running')from py_class.Animal import Animal# 单继承class Cat(Animal): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print(self.__name + 'is running') 测试类 123456789101112131415161718from py_class.Animal import Animalfrom py_class.Dog import Dogfrom py_class.Cat import Catfrom py_class.PIg import Pigdog = Dog('wangwang', 1)dog.run()cat = Cat('miaomiao', 1)cat.run()pig = Pig('big pig', 100)pig.run() # pig is running very slowly...# pig.play() # big pig is very good !print(isinstance(cat, Animal)) # Trueprint(isinstance(cat, Cat)) # True'''由此可见，cat变量既是Cat类型，也是Animal类型''' 多态代码示例 1234567891011121314151617181920212223242526''' 多态的实现方式 1 类似于java这种静态语言的实现，必须传入Animal类型或其子类 # 多态的使用 将 父类 作为参数def run_test(animal): animal.run()'''''' 多态的实现方式 2 属于python的动态语言实现' 这种方式实现的结果与 方式 1 完全一样 原理： 不一定要传入Animal类型，只要保证传入的对象一个run()方法就可以了. 例如：传递的对象为ints，这不是Animal的任何一个子类，只要将赋予run()方法就足以。 动态语言的'鸭子类型'： 它并不要求严格的继承体系，一个对象只要"看起来像鸭子，走起路来像鸭子"，那么它就是鸭子。'''def run_test(ints): ints.run()# 多态的使用 实际参数为具体的子类，得到的结果为各个子类的具体表现run_test(Animal('Animal', 1)) # Animal is runningrun_test(Dog('Dog', 1)) # Dog is runningrun_test(Cat('Cat', 1)) # Catis runningrun_test(Pig('Cat', 1)) # pig is running very slowly... 获取对象信息 getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 12345678910111213141516171819202122232425262728'''isinstance() 查看一个变量的继承关系'''print(isinstance(cat, Animal)) # Trueprint(isinstance(cat, Cat)) # Trueprint(isinstance(pig, Animal)) # Trueprint(isinstance(pig, Pet)) # Trueprint(isinstance(pig, Pig)) # True''' type() 当使用继承关系时，使用type()不能一直向上得到他们的父类， 因此，对于有 继承关系 的类来说不合适'''print(type(123)) # &lt;class 'int'&gt;print(type(dog)) # &lt;class 'py_class.Dog.Dog'&gt;def compare(obj1, obj2): if type(obj1) == type(obj2): print(type(obj1) == type(obj2)) print(str(obj1) + '==' + str(obj2)) else: print(type(obj1) == type(obj2)) # False print(str(obj1) + '!=' + str(obj2))compare(dog, cat)'''获取一个对象所有的属性和方法'''print(dir(dog))# ['_Dog__age', '_Dog__name', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'get_age', 'get_name', 'run', 'set_age', 'set_name']]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 09-面向对象+临时变量、方法+@property+多继承]]></title>
    <url>%2FPython3%20%2009-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%2B%40property%2B%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[绑定临时变量和临时函数 – 不限定参数使用python语言`动态语言`这一特性。 绑定临时变量 为实例对象绑定临时变量 123456# 动态的将 new_name 属性绑定至 实例 中dog.new_name = 'new cwj'print(dog.new_name) # new cwj# 删除临时添加的 new_name 属性del dog.new_name 为类绑定临时变量 123456789# 动态的将 new_name_2 属性绑定至 Dog类 中Dog.new_name_2 = 'new cwj 2'print(dog.new_name_2) # new cwj 2dog2 = Dog('wangwang', 1)print(dog2.new_name_2) # new cwj 2'''可以看到 dog 与 dog2 两个实例都具有 new_name_2 属性，由此可见 new_name_2 属性已经动态的添加至Dog类中''' 绑定临时函数 为实例对象绑定临时函数 12345678910111213141516171819202122232425from types import MethodTypedef set_color(self, color): self.color = color# 给实例绑定一个方法dog.set_color = MethodType(set_color, dog)# 通过这个方法为临时的color赋值dog.set_color('red')# set_color()这个方法是临时赋给dog变量的，而不是赋给dog2的# dog2.set_color('green') # AttributeError: 'Dog' object has no attribute 'set_color'# 输出临时参数color的值print(dog.color) # red# 删除临时方法，删除此方法的同时，也删除了此方法内的历史变量del dog.set_color# 删除临时参数# del dog.color# 当删除临时方法后，此方法将不再能使用# dog.set_color('green') # AttributeError: 'Dog' object has no attribute 'set_color' 为类绑定临时函数 1234567891011121314151617# 定义一个临时的方法def set_color2(self, color): self.color = color# 将临时定义的方法绑定给 Dog这个类Dog.set_color2 = set_color2# Dog类的两个变量dog和dog2分别调用set_color2()dog.set_color2('blue')dog2.set_color2('black')# 测试临时函数是否对临时变量赋值成功print(dog2.color) # blackprint(dog.color) # blue# 删除临时的方法del Dog.set_color2 绑定临时变量和临时函数 – 限定参数 __slots__变量`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的. 除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__` 代码示例 12345678910111213141516171819202122'''声明Pet类'''class Pet(object): ''' 使用一个特殊的变量 __slots__，这个变量可以限制外部为Pet类添加的属性。 例如此处，只允许外部为Pet类添加 name 和 age 两个属性 ''' __slots__ = ('name2', 'age')'''调用Pet类'''pet = Pet()pet.name2 = 'big pig'pet.age = 2# 通过 __slots__ 变量的声明，color不允许被定义# pet.color = 'yellow' # AttributeError: 'Pet' object has no attribute 'color'# print(Pet.__doc__) # 输出注释print(pet.name2) # big pigprint(pet.age) # 2# pig 实例对象不能调用临时变量 name2，因为 __slots__变量定义的参数名称之能限定在它所在的类中，对子类不起作用# print(pig.name2) # AttributeError: name2 @property的使用既能检查参数，又可以`用类似属性`这样简单的方式来`访问类的变量` 实现 关键字：@property,@参数名.setter 代码示例 - Pet类 12345678910111213141516171819'''Pet类'''class Pet(object): def play(self): print(self.__name + " is very good !") '''@property的使用''' # 此处的 color 为 此类对外界声明的一个变量，即：是一个变量名 # 此方法相当于 get_color() @property def color(self): return self._color # 此方法相当于 set_color(self, color) @color.setter def color(self, color): if not isinstance(color, str): raise ValueError('input a str') self._color = color 代码示例 - 调用 123456# 错误的写法，验证对于参数的检验# pet.color = 123 # ValueError: input a strpet2 = Pet()# 为Pet类的color属性设置具体的参数pet2.color = 'grew'print(pet2.color) # grew 多继承在设计类的继承关系时，通常，主线都是单一继承下来的，如果需要“混入”额外的功能，通过多重继承就可以实现，一个类在继承了一个类的基础上，再次继承另一个类。这种设计通常称之为`MixIn`。 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 如： 12class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 08-模块]]></title>
    <url>%2FPython3%20%2008-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Python所有的内置函数：https://docs.python.org/3/library/functions.html 定义在`python`中一个`.py`文件就是一个模块(Module) 优点 提高代码的可维护性 代码的复用性 避免函数名和变量名的冲突 为避免模块名命名冲突，引入了包(每一个包目录下都有一个文件：__init__.py。这个文件是必须存在的，否则python回将这个目录当成普通的目录，而不是一个python包。这个文件可以是空文件，也可以有代码。因为__init__.py本身就是一个模块(mycompany)) 模板1234567891011121314151617#!/usr/bin/env python3# _*_ coding:utf-8 _*_# 当前模块的文档注释，任何模块代码的第一行字符串都视为该模块文档的注释'A test module'# 使用'__author__'变量将作者的名字写入此模块__author__ = 'Yannis Cheng''''以上为python模块的标准文件模板''''''注意到这两行代码：'''if __name__=='__main__': test()'''当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。''' 安装第三方模块在Python中，安装第三方模块，是通过包管理工具`pip`完成的。 在Mac或者Linux下可能会并存`Python 3.X`和`Python 2.X`，此时的命令应该为`pip3` 函数&amp;变量 作用域 公开public：可以被直接引用，如’abs‘等。类似__name__这样的变量是特殊变量可以被直接引用。自己定义的变量一般不使用这种变量名。 非公开：_abc，__aabc python中并没有一种方法可以完全限制访问private函数访问，但是从编程习惯中不应该引用private函数或变量]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 06-闭包+匿名+装饰器+偏函数]]></title>
    <url>%2FPython3%20%2006-%E9%97%AD%E5%8C%85%2B%E5%8C%BF%E5%90%8D%2B%E8%A3%85%E9%A5%B0%E5%99%A8%2B%E5%81%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[参考：http://www.cnblogs.com/vamei/archive/2012/12/15/2772451.html 闭包闭包是函数式编程的重要语法结构，python是以`函数对象`为基础的，python一切皆对象。函数这一语法结构也是一个对象。 定义解释 在一个内部函数里，对在外部作用域的（非全局）变量进行引用，那么内部函数就认为是闭包closure ‘闭包’是‘词法闭包’的简称，是指应用了自由变量的函数。这个被引用的自由变量的将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 ‘闭包’是由函数和其他相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 ‘python’中的闭包：一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。而这个函数B就叫做闭包，在调用函数A时传递的参数就是自由变量。 闭包实际上就是一个简化的类，它提高了代码的复用性 闭包函数代码示例 123456789101112'''闭包示例代码inner_func就是一个闭包函数，它引用自由变量name。name就是inner_func()的环境变量'''def func01(name): def inner_func(age): print('name: ', name, 'age: ', age) return inner_funcbb = func01('cwj')bb(25) # name: cwj age: 25 关于闭包函数的使用问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152'''错误的闭包函数 1 闭包函数中， 闭包中的变量m不会修改外部函数中m的值。'''def foo(): m = 0 def fool(): m = 11 print(m) print(m) # 0 fool() # 11 print(m) # 0print(foo())'''错误的闭包函数 2 '''def foo2(): a = 1 def fool2(): # a = a +1 # UnboundLocalError: local variable 'a' referenced before assignment return a # 1 return fool2ccc = foo2() # 此时：ccc = fool2，ccc只是获得到了一个对象print(ccc()) # 此时：ccc = fool2(), ccc获取到的是一个实例flist = []for i in range(3): # 编写 1 # def foo3(x): def foo3(x, y = i): # 编写 1 的输出 # print(x + i) print(x + y) flist.append(foo3)for f in flist: f(2)'''编写 1 的运行结果为：444结果是4,4,4。这是因为当把函数加入flist列表里时，python还没有给i赋值，只有当执行时，再去找i的值是什么，这时在第一个for循环结束以后，i的值是2，所以以上代码的执行结果是4,4,4.编写 2 的运行结果为：234在程序里面经常会出现这类的循环语句，Python的问题就在于，当循环结束以后，循环体中的临时变量i不会销毁，而是继续存在于执行环境中。还有一个python的现象是，python的函数只有在执行时，才会去找函数体里的变量的值''' 闭包的作用 参考：http://www.jb51.net/article/54498.htm 闭包主要在函数开发中使用 当闭包函数执行完毕后，仍然能够保持住当前的运行环境 闭包可以根据外部作用域的局部变量来得到不同的结果 引用：闭包与并行运算 闭包有效的减少了函数所需定义的参数数目。这对于并行运算来说有重要的意义。在并行运算的环境下，我们可以让每台电脑负责一个函数，然后将一台电脑的输出和下一台电脑的输入串联起来。最终，我们像流水线一样工作，从串联的电脑集群一端输入数据，从另一端输出数据。这样的情境最适合只有一个参数输入的函数。闭包就可以实现这一目的。 并行运算正称为一个热点。这也是函数式编程又热起来的一个重要原因。函数式编程早在1950年代就已经存在，但应用并不广泛。然而，我们上面描述的流水线式的工作并行集群过程，正适合函数式编程。由于函数式编程这一天然优势，越来越多的语言也开始加入对函数式编程范式的支持。 匿名函数定义 匿名函数由关键字lambda表示。:前面的参数名表示函数的参数，:后面的表达式表示为函数执行具体操作的表达式。 ####特点 python对匿名函数的支持有限，只能在一些简单的情况下使用匿名函数 匿名函数有个数限制，只能有一个表达式，不用写return，返回值就是该表达式的结果。 代码示例 1234'''匿名函数的使用 - 1'''print(list(map(lambda x: x*x, [1, 2, 3, 4]))) # [1, 4, 9, 16]'''匿名函数的使用 - 2''' 装饰器定义在代码运行期间动态增加功能的方式，称之为“装饰器(decorator)” 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192'''原函数def now(): print('2017-07-16')now() # 2017-07-16''''''定义一个 now() 的 装饰器函数 log()'''def log(func_origin): def add_func(*args, **kwargs): print('call %s()' % func_origin.__name__) # 因为log()是一个decorator，所以接受一个函数作为参数，并返回一个函数。 # 返回原函数所具有的功能 return func_origin(*args, **kwargs) return add_func'''使用 装饰器函数 log()'''@log# @log 等价于 now = log(now)def now(): print('2017-07-16')'''调用被装饰器装饰的函数now()'''now()'''运行结果：call now()2017-07-16释义：由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。''''''需要传入参数的decorator, 即：3层嵌套'''def log2(text): def decorator(func): def wrap(*args, **kwargs): print('%s %s()' % (text, func.__name__)) # return func(*args, **kwargs) return func() # 输出结果中有：2017-07-16 # return func # 输出结果中没有：2017-07-16 return wrap return decorator'''3层嵌套的使用'''#@log2('execute')# @log2 等价于 now2 = log2('execute')(now2)def now2(): print('2017-07-16')now2 = log2('execute')(now2)now2()'''运行结果：def now():print('2017-07-16')''''''函数也是对象，它有__name__等属性，但经过decorator装饰之后的函数，它们的__name__已经从原来的'now2'变成了wrap'''print(now2.__name__) # wrapdef log3(text): def decorator3(func3): @functools.wraps(func3) # 词条语句等价于 # wrap3.__name__ = func3.__name__ # 需要把原始函数的__name__等属性复制到wrap3()函数中，否则，有些依赖函数签名的代码执行就会出错。 def wrap3(*args, **kwargs): print('%s %s()' % (text, func3.__name__)) # return func3() func3() return wrap3 return decorator3@log3('execute')def now3(): print('2017-07-16')now3()print('now3 name is : ', now3.__name__)'''运行结果execute now3()2017-07-16now3 name is : now3''' 偏函数定义当函数的参数个数太多，需要简化时，使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 代码示例 12345int2 = functools.partial(int, base=2)#等价于def int2(x, base=2): return int(x, base) functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 04-迭代器]]></title>
    <url>%2FPython3%20%2004-%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[能够使用for循环的数据类型有以下几种： 集合：list、tuple、set、dict 构建类型generator，带yield的generator function 字符串类型：str 复习：可以使用isinstance()判断一个对象是否是Iterable对象。需要导包：from collections import Iterable 1isinstance)(x, Iterable) 迭代器可以被`next()`函数调用并不断返回下一个值的对象称为——迭代器（`Iterator`） 判断一个对象是否为迭代器 1isinstance(x, Iterator) 代码示例 123456789101112131415'''判断是否 可迭代'''print(isinstance((x for x in range(1, 10)), Iterator)) # 构建类型 Trueprint(isinstance([1, 2], Iterable)) # list类型 Trueprint(isinstance((1, 2), Iterable)) # tuple类型 Trueprint(isinstance(&#123;1, 2&#125;, Iterable)) # set类型 Trueprint(isinstance(&#123;'1': 'A', '2': 'B'&#125;, Iterable)) # dict类型 Trueprint(isinstance('ABC', Iterable)) # str类型 rue'''判断是否为 迭代器 对象'''print(isinstance((x for x in range(1, 10)), Iterator)) # 构建类型 Trueprint(isinstance([1, 2], Iterator)) # list类型 Falseprint(isinstance((1, 2), Iterator)) # tuple类型 Falseprint(isinstance(&#123;1, 2&#125;, Iterator)) # set类型 Falseprint(isinstance(&#123;'1': 'A', '2': 'B'&#125;, Iterator)) # dict类型 Falseprint(isinstance('ABC', Iterator)) # str类型 False]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 05-函数式编程-函数作为返回值]]></title>
    <url>%2FPython3%20%2005-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445'''求和运算'''def add_sum(*args): add = 0 for n in args: add = add + n return addprint(add_sum(1, 2, 3, 4, 5)) # 15'''将函数 -实例- 作为返回值'''def add_sum_func(*args): def my_sum(): add = 0 for n in args: add = add + n return add return my_sum()'''将函数 -对象- 作为返回值'''def add_sum_func_02(*args): def my_sum(): add = 0 for n in args: add = add + n return add return my_sum# 调用 add_sum_func()时，返回的不是函数求和的结果，而是求和函数本身，就是延迟了函数结果的实现print(add_sum_func(1, 2, 3, 4, 5)) # 15new_f = add_sum_func(1, 2, 3, 4, 5)print(new_f) # 15# print(new_f()) # TypeError: 'int' object is not callableprint(add_sum_func_02(1, 2, 3, 4, 5)) # &lt;function add_sum_func_02.&lt;locals&gt;.my_sum at 0x1021ef8c8&gt;new_f = add_sum_func_02(1, 2, 3, 4, 5)print(new_f) # &lt;function add_sum_func_02.&lt;locals&gt;.my_sum at 0x1021ef8c8&gt;print(new_f()) # 15'''释义'''''' 函数add_sum_func()与add_sum_func_02()的区别除了函数名字上有区别，在其函数内部只有一点不同，即返回值： 一个是：return my_sum()。带()表示返回的是 函数的数值，即：结果值。 另一个是：return my_sum。不带()表示返回的是 函数本身，即：函数所在内存的地址。 通过查看输出的结果可以清晰的对比出两者的不同。''']]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 05-函数式编程-高阶函数]]></title>
    <url>%2FPython3%20%2005-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ `Python`对函数式编程提供部分支持。由于`Python`允许使用变量，因此，`Python`不是纯函数式编程语言。 函数与变量互指代码示例 12345x = abs # 函数名其实也是一个变量，变量之间是可以互指。print(x(-10)) # 10。此时，x就是一个求'绝对值'的函数abs = 10print(abs) # 10print(abs(10)) # TypeError: 'int' object is not callable。此时的abs已经不是一个函数，而是一个值为10的变量。 高阶函数将函数作为参数传入另一个函数，这样的函数被称为高阶函数。 代码示例 12345def high_func(z, y, f): return f(z) + f(y)# 将函数abs作为一个参数指向变量fprint(high_func(-1, -3, abs)) # 4 高阶函数 - map() map接收两个参数：一个是函数，另一个是Iterable， map函数的意义是：将传入的函数依次作用于每一个序列的每一个元素，并将结果作为新的Iterator返回 1234567891011121314151617181920212223242526272829303132333435363738def func(x): return x * x'''通过一行代码实现：序列中的每一个元素进行取平方运算，将结果作为list序列输出'''print(list(map(func, [1, 2, 3, 4, 5]))) # [1, 4, 9, 16, 25]v = map(func, [1, 2, 3, 4, 5])print(isinstance(v, Iterator)) # Trueprint(isinstance(v, Iterable)) # Trueprint(isinstance('abc', Iterator)) # False'''使用 next() 输出Iterator类型的对象 修改前'''# while True:# print(next(v))'''1StopIteration491625''''''修改后'''while True: try: print(next(v)) except StopIteration: break'''1491625''' 高阶函数 - reduce() 参数：两个参数。函数名，序列 作用：将结果继续和序列的下一元素做函数名指定的运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ls = [1, 2, 3, 4, 5]def fun_add(x, y): return x + yprint(reduce(fun_add, ls)) # 15.# 将序列 ls 中的数变成组合成一个整数def func_int(x, y): return x * 10 + yprint(reduce(func_int, ls)) # 12345def func_str(s): # 将字符串转换为int类型。根据`键`取对应的`值` return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s]# 将str类型变为int类型print(reduce(func_int, list(map(func_str, '1234567')))) # 1234567# 将以上方法编写为一个str类型转int的方法def func_str_to_int(s): def f_int(x, y): return x * 10 + y def f_str(ss): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[ss] return reduce(f_int, map(f_str, s))print(func_str_to_int('11223344')) # 11223344'''测试，将不规则的输入按照指定的要求输出。如：'AsdA' 'asdS' 输出后的结果为：'Asda', 'Asds' '''def func_rule(s): # if isinstance(s, str): if isinstance(s, list): def func_to_up(ss): return ss[0].upper() + ss[1::].lower() return list(map(func_to_up, s)) else: print('输入的参数类型有误！') return '-1'L1 = ['adam', 'LISA', 'barT']print(func_rule(L1)) # ['Adam', 'Lisa', 'Bart']'''求乘积'''ll = [3, 5, 7, 9]def prod(lll): def xx(x, y): return x * y return reduce(xx, lll)print(prod(ll)) # 945 高阶函数 - filter() 作用：过滤函数. True保留序列中的元素，False删除序列中的元素 1234567lf = [1, 2, 3, 4, 5]# 过滤一个序列中的偶数def func_odd(n): return n % 2 == 1print(list(filter(func_odd, lf))) # [1, 3, 5] 高阶函数 - sorted() 排序算法 1234567891011121314151617181920212223# 对list类型的数据排序ls01 = [1, -9, 10, 5, 23, -3]print(sorted(ls01)) # [-9, -3, 1, 5, 10, 23]# 高阶函数使用 按照绝对值进行排序print(sorted(ls01, key = abs)) # [1, -3, 5, -9, 10, 23]ls02 = ['asd', 'ffgd', 'fhfgh', 'werr', 'bnbm']# 高阶函数使用 对 字符串 进行排序 根据小写字母排序print(sorted(ls02, key=str.lower)) # ['asd', 'bnbm', 'ffgd', 'fhfgh', 'werr']# 高阶函数使用 对 字符串 进行排序 根据大写字母排序--实现方式1print(sorted(ls02, key=str.lower, reverse=True)) # ['werr', 'fhfgh', 'ffgd', 'bnbm', 'asd']L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]'''根据学生的名字排序'''print(sorted(L)) # [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]'''根据学生的成绩排序'''print(sorted(L, key=itemgetter(1))) # [('Bart', 66), ('Bob', 75), ('Lisa', 88), ('Adam', 92)] itemgetter()的使用 参考：http://www.cnblogs.com/zhoufankui/p/6274172.html operator.itemgetter函数用于获取对象指定的下标数据。如根据学生成绩排序的方法使用中：获取序列中tuple元素下标为1的数据 operator.itemgetter函数获取的不是数值，而是重新定义了一个函数，通过将该函数作用于对象上才能获取数据，如：将数值赋值给key 特点：itmegetter()中的参数可以不按照数字大小的顺序来填入，可以使用2，1这样的顺序，表示 先获取 下标为2的数据值，再获取下标为1的数据的值。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-数据-序列]]></title>
    <url>%2FPython3%20%2002-%E6%95%B0%E6%8D%AE-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[通过print()结果来区分各种序列类型 []是list ()是tuple {}是set {key:value, ...}是dict 说明：在序列声明时： list使用[] tuple与set使用()。其中声明set值时用到set关键字，以区分tuple dict使用{} set使用set() 关于集合–list和tuple list是python内置的、是有序的、可随时添加、删除其中元素的数据类型。通过[]来包裹内容 tuple是有序、”指向不可变“的另一种集合，称为”元组“。通过()来包裹内容 list使用print()后打印的结果为：`[]`` set使用print()后打印的结果为：{} 序列相加相同数据类型序列之间可以相加，不同数据类型序列不能相加 1.list 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051nameList = ['张三', '李四', '王五']print(nameList) #['张三', '李四', '王五']#增 方式-1：追加,只能添加到集合的末尾nameList.append('赵六')print(nameList) #['张三', '李四', '王五', '赵六']#增 方式-2：插入。参数1，添加的位置；参数2，插入的内容nameList.insert(1,'钱七')print(nameList) #['张三', '钱七', '李四', '王五', '赵六']#删nameList.pop(1)print(nameList) #['张三', '李四', '王五', '赵六']#删，无参数情况下默认删除最后一个元素nameList.pop()print(nameList) #['张三', '李四', '王五']#改 根据指定的下标，替换元素nameList[0] = '孙八'print(nameList) #['孙八', '李四', '王五']#查 输出集合的长度print(len(nameList)) #3#查 输出指定位置的元素 方式-1：从前向后，正序print(nameList[1]) #李四#查 输出指定位置的元素 方式-2：从后向前，倒序print(nameList[-1]) #王五#查 循环遍历，方式-1 forfor nameSingle in nameList: print(nameSingle)'''孙八李四王五'''#查 循环遍历，方式-2 whilecount = len(nameList)while count &gt; 0: print(nameList[(-count)]) count = count-1'''孙八李四王五''' 2.tuple 代码示例 123456789101112131415161718tupleValue = (1,2)#空的tupletupleValue01 = ()#只有1个元素的tuple定义时必须加一个逗号·,·，来消除歧义。若不加，则定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号。tupleValue02 = (1,)#一个“可变的”tuple：变的不是tuple的元素，而是其中的list的元素#tuple一开始指向的list并没有改成别的list，所以所谓的“不变”是说，tuple的每个元素，指向永远不变。# 即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！t = ('a', 'b', ['A', 'B'])print(t[2][0])print(t[2][1])'''AB''' 关于dict和set dict dict在其他语言中称为map，其存储的值是 无序 的，使用的键-值对（key-value）存储,用{}来包裹内容。 dict使用print()后打印的结果为：{‘mac’: 999999, ‘hp’: 777777, ‘ASUS’: 46567} dict默认是去重复的 注意: dict的key必须是不可变对象。 特点：和list相比 1.查询速度快 2.内存占用量大 dict代码示例 1234567891011121314151617181920d = &#123;'mac':999999, 'hp':777777, 'ASUS':46567&#125;#查print(d['mac']) #999999#改d['mac'] = 90000print(d['mac']) #90000#判断dict中是否存在当前的键 方法-1print('mac' in d) #Trueprint('lenvol' in d) #False#判断dict中是否存在当前的键 方法-2print(d.get('mac')) #90000print(d.get('lenvol')) #None#删d.pop('mac')print(d) #&#123;'hp': 777777, 'ASUS': 46567&#125; set set是 list的精简版，去掉其重复的元素，而且只存储key值，不存储value值。即set内部是无重复元素的。 set 不能放入 可变对象.因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素” set使用print()后显示的结果是：{} set中到的参数只能放一个。 注意: dict的key必须是不可变对象。 特点：和list相比 1.查询速度快 2.内存占用量大 set代码示例 12345678910111213141516171819202122l = [1,5,1,1,2,2,3,3,4,5]print(l) #[1, 5, 1, 1, 2, 2, 3, 3, 4, 5]print(len(l)) #10s = set(l)print(s) #&#123;1, 2, 3, 4, 5&#125;print(len(s)) #5s.add(7)print(s) #&#123;1, 2, 3, 4, 5, 7&#125;print(len(s)) #6s.remove(7)print(s) #&#123;1, 2, 3, 4, 5&#125;print(len(s)) #5s2 = set([4,5,6,7,8,9])#交集print((s &amp; s2)) #&#123;4, 5&#125;#并集print((s | s2)) #&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; 解释“不可变对象”代码示例 12345678910111213141516171819a = 'abc'print(a)print(a.replace('a','A'))print(a)'''abcAbcabc'''b = a.replace('a','A')print(b)print(a)print(b)'''AbcabcAbc''' 由上面的代码可以看出：在调用了变量a的replace()之后，立即输出变量a的值，此时变量a的值是修改后的，但是在次输出a的值时，还是原来的内容，即：变量a的内容最终并没有被修改。 那为什么立即输出a修改后的内容时是变化的呢？ 当我们把修改后a的值赋给变量b时，不管输出多少次b变量的值，其内容一直是不变的。也就是说：变量b存储的是一个新的内容，即一个新的str类型的对象。而这个新的str类型的对象是在变量a所指的对象的基础上修改之后的新对象。 结论就是：不可变对象修改后得到的对象是一个新的对象，而原有的对象保持不变 条件判断elif是else if的缩写，完全可以有多个elif 代码示例 1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环 1.for A in AList. 将‘AList集合’中的每一个元素赋值到‘变量A’中2.while n。只要条件’n‘满足，就将‘AList集合’中的每一个元素取出并赋值到变量中 for ... in ... while 遍历主要是使用: for in代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 ls = [1, 2, 3, 4, 5, 6, 7, 8, 9] sum02 = 0 for item in ls: print(item) sum02 = sum02 + item print(sum02) ''' 1 2 3 4 5 6 7 8 9 45 ''' d = &#123;'cwj': 150, 'zh': 145, 'ww': 234, 'cwj': 200&#125; print(d) # &#123;'cwj': 150, 'zh': 145, 'ww': 234&#125; print(len(d)) # 3 print(d.keys()) # dict_keys(['cwj', 'zh', 'ww']) dlk = list(d.keys()) print(dlk) # ['cwj', 'zh', 'ww'] dlks = set(dlk) print(dlks) # &#123;'zh', 'ww', 'cwj'&#125; dtk = tuple(d.keys()) print(dtk) # ('cwj', 'zh', 'ww') '''遍历方式 1''' for (key, value) in d.items(): print(key, value) ''' cwj 200 zh 145 ww 234 ''' '''遍历方式 2''' for key in d: print('dict[%s]\'s value is : ' % key, d[key]) ''' dict[cwj]'s value is : 200 dict[zh]'s value is : 145 dict[ww]'s value is : 234 ''' '''遍历方式 3 ，遍历到指定的key时，修改其元素''' for key in d.keys(): print(key) print(d[key]) if key == 'cwj': d[key] = 500 print('ok cwj,your grade has changed!') print(d) ''' cwj 200 ok cwj,your grade has changed! zh 145 ww 234 &#123;'cwj': 500, 'zh': 145, 'ww': 234&#125;''' 几个内置函数代码示例 1234567891011121314151617ll = [1, 2, 3, 4]ll2 = [5, 6, 7, 8]ll3 = [1, 2, 3, 4, 5, 6, 7, 8]ll4 = [2, 7, 4, 5, 0, 1, 9, 1]print(ll * 2) # [1, 2, 3, 4, 1, 2, 3, 4]print(ll + ll2) # [1, 2, 3, 4, 5, 6, 7, 8]# 不能相减# print(ll3 - ll2)# 成员资格# 检测 1 是否在 ll2序列 中， 使用 in 关键字返回值# 为：True or Falseprint(1 in ll2) # False# 获得序列中的最大值print(max(ll3)) # 8print(min(ll4)) # 0]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-生成器+切片]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E7%94%9F%E6%88%90%E5%99%A8%2B%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[高级特性——(slice)切片，表示为[::] 切片语法：[1:4:2] 数字’1’ 表示开始的索引位置 数字’4’ 表示结束的索引位置 数字’2’ 表示间隔的索引数 补充于：2017年07月18日16:29:53 Python序列切片操作：http://developer.51cto.com/art/201304/389771.htm 切片的方向与位置 对于序列结构数据来说，索引和步长都具有正负两个值任意一个序列结构数据的索引范围为: -len(consequence) 到 len(consequence)-1 范围内的连续整数。step 步长：默认为1，步长值不能为0。切片过程:从第1个想要的对象开始，到第1个不想要的对象结束 说明 正索引默认位置 负索引默认位置 序列方向说明 左 –&gt; 右 左 &lt;– 右 序列第一个元素位置 0 -len(consequence) 序列末元素位置 len(consequence)－1 -1 切片方向代码示例 12345678s3 = [1,2,3,4,5]print(s3[1:4:1]) # [2, 3, 4]print(s3[-4:-2]) # [2, 3]print(s3[-3:-1]) # [3, 4]print(s3[-5:]) # [1, 2, 3, 4, 5]print(s3[:]) # [1, 2, 3, 4, 5]print(s3[-1::-1]) # [5, 4, 3, 2, 1]print(s3[-1:]) # [5] range语法range(start, stop, step) 参考：http://www.nowamagic.net/academy/detail/1302446 根据start和stop确定范围，根据step设定步长 range与xrange 两者都能用于for循环中range 与 xrange 用法上完全相同，不同点是，产生的结果类型不同 range 产生的结果是 list xrange 产生的结果是 生成器 代码示例 123456789101112'''这两个输出的结果都是一样的，实际上有很多不同，''''''range会直接生成一个list对象'''&gt;&gt;&gt; range(5)[0, 1, 2, 3, 4]'''而xrange则不会直接生成一个list，而是每次调用返回其中的一个值'''&gt;&gt;&gt; xrange(5)xrange(5)&gt;&gt;&gt; list(xrange(5))[0, 1, 2, 3, 4]'''要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。''' 函数range的使用12345678910111213141516'''表示从1开始，到10之前（不包括10'''l = range(1, 10)'''从0开始（0可以省略），生成10个数'''ll = range(10)'''从0开始，生成10个数，公差为2（相邻的数之间间隔为2）'''lll = range(0, 10, 2)'''根据range的规则，生成指定的序列'''print(l) # range(1, 10)print(ll) # range(0, 10)print(list(l)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]print(list(ll)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]print(list(lll)) # [0, 2, 4, 6, 8]'''从缩影0开始，去之后索引+2对应的具体数值'''print(list(lll)[::2]) # [0, 4, 8] 使用range进行求和 123456sum = 0numbers = range(1, 10)for i in numbers: sum += iprint(sum)'''45''' 对list使用切片1234567891011l = ['cwj', 'serr', 'bob', 'jack']'''取3个元素 使用方法 切片（slice）,是指：取出一个范围内的元素''''''从索引0开始，直到3为止，但是不包括索引3，实际的取得索引为0，1，2 如果索引是从0开始的，0可以省略'''print(l[0:3]) # ['cwj', 'serr', 'bob']print(l[:3]) # ['cwj', 'serr', 'bob']'''倒着取出元素'''print(l[-3:]) # ['serr', 'bob', 'jack']print(l[0:-3]) # ['cwj'] 对str使用切片1234s = 'cwj, cwj, cwj, cwj'sp = s[::]print(sp) # cwj, cwj, cwj, cwjprint(sp[0:4:2]) # cj 对dict使用切片 – dict不适用与切片123print("对dict使用切片")d = &#123;'cwj': 150, 'zh': 145, 'ww': 234, 'cwj': 200&#125;# print(d[1:3]) # TypeError: unhashable type: 'slice' 对tuple使用切片1234567891011121314print(range(8)) # range(0, 8)ll5 = range(8) # range(0, 8)print(ll5)t = tuple(ll5)print(t) # (0, 1, 2, 3, 4, 5, 6, 7)lls = t[::]print('将 t序列 复制后的结果为：')print(lls)'''将 t序列 复制后的结果为：(0, 1, 2, 3, 4, 5, 6, 7)注意： tuple执行切片以后仍是一个tuple''' 对set使用切片1234s = set(lls)print(s) # &#123;0, 1, 2, 3, 4, 5, 6, 7&#125; 是set类型的数据spl = t[::]print(spl) # (0, 1, 2, 3, 4, 5, 6, 7) 使用range后是tuple类型的数据 迭代器 for 的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768s = 'ABC'for c in s: print(c)'''使用下标循环'''l = [1, 2, 3, 4]for i, value in enumerate(l): print(i, value)'''0 11 22 33 4'''for i, ch in enumerate(s): print(i, ch)'''0 A1 B2 C'''d = &#123;'A': 123, 'B': 456&#125;print(d) # &#123;'A': 123, 'B': 456&#125;for i, dict0 in enumerate(d): print(i, d.items())'''0 A1 B'''ls = [(1, 1), (2, 2), (3, 3)]for x, y in ls: print(x, y)'''1 12 23 3''''''列表生成器'''for x in range(1, 10): print(x * x)'''149162536496481''''''生成的序列后，进行计算'''print([x * x for x in range(1, 9)]) # [1, 4, 9, 16, 25, 36, 49, 64]'''生成序列后，新进行取余数预算，然后进行相乘运算'''print([x*x for x in range(1, 10) if x % 2 == 0]) # [4, 16, 36, 64]'''遍历两个字符串进行 排列组合'''print([m + n for m in 'ABC' for n in '123']) # ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']'''将dict类型的数据转换为 序列'''d = &#123;'A': 1, 'B': 2, 'C': 3&#125;print([k + ' = ' + str(v) for k, v in d.items()]) # 'A = 1', 'B = 2', 'C = 3'] yield关键字 定义generator函数的另一中方式： 当一个函数中含有关键字 yield时，这个函数就不在是一个普通的函数，而是一个generator函数 带有yield关键字的generator函数，执行流程与普通函数不同： - 普通函数：执行到return或者函数的最后一句时，退出函数。 - 带有yield关键字的generator函数，调用next()函数时执行操作，遇到yield()函数时，退出返回。当 再次执行此函数时从上次返回yield语句处继续执行 运行含有yield关键字的函数 123456789101112131415161718192021222324252627282930313233343536def p_yield(): print('step_01') yield 1 print('step_02') yield 2 print('step_03') yield 3# 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：o = p_yield()next(o) # step_01next(o) # step_02next(o) # step_03# next(o) # StopIterationdef fib(max): n, a, b = 0, 0, 1 #l = [] while n &lt; max: '''方法1 返回值：1 \n 2 \n 3 \n 4 \n 5''' # print(b) ''' 方法2 返回值：[1, 1, 2, 3, 5] 函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List来保存中间结果，而是通过 iterable 对象来迭代。 ''' #l.append(b) '''方法3 返回值：1 \n 1 \n 2 \n 3 \n 5. 使用yield关键字，使得生成的值为一个generator对象,而不是使用list占用大量的内存''' yield b a, b = b, a + b n = n + 1 #return l# print(fib(5)) yield关键字的使用 参考：https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/ yield关键字 使得一个普通的函数变成一个generator函数。Python解释器会将其视为一个generator，当for循环fib（5）函数的返回值时，实际调用的是iterable对象。 一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用， 但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。 虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值， 不仅代码简洁，而且执行流程异常清晰 12for n in fib(5): print(n) 区分：fib与fib(5) fib：是一个generator function 好比于：类的定义 fib(5)：是调用 fib 后返回的一个generator对象 好比于：类的实例化]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-参数类型]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[默认参数必须指向 不可变对象。 因为不变对象一旦创建，对象内部的数据就 不能修改，这样就减少了由于修改数据导致的错误。 此外，由于对象不变，多任务环境下同时读取对象 不需要加锁，同时读一点问题都没有。 函数参数的5种类型 1.必选参数2.默认参数3.可变参数4.关键字参数5.命名关键字参数组合参数注意： 函数参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 必选参数代码示例 1234def fun(num): print(num*num)fun(10) #100 默认参数代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041##默认参数示例 1: tag = 2,为默认参数def fun2(num, tag = 2): s = 1 while tag &gt; 0: tag = tag - 1 s = s * num return sprint(fun2(5)) #25print(fun2(5,3)) #125#默认参数示例 2def fun3(name, age = 6, city = 'beijing'): print("name is %s" % name) print("age is %d" % age) print("city is %s" % city)fun3('cwj')'''name is cwjage is 6city is beijing '''#默认参数在赋值时要注明： 参数名称fun3('cwj', age = 9)'''name is cwjage is 9city is beijing'''fun3('cwj', city='tinajin')'''name is cwjage is 6city is tinajin''' 可变参数可变参数（个数可变），其本质是 `tuple`集合，由函数返回的结果可以看出 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个`tuple` 代码示例 12345678910111213141516171819202122def fun4(*numbers): sum = 0 for num in numbers: sum = sum + num * num print(sum)fun4(2,3,4) #29'''*l表示把l这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见'''l = [2,3,4]fun4(*l) #29'''*t表示把t这个tuple的所有元素作为可变参数传进去。这种写法相当有用，而且很常见'''t = (2,3,4)fun4(*t) #29e#可变参数个数为0fun4() #0 关键字参数关键字参数本质 dict（实际参数为 键值对 即可） 而关键字参数允许你传入0个或任意个含 参数名的参数 ，这些关键字参数在函数 内部 自动组装为一个 dict。 12345678910111213141516171819202122232425262728293031323334353637383940414243def fun5(name, age, **keyWord): print('fun5-----') print("name is : ", name) print("age is : %d" % age) print("address is : ", keyWord)#传入1个关键字参数fun5('cwj', 24, address='tianjin')'''name is : cwjage is : 24address is : &#123;'address': 'tianjin'&#125;'''#传入多个关键字参数fun5('cwj', 24, address='beijing', weather='hot')'''name is : cwjage is : 24address is : &#123;'address': 'beijing', 'weather': 'hot'&#125;'''#传入0个参数fun5('cwj', 24)'''name is : cwjage is : 24address is : &#123;&#125;'''#在有现成dict类型的情况下#此处是将d这个dict类型对象的所有 key-value 用关键字参数导入到函数的**keyWord参数中，keyWord获得的是d的一份拷贝，对keyWord的改变将不会影响到函数外的d本身。d = &#123;'address': 'beijing', 'wether':'hot'&#125;fun5('cwj', 24,**d)name is : cwjage is : 24address is : &#123;'address': 'beijing', 'wether': 'hot'&#125; 命名关键字此种参数是用来 限制关键字参数 的名字，就是仅接受 已经命名的形参 的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455'''表示方法1：*，参数名1，参数名2'''def fun6(name, age, *, address, wethear): print('fun6-----') print("name is : ", name) print('age is : %d' % age) print('address is : %s' % address) print('wether is : ', wethear)fun6('cwj', 26, address='tianjin', wethear='hot')'''name is : cwjage is : 26address is : tianjinwether is : hot''''''表示方法2，若函数中已经含有一个'可变参数'，则之后的参数不需要在添加 * 符号'''def fun7(name, age, *keyWord, city, wether): print('fun7-----') print('name is : ', name) print('age is : ', age) print('keuWord is : ', keyWord) print('city is : ', city) print('wether is : ', wether)fun7('cwj', 24, 'xian', city='tianjin', wether='windy')'''name is : cwjage is : 24keuWord is : ('xian',)city is : tianjinwether is : windy''''''表示方法3：设置有默认值的命名关键字参数'''def fun8(name, *, city='beijng',wether): print(name, city, wether)fun8('cwj',wether='hot')'''cwj beijng hot'''def fun9(name): passfun9('cwj') 组合参数代码示例 12345678910111213141516171819202122232425262728293031# 参数 必须参数，可选参数，可变参数，关键字参数def fun10(name, age=19, *key_word, **city): print(name, age, key_word, city)# 参数 必须参数，可选参数，可变参数，命名关键字参数def fun11(name, age=19, *key_word, city, weather): print(name, age, *key_word, city, weather)# 参数 必须参数，可选参数，命名关键字参数def fun12(name, age=8, *, city, weather): print(name, age, city, weather)# 参数 可选参数，可变参数，命名关键字参数def fun13(age=23, *l_num, **key_word): print(age, l_num, key_word)l = [1, 2, 3]fun10('cwj', 24, *l) # cwj 24 (1, 2, 3) &#123;&#125;fun10('cwj', 24, *l, city='beijing') # cwj 24 (1, 2, 3) &#123;'city': 'beijing'&#125;fun11('cwj', 24, *l, city='tianjin', weather='hot') # cwj 24 1 2 3 tianjin hotfun12('cwj', age=24, city='xian', weather='very hot') # cwj 24 xian very hotfun12('cwj', 0, city='beijing', weather='windy') # cwj 0 beijing windyfun13(24, *l, fa='sss') # 24 (1, 2, 3) &#123;'fa': 'sss'&#125;]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-返回值]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在python交互环境中，使用本地文件自己定义的函数进入到文件所在的目录下后，将HelloWorld文件中的my_abs方法导入到交互环境中： from HelloWorld import my_abs Hello World 输出的是中文my_abs(-12)12 为系统函数建立别名12a = absprint(a(-90)) #90 空函数 - passpass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码 能运行起来。这样的函数适用于在上下文中，保持 整体逻辑思路 的通畅。 代码示例 12def nop(): pass 除了在函数体内使用之外，在其他语句中也可以使用：代码示例 12if age &gt;= 18: pass 函数参数检查 - isinstance()当我们自定义的函数传入了不恰当的参数时，python的函数能够检测出错误的参数，而我们自定义的函数则不能。当报错时，提示的错误信息和系统内置的函数提示的错误信息也不一样。我们应该完善我们自己定义的函数，使用isinstance()方法 代码示例 1234567891011def my_abs_good(x): # if not isinstance(x,(int, float)): raise TypeError('输入的参数类型异常') if x &gt; 0: return x else: return -xprint(my_abs_good(-2)) #2print(my_abs_good('a')) #TypeError: 输入的参数类型异常 判断一个数据类型是否为可迭代对象代码示例 123s = 'ABC'print(isinstance(s, Iterable)) # Trueprint(isinstance(123, Iterable)) # False 自定义函数的返回值 多个返回值 的本质是一个：tuple对象。只有一个返回值时，默认不显示() 多返回值 代码示例 123456789101112131415161718192021222324252627282930313233def getXY(x, y, step, angle = 0): nx = x + step * math.cos(angle) ny = y - step * math.cos(angle) #返回两个值 return nx, ny# 1x, y = getXY(10,20,100)print(x, y) #110.0 -80.0# 2x, y = (110.0, -80.0)print(x, y) #110.0 -80.0# 3z = getXY(10,20,100)print(z) #(110.0, -80.0)# 4z2 = (10)print(z2) #10'''比较 #1，#2，#3, #4 可以得出，函数的返回值其实是一个tuple对象,当返回值只有1个时，回省略掉()'''print(getXY(10,20,100)) #(110.0, -80.0)x, y, z = (10, 20, 100)print(x, y, z) #10 20 100print(x) #10'''在声明多个变量的同时，也将tuple对象的值对应的赋值给变量，很神奇！''' 没有返回值 return None 代码示例 12def noRetuen(): print('aaaa') 返回值小结 定义函数时，需要确定 函数名 和 参数个数； 如果有必要，可以先对参数的 数据类型 做检查； 函数体内部可以用 return 随时返回函数结果； 函数执行完毕也 没有return语句 时，自动 return None。 函数可以同时返回 多个值，但其实就是一个 tuple。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 01-基础-基本数据类型]]></title>
    <url>%2FPython3%20%2001-%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python是一种计算机编程语言，使用Unicode编码，支持多语言(动态语言，因为变量本身不固定)。 是一种解释性语言在运行 .py 文件时需要通过 解释器 进行解释然后显示呢结果。 区分大小写 参考网站：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 Python代码创建方式 1.在 终端环境 中编写 2.在 文件 中编写 方式 1：在终端环境下 输入 python 进入python交互模式，在&gt;&gt;&gt;后名编写代码： 12300 + 100400 输入 exit() 退出python模式。 方式 2：在文件中 直接在文件中编写代码，然后打开终端进入文件所在目录，运行： 1python 文件名.py 语法1、采用缩进方式（4个空格） 2、大小写敏感，例如：`True`, `False`, `None` 注释 # 单行注释 &#39;&#39;&#39; &#39;&#39;&#39;多行注释 符号 ：作用 :结尾表示时，缩进的语句视为代码块,如： 1234if ooo: XXXelse: XXX 字符串编码 参考：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000 ASCII、Unicode和UTF-8的关系在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。所以你看到很多网页的源码上会有类似的信息，表示该网页正是用的UTF-8编码 Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言 数据类型和变量 整数 浮点型 字符串 布尔值 空值 变量 常量 列表 字典 自定义数据类型 整数1，-1，0x123。 整数的除法在Python中有两种：/和//。 其中/表示除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数 1print(13/5) #2.6 另一种除法//称为地板除，两个整数的除法仍然是整数: 1print(13//5) #2 浮点型1.2， 1.23e9, 12.3e8， 1.23e-8 字符串（！此处划重点！） 字符串类型是str。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示。 使用 &#39; &#39; 或者 &quot; &quot; 表示的任意字符。其中包括 “‘”的用法 &quot;I&apos;m OK&quot; 既有&#39;又有&quot;的表示方法 I’m “OK”的用法： &apos;I \&apos;m \&quot;OK\&quot;&apos; 即：需要显示的特殊字符或者需要转义的字符用 \ 表示。 如果不需要转义当前字符，则可以使用 r&#39;&#39; 表示 &#39;&#39;内部不需要转义的字符，例如： 1print(r'"I\'m \"OK\""') 结果为： &quot;I\&apos;m \&quot;OK\&quot;&quot; 在&#39;&#39;&#39; &#39;&#39;&#39; 内可以不使用\n换行符而直接表示多行内容 123print('''line1line2line3''') 结果为： 123line1line2line3 布尔值 注意True和False的大小写，而且布尔值可以用and、or和not运算 测试代码： 123456789101112131415161718print(3 &gt; 2) #Trueprint(3 &lt; 2) #Falseif 3 &gt; 2 and 4 &lt; 5: print("3 &gt; 2")else: print("3 &lt; 2") #3 &gt; 2if 3 &gt; 2 or 4 &gt; 5: print("3 &gt; 2")else: print("3 &lt; 2") #3 &gt; 2if not 4 &lt; 5: print("3 &gt; 2")else: print((not 4 &lt; 5)) #False print("3 &lt; 2") #3 &lt; 2 空值 空值是用None表示的（注意大小写），但是None不能理解为0。 变量 Python与其他不同的是它的变量的类型是通过被赋予的值得类型决定的，即： 后者决定前者的类型。 Python的变量只是一个名字而已，数值内容及其类型才是重点，决定了变量名的实际意义。 变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错,例如Java是静态语言. 12345678a = 123print(a) #123a = "a是个变量名"print(a) #a是个变量名a = Trueprint(a) #Trueb = aprint(b) #True 常量 在Python中，通常用全部大写的变量名表示常量，全部大写的变量名表示常量只是一个习惯上的用法。 格式化输出 格式化输出字符串 – 同C语言，格式化与实际数据之间通过%连接 使用%，%运算符就是用来格式化字符串的，其中 %s 表示替换字符串，%d 表示替换整数，%f 表示替换浮点型%x 表示16进制 代码示例 12345678910name = input('请输入你的名字：') #请输入你的名字：yannisprint('Hello, %s ,你好啊~' % name) #Hello, yannis ,你好啊~age = input("请输入你的年龄： ")print("你的年龄为 %d，确认：%d" % (12,12)) #你的年龄为 12，确认：12#在不确定使用何种类型的数据时，用%s即可print('age is : %s; Gener: %s' % (32,False)) #age is : 32; Gener: False#字符串里面的%是一个普通字符时,需要转义，用%%来表示一个%print('增长率为：%d%%' % 7) #增长率为：7% 一个计算成绩比率的小代码 12345678910111213141516grade1 = input("请输入去年的成绩：")grade2 = input("请输入今年的成绩："#此处将str类型的grade1转换为int的10进制类型，参数：grade1表示待转换的数据，参数：10，表示进制num = int(grade1,10) - int(grade2,10)#此处将int类型的num转换为str类型print('num is : ' + str(num))print('abs is : %d' % abs(num))#将结果转换为float类型mPercent = float(((abs(num))/int(grade1,10))*100)print('mPercent is : ' + str(mPercent))#格式化输出结果print('成绩变化率为：%.2f%%' % mPercent)]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux/Unix系统文件结构]]></title>
    <url>%2FLinux%3AUnix%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[/bin系统有很多放置执行档的目录，但/bin比较特殊。 因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 /etc系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop /etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。 /etc/X11/ ：与XWindow有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 /lib系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /mediamedia是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 /opt这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 /root系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 /sbinLinux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srvsrv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 /tmp这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下： /lost+found这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 根目录下与开机过程有关的目录1234567除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 /usr 的意义与内容：依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。 /usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： /usr/X11R6/为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。/usr/bin/绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var 的意义与内容：如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。 /var/cache/应用程序本身运作过程中会产生的一些暂存档 /var/lib/程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。四. 目录树(directory tree) :在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html 描述： （1）装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 （1）装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。 装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。 在装饰模式中的角色有：查看OO DesignPattern文件夹中的图片。 ● 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 ● 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 ● 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 ● 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 ###装饰模式的优点： （1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。 装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。 继承关系则不同，继承关系是静态的，它在系统运行前就决定了。 （2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 装饰模式的缺点： （1）由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。 （2）但是，在另一方面，使用装饰模式会产生比使用继承关系——“更多”的——“对象”。更多的对象会使得查错变得困难，特别是这些对象看上去——都很相像。 透明性问题： 透明性的要求 装饰模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。 用孙悟空的例子来说，必须永远把孙悟空的所有变化都当成孙悟空来对待，而如果把老孙变成的鱼儿当成鱼儿， 而不是老孙，那就被老孙骗了，而这时不应当发生的。 下面的做法是对的： TheGreatestSage sage = new Monkey(); TheGreatestSage bird = new Bird(sage); 而下面的做法是不对的： Monkey sage = new Monkey(); Bird bird = new Bird(sage); 半透明的装饰模式 然而，纯粹的装饰模式很难找到。装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。 在增强性能的时候，往往需要建立新的公开的方法。 即便是在孙大圣的系统里，也需要新的方法。比如齐天大圣类并没有飞行的能力，而鸟儿有。这就意味着鸟儿应当有一个新的fly()方法。 再比如，齐天大圣类并没有游泳的能力，而鱼儿有，这就意味着在鱼儿类里应当有一个新的swim()方法。 这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。 换言之，允许装饰模式改变接口，增加新的方法。 这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法： 例如： TheGreatestSage sage = new Monkey(); Bird bird = new Bird(sage); bird.fly(); 半透明的装饰模式是介于装饰模式和适配器模式之间的。 适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。 大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做—-半装饰、半适配器模式。 示例：/** * Created by chengwenjia on 17-3-10. * * 抽象构件角色，给出接口，规范准备接收责任的对象。 */ public interface Component { public void operator(); } //------------------------------------------- /** * Created by chengwenjia on 17-3-10. * * 具体构件角色 */ public class ConcreteComponent implements Component { @Override public void operator() { System.out.println(&quot;Component的原始技能--没有技能&quot;); } } //-------------------------------------------- /** * Created by chengwenjia on 17-3-10. * * 装饰角色 */ public class Decorator implements Component { private Component component; public Decorator(Component component) { this.component = component; } @Override public void operator() { //将具体执行的方法委派给构件 component.operator(); } } //----------------以上3个为装饰者模式的基础组成类----------------------------- /** * Created by chengwenjia on 17-3-10. * 具体的装饰角色 --新增技能1 */ public class DecoratorA extends Decorator { public DecoratorA(Component component) { super(component); } @Override public void operator() { super.operator(); System.out.println(&quot;Component的新技能--上天&quot;); } } /** * Created by chengwenjia on 17-3-10. * 具体的装饰角色 */ public class DecoratorB extends Decorator { public DecoratorB(Component component) { super(component); } @Override public void operator() { super.operator(); System.out.println(&quot;Component的新技能--下海&quot;); } } /** * Created by chengwenjia on 17-3-10. * 具体的装饰角色 -- 半透明装饰者的产生类 */ public class DecoratorD extends Decorator { public DecoratorD(Component component) { super(component); } @Override public void operator() { super.operator(); System.out.println(&quot;Component新增技能--捣乱&quot;); } //此类的产生导致由“全透明”转变为“半透明” public void otherMethod(){ System.out.println(&quot;非继承方法，调用的是自己定义的方法&quot;); } } 以上3个为装饰者模式的具体装饰类 /** * Created by chengwenjia on 17-3-10. * * 装饰者模式测试 */ public class Decorator_DesignPattern { public static void main(String[] args){ Component component = new ConcreteComponent(); System.out.println(&quot;---------0A--------&quot;); Component A = new DecoratorA(component); A.operator(); System.out.println(&quot;---------0B--------&quot;); Component B = new DecoratorB(component); B.operator(); System.out.println(&quot;---------0C--------&quot;); Component C = new DecoratorC(component); C.operator(); System.out.println(&quot;---------0A--------&quot;); Component C2 = new DecoratorC(A); C2.operator(); System.out.println(&quot;---------0D--------&quot;); DecoratorD D = new DecoratorD(component); D.operator(); D.otherMethod(); /** * 输出结果： * ---------0A-------- Component的原始技能--没有技能 Component的新技能--上天 ---------0B-------- Component的原始技能--没有技能 Component的新技能--下海 ---------0C-------- Component的原始技能--没有技能 Component新增技能--吃草 ---------0A-------- Component的原始技能--没有技能 Component的新技能--上天 Component新增技能--吃草 ---------0D-------- Component的原始技能--没有技能 Component新增技能--捣乱 非继承方法，调用的是自己定义的方法 */ } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/self_study/article/details/51628486 说明创建一个抽象类方法，里面写有代理与主题共同的方法。 public abstract class MyObject { //代理与实际主题的共同方法 public abstract void operate(); } 真实主题 public class RealObject extends MyObject { @Override public void operate() { System.out.println(&quot;这是来自RealObject的方法处理&quot;); } } 代理主题 public class ProxyObject extends MyObject { private RealObject realObject; //在此类中调用真实的主题，因为是代理主题“代理”真实主题中的方法，需要用到真实主题的引用 public ProxyObject(RealObject realObject) { this.realObject = realObject; } @Override public void operate() { System.out.println(&quot;在处理“RealObject”之前，处理代理模式中自己的方法处理&quot;); //在此处调用真实主题中的同名方法。 realObject.operate(); System.out.println(&quot;在处理“RealObject”之后，处理代理模式中自己的方法处理&quot;); } } 测试 public class Proxy_DesignPattern { public static void main(String[] args){ ProxyObject proxyObject = new ProxyObject(new RealObject()); proxyObject.operate(); } } /** * 输出结果： * 在处理“RealObject”之前，处理代理模式中自己的方法处理 这是来自RealObject的方法处理 在处理“RealObject”之后，处理代理模式中自己的方法处理 */ 代理模式的角色：Subject：抽象主题类 该类的主要职责是声明真实主题与代理的共同接口方法，该类既可以是一个抽象类，也可以是一个接口； RealSubjct：真实主题类 该类也称为被委托类或被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户端则通过代理类间接地调用真实主题类中定义的方法； ProxySubject：代理类 该类也称为委托类或代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中对应的接口方法，以此起到代理的作用； Client：客户类 即使用代理类的部分。 代理模式根据实际使用的场景也可以分为以下几种：远程代理（Remote Proxy） 为某个在不同的内存地址空间的对象提供局部代理，使系统可以将 Server 部分的实现隐藏，以便 Client 可以不必考虑 Server 的存在，类似于 C/S 模式（主要拦截并控制远程方法的调用，做代理防火墙之类的）； 虚拟代理（Virtual Proxy） 使用一个代理对象标识一个十分耗资源的对象，并在真正需要时才创建，实现一个延迟加载的机制； 保护代理（Protection Proxy） 使用代理控制对原始对象的访问，该类型的代理通常被用于原始对象有不同访问权限的情况； 智能引用（Smart Proxy） 在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数； 写时拷贝（克隆）代理（Copy-on-write Proxy） 其实是虚拟代理的一个分支，提供了拷贝大对象的时候只有在对象真正变化后才会进行拷贝（克隆）的操作，即延迟拷贝。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[被观察者 123456789101112131415161718192021222324252627282930313233343536public interface MyObject &#123; public void register(Observer observer); public void unRegister(Observer observer); public void notifyData(String string);&#125;public class ImplObject implements MyObject &#123; private static final String TAG = "ImplObject"; private ArrayList&lt;Observer&gt; list; public ImplObject() &#123; list = new ArrayList&lt;Observer&gt;(); &#125; @Override public void register(Observer observer) &#123; list.add(observer); Log.e(TAG, "register list size is : " + list.size() ); &#125; @Override public void unRegister(Observer observer) &#123; list.remove(observer); Log.e(TAG, "unRegister list size is : " + list.size() ); &#125; @Override public void notifyData(String string) &#123; for (Observer o : list) &#123; o.updateData(string); &#125; &#125;&#125; 观察者 1234567891011121314151617181920public interface Observer &#123; public void updateData(String string);&#125; public class ImplObserver implements Observer &#123; private List&lt;TextView&gt; list; public ImplObserver(List&lt;TextView&gt; list) &#123; this.list = list; &#125; @Override public void updateData(String string) &#123; for (TextView t : list) &#123; t.setText(list.indexOf(t) + " 号接收者收到 : " + string); &#125; &#125;&#125; 应用 public class MainActivity extends AppCompatActivity { private static final String TAG = "MainActivity"; private Button sendBtn; private TextView t1,t2,t3; private EditText editText; private MyObject object; private Observer observer; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); List&lt;TextView&gt; list = new ArrayList&lt;TextView&gt;(); list.add(t1); list.add(t2); list.add(t3); object = new ImplObject(); observer = new ImplObserver(list); object.register(observer); click(); } private void click() { sendBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String getStr = editText.getText().toString(); object.notifyData(getStr); } }); } private void initView() { sendBtn = (Button) findViewById(R.id.send); t1 = (TextView) findViewById(R.id.text1); t2 = (TextView) findViewById(R.id.text2); t3 = (TextView) findViewById(R.id.text3); editText = (EditText) findViewById(R.id.edit); } } 实例： Android的广播机制。 我们平时使用本地广播主要就是下面四个方法: LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this); localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter); localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver); localBroadcastManager.sendBroadcast(Intent intent) 调用registerReceiver方法注册广播，调用unregisterReceiver方法取消注册，之后直接使用sendBroadcast发送广播，发送广播之后，注册的广播会收到对应的广播信息，这就是典型的观察者模式 EventBus。 观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件： EventBus.getDefault().register(Object subscriber); EventBus.getDefault().unregister(Object subscriber); EventBus.getDefault().post(Object event); RxJava。 创建一个被观察者： Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; sub) { sub.onNext(&quot;Hello, world!&quot;); sub.onCompleted(); } } ); 创建一个观察者，也就是订阅者： Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() { @Override public void onNext(String s) { System.out.println(s); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { } }; 观察者进行事件的订阅 myObservable.subscribe(mySubscriber);]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Builder模式]]></title>
    <url>%2FBuilder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[builder实例 public class Person { private String name; private String address; private int age; private int height; private int weight; //外部类提供一个私有构造函数供内部类调用，在该构造函数中完成成员变量的赋值， //取值为Builder对象中对应的值 private Person(Builder builder){ this.name = builder.name; this.address = builder.address; this.age = builder.age; this.height = builder.height; this.weight = builder.weight; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, height=&quot; + height + &quot;, weight=&quot; + weight + &apos;}&apos;; } //定义一个静态内部类Builder，内部的成员变量和外部类一样 public static class Builder{ private String name; private String address; private int age; private int height; private int weight; //Builder类通过一系列的方法用于成员变量的赋值，并返回当前对象本身（this） public Builder name(String name){ this.name = name; return this; } public Builder address(String address){ this.address = address; return this; } public Builder age(int age){ this.age = age; return this; } public Builder height(int height){ this.height = height; return this; } public Builder weight(int weight){ this.weight = weight; return this; } //Builder类提供一个build方法或者create方法用于创建对应的外部类， //该方法内部调用了外部类的一个私有构造函数，该构造函数的参数就是内部类Builder public Person build(){ return new Person(this); } } } 使用实例 public class MainActivity extends AppCompatActivity { private static final String TAG = &quot;MainActivity&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Person person1 = new Person.Builder(). name(&quot;张三&quot;). address(&quot;河北&quot;). age(24). height(177). build(); Log.e(TAG, person1.toString()); Person person2 = new Person.Builder(). name(&quot;刻有&quot;). address(&quot;拉萨&quot;). height(159). weight(65). build(); Log.e(TAG, person2.toString() ); Person person3 = new Person.Builder(). name(&quot;利盟&quot;). address(&quot;陕西&quot;). age(24). height(188). weight(65). build(); Log.e(TAG, person3.toString() ); Person person4 = new Person.Builder(). name(&quot;由张&quot;). address(&quot;广西&quot;). age(34). height(177). weight(55). build(); Log.e(TAG, person4.toString() ); } } 描述：在Builder类里定义了一份与Person类一模一样的变量，通过一系列的成员函数进行设置属性值， 但是返回值都是this，也就是都是Builder对象，最后提供了一个build函数用于创建Person对象， 返回的是Person对象，对应的构造函数在Person类中进行定义，也就是构造函数的入参是Builder对象， 然后依次对自己的成员变量进行赋值，对应的值都是Builder对象中的值。 特点：创建过程变得清晰，对应的值属性一目了然，可读性大大增强。 总结：定义一个静态内部类Builder，内部的成员变量和外部类一样 Builder类通过一系列的方法用于成员变量的赋值，并返回当前对象本身（this） Builder类提供一个build方法或者create方法用于创建对应的外部类，该方法内部调用了外部类的一个私有构造函数，该构造函数的参数就是内部类Builder 外部类提供一个私有构造函数供内部类调用，在该构造函数中完成成员变量的赋值，取值为Builder对象中对应的值]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/sbsujjbcy/article/details/49302717 定义：用原型模式的实例创建对象的实例，同过拷贝这些原型模式的实例创建新的对象。 优点及适用场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 注意事项： 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。 深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝例如： prototype.list = (ArrayList) this.list.clone(); 示例//实现“原型模式”第一步：实现Cloneable接口 public class Person implements Cloneable{ private String name; private String address; private int age; private int height; private ArrayList&lt;String&gt; hobbies; public Person(String name, String address, int age, int height, ArrayList&lt;String&gt; hobbies) { this.name = name; this.address = address; this.age = age; this.height = height; this.hobbies = hobbies; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public ArrayList&lt;String&gt; getHobbies() { return hobbies; } public void setHobbies(ArrayList&lt;String&gt; hobbies) { this.hobbies = hobbies; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, height=&quot; + height + &quot;, hobbies=&quot; + hobbies + &apos;}&apos;; } //实现“原型模式”第二步：重写clone（） @Override protected Object clone() throws CloneNotSupportedException { Person person = (Person) super.clone(); person.name = this.name; person.address = this.address; person.age = this.age; person.height = this.height; //person.hobbies = this.hobbies; //此处使用使用深拷贝 person.hobbies = (ArrayList&lt;String&gt;) this.hobbies.clone(); return person; } } 使用 public class Prototype_DesignPattern { public static void main(String[] args){ ArrayList&lt;String&gt; hobbies = new ArrayList&lt;String&gt;(); hobbies.add(&quot;游泳&quot;); hobbies.add(&quot;足球&quot;); hobbies.add(&quot;自行车&quot;); Person person0 = new Person(&quot;张三&quot;,&quot;北京&quot;,24,177,hobbies); System.out.println(&quot;person0 is &quot; + person0.toString()); //原型模式的使用 try { Person person1 = (Person) person0.clone(); person1.setName(&quot;王哇&quot;); hobbies.remove(&quot;足球&quot;); person1.setHobbies(hobbies); System.out.println(&quot;person1 is &quot; + person1.toString()); Person person2 = (Person) person0.clone(); person2.setAge(44); System.out.println(&quot;person2 is &quot; + person2.toString()); } catch (CloneNotSupportedException e) { e.printStackTrace(); } System.out.println(&quot;person0 is &quot; + person0.toString()); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/self_study/article/details/51234377 关键字：面向接口编程PrinciPle：原则 6大OOP：OCP–开闭原则：what 编写代码应该：面向扩展开放，对修改关闭。尽量不要通过修改现有代码来满足需求 why 要利用扩展来适应变更。 How 能用接口别用抽象，能用抽象别用具体类。 SRP–单一职责原则：what 一个类，一个方法只做一件事。 LSP–里氏替换原则：what 所有引用基类的地方都能透明的使用子类的对象 how 子类必须完全实现父类的方法。 子类可以拥有自己的属性和方法。 子类覆盖或实现父类方法时参数范围可以扩大 子类覆盖或实现父类方法时返回值范围可以缩小 DIP–依赖倒置原则：what 模块间的依赖应该通过抽象发生，具体类之间不应该有依赖关系 接口或者抽象不依赖于实现类，否则就失去了抽象接口的意义 实现 依赖于 接口或者抽象即：底层依赖于高层 ISP–接口隔离原则：what 使用接口时应该建立单一的接口，不应该建立过于臃肿的接口 接口应该 “专” 而非 “多”即：提供独立单一的接口。 LKP–最少知识原则：what 一个对象应该对 “其他对象”有最少的了解。 即：一个类对于另一个类而言，尽量减少“public”，对外只提供一个简洁的访问 自己的方法尽量自己创建，]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/tanyujing/article/details/14160941 http://blog.csdn.net/sbsujjbcy/article/details/49147839 是在内存中维护唯一对象，优点如下： 1.对于那些比较耗内存的类，只实例化一次可以大大提高性能，尤其是在移动开发中。 2.保持程序运行的时候该中始终只有一个实例存在内存中 示例public class Singleton{ private static volatile Singleton instance == null; private Singleton(){ } public static Singleton getInstance(){ if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance == new Singleton(); } } } return instance; } } 关于volatile 参考：http://www.ibm.com/developerworks/cn/java/j-jtp06197.html 概述： Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”； 与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少， 但是它所能实现的功能也仅是 synchronized 的一部分。 单例模式使用： 必须防止外部可以调用构造函数进行实例化，因此构造函数必须私有化。 必须定义一个静态函数获得该单例 单例使用volatile修饰 使用synchronized 进行同步处理，并且双重判断是否为null，在synchronized (Singleton.class)里面又进行了是否为null的判断，这是因为一个线程进入了该代码，如果另一个线程在等待，这时候前一个线程创建了一个实例出来完毕后，另一个线程获得锁进入该同步代码，实例已经存在，没必要再次创建，因此这个判断是否是null还是必须的。 单例的并发测试：见参考。实际应用public class ActivityManager { private static volatile ActivityManager instance; private Stack&lt;Activity&gt; mActivityStack = new Stack&lt;Activity&gt;(); private ActivityManager(){ } public static ActivityManager getInstance(){ if (instance == null) { synchronized (ActivityManager.class) { if (instance == null) { instance = new ActivityManager(); } } return instance; } public void addActicity(Activity act){ mActivityStack.push(act); } public void removeActivity(Activity act){ mActivityStack.remove(act); } public void killMyProcess(){ int nCount = mActivityStack.size(); for (int i = nCount - 1; i &gt;= 0; i--) { Activity activity = mActivityStack.get(i); activity.finish(); } mActivityStack.clear(); android.os.Process.killProcess(android.os.Process.myPid()); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 桌面使用命令]]></title>
    <url>%2FUbuntu%20%E6%A1%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[桌面环境：super ： 长按显示启动器快捷信息 super + 数字 ： 启动指定的应用 super + D ： 显示桌面 super + w : 所有窗口平铺 super + s : 显示所有的工作区 super + t : 打开回收站 alt + prt ： 对窗口截图 ctrl + h ： 显示隐藏文件.h开头 shift + prt ： 选取截图 shift + ctrl + T : 桌面打开终端（在同一窗口下，新的标签页） ctrl + w : 关闭应用 super + c : 搜索图片 super + v : 搜索视屏 super + a : 搜索应用 super + f : 搜索文件和文件夹 super + m : 搜索音乐 终端运行命令(简洁版) 2016年12月19日10:40:37 软件更新 apt-get update 安装 apt-get install 软件名称 卸载 apt-get remove 软件名称 其他清屏 clear vim编辑 vim（vim filename） 组添加组 groupadd 组名 删除组 groupdel 组名 更改组信息 groupmod 组名 显示当前用户所属组 groups 用户查询历史登录 last [用户名] 切换用户 su 用户名 退出切换的用户 exit 相关文件 etc/group, etc/passwd, etc/shadow 查看当前用户 w/who 添加用户 useradd 用户名 删除用户 suerdel 用户名 更改用户信息 usermod 添加用户到组中 useradd -G 组名 用户名 （G:附加组，用户将创建一个与自己同名的组） useradd -g 组名 用户名 （g：表示用户所加入的主组） 用户修改密码 passwd 用户名 查询id值 id 将用户添加至已存在的组中 usermod -a -G 组名 用户名 更改用户主要所在组 usermod -g 组名 用户名 文件pwd 查看当前目录 cat （从第一行开始显示）查看文件内容 cat [-nTAEv] tac （从最后一行开始显示） nl （显示时输出行号） nl [-b{ a, t}n{ln,rn,rz}w ] more （分页显示） space 向下翻一页 enter 向下翻一行 q 立即退出 :f 立刻显示当前文件名及当前行数 /字符串 在当前显示内容中，向下查询【字符串】 less（同more，可以向前翻页） /字符串 向上查询 ？字符串 向下查询 n 重复前一个查询 N 反向重复前一个查询 q 离开 pagedown 向下翻页 pageuP 向上翻页 head （仅显示头几行） head [-n number] 文件 tail（仅显示尾几行） tail [-n number] 文件 od （以2进制的方式读取档案） 目录与文件查看 ls [-aAdfFhilrRSt] 目录名 （可以使用×作为匹配符）ls [--color={none,auto,always}] 目录名 ls [--full-time{mtime,ctime,atime}] 目录名 ll == ls -l ls -a （显示隐藏文件及目录） pwd -P （返回真实目录，非连接目录） 路径切换 cd 文件路径cd - (返回上一个工作目录) cd ~ （home目录） cd .. (返回上层文件) cd ../目录 （同一层目录中前往其他目录） cd ~用户名 （进入此用户的home目录） 创建文件vim 文件名 （方式1） touch 文件名(空) （方式2） echo “输入内容” &gt; 文件名.后缀 （方式3） 修改文件时间+创建文件touch(空) 时间分类mtime:内容变更时间； ctime：状态时间； atime：接收时间 touch [-mcadt] 创建目录 mkdirmkdir [-mp] 目录名 （m：权限，p：自动建立多层目录） 删除目录 rmdirrmdir [-p] 目录名 （p：当前目录包含多个目录，删除时连同自身删除）仅能删除空目录 rm -rf 目录名 （删除非空目录） 慎用 更改组 chgrpchgrp [-R] 组名 文件 （R：文件夹递归） 更改拥有者 chownchown [-R] 用户名 文件 chown [-R] 用户名：组名 文件 获取文件名 basename 目录获取目录 dirname 目录文件预设权限 umaskumask [-S] (查看权限预设) 022:表示被‘拿掉的权限’,即：u,g-w,o-w umask 002 （设置权限） 权限的分类基本属性 + 隐藏属性 + 特别S属性 更改权限属性 chmodchmod [-R] 777 文件名 chmod [-R] u=(+/-)rwx,g=(+/-)rwx,o=(+/-)rwx 文件名 设定隐藏属性 chattrchattr [+-=][ASacdistu] 文件或目录名 (最常用a，i) chattr +a：表示在原有参数的基础上，追加参数-append，表示只能向文件中添加数据，不能删除,多用于日志。 chattr +i：表示文件不能被删除，改名，设定链接关系，同时不能写入，追加内容。 显示隐藏属性 lsattrlsattr [-aR] 文件或目录名 SUID,SGID,SBIT 设定4：SUID（使用在非目录上） 2：SGID（目录与文件均可） 1：SBIT（使用在非文件上） e.g. chmod 4755 文件名 结果为：-rwsr-xr-x 文件的类型 filefile 文件路径 文件查询whereis/locate（通过数据库查询,所以在查询前最好更新数据书库，updatedb文件） which find不推荐使用（伤硬盘：原理是在硬盘上查找，耗时）使用×匹配文件 which [-a] 文件 whereis [-bmsu] 文件或目录 locate 文件名 复制cp 源文件路径 新文件路径 （复制，建立快捷方式，新旧比对，复制目录） cp [-adfilprsu] cp 源1，源2…… 目录 移动mv （移动，更名 ） mv [-fiu] mv 原文件名 新文件名 mv 文件1，文件2 目录名 删除 rmrm [-rfi] 目录或文件 (若文件名中含有-，则用‘./’或者‘空格--空格’) 更新 2017年02月04日 星期六 18时34分42秒 查看磁盘空间大小命令 主要命令：df 详细命令：df -hl : 查看磁盘剩余空间（效果同 df -H） df -h : 查看每个根路径的分区大小 du -sh : [目录名] 返回该目录的大小 du -sm : [文件夹] 返回该文件夹总M数 fdisk -l : 查看硬盘分区 查看ip地址ifconfig 查看端口号主要命令 ： netstat 查看所有的服务端口: netstat -a 查看所有的服务端口，显示pid号 netstat -ap 查看某一（**）端口，则可以结合grep命令： netstat -ap | grep ** 如查看**端口，： lsof -i:** 若要停止使用这个端口的程序，使用kill +对应的pid kill pid 还有一个比较好用的命令，查看**端口： netstat -lnp | grep ** 查看端口号和运行程序： netstat -atunp | more 查看进程所用端口： netstat -tlnp|grep ** 卸载已经安装的软件命令： dpkg -l | grep appName apt-get remove appName 更新grep命令 参考：http://www.lai18.com/content/24612942.html 命令： 是linux中的搜索工具。可以用在搜索条件“过滤”。 用法： grep [选项] PATTERN 参数说明： [options] -c：只输出匹配行的计数。 -i：不区分大 小写(只适用于单字符)。 -h：查询多文件时不显示文件名。 -l：查询多文件时只输出包含匹配字符的文件名。 -n：显示匹配行及行号。 -s：不显示不存在或无匹配文本的错误信息。 -v：排除，不显示过滤的字符串的行；显示不包含匹配文本的所有行。 -E ：过滤多个字符串。 -o ：输出精确匹配的字符而不是默认的整行。 -f ：指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 Context control： -B 除了显示匹配的一行之外，并显示该行之前的num行 -A 除了显示匹配的一行之外，并显示该行之后的num行 -C 除了显示匹配的一行之外，并显示该行之前后各num行 grep &quot;String&quot; -B 10 test.txt #显示匹配的String行和String的前10行。 pattern正则表达式主要参数： \：忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 $: 匹配正则表达式的结束行。 \&lt;：从匹配正则表达 式的行开始。 \&gt;：到匹配正则表达式的行结束。 [ ]：单个字符，如 [Gg]rep 匹配Grep和grep。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求。 [^]：匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。 x\{m\}：重复字符x，m次，如：&apos;0\{5\}&apos;匹配包含5个0的行。 x\{m,\}：重复字符x,至少m次，如：&apos;0\{5,\}&apos;匹配至少有5个0的行。 x\{m,n\}：重复字符x，至少m次，不多于n次，如：&apos;0\{5,10\}&apos;匹配5 -- 10个0的行。 .：所有的单个字符。 *：有字符，长度可以为0。]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux vim 命令]]></title>
    <url>%2FLinux%20vim%20%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vim命令vi有3个模式：插入模式、命令模式、低行模式。插入模式：在此模式下可以输入字符，按ESC将回到命令模式。 命令模式：可以移动光标、删除字符等。 低行模式：可以保存文件、退出vi、设置vi、查找等功能(低行模式也可以看作是命令模式里的)。 打开文件、保存、关闭文件(vi命令模式下使用)vi filename //打开filename文件,文件名称可以不存在 :w //保存文件 :w filename //保存至filename文件 :q //退出编辑器，如果文件已修改请使用下面的命令 :q! //退出编辑器，且不保存 :wq //退出编辑器，且保存文件 :wq! //强制保存内容退出 3.插入文本或行(vi命令模式下使用，执行下面命令后将进入插入模式，按ESC键可退出插入模式)a //在当前光标位置的右边添加文本 A //在当前行的末尾位置添加文本 i //在当前光标位置的左边添加文本 I //在当前行的开始处添加文本(非空字符的行首) O //在当前行的上面新建一行 o //在当前行的下面新建一行 R //替换(覆盖)当前光标位置及后面的若干文本 J //合并光标所在行及下一行为一行(依然在命令模式) 移动光标(vi命令模式下使用)&lt;1&gt;、使用上下左右方向键 &lt;2&gt;、命令模式下： h 向左、l 向右、j 向下 、k 向上。 Backspace 向左、空格键 向右、Enter 移动到下一行首、- 移动到上一行首。 &lt;3&gt; $ 跳至行末，0 跳至行首 删除、恢复字符或行(vi命令模式下使用)x //删除当前字符 nx //删除从光标开始的n个字符 dd //删除当前行 ndd //向下删除当前行在内的n行 d&lt;enter&gt; //删除光标所在行及下一行(共计删除2行) u //撤销上一步操作 U //撤销对当前行的所有操作 搜索(vi命令模式下使用)/vpser //向光标下搜索vpser字符串 ?vpser //向光标上搜索vpser字符串 n //向下搜索前一个搜素动作 N //向上搜索前一个搜索动作 跳至指定行(vi命令模式下使用)n //跳n行 n+ //向下跳n行 n- //向上跳n行 G //跳至文件的底部 gg //跳至文件顶部 设置行号(vi命令模式下使用):set nu //显示行号 :set nonu //取消显示行号 复制、粘贴(vi命令模式下使用)yy //将当前行复制到缓存区，也可以用 &quot;ayy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。 nyy //将当前行向下n行复制到缓冲区，也可以用 &quot;anyy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。 yw //复制从光标开始到词尾的字符。 nyw //复制从光标开始的n个单词。 y^ //复制从光标到行首的内容。 y$ //复制从光标到行尾的内容。 p //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用&quot;ap 进行粘贴。 P //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用&quot;aP 进行粘贴。 替换(vi命令模式下使用):s/old/new //用new替换行中首次出现的old :s/old/new/g //用new替换行中所有的old :n,m s/old/new/g //用new替换从n到m行里所有的old :%s/old/new/g //用new替换当前文件里所有的old 编辑其他文件:e otherfilename //编辑文件名为otherfilename的文件。 修改文件格式:set fileformat=unix //将文件修改为unix格式，如win下面的文本文件在linux下会出现^M。 总结：当如果不知道自己处在什么模式时可以按: 2次Esc键 即可回到命令模式，会有最后提醒一点： 注意大小写！！！ Linux中vim编辑注意事项 2016年12月17日21:47:04 Ctrl s： 暂停该终端 Ctrl q： 让终端继续运行 Ctrl c： 中止当前正在执行的程序。 Ctrl d： 相当于exit命令，退出当前会话。 Ctrl z： 将当前运行的程序放到后台运行。与运行时加&amp;类似。 Tab键自动补全命令。 Linux中Terminal快捷键的使用 2017年 01月 09日 星期一 22:21:36 CST 文件：shift + ctrl + T： 新标签页打开新的终端 shift + ctrl + N： 新的窗口打开新的终端 alt + w : 关闭终端 alt + Q : 关闭全部终端 编辑：ctrl + C ： 复制 ctrl + V ： 粘贴 查看：F11 ： 全屏 ctrl + = : 放大 ctrl + - ： 缩小 ctrl + 0 ： 正常大小 查找：ctrl + F ： 查找 ctrl + G ： 查找下一个 ctrl + H ： 查找上一个 ctrl + J ： 清除高亮查找 标签页：ctrl + pgup : 向上翻页 ctrl + pgdn : 向下翻页 shift + ctrl + pgup ： 标签内容移动之左侧标签 shift + ctrl + pgdn ： 标签内容移动之右侧标签 alt +数字 ： 切换至指定的标签页]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装记录]]></title>
    <url>%2FUbuntu16.04%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[以下省略“sudo”命令表示是在root权限下运行的 ubuntu16.04使用参考网址 Linux使用设置 &gt;&gt;网页 http://m.blog.csdn.net/article/details?id=51049513Linux命令大全 &gt;&gt;网页 http://www.runoob.com/linux/linux-command-manual.htmlLinux命令大全–支持在线搜寻 http://man.linuxde.net/文档手册中心 –ChinaUnix &gt;&gt;网页 http://man.chinaunix.net/Linux Kernel –ChinaUnix &gt;&gt;网页 http://man.chinaunix.net/tech/lyceum/linuxK/tlk.htmlLinux Git使用 &gt;&gt;网页 http://v.youku.com/v_show/id_XNzgwOTk0NDQw.html?f=22842023&amp;spm=a2hzp.8244740.0.0&amp;from=y1.7-1.1以下省略“sudo”命令表示是在root权限下运行的 root登录 先设定一个root的密码： sudo passwd root root 登陆： su root cp -p /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak vi /etc/lightdm/lightdm.conf 在lightdm.conf最后增加一行： greeter-show-manual-login=true 重启后，即可用root登入。 系统没有声音Ubuntu在root用户下，为了安全考虑默认关闭系统的声音。 将root加到pulse和pulse-access组： usermod -a -G pulse-access root gpasswd -a root pulse gpasswd -a root pulse-access 编辑/etc/default/pulseaudio文件 cp -p /etc/default/pulseaudio/etc/default/pulseaudio.bak vim /etc/default/pulseaudio 修改以下两处 PULSEAUDIO_SYSTEM_START=1 DISALLOW_MODULE_LOADING=0 改为1和0，表示允许运行在system环境，允许动态加载模块。 重启计算机 有声音但在“系统设置”中无法调节声音： 运行： gedit /root/.profile 在文件的最后添加： pulseaudio --start --log-target=syslog 当在“系统设置”中出现“伪声音”时，且无法实际调节声音时： apt install pavucontrol pavucontrol 系统正常耳机没有声音 参考网址：http://www.linuxdiyf.com/linux/25529.html 终端运行 alsamixer 按M键把关闭的都大开（关闭的都显示的是MM），然后调节到合适的位置，白色为宜 最后一项Independ显示为ON表示耳机和音箱只能有一个有声音，按M键关闭则表示耳机和音箱可以同时有声音 （–未进行测试–） 若耳机还是没声音，可是试着运行 gedit /etc/modprobe.d/alsa-base.conf 在最后一行加入 #enable headphoneoptions snd-hda-intel power_save=10 power_save_controller=N model=6stack-dig 然后运行 apt-get remove alsa-base 然后重启 shutdown -r now 重启后运行 apt-get install alsa-base ubuntu16.04系统字体变成方框问题进入到字体的目录下/usr/share/fonts/，输入下面的命令： cd /usr/share/fonts/ 制作ubuntu16.04app启动图标 2016年12月15日15:40:42 在文件所在目录下新建一个Studio.desktop文件,并用gedit打开,然后将下面的内容复制进去并修改. [Desktop Entry] Name=应用的名称 Type=Application（不改） Icon=你的AndroidStudio解压目录的绝对路径/android-studio/bin/studio.png Exec=sh 你的AndroidStudio解压目录的绝对路径/android-studio/bin/studio.sh 保存退出(注意：每一行后面都不能有空格,否则失败) 右键该文件–&gt;属性–&gt;权限–&gt;选择“允许作为程序执行文件”,此时发现图标变了,双击打开App 安装ADB 2017年01月30日 星期一 15时57分56秒 参考： http://www.itdadao.com/articles/c15a299707p0.html http://www.jianshu.com/p/8768e5bccfa8 若apt-get install 失败： sudo add-apt-repository ppa:phablet-team/tools (原始ppa更好) sudo apt-get update sudo apt-get install android-tools-adb 出现异常： E: 无法获得锁 /var/lib/dpkg/lock – open (11: 资源临时不可用) E: 无法对管理目录(/var/lib/dpkg/)加锁，是不是另一个包管理程序在使用它？ 解决办法： 删除有问题的文件 安装 JDK + Eclipse + Apache Tomcat 2016年12月14日15:32:34以下省略“sudo”命令表示是在root权限下运行的 JDK8 （下载地址） http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz 在所在的文件夹目录下，可以直接打开terminal，跳过以下两句操作，直接进行环境配置 cd /Downloads tar -zxvf jdk-8u101-linux-x64.tar.gz 3.配置环境变量 gedit /etc/profile 在文件末尾添加以下内容： export JAVA_HOME=/home/lt/Java/jdk1.8.0_101(你的Jdk目录) export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 更新文件（必须执行） source /etc/profile notice！若在终端中出现:程序 ‘javac’ 已包含在下列软件包中： update-alternatives --install /usr/bin/javac javac /root/文档/jdk1.8.0_112/bin/javac 300 update-alternatives --install /usr/bin/java java /root/文档/jdk1.8.0_112/bin/java 300 Eclipse（eclipse安装工具） （下载地址） https://www.eclipse.org/downloads/download.php?file=/oomph/epp/neon/R/eclipse-inst-linux64.tar.gz 解压 tar -zxcf eclipse-inst-linux64.tar.gz 进入解后目录下,双击eclipse.inst运行安装程序 若有安装错误执行 mkdir jre cd jre ln -s （你的JDK目录/bin bin） Tomcat9 （下载地址） http://tomcat.apache.org/download-90.cgi 在所在的文件夹目录下，可以直接打开terminal，跳过以下两句操作，直接进行环境配置 cd Downloads/ unzip apache-tomcat-9.0.0.M9.zip 配置环境变量： export CATLINA_HOME=/home/lt/Java/apache-tomcat-9.0.0.M9（文件所在路径） sourse /etc/profile 安装MySQL+WorkBrench 2016年12月15日15:54:09 以下省略“sudo”命令表示是在root权限下运行的 ubuntu16.04安装mysql5.7未用sudo apt-get update未用sudo apt-get upgrade apt-get install mysql-server mysql-client apt-get install libmysqlclient-dev 自动安装会装上5.7的client端，中间会弹出提示框输入root的密码 安装完成之后检查是否成功。socket处于 listen 状态则表示安装成功 netstat -tap | grep mysql 未用sudo groupadd mysql未用sudo useradd -r -g mysql mysql 修改密码 未用sudo /usr/bin/mysqladmin -u root password 登陆mysql数据库可以通过如下命令： mysql -u root -p -u 用户名， -p 用户密码，输入后提示输入密码，此时输入密码就可以登录到mysql 安装客户端apt-get install mysql-workbench 安装RabbitVCS 2017年02月06日 星期一 14时04分24秒参考：http://blog.csdn.net/catshitone/article/details/48022315 注： 安装完毕后，注销LogOut，重新登录，在文件夹和文件夹内点击鼠标右键就用RabbitVCS操作工具了。 如果不能正常运行则输入： sudo apt-get install python-nautilus python-configobj python-gtk2 python-glade2 python-svn python-dbus python-dulwich subversion meld 再次更新软件包库： sudo apt-get update 注销LogOut，重新登录即可。 安装Terminator 2017年02月06日 星期一 15时53分34秒参考： http://www.jianshu.com/p/cee2de32ca28 安装： apt-get install terminator 卸载： apt-get remove terminator 快捷键(自定义之后的): 水平分割终端 : Ctrl+O 垂直分割终端 : Ctrl+E 搜索 : Ctrl+F 复制 : Ctrl+C 粘贴 : Ctrl+V clear屏幕 : Ctrl+G 关闭当前终端 : Ctrl+W 退出当前窗口 : Ctrl+Q 变化当前窗口位置 ：super+R 全屏状态 : F11 在垂直分割的终端中将分割条向右移动 :Ctrl+Right 在垂直分割的终端中将分割条向左移动 :Ctrl+Left 隐藏/显示滚动条 :Ctrl+Shift+S 配置文件（可参考）： [global_config] handle_size = -3 enabled_plugins = CustomCommandsMenu, LaunchpadCodeURLHandler, APTURLHandler, LaunchpadBugURLHandler title_transmit_fg_color = &quot;#000000&quot; suppress_multiple_term_dialog = True title_transmit_bg_color = &quot;#3e3838&quot; inactive_color_offset = 1.0 [keybindings] [profiles] [[default]] palette = &quot;#000000:#5a8e1c:#2d5f5f:#cdcd00:#1e90ff:#cd00cd:#00cdcd:#e5e5e5:#4c4c4c:#868e09:#00ff00:#ffff00:#4682b4:#ff00ff:#00ffff:#ffffff&quot; background_image = &quot;&quot; background_darkness = 0.68 scrollback_lines = 3000 background_type = transparent use_system_font = scroll_background = False show_titlebar = False cursor_shape = ibeam font = Liberation Mono 12 background_color = &quot;#0e2424&quot; foreground_color = &quot;#e8e8e8&quot; [layouts] [[default]] [[[child1]]] type = Terminal parent = window0 profile = default [[[window0]]] type = Window parent = &quot;&quot; size = 925, 570 [plugins] ubuntu安装Wine 参考：http://www.ubuntukylin.com/ukylin/forum.php?mod=viewthread&amp;tid=27068 安装源 sudo add-apt-repository ppa:wine/wine-builds sudo apt-get update 安装wine apt-get install wine1.8 卸载wine 1).卸载wine主程序，在终端里输入： sudo apt-get remove --purge wine 2).然后删除wine的目录文件： rm -r ~/.wine 3).卸载残留不用的软件包： sudo apt-get autoremove 终端中输入wine，检测是否安装完成 ubuntu安装WebStorm 2017年02月16日 星期四 12时31分00秒 参考：https://quanru.github.io/2016/04/17/%E4%BD%BF%E7%94%A8%20Linux%20%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91Web%E5%89%8D%E7%AB%AF/webstorm使用快捷键参考： http://blog.csdn.net/zghekuiwu/article/details/54382145 https://github.com/damao/Intellij-IDEA-F2E#%E6%B3%A8%E5%86%8C 下载： http://www.jetbrains.com/webstorm/index.html 解压下载的 gz 包，在bin/下运行： ./webstorm.sh WebStorm 默认情况下是需要收费的，可以申请为开源项目的贡献者来获得 licenses。 安装完成后，在 File - Settings - Plugins，选择需要安装的插件，例如 AngularJS、Markdown 等。 在 File - Settings - Directories 下，通过 Add content Root 来设置我们的项目路径 在 File - Settings - JavaScript - Libraries 下，勾选想要支持的库，建议全部勾上（如 NodeJS）。 在 File - Settings - Editor - Colors &amp; Fonts - Font 下，选择自己想要的主题， 然后 Save as… 保存自己想要的主题名称，设置字体为Ubuntu Mono， 字体设置为 16（貌似有点小，相当于 Eclipse 下的 12） 在 File - Settings - Appearance 下，勾选 Show line numbers 选项。 破解方式：选择line server 方式，输入： http://idea.iteblog.com/key.php 安装ubuntu主题 2016年12月15日14:54:25 安装主题管理工具： apt-get install unity-tweak-tool 安装主题 apt-add-repository ppa:numix/ppa apt-get update apt-get install numix-icon-theme-circle //安装图标 apt-get install numix-gtk-theme //安装主题 安装docky（Mac桌面下方的启动器） 参考网址：http://www.aichengxu.com/view/992905参考网址：http://www.noobslab.com/2014/11/mbuntu-macbuntu-1410-transformation.html install docky add-apt-repository ppa:docky-core/ppa apt-get update apt-get install docky apt-get remove docky docky 安装XX-Net 2017年02月04日 星期六 17时17分36秒 安装xx-net 安装firefox或者chrome 设置： 系统设置 --&gt; 网络 --&gt; 网络代理 --&gt; 方法：自动 配置：http://127.0.0.1:8086/proxy.pac 全局配置 重点： 此项目来自GitHub，可以直接clone到本地 需要使用到Google AppID，以此进行服务器部署，以达到真正上网的目的 使用host科学上网 2016年12月15日16:04:07使用host文件进行翻墙参考链接：https://laod.cn/hosts/2016-google-hosts.html 安装sbulime text3 2017年 01月 28日 星期六 15:05:31 CST安装参考： http://www.cnblogs.com/unflynaomi/p/5704293.html 汉化，中文输入问题参考： http://blog.csdn.net/u013453604/article/details/48002127 汉化，无法输入中文资源： http://download.csdn.net/detail/u013453604/9049633 不能输入中文问题参考： http://www.cnblogs.com/mo-wang/p/5120484.html（步骤不全，修改的内容全面） http://www.liuqianfei.com/article/3e51f07d254b464995b0f4c94cc1d69c（步骤全面） 配置java，python，markdown： http://www.jianshu.com/p/58bf9e4d5b32 安装步骤： sudo add-apt-repository ppa:webupd8team/sublime-text-3 sudo apt-get update sudo apt-get install sublime-text-installer 安装：python3 apt install python3-pip 卸载 sublime text 命令： sudo apt-get remove sublime-text-installer 启动sublime text3 在terminal终端中输入：subl 打开指定的文件： subl 文件名 解决sublime无法输入中文的问题在进行所有操作时首先进行依赖包的安装：代码依赖于 gtk 2.0，编译 c 需要安装 build-essential。 sudo apt-get install build-essential libgtk2.0-dev 如果路径中含有空格，你必须使用双引号将路径括起来： $ subl &amp;quot;~/Documents/test/my test file.txt&amp;quot; 解决无法输入中文问题 - 2017年03月12日 星期日 15时17分24秒 参考：http://www.jianshu.com/p/03a9092c73e2亲测有效！ 解决事件输入问题 参考：https://my.oschina.net/antsky/blog/491146 WPS字体缺失 下载缺失的字体文件，然后复制到Linux系统中的/usr/share/fonts文件夹中。 国外下载地址：https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip 国内下载地址：https://pan.baidu.com/s/1eS6xIzosudo cp * /usr/share/fonts 执行以下命令,生成字体的索引信息： sudo mkfontscale sudo mkfontdir 运行fc-cache命令更新字体缓存。 sudo fc-cache 重启wps即可，字体缺失的提示不再出现。 WPS不能输入中文问题 参考:http://forum.ubuntu.org.cn/viewtopic.php?f=48&amp;t=476937原因：环境变量未正确设置，以上可以直接针对wps设置。 解决办法,终端输入: gedit /usr/bin/wps 在此文件中输入一下内容,#!/bin/bash之后: export XMODIFIERS=&quot;@im=fcitx&quot; export QT_IM_MODULE=&quot;fcitx&quot; 安装WeChat 2016年12月13日22:43:53 安装linux微信： 下载地址:https://github.com/geeeeeeeeek/electronic-wechat/releases apt-get install git git clone https://github.com/geeeeeeeeek/electronic-wechat.git cd electronic-wechat apt-get install npm apt-get install nodejs-legacy npm install &amp;&amp; npm start 官方推荐的安装方法： To clone and run this repository you’ll need Git and Node.js (which comes with npm) installed on your computer. From your command line: Clone this repository git clone https://github.com/geeeeeeeeek/electronic-wechat.git# Go into the repositorycd electronic-wechat# Install dependencies and run the app npm install &amp;&amp; npm start To pack into an app, simply type one of these: npm run build:osx npm run build:linux]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alias 的使用]]></title>
    <url>%2FAlias%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[所有命令均在ubuntu16.04环境下完成，在不同环境下可能会有差异 alias介绍alias用于自定义快捷命令，避免总是使用相同的，重复的，冗长的命令来执行操作 alias的用法1.添加新的自定义快捷方式 alias 自定义新名字=&quot;操作命令&quot; 示例：将进入文档目录的命令定义为 cdd 新命令 alias cdd=&quot;cd /root/文档/&quot; 2.删除自定义的快捷方式： unalias 自定义新名字 示例：删除 cdd 新命令 unalias cdd 3.查询自定义快捷方式： alias alias的存储注： 若不保存在文件中，则只能在当前的`terminal`中使用,只有保存到文件中后才能供以后继续使用 来自～/.bashrc文档的介绍 Alias definitions.You may want to put all your additions into a separate file like ~/.bash_aliases, instead of adding them here directly. See /usr/share/doc/bash-doc/examples in the bash-doc package. 使用以下方式，将自定义的快捷键存入系统已有文件中。此文件位于/root/下: vim ~/.bashrc 使用以下方式，将自定义的快捷键存入”指定”的新文件中。此文件位于/root/下: vim ~/.bash_aliases 注： 对于以上两中方式，必须使用： source ~/.bash_aliases 命令更新文件，否则自定义快捷键将不会被找到，无法起作用。 个人快捷命令组合：alias ll=&apos;ls -l&apos; alias la=&quot;ls -la&quot; alias ohb=&apos;open /Users/yannischeng/HexoBLog/&apos; alias ohbs=&apos;open /Users/yannischeng/HexoBLog/source/_posts&apos; alias oup=&apos;open /Users/yannischeng/.bash_profile&apos; alias chbl=&apos;cd /Users/yannischeng/HexoBLog&apos; alias chbsl=&apos;cd /Users/yannischeng/HexoBLog/source/_posts&apos; alias cup=&apos;cd /Users/yannischeng/&apos; alias sup=&apos;source .bash_profile&apos; alias om=&apos;open /Applications/MWeb.app&apos; alias oas=&apos;open /Applications/&quot;Android Studio&quot;.app&apos; alias osb=&apos;open /Applications/&quot;Sublime Text&quot;.app&apos; alias ogc=&apos;open /Applications/&quot;Google Chrome&quot;.app&apos;]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略者模式]]></title>
    <url>%2F%E7%AD%96%E7%95%A5%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[仅仅知道抽象、继承、多态、封装并不会马上让你变成好的面向对象设计者。设计大师关注的是弹性、可维护、可应付改变的设计。 软件开发的一个不变真理：CHANGE。 策略模式（Strategy Pattern）定义：定义算法族（一组行为），分别封装起来（定义成为不同的接口），让他们之间可以互相替换。 此模式让算法之间的变化（写成接口）独立于算法的使用者（调用类）。 OO设置原则： 封装变化: a)找出应用中可能需要变化之处，把他们独立出来——封装，不要和固定的代码混在一起。 b)把会变化的部分取出并封装起来，以后便可以轻易的改动活着扩充此部分，而不影响不需要变化的部分（每个设计模式背后的精神所在）。 针对接口编程（针对超类型编程），而不是针对实现编程： a)针对接口编程：关键是利用多态（运行时动态的改变行为）。 b)针对超类型编程：变量的声明类型应该是超类型（一个抽象类或一个接口） 多用组合，少用继承： “有一个”可能比“是一个”好。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
