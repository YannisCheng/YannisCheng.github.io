<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin-协程4-共享的可变状态与并发]]></title>
    <url>%2FKotlin-%E5%8D%8F%E7%A8%8B4-%E5%85%B1%E4%BA%AB%E7%9A%84%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E4%B8%8E%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Kotlin-协程4-共享的可变状态与并发 参考： 共享的可变状态与并发]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-协程3-通道]]></title>
    <url>%2FKotlin-%E5%8D%8F%E7%A8%8B3-%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[Kotlin-协程3-通道 参考： 通道]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-协程2-异步流]]></title>
    <url>%2FKotlin-%E5%8D%8F%E7%A8%8B2-%E5%BC%82%E6%AD%A5%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Kotlin-协程2-异步流 参考： 异步流]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-协程1-基础]]></title>
    <url>%2FKotlin-%E5%8D%8F%E7%A8%8B1-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Kotlin-协程1-基础 协程 是 计算机程序组件，通过允许挂起 和 恢复 执行 来概括 非抢占式多任务 处理的 子例程。 参考： 协程基础取消与超时组合挂起函数协程上下文与调度器 Kotlin 是一门仅在 标准库 中提供 最基本底层 API 以便各种 其他库 能够利用 协程 的语言。async 与 await 在 Kotlin 中并不是关键字，甚至都不是标准库的一部分。Kotlin 的 挂起函数（suspending function） 概念为 异步 操作提供了比 future 与 promise 更安全、更不易出错的抽象。 kotlinx.coroutines 是由 JetBrains 开发的功能丰富的协程库。 CoroutineScopeGlobalScopeDispatchersCoroutineContextJobThreadLocalThreadContextElementFlowSequenceChannel互斥 MutexActors Deferred]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-协程-概念]]></title>
    <url>%2FKotlin-%E5%8D%8F%E7%A8%8B-%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Kotlin-协程 对于 异步 或 非阻塞 编程的现实，在 Kotlin 中采取了一种非常灵活的方法，即：在 语言级别 提供Coroutine（协程） 支持，并将大多数功能 委托给库，这与 Kotlin 的哲学非常一致。 协程维基百科 1Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes. 翻译 协程 是 计算机程序组件，通过允许挂起 和 恢复 执行 来概括 非抢占式多任务 处理的 子例程。 协程 非常适合于实现熟悉的程序组件，例如协作任务，异常，事件循环，迭代器，无限列表和管道。 关键词：非抢占式多任务、并发、 切换 无需任何 系统调用 或 阻塞调用 协程？线程？释义维基百科 123Coroutines are very similar to threads. However, coroutines are cooperatively multitasked, whereas threads are typically preemptively multitasked. This means that coroutines provide concurrency but not parallelism. The advantages of coroutines over threads are that they may be used in a hard-realtime context (switching between coroutines need not involve any system calls or any blocking calls whatsoever), there is no need for synchronisation primitives such as mutexes, semaphores, etc. in order to guard critical sections, and there is no need for support from the operating system.It is possible to implement coroutines using preemptively-scheduled threads, in a way that will be transparent to the calling code, but some of the advantages (particularly the suitability for hard-realtime operation and relative cheapness of switching between them) will be lost. 翻译： 协程 与 线程 非常相似。 但是： 协程 ： 协作式 多任务 。提供 并发性，但 不 提供 并行性。 线程 ： 抢先式 多任务。 协程 相比于 线程 的 优点是： 其可以在 硬实时（Real-time computing） 上下文中使用（协程 之间的 切换 不需要任何 系统调用 或任何 阻塞调用） 不需要同步原语，例如互斥体，信号量等。 为了保护关键部分，并且 不需要操作系统的支持。 可以使用抢先调度的线程来实现协程，这种方式对于调用代码将是透明的，但是某些优点（尤其是对硬实时操作的适用性以及在它们之间进行切换的相对便宜）将丢失。 概念解释抢占（Preemption）维基百科 1In computing, preemption is the act of temporarily interrupting a task being carried out by a computer system, without requiring its cooperation, and with the intention of resuming the task at a later time. Such changes of the executed task are known as context switches. It is normally carried out by a privileged task or part of the system known as a preemptive scheduler, which has the power to preempt, or interrupt, and later resume, other tasks in the system. 翻译 在计算中，抢占 是 暂时 中断 计算机系统 正在执行 的 任务 而 无需其配合，并打算在 以后恢复该任务 的 行为。 执行任务的 此类更改 称为 上下文切换。 它通常由 特权任务 或 系统 的一部分（称为抢先调度程序）执行，该任务可以 抢占 或 中断 系统中的其他任务，或在 以后继续执行其他任务。 多任务（multitasking）在计算中，多任务处理 是在一定时间内 并发执行 多个任务（也称为流程）。 新任务 可以在 完成之前 中断已经开始的任务，而不是等待它们结束。结果，计算机以 交错 的方式执行 多个任务 的 分段，同时任务 共享 诸如中央处理单元（CPU）和主存储器之类的 公共处理资源。 多任务 自动中断 正在运行的程序，保存其状态（部分结果，存储器内容和计算机寄存器内容），并加载 另一个程序 的 保存状态 并将 控制权 转移给它。 该 上下文切换 可以按： 固定的 时间间隔 启动（抢先式多任务处理）， 对 正在运行 的程序 进行编码，以使其在 被中断 时向 监控软件 发送信号（协作式多任务处理）。 多任务 不需要 完全同时并行 执行 多个任务。相反，它允许在给定的 时间段内 执行 多个任务。即使在多处理器计算机上，多任务处理 也可以运行比CPU多得多的任务。 多任务处理 是计算机操作系统的常见功能。它可以 更有效地使用计算机硬件。 并发（Concurrency）在计算机科学中，并发 是 无序 或部分顺序 执行程序、算法或问题的不同部分或单元的能力，而不会影响最终结果。这允许 并行执行 并发单元，这可以显着提高 多处理器 和 多核系统 中执行的 整体速度。 用更多的技术术语来说： 并发是指 程序、算法或问题的可分解性，可以分解为 与顺序无关 或 部分有序 的 组件或单元 餐饮哲学家的问题 并行（Parallel） 背景： 传统上，计算机软件是为 串行计算 编写的。为了解决问题，将算法构造并实现为 指令的串行流。这些指令在一台计算机的中央处理单元上执行。一次 只能执行 一条指令-该指令完成后，将执行下一条指令。 另一方面，并​​行计算 同时 使用 多个处理元素 来解决问题。这是通过 将问题分解 为 独立的部分 来实现的，以便 每个处理元素 可以与 其他元素 同时执行。 处理元素 可以是多种多样的，并且可以包括资源，例如具有多个处理器的单台计算机，数台联网的计算机，专用硬件或上述各项的任意组合。 并行计算： 并行计算 是在 一种类型的计算中，许多计算 或 执行过程 是同时进行 的。大问题 通常可以 分为小问题，然后 可以同时解决。 并行计算 有几种不同的形式：位级、指令级、数据 和 任务并行。 并行技术 长期以来一直用于高性能计算 中。 并行计算 与 并发计算 区别： 在 并行计算 中：通常将计算任务 分解 为几个，通常是 很多非常相似 的 子任务，这些 子任务 可以 独立处理，并在完成后将其 结果合并。 在 并发计算 中：各种过程通常 不解决相关任务。当他们这样做时，这在 分布式计算 中很常见，各个任务 的 性质 可能有所 不同，并且在执行过程中通常需要进行一些 进程间的通信。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-About]]></title>
    <url>%2FKotlin-About%2F</url>
    <content type="text"><![CDATA[Kotlin是啥 Kotlin 的 多平台 就是：就是通过expect/actual（预期声明/实际声明）机制来实现代码共享` Kotlin-支持多平台开发可使用 Kotlin开发Android、iOS、后端 、原生和 Web应用程序 。享受在平台之间 共享通用代码 的好处。 Kotlin/Native 支持以下平台： iOS（arm32、 arm64、 模拟器 x86_64） macOS（x86_64） watchOS (arm32、 arm64、 x86) tvOS (arm64、 x86_64) Android（arm32、arm64、 x86、 x86_64） Windows（mingw x86_64、 x86） Linux（x86_64、 arm32、 arm64、 MIPS、 MIPS 小端次序） WebAssembly（wasm32） 多平台编程多平台编程 有了对 JVM、Android、JavaScript、iOS、Linux、Windows、 Mac 甚至像 STM32 这样的嵌入式系统的支持，Kotlin 可以处理现代应用程序的 任何组件 与 所有组件。 这为 代码 与 专业知识 的 复用 带来了宝贵的收益，节省了工作量去完成更具挑战任务，而不是将所有东西都实现两次或多次。 多平台如何工作？多平台 并不是为 所有平台 编译全部代码。这个模型有其明显的局限性，我们知道现代应用程序需要访问其所运行平台的独有特性。Kotlin 并不会限制你只使用其中所有 API 的公共子集。 每个组件都可以根据需要与其他组件 共享 尽可能多的 代码， 而通过语言所提供的 expect/actual机制 可以随时访问平台 API。 Multiplatform Programming - 特定于平台的声明（Platform-Specific Declarations）特定于平台的声明 原文 One of the key capabilities of Kotlin&#39;s multiplatform code is a way for common code to depend on platform-specific declarations. 翻译 Kotlin 的 多平台代码 的关键功能之一是使 通用代码 依赖 于 特定于平台 的 声明方式。 原文 As an alternative, Kotlin provides a mechanism of expected and actual declarations. With this mechanism, a common module can define expected declarations, and a platform module can provide actual declarations corresponding to the expected ones. 翻译 作为替代方案（在 通用代码 中 构建一组接口），Kotlin 提供了 预期声明 和 实际声明 的机制。通过这种机制，通用 公共模块 定义预期声明，而具体 平台模块 可以提供与 期望声明 相对应的 实际声明。 如果使用其他语言的方案来实现多平台，它们通常在 通用代码 中 构建一组接口，然后在 对应平台 的 特定模块 中 实现这些接口。 但是这样的实现存在2个问题： 如果在实现所需功能的平台上有一个 库，并且希望 直接使用 该库的API而无需额外的包装程序，则这种方法（构建并实现接口）并不理想。 它要求将公共声明表示为接口，但是这些接口并 不能涵盖所有可能的情况。 示例官网示例此代码是公共模块的一部分： 123456789package org.jetbrains.fooexpect class Foo(bar: String) &#123; fun frob()&#125;fun main() &#123; Foo("Hello").frob()&#125; 这是相应的 JVM模块： 1234567package org.jetbrains.fooactual class Foo actual constructor(val bar: String) &#123; actual fun frob() &#123; println("Frobbing the $bar") &#125;&#125; 要点： 公共模块 中的 预期声明 与其对应的 实际声明 始终具有 完全相同 的 完整限定名。 预期声明 标有 expect 关键字；实际声明 标有 actual 关键字。 与 预期声明 匹配的任何 实际声明 都要标记为 actual。 预期声明 决 不包含任何实现代码。 预期声明 并不限于 接口 与 接口成员。 如果具有要在 通用代码 中使用的 特定于平台的库，同时为另一个平台提供自己的实现，则可以为 现有类提供类型别名 作为实际声明。如： 1234567expect class AtomicRef&lt;V&gt;(value: V) &#123; fun get(): V fun set(value: V) fun getAndSet(value: V): V fun compareAndSet(expect: V, update: V): Boolean&#125;actual typealias AtomicRef&lt;V&gt; = java.util.concurrent.atomic.AtomicReference&lt;V&gt; ArrayList 示例：预期声明 1expect class ArrayList&lt;E&gt; : MutableList&lt;E&gt;, RandomAccess &#123;&#125; 实际声明 123456789package kotlin.collections@SinceKotlin("1.1") public actual typealias RandomAccess = java.util.RandomAccess@SinceKotlin("1.1") public actual typealias ArrayList&lt;E&gt; = java.util.ArrayList&lt;E&gt;@SinceKotlin("1.1") public actual typealias LinkedHashMap&lt;K, V&gt; = java.util.LinkedHashMap&lt;K, V&gt;@SinceKotlin("1.1") public actual typealias HashMap&lt;K, V&gt; = java.util.HashMap&lt;K, V&gt;@SinceKotlin("1.1") public actual typealias LinkedHashSet&lt;E&gt; = java.util.LinkedHashSet&lt;E&gt;@SinceKotlin("1.1") public actual typealias HashSet&lt;E&gt; = java.util.HashSet&lt;E&gt;]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-集合]]></title>
    <url>%2FKotlin-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[数组 Kotlin数组是一个带有类型参数的类，其元素类型被指定为相应的类型参数。 vararg关键字：参数数量可变 创建数组 arrayOf函数，该函数的实参作为数组的元素； arrayOfNulls函数，创建一个给定大小的数组，包含的是null值。一般用来创建元素类型可空的数组； Array构造方法，接收一个数组的大小和lambda表达式。lambda表达式用来创建每一个数组元素，不能显式地传递每一个元素。 集合与数组的转换1234567val list = listOf("daqi","java","kotlin")//集合转数组list.toTypedArray()val array = arrayOf("")//数组转集合array.toList() 装箱与非装箱Array类的类型参数决定了创建的是一个基本数据类型装箱的数组。当需要创建没有装箱的基本数据类型的数组时，必须使用基本数据类型数组。Kotlin为每一种基本数据类型提供独立的基本数据类型数组。例如：Int类型的数组叫做IntArray。基本数据类型数组会被编译成普通的Java基本数据类型的数组，如int[]。因此基本数据类型数组在存储值时并没有装箱。 集合参考 继承关系：MutableCollection -&gt; Collection -&gt; Iterable Kotlin 直接使用的是 原生 Java 集合 可变与不可变Kotlin与Java最大的不同之一就是：Kotlin将集合分为只读和可变集合。 这种区别源自最基础的集合接口：kotlin.collections.Collection。该接口可以对集合进行一些基本操作，但无任何添加和移除元素的方法。 1234567public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123; public val size: Int public fun isEmpty(): Boolean public operator fun contains(element: @UnsafeVariance E): Boolean override fun iterator(): Iterator&lt;E&gt; public fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean&#125; 只有实现 kotlin.collections.MutableCollection 接口才可以修改集合的数据。MutableCollection 接口继承自 Collection，并提供 添加、移除 和 清空 集合元素的方法。 123456789public interface MutableCollection&lt;E&gt; : Collection&lt;E&gt;, MutableIterable&lt;E&gt; &#123; override fun iterator(): MutableIterator&lt;E&gt; public fun add(element: E): Boolean public fun remove(element: E): Boolean public fun addAll(elements: Collection&lt;E&gt;): Boolean public fun removeAll(elements: Collection&lt;E&gt;): Boolean public fun retainAll(elements: Collection&lt;E&gt;): Boolean public fun clear(): Unit&#125; 创建 集合类型 只读 可变 List listOf mutableList、arrayListOf Set setOf mutableSetOf、hashSetOf、linkedSetOf、sortedSetOf Map mapOf mutableMapOf、hashMapOf、linkeMapOf、sortedMapOf 测试代码： 使用在Java类中编写一些打印集合类型的静态方法： 1234567public static void collectionsType(Collection collection)&#123; System.out.println(collection.getClass().getName());&#125;public static void mapType(Map map)&#123; System.out.println(map.getClass().getName());&#125; 在Kotlin中创建只读集合和可变集合，并将其传入之前声明的Java静态方法中进行打印： 1234567891011121314151617181920212223242526val emptyList = listOf&lt;Int&gt;()val emptySet = setOf&lt;Int&gt;()val emptyMap = mapOf&lt;Int,Int&gt;()val initList = listOf(1)val initSet = setOf(2)val initMap = mapOf(1 to 1)val list = listOf(1,2)val set = setOf(1,2)val map = mapOf(1 to 1,2 to 2)//-------val emptyMutableList = mutableListOf&lt;Int&gt;()val emptyMutableSet = mutableSetOf&lt;Int&gt;()val emptyMutableMap = mutableMapOf&lt;Int,Int&gt;()val initMutableList = mutableListOf(1)val initMutableSet = mutableSetOf(2)val initMutableMap = mutableMapOf(1 to 1)val mutableList = mutableListOf(1,2)val mutableSet = mutableSetOf(1,2)val mutableMap = mutableMapOf(1 to 1,2 to 2) 运行结果： 12345678910111213141516171819202122232425空元素只读集合kotlin.collections.EmptyListkotlin.collections.EmptySetkotlin.collections.EmptyMap单元素只读集合java.util.Collections$SingletonListjava.util.Collections$SingletonSetjava.util.Collections$SingletonMap多元素只读集合java.util.Arrays$ArrayListjava.util.LinkedHashSetjava.util.LinkedHashMap--------------------------------------空元素可变集合java.util.ArrayListjava.util.LinkedHashSetjava.util.LinkedHashMap单元素可变集合java.util.ArrayListjava.util.LinkedHashSetjava.util.LinkedHashMap多元素可变集合java.util.ArrayListjava.util.LinkedHashSetjava.util.LinkedHashMap 集合使用的注意事项 优先使用只读集合，只有在需要修改集合的情况下才使用可变集合。 只读集合不一定是不可变的。如果你使用的变量是只读接口的类型，该变量可能引用的是一个可变集合。因为只读接口Collection是所有集合的”基类” 只读集合并不总是线程安全的。如果需要在多线程环境中处理数据，必须使用支持并发访问的数据结构。 型变 与 可空性只读集合类型是型变的。可变集合是不可型变的。 扩展支持]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack-WorkManager]]></title>
    <url>%2FJetpack-WorkManager%2F</url>
    <content type="text"><![CDATA[Jetpack-WorkManager：满足后台调度需求。官网定义：使用 WorkManager API 可以轻松地调度即使在 应用退出 或 设备重启 时 仍应运行的可延迟异步任务。 后台处理指南参考 每个 Android 应用都有一个主线程，负责处理界面（包括测量和绘制视图）、协调用户互动以及接收生命周期事件。如果有太多工作在主线程中进行，则应用可能会挂起或运行速度变慢，从而导致用户体验不佳。 任何长时间运行的计算和操作（例如解码位图、访问磁盘或执行网络请求）都应在 单独的后台线程 上完成。 一般来说，任何所需时间 超过几毫秒 的任务都应该分派到 后台线程。 后台处理存在的问题后台任务会使用设备的有限资源，例如 RAM 和电池电量。 为了最大限度地 延长电池续航时间 并强制推行良好的应用行为，Android 会在应用（或前台服务通知）对用户不可见时，限制后台工作。 Android 6.0（API 级别 23）引入了 低电耗模式 和 应用待机模式。 低电耗模式 ：会在屏幕处于关闭状态且设备处于静止状态时限制应用行为。 应用待机模式：会将未使用的应用置于一种特殊状态，进入这种状态后，应用的网络访问、作业和同步会受到限制。 Android 7.0（API 级别 24）：限制了隐式广播，并引入了随时随地使用低电耗模式。 Android 8.0（API 级别 26）：进一步限制了后台行为，例如在后台获取位置信息和释放缓存的唤醒锁定。 Android 9（API 级别 28）：引入了应用待机存储分区，通过它，系统会根据应用使用模式动态确定应用资源请求的优先级。 如何选择合适的解决方案 工作可以延迟，还是需要立即执行？ 例如，如果需要从网络中提取一些数据以对用户点击按钮的操作作出响应，则必须立即执行该工作。但是，如果希望将日志上传到服务器，则可以延迟执行该工作，而不会影响应用的性能或用户期望。 工作是否依赖系统条件？ 可能希望仅在设备满足特定条件（例如连接到电源、连接到互联网等）时运行作业。例如，应用可能需要定期压缩存储的数据。为避免对用户造成影响，因此可能会希望仅在设备充电和处于闲置状态时运行该作业。 作业是否需要在确切的时间运行？ 日历应用可能会允许用户为事件设置在特定时间触发的提醒。用户希望在正确的时间看到提醒通知。在其他情况下，应用可能不会关注作业的确切运行时间。应用可能会有常规要求，例如“必须先运行作业 A，然后运行作业 B、作业 C”，但不要求作业在特定时间运行。 4种方案WorkManager 对于可延迟的工作以及预计即使设备或应用重启也会运行的工作，请使用 WorkManager，其可在满足工作的条件（例如网络可用性和电源）时妥善运行可延迟的后台工作。 WorkManager 提供向后兼容的 API（兼容 API 级别 14 及更高级别），利用 ： JobScheduler API（API 级别 23 及更高级别）帮助优化更低级别设备上的电池续航时间、批量作业。 AlarmManager 和 BroadcastReceiver 的组合。 前台服务对于需要立即运行并且必须执行完毕的由用户发起的工作，请使用前台服务。使用前台服务可告知系统应用正在执行重要任务，不应被终止。前台服务通过通知栏中的不可关闭通知向用户显示。 AlarmManager如果您需要在确切的时间运行某项作业，则使用 AlarmManager。其会在您指定的时间启动应用（如有必要），以便运行该作业。但是，如果作业不需要在确切的时间运行，则 WorkManager 是更好的选择，其能更好地平衡系统资源。例如，如果您需要大约每小时运行一次某项作业，但不需要在特定时间运行该作业，则应使用 WorkManager 设置周期性作业。 DownloadManager如果您的应用执行长时间运行的 HTTP 下载，考虑使用 DownloadManager。客户端可能会请求将 URI 下载到位于应用进程之外的特定目标文件中。内容下载管理器会在后台执行下载操作，它负责处理 HTTP 互动，在下载失败或连接发生更改以及系统重新启动后重新尝试下载。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android各个版本主要变更]]></title>
    <url>%2FAndroid%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E4%B8%BB%E8%A6%81%E5%8F%98%E6%9B%B4%2F</url>
    <content type="text"><![CDATA[Android各个版本主要变更 Android 4.4 KitKat，API 级别：19Android 5.0 Lollipop，API 级别：21；Android 5.1 (LOLLIPOP_MR1) ，API 级别：22Android 6.0 Marshmallow，API 级别：23Android 7.0 Nougat，API 级别：24；Android 7.1， API 级别：25Android 8.0 Oreo，API 级别 26；Android 8.1，API 级别 27Android 9 Pie，API 级别 28Android 10，API 级别 29 Android 4.4 KitKat，API 级别：19 打印框架 NFC 读取器模式 红外线发射器 场景和转场 外部存储空间访问 沉浸式全屏模式 透明系统状态栏 应用权限 Android 5.0 Lollipop，API 级别：21变更 ART 运行时取代 Dalvik 成为平台默认设置。Android 4.4 中已引入处于实验阶段的 ART 运行时。 预先 (AOT) 编译 改进的垃圾回收 (GC) 改进的调试支持 通知 Android NDK 中的 64 位支持 Android 6.0 Marshmallow，API 级别：23变更 运行时权限 低电耗模式 应用待机模式 取消支持 Apache HTTP 客户端，使用 HttpURLConnection 硬件标识符访问权 通知 WLAN 和网络连接变更 相机服务变更 ART 运行时环境 APK 验证 USB 连接 Android 7.0 Nougat ，API 级别：24变更 低电耗模式 Project Svelte：后台优化，移除了三项隐式广播 系统权限更改 在应用间共享文件。要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。 NDK 应用链接至平台库 Android 8.0 Oreo，API 级别 26变更 针对所有 API 级别的应用 后台执行限制 Android 后台位置限制 应用快捷键 语言区域和国际化 提醒窗口 网络连接和 HTTP(S) 连接 蓝牙 隐私性 联系人提供程序使用情况统计方法的变更 针对 Android 8.0 的应用 提醒窗口 内容变更通知 视图焦点 隐私性 权限 Android 9 Pie，API 级别 28变更-所有应用 电源管理 隐私权变更 对使用非 SDK 接口的限制 安全行为变更 现在强制执行 FLAG_ACTIVITY_NEW_TASK 要求 屏幕旋转变更 以 API 级别 28 及更高级别为目标的应用 前台服务 隐私权变更 Android 10，API 级别 29所有应用变更 限制非 SDK 接口 手势导航 NDK 应用使用情况 Android Beam 已弃用 摄像头变更 电池用量跟踪 ZIP 文件实用程序库变更 android.preference 库已弃用 应用使用情况 关于以旧版 Android 系统为目标平台的应用的警告 安全]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack-ViewBing]]></title>
    <url>%2FJetpack-ViewBing%2F</url>
    <content type="text"><![CDATA[Jetpack-ViewBing：替代 findViewById 在模块中启用 视图绑定 之后，系统会为该模块中的每个 XML布局文件 生成一个绑定类。绑定类的实例包含对在相应布局中 具有ID的所有视图 的 直接引用。 设置模块开启视图绑定 功能 可按模块启用。要在某个模块中启用视图绑定，请将 viewBinding 元素添加到其 build.gradle 文件中，如下例所示： 123456android &#123; ... viewBinding &#123; enabled = true &#125;&#125; 忽略某个视图如果想 忽略 某个布局文件将 tools:viewBindingIgnore=&quot;true&quot; 属性添加到相应 布局文件 的 根视图 中： 12345&lt;LinearLayout ... tools:viewBindingIgnore=&quot;true&quot; &gt; ...&lt;/LinearLayout&gt; 使用 获取xml文件对应的绑定类 为某个模块启用视图绑定功能后，系统会为该模块中包含的每个 XML布局文件 各生成一个 绑定类：将 XML 文件的 名称 转换为 驼峰式大小写，并在末尾添加 Binding 一词。如xml文件名：result_profile.xml，对应生成的绑定类名：ResultProfileBinding。 示例xml文件 12345678910111213141516171819&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;TextView android:id="@+id/tv_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TV" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_bias="0.3" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintVertical_bias="0.022" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 获取更布局 每个绑定类还包含一个 getRoot() 方法，用于为相应布局文件的根视图提供直接引用。在此示例中，ResultProfileBinding 类中的 getRoot() 方法会返回 ConstraintLayout 根视图。 设置布局 通过调用其静态 inflate() 方法能获取生成的 绑定类的实例。通常情况下还会调用setContentView() 将该绑定类的根视图作为参数进行传递，以使它成为屏幕上的活动视图。 界面view获取 在这个示例xml文件中，有一个id为tv_name的TextView，那么在绑定类中就存在一个对此id值对应的TextView的对象的引用。 代码中使用示例 12345678private lateinit var binding: ResultProfileBinding@Overridefun onCreate(savedInstanceState: Bundle) &#123; super.onCreate(savedInstanceState) binding = ResultProfileBinding.inflate(layoutInflater) setContentView(binding.root)&#125; 操作界面视图元素 12binding.name.text = viewModel.namebinding.button.setOnClickListener &#123; viewModel.userClicked() &#125; Kotlin中使用DataBinding遇到 Unresolved reference: databinding 添加插件 1apply plugin: &apos;kotlin-kapt&apos; 查看gradle版本号 12345buildscript &#123; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.6.1&apos; &#125;&#125; 添加依赖，版本号同第2步 123dependencies &#123; kapt &quot;com.android.databinding:compiler:3.6.1&quot;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack-DataBing]]></title>
    <url>%2FJetpack-DataBing%2F</url>
    <content type="text"><![CDATA[Jetpack-DataBing：以声明方式将可观察数据绑定到界面元素 使用 声明方式（而非程序化地）将布局中的 界面组件 绑定 到应用中的 数据源。 涉及内容： 使用入门 准备开发环境 布局和绑定表达式 借助 表达式 语言，可以将 变量 关联 到布局中的 视图。 一个xml文件示例： 123456789&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="viewmodel" type="com.myapp.data.ViewModel" /&gt; &lt;/data&gt; &lt;ConstraintLayout... /&gt; &lt;!-- UI layout's root element --&gt;&lt;/layout&gt; 在这个xml文件中与以往不同的是：根节点是layout，内部元素分为2类：&lt;data&gt;、&lt;View&gt; 使用可观察的数据对象 数据绑定库 可以生成用于访问布局变量和视图的绑定类。 生成的绑定类 绑定适配器 每一个 布局表达式 都有一个对应的 绑定适配器，要求必须进行 框架调用 来设置相应的 属性 或 监听器。 将布局视图绑定到架构组件 双向数据绑定 使用入门数据绑定库灵活、兼容性广，是一个支持库，因此可以运行在 Android 4.0（API 级别 14）或更高 的设备上。 代码库支持设置 123456android &#123; ... dataBinding &#123; enabled = true &#125;&#125; 布局和绑定表达式数据绑定库 会自动生成将 布局中的视图 与 数据对象绑定 的 类。 数据绑定布局文件以根标记 &lt;layout&gt; 开头，后跟 &lt;data&gt; 元素和 &lt;view&gt; 根元素。 数据绑定布局文件 示例文件： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="duck" type="com.yannis.myapplication.bean.DuckBean" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:layout_width="100dp" android:layout_height="40dp" android:text="@&#123;duck.duckName&#125;" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="40dp" android:text="@&#123;duck.duckColor&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; &lt;data&gt; 中的 duck变量 描述了可在此布局中使用的 属性。 12345 &lt;data&gt; &lt;variable name="duck" type="com.yannis.myapplication.bean.DuckBean" /&gt;&lt;/data&gt; 布局中的 表达式 使用 @{} 语法写入特性属性中。 1234&lt;TextView android:layout_width="100dp" android:layout_height="40dp" android:text="@&#123;duck.duckColor&#125;" /&gt; 注意：布局表达式 应保持精简，因为它们无法进行单元测试，并且拥有的 IDE 支持也有限。为了简化布局表达式，可以使用 自定义绑定适配器。 数据对象-data1data class DuckBean(var duckName: String, val duckColor: String) 绑定数据系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写形式 并在末尾添加 Binding 后缀。如：activity_main.xml 布局文件的绑定类型为 ActivityMainBinding。 在Activity中： 1234567class SecondActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val binding: ActivitySecondBinding = DataBindingUtil.setContentView(this, R.layout.activity_second) binding.duck = DuckBean("Jakson","Black") &#125;&#125; 在Fragment中： 12345678910111213141516171819202122private lateinit var userModel: UserViewModeoverride fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) userModel = ViewModelProvider(this)[UserViewMode::class.java] arguments?.let &#123; userModel.curName.value = it.getString(ARG_PARAM1) &#125;&#125;override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; userModel = ViewModelProvider(this)[UserViewMode::class.java] userModel.curName.value = "Fragment_A" val binding = DataBindingUtil.inflate&lt;FragmentABinding&gt;(inflater, R.layout.fragment_a, container, false) .apply &#123; mode = userModel tvFa.text = param1 btnA.setOnClickListener &#123; userModel.curName.value = "Changed A__F" &#125; &#125; return binding.root&#125; 表达式语言表达式语言 Null 合并运算符 如果 左边 运算数 不是 null，则 Null 合并运算符 (??) 选择 左边 运算数，如果左边运算数是 null ，则选择 右边 运算数 1android:text="@&#123;user.displayName ?? user.lastName&#125;" 等价于 1android:text="@&#123;user.displayName != null ? user.displayName : user.lastName&#125;" 避免出现 Null 指针异常 生成的数据绑定代码会自动检查 有没有 null 值 并 避免 出现 Null 指针异常。例如，在表达式 @{user.name}中，如果 user 为 Null，则为 user.name 分配默认值 null。如果您引用 user.age，其中 age 的类型为 int，则数据绑定使用默认值 0。 集合 为方便起见，在 表达式 中使用 [] 运算符访问常见集合例如：数组、列表、稀疏列表和映射。为使 XML 不含语法错误，在声明数据变量时，必须 转义 &lt; 字符。例如：不要写成 List&lt;String&gt; 形式，而是必须写成 List&amp;lt;String&gt;。 示例： 12345678910111213141516&lt;data&gt; &lt;import type="android.util.SparseArray"/&gt; &lt;import type="java.util.Map"/&gt; &lt;import type="java.util.List"/&gt; &lt;variable name="list" type="List&amp;lt;String&gt;"/&gt; &lt;variable name="sparse" type="SparseArray&amp;lt;String&gt;"/&gt; &lt;variable name="map" type="Map&amp;lt;String, String&gt;"/&gt; &lt;variable name="index" type="int"/&gt; &lt;variable name="key" type="String"/&gt;&lt;/data&gt;…android:text="@&#123;list[index]&#125;"…android:text="@&#123;sparse[index]&#125;"…android:text="@&#123;map[key]&#125;" 字符串字面量 使用 单引号 括住特性值，这样就可以在 表达式 中使用 双引号 1android:text='@&#123;map["firstName"]&#125;' 资源 事件处理事件处理 https://juejin.im/post/5d0b1e4ff265da1b96130a1b#heading-11 官方代码中提供了2种方式 方法引用 监听器绑定 但是不知道为什么第1种方式方法引用总是无法通过编译，总是报错。错误为：Cannot find a setter for &lt;TextView android:onClick&gt; that accept the paramter type of void。于是放弃。 于是只有第2种可以通过测试。但是如果按照官网的写法，点击对应View是没有任何反应的。正确的编写方式如下（监听器绑定）： 监听器接口： 123interface FragmentCall &#123; fun clickMethod()&#125; 布局文件： 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="fCallBack" type="com.yannis.myapplication.ui.click.FragmentCall" /&gt; &lt;/data&gt; &lt;Button android:id="@+id/btn_a" android:layout_width="match_parent" android:layout_height="wrap_content" android:text='"FA 点我A"' app:layout_constraintBottom_toBottomOf="parent" android:onClick="@&#123;()-&gt;fCallBack.clickMethod()&#125;" /&gt;&lt;/layout&gt; 控制器代码： 12345678class FragmentA : Fragment() , FragmentCall &#123; val binding = …….apply&#123; setFCallBack(this@FragmentA) &#125; override fun clickMethod() &#123; userModel.curName.value = "Changed A__F" &#125;&#125; 在官网的示例代码中是没有setFCallBack(this@FragmentA)设置this这句代码的。因此在实际的代码中，触发点击事件的时候也不会有响应。 以上就是一个完整的、点击后有响应的 监听器绑定 事件处理的示例代码。 导入、变量、包含参考 导入示例： 123456789101112131415&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;import type="android.view.View"/&gt; &lt;/data&gt; &lt;TextView android:id="@+id/tv_fa" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:visibility="@&#123;1&amp;lt;2 ? View.VISIBLE:View.INVISIBLE&#125;" android:text="@&#123;mode.curName??String.valueOf(1)&#125;" /&gt;&lt;/layout&gt; 使用View的属性 1android:visibility="@&#123;1&amp;lt;2 ? View.VISIBLE:View.INVISIBLE&#125;" 别名123456789101112&lt;import type="android.view.View" alias="Vista"/&gt; ……&lt;TextView android:id="@+id/tv_fa" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:visibility="@&#123;1&amp;lt;2 ? Vista.VISIBLE:Vista.INVISIBLE&#125;" android:text="@&#123;mode.curName??String.valueOf(1)&#125;" /&gt; 类型转换您还可以使用导入的类型来对表达式的一部分进行类型转换。以下示例将 connection 属性强制转换为类型 User： 1234&lt;TextView android:text="@&#123;((User)(user.connection)).lastName&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 变量包含使用可观察的数据对象查看 LiveData的使用。 生成的绑定类数据绑定库 可以生成用于访问layout的变量和视图的绑定类。绑定类的名称和包可以自定义。所有生成的绑定类都是从 ViewDataBinding 类继承而来的。 默认情况下，系统会为每个布局文件生成一个绑定类。 动态变量有时系统并不知道特定的绑定类。例如，针对任意布局运行的 RecyclerView.Adapter 不知道特定绑定类。在调用 onBindViewHolder() 方法时，仍必须指定绑定值。 在以下示例中，RecyclerView 绑定到的所有布局都有 item 变量。BindingHolder 对象具有一个 getBinding() 方法，这个方法返回 ViewDataBinding 基类。 12345override fun onBindViewHolder(holder: BindingHolder, position: Int) &#123; item: T = items.get(position) holder.binding.setVariable(BR.item, item); holder.binding.executePendingBindings();&#125; 自定义绑定类名称以下布局在当前模块的 databinding 包中生成FragA绑定类。 12&lt;data class="FragA"&gt;…… 可以在类名前添加句点和前缀，从而在其他文件包中生成绑定类。以下示例在模块包中生成绑定类： 12&lt;data class=".ContactItem"&gt; … 还可以使用完整软件包名称来生成绑定类。以下示例在 com.example 包中创建 ContactItem 绑定类 12&lt;data class="com.example.ContactItem"&gt; … 绑定适配器 官网参考 绑定适配器 负责发出相应的 框架调用 来 设置值。数据绑定库允许您指定调用的方法来设置值，提供自己的绑定逻辑以及使用适配器指定返回对象的类型。 自定义属性绑定自定义属性绑定 说明： @BindingAdapter： 注解。作用于 方法 （和类无关，这个自定义属性的方法可以写在任何地方）。 自定义属性绑定 方法 必须为 公共静（public static）方法，可以有 1个到多个 参数。 在 Kotlin 中，必须使用 @JvmStatic 表示静态，否则编译报错。参考 自定义属性绑定 实际示例 参考： 1234567891011object BindingAdapter &#123; @JvmStatic @BindingAdapter(value = ["url", "placeHolder"], requireAll = false) fun imgUrl(imageView: ImageView, url: Int, placeHolder: Int) &#123; Glide.with(imageView) .load(url) .placeholder(placeHolder) .into(imageView) &#125;&#125; 123456789&lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/image" app:layout_constraintTop_toBottomOf="@id/btn_a" app:layout_constraintLeft_toLeftOf="parent" app:url="@&#123;mode.imgUrl&#125;" app:placeHolder="@&#123;mode.holder&#125;" /&gt; 示例说明： 有2个参数，如果这2个参数 无须同时 调用，那么必须要设置 requireAll = false，requireAll 默认值为 true。 如果只有 1个 参数时，可简写为 @BindingAdapter(&quot;url&quot;) 使用旧值注意： 如果是 多个属性，那么方法的参数 必须 要把 先 所有的属性的 旧值列举 出来，然后 再 列举新属性值。这个 顺序不能乱的。并不是一个属性旧值跟一个属性新值。 对象转换类型转换 将布局视图绑定到架构组件使用 LiveData 将数据变化通知给界面 LiveData 要将 LiveData 对象与 绑定类 一起使用，您需要指定 生命周期所有者 来定义 对象的范围。以下示例在 绑定类实例化后 将 Activity 指定为 生命周期所有者： 123456789class ViewModelActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; // Inflate view and obtain an instance of the binding class. val binding: UserBinding = DataBindingUtil.setContentView(this, R.layout.user) // Specify the current activity as the lifecycle owner. binding.setLifecycleOwner(this) &#125;&#125; ViewModel 使用 ViewModel 组件来将 数据绑定到布局。在 ViewModel 组件中，您可以使用 LiveData 对象 转换数据 或 合并 多个数据源。 12345678class ScheduleViewModel : ViewModel() &#123; val userName: LiveData init &#123; val result = Repository.userName userName = Transformations.map(result) &#123; result -&gt; result.value &#125; &#125;&#125; 使用 ViewModel 管理界面相关数据通过将 ViewModel 组件与数据绑定库结合使用，可以将界面逻辑从布局移出之后移入到ViewModel 组件中，以便于测试。 数据绑定库 确保在需要时将视图与数据源``绑定或解绑。 要将 ViewModel 组件与 数据绑定库 一起使用，必须实例化 从类继承而来的组件，获取绑定类的实例，并将 组件 分配给 绑定类 中的 属性。 12345678910111213class ViewModelActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; // Obtain the ViewModel component. UserModel userModel = ViewModelProviders.of(getActivity()) .get(UserModel.class) // Inflate view and obtain an instance of the binding class. val binding: UserBinding = DataBindingUtil.setContentView(this, R.layout.user) // Assign the component to a property in the binding class. binding.viewmodel = userModel &#125;&#125; 在布局中，使用 绑定表达式 将 ViewModel 组件的属性和方法分配给对应的视图，如以下示例所示： 1234&lt;CheckBox android:id="@+id/rememberMeCheckBox" android:checked="@&#123;viewmodel.rememberMe&#125;" android:onCheckedChanged="@&#123;() -&gt; viewmodel.rememberMeChanged()&#125;" /&gt; 双向数据绑定]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-进阶]]></title>
    <url>%2FKotlin-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Kotlin-进阶 异常处理 线程 协程 Kotlin与Java混编 数据类型映射 Java与Kotlin互调 I/O文件管理 File类 字节流根类：InputStream、OutputStream 字符流根类：Reader与Writer 网络编程 基础 TCP Socket UDP Socket 数据交换格式：JSON（Kotlin官方没有JSON解码，需调用第三库） URL类访问网络资源 反射 注解]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin与编程思想]]></title>
    <url>%2FKotlin%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[Kotlin中涉及到的编程思想 函数式编程 Lambda表达式 流式（Stream）API 函数式编程函数式编程扫盲篇 命令式编程 &amp; 函数式编程 命令式编程：一种是像输入命令一样，一步一步告诉计算机如何处理业务逻辑（还记得吗，计算机很笨，只会做它懂的事情）。 函数式编程：告诉计算机，我需要什么不用去详细地告诉它要怎么做，由于计算机不可能理解我们的需求，所以我们把函数拼接到一起，让数据按照我们设想的方式流动，我们只要在数据流的最前面输入参数，等数据自己流完整个处理过程，就能得到我们需要的数据。如果数据有误或者需要修改业务，我们就去调整这个数据流，将它里面的数据流动调整为我们需要的方式。 函数式编程的运算过程是高度抽象的 面向对象 &amp; 函数式编程 不同 面向对象 把真实世界抽象为 类 和 对象，函数式编程 则把真实世界抽象为 函数； 面向对象 关心的是 对象 的 行为、之间的关系， 函数式编程 关心的是 函数 的 行为、之间的组合运用； 面向对象 只要对象不出错，对象关系不出错就可以，函数式编程 只要奔涌在 函数组合 里的数据流 按照预期进行转换就可以。 概念纯函数举例：在数学的范畴里，函数的运算是 不受干扰 的，比如你算一个数字的平方根，只要参数确定，计算的过程永远是一致的，算出来的 结果永远是一样 的。 命令式编程 中函数变得“不纯洁”了，函数的运算会 受到干扰，而且干扰无处不在。例如，我们可以在函数里使用一个会变化的 全局变量，只要在任何位置/时间/线程里 修改 这个全局变量，函数就会输出不同的结果。 在 函数式编程 里，重心是 函数组合 和 数据流，更加不允许有干扰，所以要求我们编写 纯函数。 不过，纯函数就像是编码规范，Kotlin鼓励而不是强制写出函数，毕竟，编程是为了与真实世界交互的，有时候必须使用一些“不纯洁”的函数，所以我们不要求彻底的纯函数化，只要求尽量写出纯函数。 不变性函数式编程 不仅要求 纯函数，还要求 保存不变性（Kotlin用val和集合表示不变性）。在函数式编程 里，没有可变变量，一个变量一旦被赋值，就不可更改。 优点 程序运行的整个流程是 固定可重现 的，如果出了问题，只要跟着数据流走一遍就能找到出错点。 多线程安全。它可以完美地规避多个线程同时修改一个数据时的同步问题（变量不再允许修改，每个线程需要各自生成变量），这一点对于目前大量应用多线程的工程现状来说，特别有实际价值。 一切都是函数函数式编程 里 没有变量，一切都是函数（就像面向对象编程里，一切都是对象），变量实际上被函数取代了。 例如：如果变量不可变，我们还要怎样去做业务逻辑呢？函数式编程给出的方式就是——用函数去返回一个复制的新对象，在这个新的对象里，改掉你想改的那个值。 所以，函数式编程 里 只能 新增变量，不能 修改变量，所以 函数式编程 可能会 非常耗内存（生成的变量太多了，而且业务不走完，变量不释放） 在函数式编程里还有一个特点 —— 没有循环 高阶函数“函数是一等公民”：函数拥有和数据一样的地位，都可以作为 参数 和 返回值，相应的就出现了 高阶函数 的概念。简单理解： 高阶函数 就是 参数为函数，或者 返回值为函数 的 函数。 闭包闭包 不是函数，在逻辑上 是封闭 的，它使用 自己内部的数据，用 自己内部的逻辑 进行处理，外部 只能得到闭包的 输出，无法输入，也无法干扰。 在系统资源上，闭包是持久使用的，它会一直在系统里，不像函数那样会被系统注销掉。闭包 在 函数式编程里可以简化参数量、减少变量，会更加方便我们的开发。 Lambda表达式释义为了写高阶函数 和 闭包，Kotlin支持 Lambda表达式。在 Kotlin 中，函数 也是作为 类型 的一种出现的，即：函数类型。Lambda表达式 也叫 λ表达式，它看起来就是对 匿名方法（如：回调、事件响应、Runnable等）的 简化写法，目的是为了 更贴近函数式编程把函数作为参数的思想。 Lambda表达式 包括： 最外面的 {} 用 () 来定义的参数列表， -&gt; 表达式或语句块。 Kotlin 允许我们把函数的最后一个Lambda表达式参数移除括号外。即： 123456789在使用`lambda表达式`时，有时看似是：arrayCase.forEach &#123; Log.e(&quot;TAG-forEach&quot;,&quot;arrayCase item is :$it&quot;)&#125;实际上是：arrayCase.forEach (&#123; Log.e(&quot;TAG-forEach&quot;,&quot;arrayCase item is :$it&quot;)&#125;) 当1个接口仅有1个方法需要实现时，是可以使用Lambda表达式的。 lambda表达式书写 12345678910111213141516171819val lambdaCase = &#123; // 1. 参数及其类型 left: Int, right: Int // 2. 箭头 -&gt; // 3. 函数体。函数体的最后一句的表达式结果就是: Lambda 表达式的返回值 left + right&#125;val lambdaStr = &#123; // 仅有一个函数体 "lambda表达式"&#125;Log.e("TAG-lambda", "lambdaCase value is $&#123;lambdaCase(2, 3)&#125;")// 结果为：TAG-lambda: lambdaCase value is 5Log.e("TAG-lambda", "lambdaStr value is $&#123;lambdaStr()&#125;")// 结果为：lambdaStr value is lambda表达式 总结： 最后1个Lambda可以移出 () 去; 只有1个Lambda，()可省略 ; 当 Lambda 只有一个参数时，默认为 it 入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入 匿名内部类使用Lambda表达式示例：未使用Lambda表达式： 123456new Thread(new Runnable()&#123;// 接口名 @Override public void run()&#123;// 方法名 System.out.println("Thread run()"); &#125;&#125;).start(); 使用Lambda表达式后： 123new Thread( () -&gt; System.out.println("Thread run()")// 省略接口名和方法名).start(); 流式（Stream）API要让数据流在组合函数里流动起来，就需要使用流式API，流式API使我们更容易把函数组合起来，而且使整个数据流动过程更加直观。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack-Lifecycle]]></title>
    <url>%2FJetpack-Lifecycle%2F</url>
    <content type="text"><![CDATA[Jetpack-Lifecycle：管理 Activity 和 Fragment 生命周期 Lifecycle 是什么 Jetpack-Lifecycle：处理生命周期官网解释：使用 一个具有Android生命周期的对象 —— 生命周期感知型组件（自定义） 处理 生命周期（如 Activity 和 Fragment）的状态变化。 注解+观察者 使用关系： AppCompatActivity &lt;- FragmentActivity &lt;- ComponentActivity &lt;- LifecycleOwner,ViewModelStoreOwner,SavedStateRegistryOwner LiveData：一种具有生命周期感知能力的可观察的数据存储器类 与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新 处于活跃生命周期状态 的应用组件观察者。 Jetpack-ViewMode：旨在以 注重生命周期 的方式存储 和 管理 界面相关的数据 生命周期感知型组件的最佳做法 使界面控制器（Activity 和 Fragment）尽可能保持精简。它们不应试图获取自己的数据，而应使用 ViewModel 执行此操作，并观察 LiveData对象 以将更改体现到视图中。 设法编写数据驱动型界面，对于此类界面，界面控制器的责任是随着数据更改而更新视图，或者将用户操作通知给 ViewModel。 将数据逻辑 放在 ViewModel 类中。 ViewModel 应充当 界面控制器 与应用 其余部分 之间的连接器。不过要注意，ViewModel 不负责获取数据（例如，从网络获取）。ViewModel 应 调用相应的组件来获取数据，然后将结果提供给界面控制器。 如果界面很复杂，不妨考虑创建 presenter 类来处理界面的修改。这可能是一项艰巨的任务，但这样做可使界面组件更易于测试。 避免在 ViewModel 中引用 View 或 Activity 的 上下文。 如果 ViewModel 存在的时间比 Activity 更长（在配置更改的情况下），Activity 将泄露并且不会由垃圾回收器妥善处置。 使用 Kotlin 协程 管理长时间运行的任务和其他可以异步运行的操作。 使用示例自定义一个具有生命周期的类——观察者12345678910111213141516171819202122232425262728293031323334353637383940414243444546class UserMode (private val lifecycle:Lifecycle):LifecycleObserver&#123; // 构造函数初始化 init &#123; // 注册 lifecycle.addObserver(this) &#125; // Lifecycler.Event 的使用方式 @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun create() &#123; Log.i("UserModule", "UserModule:create") &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) fun start() &#123; Log.i("UserModule", "UserModule:start") // Lifecycle.State的使用方式 if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) &#123; Log.i("UserModule", "当前已经处于STARTED状态") &#125; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun resume() &#123; Log.i("UserModule", "UserModule:resume") &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) fun pause() &#123; Log.i("UserModule", "UserModule:pause") &#125; @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun stop() &#123; Log.i("UserModule", "UserModule:stop") &#125; @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) fun destroy() &#123; // 反注册 lifecycle.removeObserver(this) Log.i("UserModule", "UserModule:destroy") &#125;&#125; 自定义一个LifecycleOwner的实现类——被观察者123456789101112131415161718192021class MainActivity : AppCompatActivity(), LifecycleOwner &#123; private var module:UserMode = UserMode(lifecycle) private lateinit var lifecycleRegistry: LifecycleRegistry override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) lifecycleRegistry = LifecycleRegistry(this) lifecycleRegistry.markState(Lifecycle.State.CREATED) &#125; public override fun onStart() &#123; super.onStart() lifecycleRegistry.markState(Lifecycle.State.STARTED) &#125; override fun getLifecycle(): Lifecycle &#123; return lifecycleRegistry &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack-ViewMode]]></title>
    <url>%2FJetpack-ViewMode%2F</url>
    <content type="text"><![CDATA[Jetpack-ViewMode：旨在以 注重生命周期 的方式存储 和 管理 界面相关的数据 ViewMode 是什么ViewMode 设计出发点： 屏幕旋转时的数据保存与恢复； 在界面控制器中进行的子线程耗时处理易导致内存泄漏 ViewMode 出现的目的：从 界面控制器逻辑 中 分离 出 视图数据所有权 的做法更易行且更高效。 ViewModel 是 架构组件 为 界面控制器 提供的 辅助程序类，该类负责 为界面准备数据。在配置更改期间会自动保留 ViewModel对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。 注意：ViewModel 绝不能引用 视图、Lifecycle 或可能存储对 Activity 上下文的引用的任何类。因为：ViewModel 对象 存在的时间比 View 或 LifecycleOwners 的特定实例存在的时间更长。解决办法： 在ViewModels 和 Views 之间进行通信的推荐方法是使用 LiveData 或其他库中的observables的观察者模式。 ViewModel 对象 可以包含 LifecycleObservers，如 LiveData 对象。但是，ViewModel 对象 绝不能观察 对生命周期感知型 可观察对象（如 LiveData 对象）的更改。 ViewMode 生命周期ViewModel对象 存在的 时间范围 是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel 将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失： 对于 Activity 是在其完成时； 对于 Fragment 是在其分离时。 下图表示了 Activity 经历屏幕旋转而后结束的过程中所处的各种生命周期状态。该图还在关联的 Activity 生命周期的旁边显示了 ViewModel 的生命周期。 如果 ViewModel 需要 Application 上下文（例如，为了查找系统服务），它可以 扩展 AndroidViewModel类 并设置用于接收 Application 的 构造函数，因为 Application类会扩展 Context。 此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。 AndroidViewModel源码： 1234567891011121314151617public class AndroidViewModel extends ViewModel &#123; @SuppressLint("StaticFieldLeak") private Application mApplication; public AndroidViewModel(@NonNull Application application) &#123; mApplication = application; &#125; /** * Return the application. */ @SuppressWarnings(&#123;"TypeParameterUnusedInFormals", "unchecked"&#125;) @NonNull public &lt;T extends Application&gt; T getApplication() &#123; return (T) mApplication; &#125;&#125; 构造函数中传入Application，扩大了 ViewModel 的生命周期。 在 Fragment 之间共享数据两个 Fragment 可以使用 其所在 的 Activity 范围 共享ViewModel 来处理此类通信。 示例： 建立2个Fragment FragmentA 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private const val ARG_PARAM1 = "param1"class FragmentA : Fragment() &#123; private var param1: String? = null private var rootView:View? = null private var tv:TextView? = null private lateinit var mode: UserViewMode override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) arguments?.let &#123; param1 = it.getString(ARG_PARAM1) &#125; &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; // Inflate the layout for this fragment rootView = inflater.inflate(R.layout.fragment_a, container, false) setDataToView() // 与其他包含 UserViewMode 的界面控制器同步数据时，采用的初始化 mode = activity?.run &#123; ViewModelProvider(this)[UserViewMode::class.java] &#125;?:throw Exception("Invalid Activity") // 不与其他包含 UserViewMode 的界面控制器同步数据时，采用的初始化 // mode = ViewModelProvider(this)[UserViewMode::class.java] mode.curName.observe(viewLifecycleOwner,Observer&lt;String&gt;&#123; tv!!.text = it &#125;) return rootView &#125; private fun setDataToView() &#123; // 声明方式1 //val tvShow: TextView = rootView?.findViewById(R.id.tv_fa) as TextView //tvShow.text = param1 // 声明方式2 tv = rootView?.findViewById&lt;TextView&gt;(R.id.tv_fa) tv!!.text = param1 val btn: Button? = rootView?.findViewById(R.id.btn_a) btn!!.setOnClickListener &#123; mode.curName.value = "Changed A__F" &#125; &#125; companion object &#123; @JvmStatic fun newInstance(param1: String) = FragmentA().apply &#123; arguments = Bundle().apply &#123; putString(ARG_PARAM1, param1) &#125; &#125; &#125;&#125; FragmentB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private const val ARG_PARAM1 = "param1"class FragmentB : Fragment() &#123; private var param1: String? = null private var rootView:View? = null private var btn: Button? = null private var tv:TextView? = null private lateinit var mode: UserViewMode override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) arguments?.let &#123; param1 = it.getString(ARG_PARAM1) &#125; &#125; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; rootView = inflater.inflate(R.layout.fragment_b, container, false) setDataToView() mode = activity?.run &#123; ViewModelProvider(this)[UserViewMode::class.java] &#125;?:throw Exception("Invalid Activity") mode.curName.observe(viewLifecycleOwner, Observer&lt;String&gt; &#123; tv!!.text = it &#125;) return rootView &#125; private fun setDataToView() &#123; tv = rootView?.findViewById(R.id.tv_fb) tv!!.text = param1 btn = rootView?.findViewById(R.id.btn_b) btn!!.setOnClickListener &#123; mode.curName.value = "Changed F--B" &#125; &#125; companion object &#123; @JvmStatic fun newInstance(param1: String) = FragmentB().apply &#123; arguments = Bundle().apply &#123; putString(ARG_PARAM1, param1) &#125; &#125; &#125;&#125; Activity 123456private fun initFragment() &#123; fragmentA=FragmentA.newInstance("FragmentA") fragmentB = FragmentB.newInstance("FragmentB") supportFragmentManager.beginTransaction().replace(R.id.fl_one,fragmentA as FragmentA).commit() supportFragmentManager.beginTransaction().replace(R.id.fl_two,fragmentB as FragmentB).commit()&#125; 实现效果 在 Activity 中点击 A点我按钮，FragmentA 与 FragmentB 中的数据同时改变。 在 FragmentA 中点击 A点我按钮，Activity 与 FragmentB 中的数据同时改变。 在 FragmentB 中点击 A点我按钮，Activity 与 FragmentA 中的数据同时改变。 关键代码： 123mode = activity?.run &#123; ViewModelProvider(this)[UserViewMode::class.java]&#125;?:throw Exception("Invalid Activity") 如果在FragmentA中改成如下： 1mode = ViewModelProvider(this)[UserViewMode::class.java] 则结果是：仅FragmentA中的数据发生改变，Activity与FragmentB中展示的数据不会发生改变。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack-LiveData]]></title>
    <url>%2FJetpack-LiveData%2F</url>
    <content type="text"><![CDATA[Jetpack-LiveData：在底层数据更改时通知视图 LiveData 对象 的 生命周期 感知能力； 被修改数据 从 子线程 到 UI主线程 间的切换。 LiveData 释义是什么LiveData 是一种可用于 任何数据 的 封装容器，其中包括可实现 Collections 的对象，如 List。创建 LiveData实例 以存储某种类型的数据。这通常在 ViewModel 类中完成，并可通过 getter 方法进行访问。 注意：请确保将用于更新界面的 LiveData 对象存储在 ViewModel 对象中，而不是将其存储在 Activity 或 Fragment 中，原因如下： 避免 Activity 和 Fragment 过于庞大。现在，这些界面控制器负责 显示 数据，但不负责存储数据状态。 将 LiveData 实例与特定的 Activity 或 Fragment 实例 分离 开，并使对象在配置更改后继续存在。 LiveData 的优势 确保界面符合数据状态 LiveData 遵循 观察者模式。当生命周期状态发生变化时，LiveData 会通知 Observer对象。您可以整合代码以在这些 Observer对象中更新界面。观察者可以在每次发生更改时更新界面，而不是在每次应用数据发生更改时更新界面。 不会发生内存泄露 观察者 会绑定到 Lifecycle对象，并在其关联的生命周期遭到销毁后进行自我清理。 不会因 Activity 停止而导致崩溃 如果 观察者 的生命周期处于 非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。 不再需要手动处理生命周期 界面组件 只是 观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。 数据始终保持最新状态 如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。 适当的配置更改 如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。 共享资源 您可以使用 单一实例模式 扩展 LiveData 对象 以 封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。 LiveData 使用步骤自定义ViewModel类123456class UserViewMode: ViewModel() &#123; // 1. 在 `自定义ViewModel类` 中创建 `LiveData对象` val curName:MutableLiveData&lt;String&gt; by lazy &#123; MutableLiveData&lt;String&gt;() &#125;&#125; 所有者类中12345678910111213141516171819override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(activity_main) initView() // 2. 在 `所有者` 中初始化 `自定义ViewModel类` 对象 model = ViewModelProvider(this).get(UserViewMode::class.java) // 3. 在 `所有者` 中创建一个 `观察者` 接收新数据然后更新UI val nameObserver = Observer&lt;String&gt;&#123;userResult-&gt; tvName.text = userResult &#125; // 4. 在 `所有者` 中添加：`当前所有者` 和 `观察者` 的 对象，此时： LiveData对象 开始"具有感知生命周期的能力”。 model.curName.observe(this,nameObserver) // 5. 在 `所有者` 中接收新修改的数据 btn.setOnClickListener &#123; model.curName.value = "Dear Jodon" &#125;&#125; LiveData 中的角色： LifecycleOwner：界面控制器（Activity/Fragment） Observer：界面元素。 LiveData 类内容添加观察者；向观察者通知修改数据（包括：线程切换）生命周期感知内部类： 抽象类ObserverWrapper：对观察者进行（活跃）状态处理。 onActive();：活跃状态 onInactive();：非活跃状态 dispatchingValue(this);：观察者处于活跃时，进行被修改数据的分发 isAttachedTo(LifecycleOwner owner)：所有者的添加 detachObserver()：所有者的移除 类LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver：观察者的生命周期范围。在 observe() 中处理所有者和观察者。 重写 shouldBeActive()：判断当前观察者状态是否处于活跃状态 onStateChanged()：根具观察者生命周期状态判断是否移除观察者；调用ObserverWrapper#onStateChanged(boolean newActive) 类AlwaysActiveObserver extends ObserverWrapper。在observeForever()中处理所有者和观察者。： 重写 shouldBeActive() 使其返回值总是为 true。 LiveData 的使用流程大致分为3步： 初始化 创建观察者 为所有者和观察者建立联系。 新数据赋值 添加观察者LiveData#observe() 生命周期内订阅1public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) 方法中的2个参数： owner ：控制观察者的 所有者LifecycleOwner（其实就是Activity/Fragment） observer ：将接收事件的 Observer 1. 方法作用： 将给定的 观察者（observer） 添加到 给定所有者（owner） 的 生命周期内 的 观察者列表 中。事件在 主线程 上调度。如果 LiveData 已经设置了数据，它将被传递给观察者。 2. 数据接收： 如果 所有者（owner） 处于 Lifecycle.State.STARTED 或 Lifecycle.State.RESUMED 状态（active），则 观察者 将仅接收事件。 如果 所有者（owner） 移至 Lifecycle.State.DESTROYED 状态，则 观察者 将被 自动删除。 当 所有者（owner） 不活动时 数据 发生更改 时，它将 不会收到任何更新 。如果 再次激活，它将 自动接收 最新的可用数据。 3. 引用问题 只要 不销毁 给定的 LifecycleOwner，LiveData 就会对 观察者（observer） 和 所有者（owner） 保持 强引用。销毁 后，LiveData 会 删除 对观察者和所有者的 引用。 如果给定的 所有者（owner） 已经处于 Lifecycle.State.DESTROYED 状态，则 LiveData 将忽略该调用，即：observe()。 如果给定的所有者观察者元组已经在列表中，则该调用将被忽略。如果观察者已经在列表中且具有另一个所有者，则LiveData会引发IllegalArgumentException。 完整方法 123456789101112131415161718192021@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; // 主线程 assertMainThread("observe"); if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; // 在 所有者生命周期范围内 处理 观察者。 LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles"); &#125; if (existing != null) &#123; return; &#125; // 所有者 添加 观察者，将 观察者 与 所有者的生命周期建立联系。 owner.getLifecycle().addObserver(wrapper);&#125; LiveData#observeForever() 超越生命周期订阅1public void observeForever(@NonNull Observer&lt;? super T&gt; observer) 参数： Observer: 将接收事件的observer 方法作用： 将给定的 observer 添加到 观察者列表 中。 此调用类似于带有始终处于活动状态的LifecycleOwner的observe(LifecycleOwner，Observer)。 这意味着 给定的观察者 将收到 所有事件，并且 永远不会被自动删除。 您应该手动调用 removeObserver(Observer) 停止观察此LiveData。尽管LiveData具有此类观察者之一，但它将被视为活动的。 完整代码 1234567891011121314@MainThreadpublic void observeForever(@NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread("observeForever"); AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing instanceof LiveData.LifecycleBoundObserver) &#123; throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles"); &#125; if (existing != null) &#123; return; &#125; wrapper.activeStateChanged(true);&#125; 通过方法体中的代码可以看到声明 LifecycleObserver 时用的是类 AlwaysActiveObserver ，而在这个私有内部类中重写 shouldBeActive()时，返回值是写死的永远为 true： 1234@Overrideboolean shouldBeActive() &#123; return true;&#125; 所以通过 observeForever() 进行订阅的 观察者 将一直处于 活跃状态。不会执行抽象类 LifecycleBoundObserver中对 所有者 生命周期状态的监管处理。想要停止观察此LiveData只能手动调用 removeObserver(Observer) 移除订阅观察LiveData#removeObserver()1public void removeObserver(@NonNull final Observer&lt;? super T&gt; observer) 从 观察者列表 中删除给定的 观察者。 LiveData#removeObservers()1public void removeObservers(@NonNull final LifecycleOwner owner) 删除与给定的 LifecycleOwner 关联的 所有观察者。 被修改数据 到 观察者 的流程主要流程： 从 工作线程 -&gt; UI主线程： 被修改数据-&gt; LiveData#postValue(T value)-&gt; LiveData#mPostValueRunnable-&gt; LiveData#setValue(T value)-&gt; LiveData#dispatchingValue(@Nullable ObserverWrapper initiator)-&gt; LiveData#considerNotify(ObserverWrapper observer)非活跃状态 -&gt; ObserverWrapper#activeStateChanged(boolean newActive) -&gt; onInactive()活跃状态 -&gt; Observer&lt;T&gt;#onChanged(T t) -&gt; onActive() UI主线程： 被修改数据-&gt; LiveData#setValue(T value)-&gt; LiveData#dispatchingValue(@Nullable ObserverWrapper initiator)-&gt; LiveData#considerNotify(ObserverWrapper observer)非活跃状态 -&gt; ObserverWrapper#activeStateChanged(boolean newActive) -&gt; onInactive()活跃状态 -&gt; Observer&lt;T&gt;#onChanged(T t) -&gt; onActive() 具体方法调用子线程更新数据 #postValue(T value)123456789101112protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; // 进行线程切换 ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125; 子线程与UI主线程切换处理 mPostValueRunnable对象123456789101112private final Runnable mPostValueRunnable = new Runnable() &#123; @SuppressWarnings("unchecked") @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; setValue((T) newValue); &#125;&#125;; UI主线程更新数据 #setValue(T value)1234567@MainThreadprotected void setValue(T value) &#123; assertMainThread("setValue"); mVersion++; mData = value; dispatchingValue(null);&#125; 新数据开始分发 #dispatchingValue(@Nullable ObserverWrapper initiator)1234567891011121314151617181920212223void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; 通知观察者更新数据 #considerNotify(ObserverWrapper observer)12345678910111213141516171819private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; return; &#125; //检查最新状态b4调度。也许它改变了状态，但是我们还没有得到这个事件。 // // 我们仍然要先检查observer.active，以将其作为事件的入口。So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData);&#125; 数据更新最终调用接口的Observer&lt;T&gt;的方法#onChanged(T t)，完成 被修改数据 被通知到 观察者 的全过程。 1234567public interface Observer&lt;T&gt; &#123; /** * 数据更改时调用 * @param t The new data */ void onChanged(T t);&#125; LiveData 的生命周期感知能力抽象类 ObserverWrapper#activeStateChanged(boolean newActive) 处理 被修改数据 与 观察者活跃状态 之间的关系 1234567891011121314151617181920private abstract class ObserverWrapper &#123; void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; // 立即设置为活动状态，因此我们永远不会将任何内容分发给不活动的所有者 mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive(); &#125; if (mActive) &#123; dispatchingValue(this); &#125; &#125;&#125; 通过： 12345678if (wasInactive &amp;&amp; mActive) &#123; // 有活跃观察者，处于活跃状态 onActive();&#125;if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; // 无活跃观察者，处于非活跃状态 onInactive();&#125; 告知观察者所处的激活状态，以便在 活跃状态 和 非活跃状态 处理不同的逻辑 LiveData 扩展： onActive() onInactive() 转换 LiveData：Transformationsmap()和switchMap()允许LiveData实例功能的组合和委托。转换是延迟计算的，仅在观察到返回的LiveData时才运行。生命周期行为从输入的源LiveData实例到返回新值的行为为止。 变换的本质：观察者模式的嵌套 涉及到的类-MutableLiveDataMediator 中文翻译：调解员；Mutable 中文翻译：可变的 MutableLiveData 类可以监听 其他LiveData 对象 并 处理 它们发出的 事件。MediatorLiveData 能正确地将 其状态 （onActive() 和 onInactive()）传播到 源LiveData对象。 继承关系： 1MediatorLiveData&lt;T&gt; : MutableLiveData&lt;T&gt; : LiveData&lt;T&gt; 嵌套观察者：MutableLiveData 是 LiveData子类，可以观察其他LiveData对象，并对其 OnChanged() 做出反应。 自身状态回传：此类正确地将自身active/inactive 状态传播到源LiveData对象。 这种功能是通过：MutableLiveData 类重写 onActive() 和 onInactive()实现的。因为在这2个方法中调用的是MutableLiveData 内部静态类 Source中的 plug()和unplug()，而在这2个方法中对源LiveData对象进行了处理。 addSource()：MediatorLiveData的主要方法123456789101112131415@MainThreadpublic &lt;S&gt; void addSource(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? super S&gt; onChanged) &#123; Source&lt;S&gt; e = new Source&lt;&gt;(source, onChanged); Source&lt;?&gt; existing = mSources.putIfAbsent(source, e); if (existing != null &amp;&amp; existing.mObserver != onChanged) &#123; throw new IllegalArgumentException( "This source was already added with the different observer"); &#125; if (existing != null) &#123; return; &#125; if (hasActiveObservers()) &#123; e.plug(); &#125;&#125; 在addSource()中，主要有2个参数： LiveData&lt;S&gt; source Observer&lt;? super S&gt; onChanged 实际上这2个参数都被赋值给了 MutableLiveData的内部静态类：Source&lt;V&gt;。 Source：MutableLiveData的内部静态类1234567891011121314151617181920212223242526private static class Source&lt;V&gt; implements Observer&lt;V&gt; &#123; final LiveData&lt;V&gt; mLiveData; final Observer&lt;? super V&gt; mObserver; int mVersion = START_VERSION; Source(LiveData&lt;V&gt; liveData, final Observer&lt;? super V&gt; observer) &#123; mLiveData = liveData; mObserver = observer; &#125; void plug() &#123; mLiveData.observeForever(this); &#125; void unplug() &#123; mLiveData.removeObserver(this); &#125; @Override public void onChanged(@Nullable V v) &#123; if (mVersion != mLiveData.getVersion()) &#123; mVersion = mLiveData.getVersion(); mObserver.onChanged(v); &#125; &#125;&#125; 由源码可知：Source&lt;V&gt; 是实现了Observer&lt;V&gt;接口的一个观察者类。通过其构造方法接收了addSource()中的2个参数 LiveData&lt;S&gt; source Observer&lt;? super S&gt; onChanged 而且这个内部静态类中，还处理了：注册、发注册和onChanged()。 注意：在plug()与unplug()中调用的是：observeForever() 与 removeObserver()，不是observe()。 Transformations#map()源码： 1234567891011121314@MainThread@NonNullpublic static &lt;X, Y&gt; LiveData&lt;Y&gt; map( @NonNull LiveData&lt;X&gt; source, @NonNull final Function&lt;X, Y&gt; mapFunction) &#123; final MediatorLiveData&lt;Y&gt; result = new MediatorLiveData&lt;&gt;(); result.addSource(source, new Observer&lt;X&gt;() &#123; @Override public void onChanged(@Nullable X x) &#123; result.setValue(mapFunction.apply(x)); &#125; &#125;); return result;&#125; 涉及到的类：MediatorLiveData。这是在执行addSource()后得到的返回值类型，在这个方法中将源LiveData作为被观察者，将源LiveData中的具体数据作为观察者，只不过这个观察者的数据是传递给MediatorLiveData&lt;Y&gt;类型返回的。 示例： 1234LiveData userLiveData = ...; LiveData userName = Transformations.map(userLiveData, user -&gt; &#123; return user.firstName + " " + user.lastName; // Returns String &#125;); 示例解读：当userLiveData对象发生变化时，Transformations#map()将返回一个String类型的userName值。即：userName观察userLiveData，当userLiveData发生改变时通知userName进行更新。 Transformations#switchMap()示例： 1234567MutableLiveData userIdLiveData = ...; LiveData userLiveData = Transformations.switchMap(userIdLiveData, id -&gt; repository.getUserById(id)); // Returns LiveData void setUserId(String userId) &#123; this.userIdLiveData.setValue(userId); &#125; 合并多个 LiveData 源MediatorLiveData 是 LiveData 的子类，允许 合并 多个LiveData源。只要任何 原始LiveData 源对象 发生更改，就会 触发 MediatorLiveData 对象 的 观察者。 官网示例： 123456LiveData liveData1 = ...;LiveData liveData2 = ...;MediatorLiveData liveDataMerger = new MediatorLiveData&lt;&gt;();liveDataMerger.addSource(liveData1, value -&gt; liveDataMerger.setValue(value));liveDataMerger.addSource(liveData2, value -&gt; liveDataMerger.setValue(value)); 在这个官网示例中有2个LiveData源：liveData1、liveData2。liveDataMerger对象 就是将2个源LiveData对象合并的对象。 实际测试示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 自定义 ViewModel类class UserViewMode : ViewModel() &#123; var strLiveData1: MutableLiveData&lt;String&gt;? = MutableLiveData&lt;String&gt;() var strLiveData2: MutableLiveData&lt;String&gt;? = MutableLiveData&lt;String&gt;() var mediatorModel: MediatorLiveData&lt;String&gt;? = MediatorLiveData&lt;String&gt;()&#125;// 在Activity类中class MainActivity : AppCompatActivity() &#123; private lateinit var model: UserViewMode model = ViewModelProvider(this).get(UserViewMode::class.java) override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(activity_main) mergeLiveDataCase() // 修改数据 btn.setOnClickListener &#123; model.strLiveData1?.value = "123" model.strLiveData2?.value = "4567" model.strLiveData1?.value = "123--new" model.strLiveData2?.value = "4567--new" &#125; &#125; /** * 合并多个LiveData数据源 */ private fun mergeLiveDataCase() &#123; // 为合并对象添加数据源 with(model) &#123; strLiveData1?.let &#123; mediatorModel?.addSource(it) &#123; mediatorModel?.value = it &#125; &#125; ?: Log.e("TAG", "strLiveData1 null") strLiveData2?.let &#123; mediatorModel?.addSource(it) &#123; mediatorModel?.value = it &#125; &#125; ?: Log.e("TAG", "strLiveData2 null") &#125; // 为合并对象添加观察者 model.mediatorModel?.observe(this, Observer&lt;String&gt; &#123; Log.e("TAG-Live-Merge", "merge data is : $it") &#125;) &#125;&#125; 运行结果输出： 1234E/TAG-Live-Merge: merge data is : 123E/TAG-Live-Merge: merge data is : 4567E/TAG-Live-Merge: merge data is : 123--newE/TAG-Live-Merge: merge data is : 4567--new]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack与androidX]]></title>
    <url>%2FJetpack%E4%B8%8EandroidX%2F</url>
    <content type="text"><![CDATA[Jetpack与androidX AndroidX概览AndroidX androidx 命名空间中的组件包含 Android Jetpack 库。与suppor库一样，androidx 命名空间中的库与 Android 平台分开提供，并向后兼容各个 Android 版本。 AndroidX 对原始 Android 支持库进行了重大改进，原始 Android 支持库现在已不再维护。androidx 软件包完全取代了支持库，不仅提供同等的功能，而且提供了新的库。 与支持库不同，androidx 软件包会单独维护和更新。从版本 1.0.0 开始 版本 28.0.0 是支持库的最后一个版本。我们将不再发布 android.support库版本。所有新功能都将在 androidx 命名空间中开发。 迁移到 AndroidX如果要在 新项目 中使用命名空间为 androidx 的库，则需要将 编译 SDK 设置为 Android 9.0（API 级别 28） 或更高版本，这是因为，1.0.0 版本的 AndroidX 工件是与支持库 28.0.0 工件等效的二进制文件。 并在 gradle.properties 文件中将以下两个 Android Gradle 插件标记设置为 true。 android.useAndroidX=true ： Android 插件会使用对应的 AndroidX 库而非支持库。 android.enableJetifier=true ：Android 插件会通过重写现有第三方库的二进制文件，自动将这些库迁移为使用 AndroidX。 Android Jetpack是什么？Jetpack Jetpack 包含 与平台 API 解除捆绑 的 androidx.*库。 这些库遵循严格的语义版本控制。版本字符串（例如 1.0.1-beta02）包含3个数字，分别代表 major 级别、minor 级别和 问题修复 级别。预发布版本也有一个后缀，用于指定预发布阶段（Alpha 版、Beta 版、候选版本）和版本号（01、02 等）。 库的每个版本都要经历3个预发布阶段，才能成为稳定版本。 Jetpack包含 androidx.* 程序包库，与平台API 无关。这意味着它提供了向后兼容性，并且比Android平台更频繁地更新，从而确保您始终可以访问Jetpack组件的最新和最新版本。 Android Jetpack 组件Android Jetpack组件是一个库的集合，这些库可以单独采用，也可以构建在一起以协同工作。 Jetpack包括的组件 由上图可以看到，Jetpack 组件主要包括：（Foundation）基础、（Architecture）架构组件、（Behavior）行为、UI共计4个部分。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础]]></title>
    <url>%2FC%2B%2B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C++基础-01 头文件新版头文件使用方式：#include &lt;iostream&gt;，省略了.h。 C++是C的一个超集，包含C的语法和规则。 sizeof()参考：https://www.cnblogs.com/huolong-blog/p/7587711.html 变量变量、方法使用规则： 先声明 后初始化 变量使用3步骤： 声明 定义 初始化 只有当变量被定义后，才能进行赋值。因为只有当变量被定义后才会分配内存空间，而声明是不会为变量分配内存空间的； 在多个源文件中：一个声明变量在源文件A中被声明，在源文件B中被定义初始化后，在源文件C中是无法使用源文件B中定义初始化的变量值。 extern 关键字：extern 修饰符通常用于：当有两个或多个文件 共享相同 的全局变量或函数的时候。 作用在变量之前：变量只允许定义一次，但可以在多个文件中声明。extend 关键字可以声明在任何位置。即时声明是在作用域更小的范围内，定义初始化是在更大范围内。 函数声明：extern 用于标识次函数为外部可调用函数 在程序中，局部变量和全局变量的名称可以相同。但是在函数内的局部变量与全局变量是两个独立的变量，互不影响。 static 关键字：作用域、生命周期从作用域看： 全局变量 具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。 静态全局变量 也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。 静态局部变量 具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。 从分配内存空间看： 全局变量、静态全局变量、静态局部变量都在静态存储区分配空间，而局部变量在栈里分配空间。 总结 static 全局变量:改变作用范围，不改变存储位置 static 局部变量：改变存储位置，不改变作用范围 静态函数 ：在函数的返回类型前加上static关键字,函数即被定义为静态函数（内部函数）。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。 宏定义(#define) 和常量 (const)的区别预处理（#define）变量定义值以后，不能用分号，否则就会计算错误，但是程序不会报错。 类型 和 安全检查 不同： 宏定义是 简单、机械 的 字符替换，无数据类型区别，同时这种替换没有类型安全检查，可能产生边际效应等错误； const常量是常量声明，有类型区别，需要在编译阶段进行类型检查； 编译器处理不同： 宏定义是一个 “编译时”概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期； const常量 是一个 “运行时”概念，在程序运行使用，类似于一个只读行数据。 存储方式不同： 宏定义是 直接替换，不会分配内存，存储与程序的代码段中； const常量需要 进行内存分配，存储与程序的数据段中 定义域不同： 定义后能否取消 宏定义可以通过#undef来使之前的宏定义失效 const常量定义后将在定义域内永久有效 是否可以做函数参数： 宏定义 不能作为参数传递给函数 const常量 可以在函数的参数列表中出现 数据类型基本数据类型C++中包含的7种数据类型 类型 关键字 布尔型 bool 字符型 char 整形 int 浮点型 float 双浮点型 double 无类型 void 宽字符 wchar_t 初始化默认值 数据类型 初始化默认值 char ‘\0’ int 0 float 0 double 0 pointer NULL 转换规则自动转换规则： 运算： 若 参与运算 的 类型不同，则 先转换成同一类型，然后 再进行运算。 转换 按 数据长度增加 的方向进行，以 保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。 若两种类型的 字节数不同，转换成 高字节 数的类型; 若两种类型的 字节数相同，且一种有符号，一种无符号，则转换成 无符号类型。 所有的 浮点运算 都是以 双精度 进行的，即使仅含float单精度量运算的表达式，也要 先转换成double型，再作运算。 char 型和 short 型参与运算时，必须 先转换成 int 型。 赋值： 在 赋值运算 中，赋值号两边量的数据类型不同时，以赋值号 左边 的类型为准。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度: 强制转换规则：强制类型转换 是通过类型转换运算 来实现的。 123int a = 1;double b = 2.1;cout &lt;&lt; "a + b = " &lt;&lt; a + (int)b &lt;&lt; endl; //输出为a + b = 3 运算符 运算符 描述 sizeof 返回变量大小 . 和 -&gt; 成员运算符：用于引用类、结构体、共同体的成员 &amp; 指针运算符：取变量地址 * 指针运算符：指向一个变量 逻辑运算符 描述 逻辑与&amp;&amp; 判断顺序：先左后右。左为假，则整个表达式为假；左为真，再判断右侧表达式是否为真。 逻辑或 判断顺序：先左后右。左为真，则整个表达式为真，不在计算右侧表达式是否为真；左为假，再计算右侧表达式是否为真。 数组存储在一块固定大小、连续的内存中的相同类型的元素的顺序的集合。注意： 调用 char 类型数组的 数组名，就能输出 整个数组的值，无需遍历或者通过索引值获取值。 普通数组指向数组的指针数组名是一个指向数组中第一个元素的常量指针。 例如： 12345678910111213141516171819202122int main()&#123; int n2[] = &#123;1, 2, 3&#125;; // 指向数组的指针 int *p; int *p2; p = n2; p2 = &amp;n2[0]; cout &lt;&lt; "n2[]自身地址为：" &lt;&lt; &amp;n2 &lt;&lt; endl; cout &lt;&lt; "指向n2的指针p的地址为：" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "指向&amp;n2[0]的指针的p2的地址为" &lt;&lt; p2 &lt;&lt; endl; /* n2[]自身地址为：0x7ffeeaa30404 指向n2的指针p的地址为：0x7ffeeaa30404 指向&amp;n2[0]的指针的p2的地址为0x7ffeeaa30404 */ cout &lt;&lt; *p &lt;&lt; "," &lt;&lt; *(p + 1) &lt;&lt; "," &lt;&lt; *(p + 2) &lt;&lt; endl; //1,2,3 return 0;&#125; 数组名即是常量指针实例展示： 1234567891011121314int main()&#123; int n2[] = &#123;1, 2, 3&#125;; for (int l = 0; l &lt; 3; ++l) &#123; cout &lt;&lt; "*(n2 + " &lt;&lt; l &lt;&lt; ") : "; cout &lt;&lt; *(n2 + l) &lt;&lt;"; \t地址为："; cout &lt;&lt; &amp;n2[l] &lt;&lt; endl; &#125; /* *(n2 + 0) : 1; 地址为：0x7ffee6cdd404 *(n2 + 1) : 2; 地址为：0x7ffee6cdd408 *(n2 + 2) : 3; 地址为：0x7ffee6cdd40c */ return 0;&#125; 传递数组给函数C++ 中可以通过指定不带索引的数组名（指针常量）来传递一个指向数组的指针。C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。 就函数而言，数组的长度是无关紧要的，因为 C++ 不会对形式参数执行边界检查。 想要在函数中传递一个数组作为参数，必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。 12345void funP(int *p);void funP(int num[]);void funP(int num[10]); 从函数返回数组C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。 1234567891011121314151617181920212223int *intArr() &#123; static int arr[10]; cout &lt;&lt; "arr地址为：" &lt;&lt; &amp;arr &lt;&lt; endl; // arr地址为：0x7ffeed55a2a0 // 设置种子 srand((unsigned) time(0)); for (int j = 0; j &lt; 3; ++j) &#123; arr[j] = rand() % 10; cout &lt;&lt; "arr["&lt;&lt;j&lt;&lt;"] value is : "&lt;&lt;arr[j] &lt;&lt; endl; &#125; return arr;&#125;int main()&#123; // 此处省略static在编译时会提示warring，但是运行时不会报错 static int *pArr ; pArr= intArr(); cout &lt;&lt; "pArr地址为：" &lt;&lt; pArr &lt;&lt; endl; for (int m = 0; m &lt; 3; ++m) &#123; cout &lt;&lt; "pArr["&lt;&lt;m&lt;&lt;"] value is : "&lt;&lt;*(pArr+m) &lt;&lt; endl; &#125; return 0;&#125; 运行结果为： 12345678arr地址为：0x10777f120arr[0] value is : 8arr[1] value is : 1arr[2] value is : 9pArr地址为：0x10777f120pArr[0] value is : 8pArr[1] value is : 1pArr[2] value is : 9 字符串C++ 提供了以下2种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 C 风格字符串C 风格字符串实际上是使用 null字符&#39;\0&#39;为终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 12345678910111213141516171819202122232425262728#include &lt;cstring&gt;// 通过宏定义计算数组长度#define foo(arr) sizeof(arr)/sizeof(arr[0])// 计算数组长度的模板函数template&lt;class T&gt;int computeArrLength(const T &amp; arr)&#123; return sizeof(arr)/ sizeof(arr[0]);&#125;int main()&#123; // C风格字符串 char cArr[] = &#123;'H', 'e', 'l', 'l', 'o'&#125;; // C++ 编译器会在初始化数组时，自动把 '\0' 放在字符串的末尾。 char cArr2[] = &#123;'H', 'e', 'l', 'l', 'o','\0'&#125;; cout &lt;&lt; "cArr value is : " &lt;&lt; cArr&lt;&lt;endl; cout &lt;&lt; "cArr 长度为：" &lt;&lt; foo(cArr)&lt;&lt; endl; cout &lt;&lt; "cArr 长度为：" &lt;&lt; computeArrLength(cArr)&lt;&lt; endl; cout &lt;&lt; "strlen(cArr) 长度为：" &lt;&lt; strlen(cArr) &lt;&lt; endl; cout &lt;&lt; "cArr2 value is : " &lt;&lt; cArr2&lt;&lt;endl; cout &lt;&lt; "cArr2 长度为：" &lt;&lt; foo(cArr2)&lt;&lt; endl; cout &lt;&lt; "cArr2 长度为：" &lt;&lt; computeArrLength(cArr2)&lt;&lt; endl; cout &lt;&lt; "strlen(cArr2) 长度为：" &lt;&lt; strlen(cArr2) &lt;&lt; endl; return 0;&#125; 结果为： 12345678cArr value is : HellocArr 长度为：5cArr 长度为：5strlen(cArr) 长度为：6cArr2 value is : HellocArr2 长度为：6cArr2 长度为：6strlen(cArr2) 长度为：5 注意： 当数组类型为char时，直接调用 char[] 名时，得到的结果是数组值而不是地址。 C++中的String类对象操作。 函数使用步骤： 声明：函数的名称、返回类型和参数 定义：提供了函数的实际主体 声明方式： 完整声明：int max(int num1, int num2) 简略声明：int max(int, int)。参数的名称并不重要，只有参数的类型是必需的 函数参数 形参传递类型 描述 值传递 将实参的值赋值给形参。在函数体内，修改形参的值对实参的值没有影响 指针传递 将实参的地址赋值给形参。在函数体内，修改形参的值就是修改实参的值 引用传递 将实参的引用赋值给形参。在函数体内，修改形参的值就是修改实参的值 默认参数12345678910111213int sum(int a, int b = 10)&#123; return a+b;&#125;int main() &#123; int numA = 10; int resultA; resultA = sum(10); cout &lt;&lt; "resultA value is : "&lt;&lt;resultA&lt;&lt; endl; resultA = sum(10,20); cout &lt;&lt; "resultA value is : "&lt;&lt;resultA&lt;&lt; endl; return 0;&#125; 结果： 12resultA value is : 20resultA value is : 30 Lambda 函数与表达式Lambda 表达式把函数看作对象。可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 语法结构：1[capture](parameters) mutable -&gt;return-type&#123;statement&#125; [capture]：捕捉列表 —— 捕捉列表能够捕捉上下文中的变量以何种方式供 lambda 函数使用。捕捉列表总是出现在 lambda 表达式的开始处。事实上，[] 是 lambda 引出符。编译器根据该引出符判断接下来的代码是否是 lambda 函数。 (parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号 () 一起省略。 mutable：mutable 修饰符。默认情况下，lambda 函数总是一个 const 函数，mutable 可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。 -&gt;return_type：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号 -&gt; 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。 {statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。 在 lambda 函数的定义式中，参数列表和返回类型都是可选部分，而捕捉列表和函数体都可能为空，C++ 中最简单的 lambda 函数只需要声明为： 1[]&#123;&#125;; [capture] 捕捉列表 捕捉列表类型 描述 [] 默认不捕获任何变量 [=] 默认以值传递的方式捕获所有变量 [&amp;] 默认以引用的方式捕获所有变量 [X] 仅以值传递的方式捕获X，其他的变量不捕获 [&amp;X] 仅以引用传递的方式捕获X，其他变量不捕获 [=,&amp;X] 默认以值传递的方式捕获所有变量，但是X通过引用的方式捕获 [&amp;,X] 默认以引用的方式捕获所有变量，但是X通过值传递的方式捕获 [this] 通过引用（实际是复制指针）的方式获取当前对象 [*this] 通过值传递的方式捕获当前对象 实例1234567891011121314151617181920212223int main()&#123; int resultA = 30; // 自动推断返回类型 // resultA参数：引用传递 //auto sumA = [&amp;resultA]&#123;return ++resultA;&#125;; // 执行sumA后，resultA 结果为：31 // 指明返回类型 // resultA参数：引用传递 //auto sumA = [&amp;resultA]()-&gt;int &#123;return ++resultA;&#125;; // 执行sumA后，resultA 结果为：31 // resultA参数：值传递 auto sumA = [=]&#123; return resultA+1;&#125;; //auto sumA = [=]()&#123; return resultA+1;&#125;; //auto sumA = [=]()-&gt;int &#123; return resultA+1;&#125;; // 执行sumA后，resultA 结果为：30 cout &lt;&lt; "sumA value is : " &lt;&lt; sumA() &lt;&lt; endl; cout &lt;&lt; "resultA change value is : " &lt;&lt;resultA &lt;&lt; endl; return 0;&#125; 指针每一个变量都有一个内存地址；每一个变量的内存的 地址 都可以通过使用 &amp; —— 取地址运算符获取；每一个变量的内存的地址中 存储的值 可以通过使用 * 运算符获取。 指针本身是一个变量，指针的值是另一个变量的地址——内存位置的直接地址。 声明方式： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的 —— 代表内存地址的十六进制数。 不同数据类型的指针之间唯一的不同，是指针所指向的变量或常量的 值 的数据类型不同。 操作一般操作有4种： 声明：int *p; 赋值/初始化：p=&amp;num 输出地址：cout &lt;&lt; p; 输出地址中存储的值：cout &lt;&lt; *p NULL值赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的 值为0 的常量。 123void showNULL()&#123; cout &lt;&lt; "NULL="&lt;&lt; NULL&lt;&lt;endl;&#125; 结果： 1NULL=0 指针算数运算符++、--、+、-、==、&gt;、&lt;。 示例：： 123456789101112131415161718192021222324252627282930313233343536373839void showOperate() &#123; int i = 10; char c = 'q'; double d = 12.0; int *pi = &amp;i; char *pc = &amp;c; double *pd = &amp;d; cout &lt;&lt; "int i size of is :" &lt;&lt; sizeof(i) &lt;&lt; endl; cout &lt;&lt; "i address size of is :" &lt;&lt; sizeof(&amp;i) &lt;&lt; endl; cout &lt;&lt; "pi address size of is :" &lt;&lt; sizeof(pi) &lt;&lt; endl; cout &lt;&lt; "pi address value is :" &lt;&lt; pi &lt;&lt; endl; cout &lt;&lt; "pi value is :" &lt;&lt; *pi &lt;&lt; endl; cout &lt;&lt; "pi value size of is :" &lt;&lt; sizeof(*pi) &lt;&lt; endl; pi++; cout &lt;&lt; "pi + 1 is : " &lt;&lt; (pi) &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "char c size of is :" &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; "c address size of is :" &lt;&lt; sizeof(&amp;c) &lt;&lt; endl; cout &lt;&lt; "pc address size of is :" &lt;&lt; sizeof(pc) &lt;&lt; endl; cout &lt;&lt; "pc address value is :" &lt;&lt; &amp;pc &lt;&lt; endl; cout &lt;&lt; "pc value is :" &lt;&lt; *pc &lt;&lt; endl; cout &lt;&lt; "pc value size of is :" &lt;&lt; sizeof(*pc) &lt;&lt; endl; pc++; cout &lt;&lt; "pi + 1 is : " &lt;&lt; (&amp;pc) &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; "double d size of is :" &lt;&lt; sizeof(d) &lt;&lt; endl; cout &lt;&lt; "d address size of is :" &lt;&lt; sizeof(&amp;d) &lt;&lt; endl; cout &lt;&lt; "pd address size of is :" &lt;&lt; sizeof(pd) &lt;&lt; endl; cout &lt;&lt; "pd address value is :" &lt;&lt; pd &lt;&lt; endl; cout &lt;&lt; "pd value is :" &lt;&lt; *pd &lt;&lt; endl; cout &lt;&lt; "pd value size of is :" &lt;&lt; sizeof(*pd) &lt;&lt; endl; pd++; cout &lt;&lt; "pi + 1 is : " &lt;&lt; (pd) &lt;&lt; endl; cout &lt;&lt; endl;&#125; 运行结果： 1234567891011121314151617181920212223int i size of is :4i address size of is :8pi address size of is :8pi address value is :0x7ffee69ce22cpi value is :10pi value size of is :4pi + 1 is : 0x7ffee69ce230char c size of is :1c address size of is :8pc address size of is :8pc address value is :0x7ffee69ce210pc value is :qpc value size of is :1pi + 1 is : 0x7ffee69ce210double d size of is :8d address size of is :8pd address size of is :8pd address value is :0x7ffee69ce220pd value is :12pd value size of is :8pi + 1 is : 0x7ffee69ce228 数组与指针、数组元素与&amp;12345678910111213141516171819202122int iArr[] = &#123;1, 2, 3, 4, 5, 6&#125;;int *iArrP = iArr;cout &lt;&lt; "iArr is : " &lt;&lt; iArr &lt;&lt; endl;cout &lt;&lt; endl;cout &lt;&lt; "iArrP is : " &lt;&lt; iArrP &lt;&lt; endl;cout &lt;&lt; "iArrP+1 is : " &lt;&lt; iArrP + 1 &lt;&lt; endl;cout &lt;&lt; "iArrP+2 is : " &lt;&lt; iArrP + 2 &lt;&lt; endl;cout &lt;&lt; "*iArrP+1 value is : " &lt;&lt; *iArrP+1&lt;&lt;endl;cout &lt;&lt; "*(iArrP+1) value is : " &lt;&lt; *(iArrP+1)&lt;&lt;endl;// 错误的赋值// *iArrP+1 = 10;// 正确的赋值*(iArrP+1) = 10;cout &lt;&lt; "*(iArrP+1) = 10 new value is : " &lt;&lt; *(iArrP+1) &lt;&lt;endl;cout &lt;&lt; endl;cout &lt;&lt; "&amp;iArr is : " &lt;&lt; &amp;iArr &lt;&lt; endl;cout &lt;&lt; "&amp;iArr[0] is : " &lt;&lt; &amp;iArr[0] &lt;&lt; endl;cout &lt;&lt; "&amp;iArr[1] is : " &lt;&lt; &amp;iArr[1] &lt;&lt; endl;cout &lt;&lt; "&amp;iArr[2] is : " &lt;&lt; &amp;iArr[2] &lt;&lt; endl; 运行结果： 123456789101112131415ffee69ce228iArr is : 0x7ffee69ce230iArrP is : 0x7ffee69ce230iArrP+1 is : 0x7ffee69ce234iArrP+2 is : 0x7ffee69ce238*iArrP+1 value is : 2*(iArrP+1) value is : 4*(iArrP+1) = 10 new value is : 10&amp;iArr is : 0x7ffee69ce230&amp;iArr[0] is : 0x7ffee69ce230&amp;iArr[1] is : 0x7ffee69ce234&amp;iArr[2] is : 0x 指针数组int *ptr[3]; 定义用来 存储int数据类型指针 的 数组。详细解释为： 1声明了1个名为ptr的数组，这个名为ptr的数组由3个整数类型的指针元素组成 原始数组示例： 12345678void showArrayPoint() &#123; int var[3] = &#123;10, 100, 200&#125;; for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; var[i] &lt;&lt; endl; &#125;&#125; 运行结果： 123Value of var[0] = 10Value of var[1] = 100Value of var[2] = 200 原示例修改后： 12345678910111213void showArrayPoint() &#123; int var[MAX] = &#123;10, 100, 200&#125;; int *ptr[MAX]; for (int j = 0; j &lt; MAX; ++j) &#123; ptr[j] = &amp;var[j]; &#125; for (int i = 0; i &lt; MAX; i++) &#123; cout &lt;&lt; "Value of var[" &lt;&lt; i &lt;&lt; "] = "; cout &lt;&lt; *ptr[i] &lt;&lt; endl; &#125;&#125; 运行结果为： 123Value of var[0] = 10Value of var[1] = 100Value of var[2] = 200]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg-01-交叉编译编译Android平台.so文件]]></title>
    <url>%2FFFmpeg-01-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%BC%96%E8%AF%91Android%E5%B9%B3%E5%8F%B0-so%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[FFmpeg编译 —— 能够编译出so库是基础中的基础 参考： 【Android 音视频开发打怪升级：FFmpeg音视频编解码篇】一、FFmpeg so库编译 问题排查 注意：本文使用 Clang 方式进行编译。 涉及概念 交叉编译 是在一个平台上生成另一个平台上的可执行代码。 例如：在PC上编译一个apk，这个apk可以跑在Android手机上，这其实就是一个交叉编译过程。 使用交叉编译的原因：利用编译平台的 性能 及 资源 快速有效的生成目标平台文件。 交叉编译环境 交叉编译最重要的是：配置好编译过程中使用到的相关的环境，而这个环境其实就是目标机器（比如Android手机）运行的环境。 C/C++编译工具链 GCC 老牌编译工具，不仅可以编译C/C++，也可以编译Java，Object-C，Go等语言。 Clang 则是一个效率更高的C/C++编译工具，并且兼容GCC，在 ndk 17 以后，把 GCC 移除了，全面推行使用 Clang 。 LLVM 是模块化、可重用的编译器及工具链技术的集合。尽管名称如此，LLVM与传统虚拟机关系不大。名称 “LLVM”本身不是缩写，它是项目的全名。 Clang 为LLVM项目 的主要子项目 —— C语言家族（C，C ++，Objective C / C ++，OpenCL，CUDA和RenderScript）中的语言提供了语言前端和工具基础结构。同时提供了GCC兼容的编译器驱动程序（clang）和MSVC兼容的编译器驱动程序（clang-cl.exe）。 LLVM最初是伊利诺伊大学的一个研究项目，目的是提供一种基于SSA的 现代编译策略，该策略能够支持任意编程语言 的 静态编译、动态编译。 资源下载 编译环境：macOS 编译方式：Clang Android NDK 20 FFmpeg 4.2.2 编译步骤 执行 ./configure （只在第一次解压ffmpeg压缩包后执行。生成基础文件，供后续编译使用，否则提示“各种文件找不到”） 配置（使用配置脚本） 编译（使用make） 安装（使用make install） 配置脚本配置基础条件： macOS FFmpeg 4.2.2 Android NDK-20b 编译方式：Clang configure配置文件修改修改ffmpeg-4.2.2/configure文件（这是一个shell脚本，用于生成一些 FFmpeg 编译需要的配置文件）： 新增 cross_prefix_clang 参数 123456789101112131415161718CMDLINE_SET=&quot; $PATHS_LIST ar arch as assert_level build_suffix cc objcc cpu cross_prefix # 新增命令行参数 cross_prefix_clang custom_allocator cxx dep_cc # 省略其他.....&quot; 修改编译工具路径设置 搜索 ar_default=&quot;${cross_prefix}${ar_default}&quot; , 找到以下代码 12345ar_default=&quot;$&#123;cross_prefix&#125;$&#123;ar_default&#125;&quot;cc_default=&quot;$&#123;cross_prefix&#125;$&#123;cc_default&#125;&quot;cxx_default=&quot;$&#123;cross_prefix&#125;$&#123;cxx_default&#125;&quot;nm_default=&quot;$&#123;cross_prefix&#125;$&#123;nm_default&#125;&quot;pkg_config_default=&quot;$&#123;cross_prefix&#125;$&#123;pkg_config_default&#125;&quot; 将中间两行修改为 1234567ar_default=&quot;$&#123;cross_prefix&#125;$&#123;ar_default&#125;&quot;#------------------------------------------------cc_default=&quot;$&#123;cross_prefix_clang&#125;$&#123;cc_default&#125;&quot;cxx_default=&quot;$&#123;cross_prefix_clang&#125;$&#123;cxx_default&#125;&quot;#------------------------------------------------nm_default=&quot;$&#123;cross_prefix&#125;$&#123;nm_default&#125;&quot;pkg_config_default=&quot;$&#123;cross_prefix&#125;$&#123;pkg_config_default&#125;&quot; 新建编译配置脚本脚本名称可自行命名，例如：build_android_clang.sh，脚本文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/zshset -x# NDK的路径NDK=/Users/yannischeng/FFmpeg/android-ndk-r20b# 编译工具链路径TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin# 交叉编译环境目录：SYSROOT=$NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot# 平台OS=android# CPU架构CPU=armv7-aARCH=arm# Android版本API=21#so库输出目录PREFIX=/Users/yannischeng/FFmpeg/Androidfunction build&#123; ./configure \ --prefix=$PREFIX \ --target-os=$OS \ --arch=$ARCH \ --cpu=$CPU \ --enable-shared \ --disable-static \ --enable-asm \ --enable-neon \ --enable-cross-compile \ --disable-doc \ --disable-ffplay \ --disable-ffprobe \ --disable-symver \ --disable-ffmpeg \ --sysroot=$SYSROOT \ --cross-prefix=$TOOLCHAIN/arm-linux-androideabi- \ --cross-prefix-clang=$TOOLCHAIN/armv7a-linux-androideabi$API- \ --extra-cflags=&quot;-fPIC&quot; make clean all make -j8 make install&#125;build 问题总结 ./configure执行后，提示： 1nasm/yasm not found or too old. Use --disable-x86asm for a crippled build. 解决：安装 yasm就能将解决 1brew install yasm Error 127 12/bin/sh: ranlib/usr/local/lib/libavdevice.a: No such file or directorymake: *** [install-libavdevice-static] Error 127 解决：由于 LIB_INSTALL_EXTRA_CMD=&#39;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME) 这个命令少打了一个空格，应该改为`LIB_INSTALL_EXTRA_CMD=&#39;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&#39;。之后要重新执行下 ./configure，不然还是报这个错。 类似：C compiler test failed. 12/Users/xxx/android-ndk-r20/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-gcc is unable to create an executable file.C compiler test failed. 原因是没有arm-linux-androideabi-gcc这个文件了。 编译Android平台后，生成后缀.a的库，不是so库 解决办法：看下编译脚本，要这么写 12--enable-shared \--disable-static \ 有可能会遇到：无法打开“armv7a-linux-androideabi21-clang”，因为无法验证开发者。 弹窗，而且只有移到废纸篓和取消这2个按钮。 解决： 进入：系统偏好设置-&gt;安全与隐私-&gt;通用选项卡。如果“左下角的小锁”处于锁定🔒状态，且同时选中任何来源选项，此时改变原选项，选择App Store 和被认可的开发者选项。注意：此时保持此界面状态，暂不做任何修改。 在终端界面再次运行自己编写的配置脚本，此时会再次弹出窗口，提示：无法打开“armv7a-linux-androideabi21-clang”，因为无法验证开发者。 此时转到刚才修改过的：系统偏好设置-&gt;安全与隐私-&gt;通用选项卡，此时在任何来源附近会有一个灰色的文字提示，且旁边有一个 允许XXX 按钮，单击允许按钮 。 再次在端界面再次运行自己编写的配置脚本，此时会弹出：macOS无法验证“armv7a-linux-androideabi21-clang”的开发者。您确定要打开它吗？，点击弹窗中的打开按钮即可。问题解决。]]></content>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg-00-概览]]></title>
    <url>%2FFFmpeg-00-%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[概念 FFmpeg官网 FFmpeg维基 关于FFmpegFFmpeg 是一套集录制、转换以及流化音视频的完整的跨平台解决方案、是领先的 多媒体框架，能够解码，编码， 转码，mux，demux，流，过滤和播放人类和机器创建的几乎所有内容。它还具有 高度的可移植性：FFmpeg可以在各种构建环境，机器体系结构和配置下，跨Linux，Mac OS X，Microsoft Windows，BSD，Solaris等编译 FFmpeg工具 ffmpeg 一个 命令行工具，来进行多媒体文件之间的格式转换。是一个非常快速的视频和音频转换器，也可以从实时音频/视频源中获取。它还可以在任意采样率之间转换，并使用高质量的多相滤波器即时调整视频大小。 ffplay FFplay是使用FFmpeg库和SDL库的非常简单且可移植的 媒体播放器。它主要用作各种FFmpeg API的测试平台 ffprobe ffprobe从多媒体流中 收集信息，并以人类和机器可读的方式进行打印。 FFmpeg开发人员库 libavutil 库是用于辅助便携式多媒体编程的 实用程序库。它包含安全的便携式字符串函数，随机数生成器，数据结构，其他数学函数，密码学和与多媒体相关的功能（例如像素和样本格式的枚举）。它不是libavcodec和libavformat都需要的代码的库。 libavcodec 库提供了通用的 编码/解码框架，并包含用于音频，视频和字幕流的多个解码器和编码器，以及几个位流过滤器。共享的体系结构提供各种服务，从位流I/O到DSP优化，使其适合于实现强大，快速的编解码器以及实验。 libavformat 库提供了一个通用框架，用于对音频，视频和字幕流进行多路复用和多路分解（混合和解混合）。它包含用于 多媒体容器格式 的 多个复用器 和 解复用器。它还支持多种输入和输出协议以访问媒体资源。 libavdevice 库提供了用于从许多常见的 多媒体输入/输出设备 获取和呈现的通用框架，并支持多种输入和输出设备，包括Video4Linux2，VfW，DShow和ALSA。 libavfilter 库提供了一个通用的 音频/视频过滤框架，其中包含多个过滤器，源和接收器。 libswscale 库执行高度优化的图像缩放以及色彩空间和像素格式 转换操作。 libswresample 库执行高度优化的音频重采样，重新矩阵化和样本格式 转换操作。]]></content>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Camera2]]></title>
    <url>%2FAndroid-Camera2%2F</url>
    <content type="text"><![CDATA[Camera2 CameraMetadata：相机控件和信息的基类。 此类定义用于查询摄像机特性或捕获结果以及设置摄像机请求参数的基本键/值映射。 CameraMetadata的所有实例都是不可变的。 在对象的整个生命周期中，带有{@link #getKeys（）}的键列表永远不会更改，带有{@code #get}的任何键返回的值也不会改变。 CameraCharacteristics CameraDeviceCameraManagerCameraCharacteristics CaptureResult public static final int LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED = 0;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Camera2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-自定义绘制Widget]]></title>
    <url>%2FFlutter-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%88%B6Widget%2F</url>
    <content type="text"><![CDATA[Flutter-自定义绘制Widget 参考: https://www.jianshu.com/p/a40032af6ae2 涉及到的类 CustomPaint。一个Widget，提供在绘制阶段在其上进行绘制的画布。 CustomPainter]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>自定义绘制Widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS下搭建Jenkins]]></title>
    <url>%2FmacOS%E4%B8%8B%E6%90%AD%E5%BB%BAJekins%2F</url>
    <content type="text"><![CDATA[macOS下搭建Jenkins Jenkins相关概念软件的开发和发布已经形成了一套标准流程，分为以下几个阶段： 1编码 → 构建 → 集成 → 测试 → 交付 → 部署 即： 不同的 软件自动化交付周期 CI：持续集成 (Continuous Integration) CD：持续交付 (Continuous Delivery) CD：持续部署 (Continuous Deployment) CI（持续集成，Continuous Integration）上面整个流程中最重要的组成部分就是 持续集成，其是指： 1频繁地（一天多次）将代码集成到主干。将软件个人研发的部分向软件整体部分交付，频繁进行集成以便更快地发现其中的错误。 持续集成的 目的：就是让产品可以 快速迭代，同时还能 保持高质量。 CD（持续交付，Continuous Delivery）1频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。 持续交付 在 持续集成 的基础上，将集成后的代码部署到更贴近真实运行环境的类生产环境(production-like environments)中。 它 强调 的是：不管怎么更新，软件是随时随地可以交付的。 CD（持续部署，Continuous Deployment）是 持续交付 的下一步，指的是：代码通过评审以后，自动部署到生产环境。持续部署的 目标 是：代码在任何时刻都是可部署的，可以进入生产阶段。持续部署的前提是能自动化完成测试、构建、部署等步骤。 Jenkins 是什么？ Jenkins 是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。 Jenkins 如何做到集成？1jenkins本质是一个特殊的http服务器，我们使用Git Push一个commit 到远程服务器，Jenkins通过Git钩子得知服务器有新的提交，就会通过配置的Git仓库路径把新提交的代码pull下来，进行编译，打包，上传等操作。 安装与卸载安装 通过 Homebrew 进行安装。 1brew install jenkins 卸载 方法1：执行命令： 1/Library/Application Support/Jenkins/Uninstall.command 方法2：前往文件夹： 1/Library/Application Support/Jenkins 双击 Uninstall.command。完成之后再次打开http://localhost:8080 访问不了，说明卸载成功。 初始化启动服务 首次安装接收后，提示： 123456Note: When using launchctl the port will be 8080.To have launchd start jenkins now and restart at login: brew services start jenkinsOr, if you don&apos;t want/need a background service you can just run: jenkins 即2种启动方式： 要立即启动，并在登录时自动在后台重新启动： 1brew services start jenkins 不希望/不需要后台服务（关闭命令窗口后，服务断开） 1jenkins 执行启动命令后，会出现 用户名 和 初始密码 提示。重点！！！ 一定要记住在命令行中生成的密码，在之后的首次登录中会用到。 12345678910Jenkins initial setup is required. An admin user has been created and a password generated.Please use the following password to proceed to installation:5a9e3ba1344e47f399c79f6f82fc91e8This may also be found at: /Users/yannischeng/.jenkins/secrets/initialAdminPassword*************************************************************************************************************************************************************************************** 初次登陆在成功启动服务后，在浏览器输入 http://localhost:8080 即可进入 Jenkins。如果是 首次登录 需要输入初始密码： 插件安装Jenkins 只是提供一个 可以进行持续集成的环境 ，所以在进行持续集成的时候，我们还需要安装各种 插件。点击 选择插件来安装即可，之后就会对插件进行顺序安装。 创建用户 url设置 初始化结束 等待所有的插件安装完毕，在浏览器地址栏输入：http://localhost:8080/restart。至此安装阶段结束 。 基础配置Jenkins全局配置配置重点！！！ Gradle 路径配置 Android SDK 路径配置 Java JDK 路径配置 Configure Systemurl/Android SDK配置 Global Tool ConfigurationJDK路径 Gradle路径 Android 单个任务配置配置重点！！！ General-&gt;高级-&gt;使用自定义工作空间 源码管理-&gt;版本控制信息填写 构建-&gt;Invoke Gradle-&gt;Gradle Version选择、Task填写 点击 新建Item执行设置 。 创建单个项目General-高级 目录：可以设置为当前项目所在目录。 显示名称：指的是在Jenkins中能够看到的名称。 源码管理 注意：在红色方框处一定要填写自己的版本控制账号信息，否则提示类似“无法连接到vcs”的信息。 构建 此处之所以能够进行gradle版本的选择，是因为在之前的“全局工具配置”中已经进行了配置。 Task的编写如果不符合规范，将会导致编译出错。 一般而言，只要完成以上简单的配置后，就可以进行最基础的Jenkins操作了。以上配置结束后，点击应用、保存即可。 更多配置构建触发器定时构建&amp;轮询SCM 参考：https://www.cnblogs.com/hong-fithing/p/10547176.html参考：https://blog.csdn.net/MenofGod/article/details/81288987 定时构建（Build periodically）：不管SVN或Git中数据有无变化，均执行定时化的构建任务 ； 轮询SCM（Poll SCM）：只要SVN或Git中数据有更新，则执行构建任务； 设置结果 语法说明 格式为（五个星）： 1* * * * * 释义 第1个*表示：分钟，取值0~59 第2个*表示：小时，取值0~23 第3个*表示：一个月的第几天，取值1~31 第4个*表示：第几月，取值1~12 第5个*表示：一周中的第几天，取值0~7，其中0和7代表的都是周日 使用举例： 每隔10分钟构建一次：H/5 * * * * 每隔1小时构建一次： H H/1 * * * 每月30号构建一次： H H 30 * * 定时构建 和 轮询SCM 使用 互不冲突，具体如何组合，需要根据项目情况合理配置。 构建后操作邮箱配置 参考：https://blog.csdn.net/qq_36396763/article/details/100115092 Jenkins-配置注意：系统管理员邮箱 必须和 发件人邮箱 一致 账号配置账号名称 账号信息设置 注意：此处的密码指的是 邮箱客户端授权码，不是自己设置的 邮箱密码 端口设置 扩展电子邮件通知配置（Extended E-mail Notification）信息设置 注意：此处的密码指的是 邮箱客户端授权码，不是自己设置的 邮箱密码 在执行下一步“自定义邮件展示内容”前需要先设置内容显示格式，否则不显示格式。 自定义邮件展示内容 具体内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;$&#123;ENV, var=&quot;JOB_NAME&quot;&#125;-第$&#123;BUILD_NUMBER&#125;次构建日志&lt;/title&gt;&lt;/head&gt;&lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot; offset=&quot;0&quot;&gt; &lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt; &lt;tr&gt; &lt;td&gt;(本邮件是程序自动下发的，请勿回复！)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;h2&gt; &lt;font color=&quot;#0000FF&quot;&gt;构建结果 - $&#123;BUILD_STATUS&#125;&lt;/font&gt; &lt;/h2&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;br /&gt; &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;项目名称&amp;nbsp;：&amp;nbsp;$&#123;PROJECT_NAME&#125;&lt;/li&gt; &lt;li&gt;构建编号&amp;nbsp;：&amp;nbsp;第$&#123;BUILD_NUMBER&#125;次构建&lt;/li&gt; &lt;li&gt;SVN&amp;nbsp;版本：&amp;nbsp;$&#123;SVN_REVISION&#125;&lt;/li&gt; &lt;li&gt;触发原因：&amp;nbsp;$&#123;CAUSE&#125;&lt;/li&gt; &lt;li&gt;构建日志：&amp;nbsp;&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;/li&gt; &lt;li&gt;构建&amp;nbsp;&amp;nbsp;Url&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;BUILD_URL&#125;&quot;&gt;$&#123;BUILD_URL&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;工作目录&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;PROJECT_URL&#125;ws&quot;&gt;$&#123;PROJECT_URL&#125;ws&lt;/a&gt;&lt;/li&gt; &lt;li&gt;项目&amp;nbsp;&amp;nbsp;Url&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;Changes Since Last Successful Build:&lt;/font&gt;&lt;/b&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;历史变更记录 : &lt;a href=&quot;$&#123;PROJECT_URL&#125;changes&quot;&gt;$&#123;PROJECT_URL&#125;changes&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; $&#123;CHANGES_SINCE_LAST_SUCCESS,reverse=true, format=&quot;Changes for Build #%n:&lt;br /&gt;%c&lt;br /&gt;&quot;,showPaths=true,changesFormat=&quot;&lt;pre&gt;[%a]&lt;br /&gt;%m&lt;/pre&gt;&quot;,pathFormat=&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;%p&quot;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;Failed Test Results&lt;/b&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;pre style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;$FAILED_TESTS&lt;/pre&gt; &lt;br /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建日志 (最后 100行):&lt;/font&gt;&lt;/b&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- &lt;tr&gt; &lt;td&gt;Test Logs (if test has ran): &lt;a href=&quot;$&#123;PROJECT_URL&#125;ws/TestResult/archive_logs/Log-Build-$&#123;BUILD_NUMBER&#125;.zip&quot;&gt;$&#123;PROJECT_URL&#125;/ws/TestResult/archive_logs/Log-Build-$&#123;BUILD_NUMBER&#125;.zip&lt;/a&gt; &lt;br /&gt; &lt;br /&gt; &lt;/td&gt; &lt;/tr&gt; --&gt; &lt;tr&gt; &lt;td&gt;&lt;pre&gt;&lt;textarea cols=&quot;80&quot; rows=&quot;30&quot; readonly=&quot;readonly&quot; style=&quot;font-family: Courier New&quot;&gt;$&#123;BUILD_LOG, maxLines=100&#125;&lt;pre&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 设置debug模式，在这种模式下能够看到关于邮件的各种信息 增加构建后操作设置触发条件 添加收件人 上传fir.im 参考：https://www.jianshu.com/p/9a245918a219 上传蒲公英 参考：https://www.jianshu.com/p/8cd8c1236c16https://blog.csdn.net/wangpingtaohn/article/details/99979996 常见问题Plugin with id ‘com.android.application’ not found.链接：https://www.oschina.net/question/3147266_2277036?sort=time [ERROR] Can’t retrieve the Gradle executable.链接：https://blog.csdn.net/ouyang_peng/article/details/83828626 肯定是gradle的路径没有配置对。]]></content>
      <categories>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境下MySQL的安装与使用-2最新]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%9A%84-2%2F</url>
    <content type="text"><![CDATA[系统：MacOS mysql操作命令参考：http://www.runoob.com/mysql/mysql-tutorial.html 使用brew进行安装、更新、服务开启、关闭。特点：简单高效。 安装1brew install mysql 安装成功提示： 12345678910111213141516171819==&gt; Downloading https://homebrew.bintray.com/bottles/mysql-8.0.18.catalina.bottle.tar.gzAlready downloaded: /Users/yannischeng/Library/Caches/Homebrew/downloads/602632daf49a89c8e48be565941801c82f424d9551e4f13f4797f4a19badbe07--mysql-8.0.18.catalina.bottle.tar.gz==&gt; Pouring mysql-8.0.18.catalina.bottle.tar.gz==&gt; /usr/local/Cellar/mysql/8.0.18/bin/mysqld --initialize-insecure --user=yannischeng --basedir=/usr/local/Cellar/mysql/8.0.18 --datadir=/usr/local/var/mysql --tmpdir=/tmp==&gt; CaveatsWe&apos;ve installed your MySQL database without a root password. To secure it run: mysql_secure_installationMySQL is configured to only allow connections from localhost by defaultTo connect run: mysql -urootTo have launchd start mysql now and restart at login: brew services start mysqlOr, if you don&apos;t want/need a background service you can just run: mysql.server start==&gt; Summary🍺 /usr/local/Cellar/mysql/8.0.18: 293 files, 281.4MB 在安装成功的信息中，需要注意命令： brew services start mysql：开启自动开启服务 mysql.server start：手动开启服务 更新1brew upgrade mysql 安装信息检查1brew info mysql 内容提示： 123456789101112131415161718192021222324252627282930313233mysql: stable 8.0.18 (bottled)Open source relational database management systemhttps://dev.mysql.com/doc/refman/8.0/en/Conflicts with: mariadb (because mysql, mariadb, and percona install the same binaries.) mariadb-connector-c (because both install plugins) mysql-connector-c (because both install MySQL client libraries) percona-server (because mysql, mariadb, and percona install the same binaries.)/usr/local/Cellar/mysql/8.0.18 (293 files, 281.4MB) * Poured from bottle on 2019-10-16 at 08:55:11From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/mysql.rb==&gt; DependenciesBuild: cmake ✘Required: openssl@1.1 ✔==&gt; RequirementsRequired: macOS &gt;= 10.10 ✔==&gt; CaveatsWe&apos;ve installed your MySQL database without a root password. To secure it run: mysql_secure_installationMySQL is configured to only allow connections from localhost by defaultTo connect run: mysql -urootTo have launchd start mysql now and restart at login: brew services start mysqlOr, if you don&apos;t want/need a background service you can just run: mysql.server start==&gt; Analyticsinstall: 68,373 (30 days), 210,745 (90 days), 805,853 (365 days)install_on_request: 64,489 (30 days), 196,784 (90 days), 751,269 (365 days)build_error: 0 (30 days) 注意： 由 ✘ 标志的是由问题的。在安装之后，运行 MySQL 时遇到的各种问题有一部分和这个是有关系的。 处理： 先检查是否已经存在 cmake 1brew unlink cmake 如果提示： 1Error: No such keg: /usr/local/Cellar/cmake 不需要理会。直接执行下一步： 1brew install cmake 运行之后提示： 123456789==&gt; Downloading https://homebrew.bintray.com/bottles/cmake-3.15.4.catalina.bottle.tar.gz==&gt; Downloading from https://akamai.bintray.com/46/46d8b2170e1bc872f5d4548a730bd7829347189aa8c50843343ff2f0e4e356e4?__gda__=exp=1571188226~hmac=bf4a7786b05e1c68dbddb95d81610c39c######################################################################## 100.0%==&gt; Pouring cmake-3.15.4.catalina.bottle.tar.gz==&gt; CaveatsEmacs Lisp files have been installed to: /usr/local/share/emacs/site-lisp/cmake==&gt; Summary🍺 /usr/local/Cellar/cmake/3.15.4: 5,800 files, 53.4MB 当再次运行 brew info mysql 后，提示的内容中就不会再有 ✘ 运行测试1mysql -uroot 如果出现如下提示： 1234567891011Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 14Server version: 8.0.18 HomebrewCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. 表示：至此MySQL安装成功，安装环节结束。 连接MySQL服务后，通过一下命令查看当前安装MySQL的版本： 1mysql -V 结果显示： 1mysql Ver 8.0.18 for osx10.15 on x86_64 (Homebrew) 密码修改使用 mysql -uroot 连接MySQL是一种没有密码、不安全的连接方式。需要设置密码。首先通过 mysql -uroot 连接MySQL服务，之后通过 SQL语句 1set PASSWORD = &quot;111111&quot;; 在 8.0.+版本，可能会报错： 1ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 出现这个问题的原因是 密码太简单，安全等级不够。将 111111 设置为 Admin_1 之类的就可以了。密码设置成之后将会提示： 1Query OK，0 rows affected（0.01 sec） 再次登录时，使用 1mysql -u root -p 就会提示 ：Enter password:，此时输入刚才设置的密码即可。 MySQL服务相关操作前提：进入MySQL安装目录的bin文件内。如：/usr/local/Cellar/mysql/8.0.18/bin]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-BindingBase]]></title>
    <url>%2FFlutter-BindingBase%2F</url>
    <content type="text"><![CDATA[Flutter-BindingBase future.whenComplete()的在源码中的使用 12345678910111213141516Future&lt;void&gt; lockEvents(Future&lt;void&gt; callback()) &#123; developer.Timeline.startSync('Lock events'); assert(callback != null); _lockCount += 1; final Future&lt;void&gt; future = callback(); assert(future != null, 'The lockEvents() callback returned null; it should return a Future&lt;void&gt; that completes when the lock is to expire.'); future.whenComplete(() &#123; _lockCount -= 1; if (!locked) &#123; developer.Timeline.finishSync(); unlocked(); &#125; &#125;); return future;&#125; BindingBase源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447/// Signature for service extensions.////// The returned map must not contain the keys "type" or "method", as/// they will be replaced before the value is sent to the client. The/// "type" key will be set to the string `_extensionType` to indicate/// that this is a return value from a service extension, and the/// "method" key will be set to the full name of the method.typedef ServiceExtensionCallback = Future&lt;Map&lt;String, dynamic&gt;&gt; Function(Map&lt;String, String&gt; parameters);/// 用于提供单例服务的 "mixins的基类（也称为“绑定”）"。////// 要在mixin的`on`子句中使用此类，请继承它并实现[initInstances()]。 /// mixin保证只在应用程序的生命周期中构造一次（更确切地说，如果在检查模式下构造两次，它将断言）。////// 用于编写应用程序的"最顶层"将具有一个继承自[BindingBase]并使用所有各种[BindingBase] mixins（例如[ServicesBinding]）的具体类。 /// 例如，Flutter中的Widgets库引入了一个名为[WidgetsFlutterBinding]的绑定。 相关库定义了如何创建绑定。 /// 可以暗示（例如，[WidgetsFlutterBinding]自动从[runApp]启动），或者可能需要应用程序显式调用构造函数。abstract class BindingBase &#123; /// "绑定"的默认抽象构造函数。 /// /// 首先调用[initInstances]以使"绑定"初始化"其实例指针"和"其他状态"，然后调用[initServiceExtensions]以使"绑定"初始化"其天文台服务扩展（如果有）"。 BindingBase() &#123; developer.Timeline.startSync('Framework initialization'); assert(!_debugInitialized); initInstances(); assert(_debugInitialized); assert(!_debugServiceExtensionsRegistered); initServiceExtensions(); assert(_debugServiceExtensionsRegistered); developer.postEvent('Flutter.FrameworkInitialization', &lt;String, String&gt;&#123;&#125;); developer.Timeline.finishSync(); &#125; static bool _debugInitialized = false; static bool _debugServiceExtensionsRegistered = false; /// 绑定此"绑定"的窗口。 /// /// 许多“其他绑定”被定义为[BindingBase]的扩展，例如[ServicesBinding]，[RendererBinding]和[WidgetsBinding]。 /// 这些绑定中的每一个都定义了与[ui.Window]交互的行为，例如： /// [ServicesBinding]注册了[ui.Window.onPlatformMessage]处理程序， /// [RendererBinding]注册了[ui.Window.onMetricsChanged]、[ui.Window. onTextScaleFactorChanged]、[ui.Window.onSemanticsEnabledChanged]和[ui.Window.onSemanticsAction]处理程序。 /// /// 这些“其他绑定”中的每一个都可以静态地单独访问[Window]，但这会妨碍使用假窗口测试这些行为以进行验证的能力。 /// 因此，[BindingBase]公开此[Window]以供其他绑定使用。 /// [BindingBase]的子类，例如[TestWidgetsFlutterBinding]，可以覆盖此访问器以返回不同的[Window]实现，例如[TestWindow]。 ui.Window get window =&gt; ui.window; /// 初始化方法。 子类重写此方法以挂接到平台并以其他方式配置其服务。 子类必须调用“super.initInstances()”。 /// /// 按照惯例，如果要将服务作为单例提供，它应该公开为`MixinClassName.instance`，一个返回`MixinClassName._instance`的静态getter，一个由`initInstances（）设置的静态字段`。 @protected @mustCallSuper void initInstances() &#123; assert(!_debugInitialized); assert(() &#123; _debugInitialized = true; return true; &#125;()); &#125; /// 初始化绑定时调用，注册服务扩展。 /// /// "绑定"想要公开服务的扩展应该重载此方法，以使用对[registerSignalServiceExtension]，[registerBoolServiceExtension]，[registerNumericServiceExtension]和[registerServiceExtension]的调用（按复杂程度递增的顺序）注册它们。 /// /// 此方法的实现必须调用其超类实现。 /// /// &#123;@macro flutter.foundation.bindingBase.registerServiceExtension&#125; /// /// See also: /// /// * &lt;https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md#rpcs-requests-and-responses&gt; @protected @mustCallSuper void initServiceExtensions() &#123; assert(!_debugServiceExtensionsRegistered); assert(() &#123; registerSignalServiceExtension( name: 'reassemble', callback: reassembleApplication, ); return true; &#125;()); if (!kReleaseMode &amp;&amp; !kIsWeb) &#123; registerSignalServiceExtension( name: 'exit', callback: _exitApplication, ); registerServiceExtension( name: 'saveCompilationTrace', callback: (Map&lt;String, String&gt; parameters) async &#123; return &lt;String, dynamic&gt;&#123; 'value': ui.saveCompilationTrace(), &#125;; &#125;, ); &#125; assert(() &#123; const String platformOverrideExtensionName = 'platformOverride'; registerServiceExtension( name: platformOverrideExtensionName, callback: (Map&lt;String, String&gt; parameters) async &#123; if (parameters.containsKey('value')) &#123; switch (parameters['value']) &#123; case 'android': debugDefaultTargetPlatformOverride = TargetPlatform.android; break; case 'iOS': debugDefaultTargetPlatformOverride = TargetPlatform.iOS; break; case 'fuchsia': debugDefaultTargetPlatformOverride = TargetPlatform.fuchsia; break; case 'default': default: debugDefaultTargetPlatformOverride = null; &#125; _postExtensionStateChangedEvent( platformOverrideExtensionName, defaultTargetPlatform.toString().substring('$TargetPlatform.'.length), ); await reassembleApplication(); &#125; return &lt;String, dynamic&gt;&#123; 'value': defaultTargetPlatform .toString() .substring('$TargetPlatform.'.length), &#125;; &#125;, ); return true; &#125;()); assert(() &#123; _debugServiceExtensionsRegistered = true; return true; &#125;()); &#125; /// [lockEvents]当前是否锁定事件。 /// /// “绑定子类”的触发事件应首先检查它，如果已设置，则排队事件而不是触发事件。 /// /// 调用[unlocked]时应刷新事件 @protected bool get locked =&gt; _lockCount &gt; 0; int _lockCount = 0; /// 锁定异步事件和callbacks的dispatching（调度），直到callback's future完成。 /// 这会导致输入滞后，因此应尽可能避免。 它主要用于“非用户交互时间”，例如允许[reassembleApplication]在它走遍树时阻塞输入（它部分异步地执行）。 /// /// [Future]是由[lockEvents]返回`callback`参数返回的。 @protected Future&lt;void&gt; lockEvents(Future&lt;void&gt; callback()) &#123; developer.Timeline.startSync('Lock events'); assert(callback != null); _lockCount += 1; final Future&lt;void&gt; future = callback(); assert(future != null, 'The lockEvents() callback returned null; it should return a Future&lt;void&gt; that completes when the lock is to expire.'); future.whenComplete(() &#123; _lockCount -= 1; if (!locked) &#123; developer.Timeline.finishSync(); unlocked(); &#125; &#125;); return future; &#125; /// 当事件解锁时由[lockEvents]调用。 /// /// 这应该刷新[locked]为真时排队的所有事件。 @protected @mustCallSuper void unlocked() &#123; assert(!locked); &#125; /// 导致整个应用程序redraw（重绘），例如 hot reload 后。 /// /// 当应用程序代码发生变化时，开发工具会使用它，以使应用程序获取任何已更改的代码。 /// 它可以通过发送`ext.flutter.reassemble`服务扩展信号手动触发。 /// /// 此方法计算量非常大，不应在生产代码中使用。 /// 永远不会有正当理由导致整个应用程序在生产中重新绘制。 Flutter框架的所有方面都知道如何在必要时重绘。 只有在开发中，当代码在运行中（例如在热加载中）或者在调试标志被切换时才需要进行开发。 /// /// 当此方法运行时，事件被锁定（例如，不dispatched（调度）pointer（指针）事件）。 /// /// 子类（绑定类）应覆盖[performReassemble()]以响应被调用的此方法。 不应该覆盖此方法本身。 Future&lt;void&gt; reassembleApplication() &#123; return lockEvents(performReassemble); &#125; /// This method is called by [reassembleApplication] to actually cause the /// application to reassemble, e.g. after a hot reload. /// /// "绑定"应该使用此方法重新注册使用闭包的任何内容，以便它们不会指向旧代码，并刷新以前计算的值的任何缓存，以防新代码以不同方式计算它们。 /// 例如，渲染层触发整个应用程序在调用它时重新绘制。 /// /// 不要直接调用此方法。 相反，使用[reassembleApplication]。 @mustCallSuper @protected Future&lt;void&gt; performReassemble() &#123; FlutterError.resetErrorCount(); return Future&lt;void&gt;.value(); &#125; /// 使用给定名称（全名“ext.flutter.name”）注册服务扩展方法，该方法不接受任何参数并且不返回任何值。 /// ///调用服务扩展时调用`callback`回调。 /// &#123;@macro flutter.foundation.bindingBase.registerServiceExtension&#125; @protected void registerSignalServiceExtension(&#123; @required String name, @required AsyncCallback callback, &#125;) &#123; assert(name != null); assert(callback != null); registerServiceExtension( name: name, callback: (Map&lt;String, String&gt; parameters) async &#123; await callback(); return &lt;String, dynamic&gt;&#123;&#125;; &#125;, ); &#125; /// 注册具有给定名称（全名“ext.flutter.name”）的服务扩展方法，该方法采用单个参数“enabled”，其值可以为“true”或值为“false”，或者可以省略以读取 当前值。 （“true”以外的任何值都被视为等于“false”。其他参数将被忽略。） /// ///调用`getter`回调以在响应被调用的服务扩展方法时获取值。 /// ///使用新值调用服务扩展方法时，使用新值调用`setter`回调。 @protected void registerBoolServiceExtension(&#123; @required String name, @required AsyncValueGetter&lt;bool&gt; getter, @required AsyncValueSetter&lt;bool&gt; setter, &#125;) &#123; assert(name != null); assert(getter != null); assert(setter != null); registerServiceExtension( name: name, callback: (Map&lt;String, String&gt; parameters) async &#123; if (parameters.containsKey('enabled')) &#123; await setter(parameters['enabled'] == 'true'); _postExtensionStateChangedEvent(name, await getter() ? 'true' : 'false'); &#125; return &lt;String, dynamic&gt;&#123;'enabled': await getter() ? 'true' : 'false'&#125;; &#125;, ); &#125; /// 注册具有给定名称（全名“ext.flutter.name”）的服务扩展方法，该方法采用与方法同名的单个参数，如果存在，则必须具有可由以下方法解析的值： [double.parse]，可以省略读取当前值。 （其他参数被忽略。） /// ///调用`getter`回调以在响应被调用的服务扩展方法时获取值。 /// ///使用新值调用服务扩展方法时，使用新值调用`setter`回调。 /// /// &#123;@macro flutter.foundation.bindingBase.registerServiceExtension&#125; @protected void registerNumericServiceExtension(&#123; @required String name, @required AsyncValueGetter&lt;double&gt; getter, @required AsyncValueSetter&lt;double&gt; setter, &#125;) &#123; assert(name != null); assert(getter != null); assert(setter != null); registerServiceExtension( name: name, callback: (Map&lt;String, String&gt; parameters) async &#123; if (parameters.containsKey(name)) &#123; await setter(double.parse(parameters[name])); _postExtensionStateChangedEvent(name, (await getter()).toString()); &#125; return &lt;String, dynamic&gt;&#123;name: (await getter()).toString()&#125;; &#125;, ); &#125; /// 更改服务扩展的状态时发送事件。 /// ///客户端应该监听此事件以了解当前的服务扩展状态。 管理状态的任何服务扩展都应该在状态更改时调用此方法。 /// ///“value”反映了新更新的服务扩展值。 /// ///将通过[registerBoolServiceExtension]，[registerNumericServiceExtension]或[registerStringServiceExtension]注册的服务扩展自动调用。 void _postExtensionStateChangedEvent(String name, dynamic value) &#123; postEvent( 'Flutter.ServiceExtensionStateChanged', &lt;String, dynamic&gt;&#123; 'extension': 'ext.flutter.$name', 'value': value, &#125;, ); &#125; /// 由[BindingBase]调度的所有事件都使用此方法而不是直接调用[developer.postEvent]，以便[BindingBase]的测试可以通过覆盖此方法来跟踪调度的事件。 @protected void postEvent(String eventKind, Map&lt;String, dynamic&gt; eventData) &#123; developer.postEvent(eventKind, eventData); &#125; /// Registers a service extension method with the given name (full name /// "ext.flutter.name"), which optionally takes a single argument with the /// name "value". If the argument is omitted, the value is to be read, /// otherwise it is to be set. Returns the current value. /// /// Calls the `getter` callback to obtain the value when /// responding to the service extension method being called. /// /// Calls the `setter` callback with the new value when the /// service extension method is called with a new value. /// /// &#123;@macro flutter.foundation.bindingBase.registerServiceExtension&#125; @protected void registerStringServiceExtension(&#123; @required String name, @required AsyncValueGetter&lt;String&gt; getter, @required AsyncValueSetter&lt;String&gt; setter, &#125;) &#123; assert(name != null); assert(getter != null); assert(setter != null); registerServiceExtension( name: name, callback: (Map&lt;String, String&gt; parameters) async &#123; if (parameters.containsKey('value')) &#123; await setter(parameters['value']); _postExtensionStateChangedEvent(name, await getter()); &#125; return &lt;String, dynamic&gt;&#123;'value': await getter()&#125;; &#125;, ); &#125; /// 调用扩展方法时会调用给定的回调。 /// 回调必须返回一个[Future]，它最终以名称/值映射的形式完成返回值，其中值可以使用`json.encode（）`转换为JSON（参见[JsonEncoder]），或者失败。 /// 如果发生故障，将向远程呼叫者报告故障并将其转储到日志中。 /// /// 返回的map将发生变异。 /// /// &#123;@template flutter.foundation.bindingBase.registerServiceExtension&#125; /// 只有在构建中包含vm-service时才能激活已注册的服务扩展，这仅在调试和配置文件模式下发生。 /// 虽然服务扩展不能在发布模式下使用，但是如果它没有包含在允许树振动器移除它的防护中，它的代码可能仍然包含在Dart快照中并炸掉二进制大小（参见下面的示例代码）。 /// &#123;@tool sample&#125; /// The following code registers a service extension that is only included in /// debug builds. /// /// 代码 /// void myRegistrationFunction() &#123; /// assert(() &#123; /// // Register your service extension here. /// return true; /// &#125;()); /// &#125; /// 代码 /// &#123;@end-tool&#125; /// /// &#123;@tool sample&#125; /// A service extension registered with the following code snippet is /// available in debug and profile mode. /// /// 代码 /// void myRegistrationFunction() &#123; /// // kReleaseMode is defined in the 'flutter/foundation.dart' package. /// if (!kReleaseMode) &#123; /// // Register your service extension here. /// &#125; /// &#125; /// 代码 /// &#123;@end-tool&#125; /// /// Both guards ensure that Dart's tree shaker can remove the code for the /// service extension in release builds. /// &#123;@endtemplate&#125; @protected void registerServiceExtension(&#123; @required String name, @required ServiceExtensionCallback callback, &#125;) &#123; assert(name != null); assert(callback != null); final String methodName = 'ext.flutter.$name'; developer.registerExtension(methodName, (String method, Map&lt;String, String&gt; parameters) async &#123; assert(method == methodName); assert(() &#123; if (debugInstrumentationEnabled) debugPrint('service extension method received: $method($parameters)'); return true; &#125;()); // VM service extensions are handled as "out of band" messages by the VM, // which means they are handled at various times, generally ASAP. // Notably, this includes being handled in the middle of microtask loops. // While this makes sense for some service extensions (e.g. "dump current // stack trace", which explicitly doesn't want to wait for a loop to // complete), Flutter extensions need not be handled with such high // priority. Further, handling them with such high priority exposes us to // the possibility that they're handled in the middle of a frame, which // breaks many assertions. As such, we ensure they we run the callbacks // on the outer event loop here. await debugInstrumentAction&lt;void&gt;('Wait for outer event loop', () &#123; return Future&lt;void&gt;.delayed(Duration.zero); &#125;); dynamic caughtException; StackTrace caughtStack; Map&lt;String, dynamic&gt; result; try &#123; result = await callback(parameters); &#125; catch (exception, stack) &#123; caughtException = exception; caughtStack = stack; &#125; if (caughtException == null) &#123; result['type'] = '_extensionType'; result['method'] = method; return developer.ServiceExtensionResponse.result(json.encode(result)); &#125; else &#123; FlutterError.reportError(FlutterErrorDetails( exception: caughtException, stack: caughtStack, context: ErrorDescription('during a service extension callback for "$method"'), )); return developer.ServiceExtensionResponse.error( developer.ServiceExtensionResponse.extensionError, json.encode(&lt;String, String&gt;&#123; 'exception': caughtException.toString(), 'stack': caughtStack.toString(), 'method': method, &#125;), ); &#125; &#125;); &#125; @override String toString() =&gt; '&lt;$runtimeType&gt;';&#125;/// Terminate the Flutter application.Future&lt;void&gt; _exitApplication() async &#123; exit(0);&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Scheduler]]></title>
    <url>%2FFlutter-Scheduler%2F</url>
    <content type="text"><![CDATA[Flutter-Scheduler 延伸阅读：理解 VSync flutter中scheduler包的内容： scheduler 包中涉及的主要内容： mixin SchedulerBinding： SchedulePhase：5个调度阶段 决定是否能够绘制的前提App生命周期： —— AppLifecycleState； 各个调度阶段的回调事件： —— 瞬态回调、持久回调、后帧回调、非渲染任务 Frame各个阶段对应的方法，并在方法中标明各个调度阶段： —— scheduleFrame()、handleBeginFrame()、handleDrawFrame()、endFrame()、scheduleTask() 3种scheduleFrame()： —— scheduleFrame()、scheduleForcedFrame()、scheduleWarmUpFrame() 单调递增时间（时间戳）的处理： —— resetEpoch() debug：调试模式的每一帧的开头/结束显示横幅 Priority：优先级 Ticker：每个动画帧调用一次回调 binding.dartSchedulerPhaseSchedulerBinding 在 SchedulerBinding.handleBeginFrame 中经历的 各个阶段。此枚举的值按照相位的顺序排序，因此它们的相对索引值可以相互比较。另见 WidgetsBinding.drawFrame 中的讨论。 1234567891011121314151617181920212223enum SchedulerPhase &#123; /// 没有正在处理的帧。 /// 任务（由[WidgetsBinding.scheduleTask]调度）、微任务（由[scheduleMicrotask]调度）、[Timer]回调、事件处理程序（例如来自用户输入）和其他回调（例如来自[Future] s，[Stream] s， 等等可能正在执行。 idle, /// 瞬态回调（由[WidgetsBinding.scheduleFrameCallback]调度）当前正在执行。 /// 通常，这些回调处理将对象更新为新的动画状态。 /// 请参阅[SchedulerBinding.handleBeginFrame]。 transientCallbacks, ///在处理瞬态回调期间安排的Microtasks是当前正在执行的。 ///这可能包括，例如，在[transientCallbacks]阶段期间产生的futures resulted回调。 midFrameMicrotasks, ///持久回调（由[WidgetsBinding.addPersistentFrameCallback]调度）当前正在执行。 ///通常，这是构建/布局/绘制管道。 请参阅[WidgetsBinding.drawFrame]和[SchedulerBinding.handleDrawFrame]。 persistentCallbacks, ///后帧回调（由[WidgetsBinding.addPostFrameCallback]调度）当前正在执行。 ///通常，这些回调将会为下一帧处理清理和工作安排。 ///请参阅[SchedulerBinding.handleDrawFrame]。 postFrameCallbacks,&#125; 持久回调 与 后帧回调 之间的调用关系：mixin WidgetInspectorService 源码说明 12345678910111213141516171819Duration _frameStart;void _onFrameStart(Duration timeStamp) &#123; _frameStart = timeStamp; SchedulerBinding.instance.addPostFrameCallback(_onFrameEnd);&#125;void _onFrameEnd(Duration timeStamp) &#123; if (_trackRebuildDirtyWidgets) &#123; _postStatsEvent('Flutter.RebuiltWidgets', _rebuildStats); &#125; if (_trackRepaintWidgets) &#123; _postStatsEvent('Flutter.RepaintWidgets', _repaintStats); &#125;&#125;void _postStatsEvent(String eventName, _ElementLocationStatsTracker stats) &#123; postEvent(eventName, stats.exportToJson(_frameStart));&#125; mixin SchedulerBinding用于运行以下内容的调度程序： Transient callbacks（瞬态回调）：由系统的 Window.onBeginFrame() 回调触发，用于将 应用程序的行为 同步 到 系统的显示。 例如，Ticker 和 AnimationController 从由此触发。 Persistent callbacks（持久回调）：由系统的 Window.onDrawFrame() 回调触发，用于在 执行瞬态回调后 以 更新 系统的显示。 例如，渲染层使用它来驱动其渲染管道。 Post-frame callbacks（后帧回调）：在持久回调之后 运行，就在 Window.onDrawFrame 回调返回之前。 Non-rendering tasks（非渲染任务）：在 帧之间 运行。 它们具有 优先级，并根据 schedulingStrategy 按 优先级顺序执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692mixin SchedulerBinding on BindingBase, ServicesBinding &#123; @override void initInstances() &#123; super.initInstances(); _instance = this; window.onBeginFrame = _handleBeginFrame; window.onDrawFrame = _handleDrawFrame; SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage); readInitialLifecycleStateFromNativeWindow(); if (!kReleaseMode) &#123; int frameNumber = 0; window.onReportTimings = (List&lt;FrameTiming&gt; timings) &#123; for (FrameTiming frameTiming in timings) &#123; frameNumber += 1; _profileFramePostEvent(frameNumber, frameTiming); &#125; &#125;; &#125; &#125; /// The current [SchedulerBinding], if one has been created. static SchedulerBinding get instance =&gt; _instance; static SchedulerBinding _instance; @override void initServiceExtensions() &#123; super.initServiceExtensions(); if (!kReleaseMode) &#123; registerNumericServiceExtension( name: 'timeDilation', getter: () async =&gt; timeDilation, setter: (double value) async &#123; timeDilation = value; &#125;, ); &#125; &#125; // ========== 生命周期 ========== ///应用程序是否可见，如果可见，是否当前是交互式的。 ///当调度[SystemChannels.lifecycle]通知时，这由[handleAppLifecycleStateChanged]设置。 ///监视此值更改的首选方法是使用[WidgetsBindingObserver.didChangeAppLifecycleState]。 AppLifecycleState get lifecycleState =&gt; _lifecycleState; AppLifecycleState _lifecycleState; ///使用窗口中的[initialLifecycleState]初始化[lifecycleState]。 ///通过任何方式（包括此方法）填充[lifecycleState]后，此方法将不执行任何操作。 这是因为[initialLifecycleState]可能已经过时，并且再次使用dart vm启动时的初始状态作为当前状态不再有意义。 ///应通过订阅[WidgetsBindingObserver.didChangeAppLifecycleState]获取最新状态。 @protected void readInitialLifecycleStateFromNativeWindow() &#123; if (_lifecycleState == null &amp;&amp; _parseAppLifecycleMessage(window.initialLifecycleState) != null) &#123; _handleLifecycleMessage(window.initialLifecycleState); &#125; &#125; ///在应用程序生命周期状态发生变化时调用。 ///使用WidgetsBindingObserver.didChangeAppLifecycleState]通知所有观察者。 ///此方法公开来自[SystemChannels.lifecycle]的通知。 @protected @mustCallSuper void handleAppLifecycleStateChanged(AppLifecycleState state) &#123; assert(state != null); _lifecycleState = state; switch (state) &#123; case AppLifecycleState.resumed: case AppLifecycleState.inactive: _setFramesEnabledState(true); break; case AppLifecycleState.paused: case AppLifecycleState.suspending: _setFramesEnabledState(false); break; &#125; &#125; Future&lt;String&gt; _handleLifecycleMessage(String message) async &#123; handleAppLifecycleStateChanged(_parseAppLifecycleMessage(message)); return null; &#125; static AppLifecycleState _parseAppLifecycleMessage(String message) &#123; switch (message) &#123; case 'AppLifecycleState.paused': return AppLifecycleState.paused; case 'AppLifecycleState.resumed': return AppLifecycleState.resumed; case 'AppLifecycleState.inactive': return AppLifecycleState.inactive; case 'AppLifecycleState.suspending': return AppLifecycleState.suspending; &#125; return null; &#125; // ========== 非渲染任务 按照优先级调度执行 ========== ///决定是否运行任务时使用的策略。 ///默认为[defaultSchedulingStrategy]。 SchedulingStrategy schedulingStrategy = defaultSchedulingStrategy; static int _taskSorter (_TaskEntry&lt;dynamic&gt; e1, _TaskEntry&lt;dynamic&gt; e2) &#123; return -e1.priority.compareTo(e2.priority); &#125; final PriorityQueue&lt;_TaskEntry&lt;dynamic&gt;&gt; _taskQueue = HeapPriorityQueue&lt;_TaskEntry&lt;dynamic&gt;&gt;(_taskSorter); ///用给定的`priority（优先级）`schedule给定的`task`，并返回一个完成`task`的最终返回值的[Future]。 ///“debugLabel”和“flow”用于将任务报告给[Timeline]，以便在分析时使用。 /// ##处理模型 ///任务将按优先级顺序在帧之间执行，不包括当前[schedulingStrategy]跳过的任务。 任务应该很短（例如，最多一毫秒），以免导致常规帧回调延迟。 ///如果动画正在运行，包括，例如，[ProgressIndicator]指示有待处理的任务，则优先级低于[Priority.animation]的任务将不会运行（至少不会运行[defaultSchedulingStrategy] ;这可以使用[schedulingStrategy]配置。 Future&lt;T&gt; scheduleTask&lt;T&gt;( TaskCallback&lt;T&gt; task, Priority priority, &#123; String debugLabel, Flow flow, &#125;) &#123; final bool isFirstTask = _taskQueue.isEmpty; final _TaskEntry&lt;T&gt; entry = _TaskEntry&lt;T&gt;( task, priority.value, debugLabel, flow, ); _taskQueue.add(entry); if (isFirstTask &amp;&amp; !locked) _ensureEventLoopCallback(); return entry.completer.future; &#125; @override void unlocked() &#123; super.unlocked(); if (_taskQueue.isNotEmpty) _ensureEventLoopCallback(); &#125; // 此调度程序是否已请求从事件循环中调用。 bool _hasRequestedAnEventLoopCallback = false; // 确保调度程序为[scheduleTask]计划的任务提供服务。 void _ensureEventLoopCallback() &#123; assert(!locked); assert(_taskQueue.isNotEmpty); if (_hasRequestedAnEventLoopCallback) return; _hasRequestedAnEventLoopCallback = true; Timer.run(_runTasks); &#125; // Scheduled by _ensureEventLoopCallback. void _runTasks() &#123; _hasRequestedAnEventLoopCallback = false; if (handleEventLoopCallback()) _ensureEventLoopCallback(); // 有时间运行下一个任务 &#125; /// 执行优先级最高的任务，如果它具有足够高的优先级。 /// 如果任务已执行且剩余其他任务（即使它们的优先级不够高），则返回true。 /// 如果没有执行任务，则返回false，如果没有调度任务，调度程序被[锁定]，或者如果最高优先级任务在给定当前[schedulingStrategy]时优先级太低，则会返回。 /// 如果没有剩余任务，也返回false。 @visibleForTesting bool handleEventLoopCallback() &#123; if (_taskQueue.isEmpty || locked) return false; final _TaskEntry&lt;dynamic&gt; entry = _taskQueue.first; if (schedulingStrategy(priority: entry.priority, scheduler: this)) &#123; try &#123; _taskQueue.removeFirst(); entry.run(); &#125; catch (exception, exceptionStack) &#123; StackTrace callbackStack; assert(() &#123; callbackStack = entry.debugStack; return true; &#125;()); FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: exceptionStack, library: 'scheduler library', context: ErrorDescription('during a task callback'), informationCollector: (callbackStack == null) ? null : () sync* &#123; yield DiagnosticsStackTrace( '\nThis exception was thrown in the context of a scheduler callback. ' 'When the scheduler callback was _registered_ (as opposed to when the ' 'exception was thrown), this was the stack', callbackStack, ); &#125;, )); &#125; return _taskQueue.isNotEmpty; &#125; return false; &#125; // ========== 瞬态回调 ========== int _nextFrameCallbackId = 0; // positive Map&lt;int, _FrameCallbackEntry&gt; _transientCallbacks = &lt;int, _FrameCallbackEntry&gt;&#123;&#125;; final Set&lt;int&gt; _removedIds = HashSet&lt;int&gt;(); ///瞬态帧回调的当前数量。 ///在一帧的开始处，调用所有当前调度的瞬态回调之前，将数量值重置为0。 ///这个数字主要是公开的，这样测试可以验证在测试资源被正常处理后仍然没有注册意外的瞬态回调。 int get transientCallbackCount =&gt; _transientCallbacks.length; ///Schedules给定的瞬态帧回调。 ///将给定的回调添加到帧回调列表中，并确保调度帧。 ///如果这是一次性注册，请忽略`rescheduling`参数。 ///如果这是一个每次触发时都会重新注册的回调，那么当你重新注册回调时，将`rescheduling`参数设置为true。 这在发布版本中没有任何影响，但在调试版本中，它确保为此回调存储的堆栈跟踪是回调是_first_ registered时的原始堆栈跟踪，而不是回调重新启动时的堆栈跟踪 注册。 这样可以更轻松地跟踪调用特定回调的原始原因。 如果`rescheduling`为真，则调用必须在帧回调的上下文中。 ///使用[cancelFrameCallbackWithId]可以取消使用此方法注册的回调。 int scheduleFrameCallback(FrameCallback callback, &#123; bool rescheduling = false &#125;) &#123; scheduleFrame(); _nextFrameCallbackId += 1; _transientCallbacks[_nextFrameCallbackId] = _FrameCallbackEntry(callback, rescheduling: rescheduling); return _nextFrameCallbackId; &#125; ///用给定的[id]取消瞬态帧回调。 ///从帧回调列表中删除给定的回调。 如果已请求帧，则不会取消该请求。 ///瞬态帧回调是使用[scheduleFrameCallback]注册的回调。 void cancelFrameCallbackWithId(int id) &#123; assert(id &gt; 0); _transientCallbacks.remove(id); _removedIds.add(id); &#125; /// Asserts that there are no registered transient callbacks; if /// there are, prints their locations and throws an exception. /// /// A transient frame callback is one that was registered with /// [scheduleFrameCallback]. /// /// This is expected to be called at the end of tests (the /// flutter_test framework does it automatically in normal cases). /// /// Call this method when you expect there to be no transient /// callbacks registered, in an assert statement with a message that /// you want printed when a transient callback is registered: /// /// 代码示例 /// assert(SchedulerBinding.instance.debugAssertNoTransientCallbacks( /// 'A leak of transient callbacks was detected while doing foo.' /// )); /// /// /// Does nothing if asserts are disabled. Always returns true. bool debugAssertNoTransientCallbacks(String reason) &#123; assert(() &#123; if (transientCallbackCount &gt; 0) &#123; // We cache the values so that we can produce them later // even if the information collector is called after // the problem has been resolved. final int count = transientCallbackCount; final Map&lt;int, _FrameCallbackEntry&gt; callbacks = Map&lt;int, _FrameCallbackEntry&gt;.from(_transientCallbacks); FlutterError.reportError(FlutterErrorDetails( exception: reason, library: 'scheduler library', informationCollector: () sync* &#123; if (count == 1) &#123; // TODO(jacobr): I have added an extra line break in this case. yield ErrorDescription( 'There was one transient callback left. ' 'The stack trace for when it was registered is as follows:' ); &#125; else &#123; yield ErrorDescription( 'There were $count transient callbacks left. ' 'The stack traces for when they were registered are as follows:' ); &#125; for (int id in callbacks.keys) &#123; final _FrameCallbackEntry entry = callbacks[id]; yield DiagnosticsStackTrace('── callback $id ──', entry.debugStack, showSeparator: false); &#125; &#125;, )); &#125; return true; &#125;()); return true; &#125; /// Prints the stack for where the current transient callback was registered. /// /// A transient frame callback is one that was registered with /// [scheduleFrameCallback]. /// /// When called in debug more and in the context of a transient callback, this /// function prints the stack trace from where the current transient callback /// was registered (i.e. where it first called [scheduleFrameCallback]). /// /// When called in debug mode in other contexts, it prints a message saying /// that this function was not called in the context a transient callback. /// /// In release mode, this function does nothing. /// /// To call this function, use the following code: /// /// 代码 /// SchedulerBinding.debugPrintTransientCallbackRegistrationStack(); /// 代码 static void debugPrintTransientCallbackRegistrationStack() &#123; assert(() &#123; if (_FrameCallbackEntry.debugCurrentCallbackStack != null) &#123; debugPrint('When the current transient callback was registered, this was the stack:'); debugPrint( FlutterError.defaultStackFilter( _FrameCallbackEntry.debugCurrentCallbackStack.toString().trimRight().split('\n') ).join('\n') ); &#125; else &#123; debugPrint('No transient callback is currently executing.'); &#125; return true; &#125;()); &#125; // ========== 持久回调 ========== final List&lt;FrameCallback&gt; _persistentCallbacks = &lt;FrameCallback&gt;[]; /// 添加持久帧回调。 /// 在瞬态（非持久）帧回调之后调用持久回调。 /// 不请求新frame。 从概念上讲，持久帧回调是“开始帧”事件的观察者。 由于它们是在瞬态帧回调之后执行的，因此它们可以驱动渲染管道。 /// 不能取消注册持久帧回调。 注册后，将在应用程序生命周期内为每个帧调用它们。 void addPersistentFrameCallback(FrameCallback callback) &#123; _persistentCallbacks.add(callback); &#125; // ========== 后帧回调 ========== final List&lt;FrameCallback&gt; _postFrameCallbacks = &lt;FrameCallback&gt;[]; ///为此帧的结尾安排回调。 ///不请求新Frame。 ///这个回调是在一个帧期间运行的，就在持久帧回调之后（即主渲染管道被刷新的时候）。 如果帧正在进行且帧后回调尚未执行，则在帧期间仍然执行注册的回调。 否则，在下一帧期间执行注册的回调。 /// ///回调按照添加顺序执行。 ///无法取消注册后帧回调。 它们只被称为一次。 /// 也可以看看： [scheduleFrameCallback]，它为下一帧的开始注册一个回调。 void addPostFrameCallback(FrameCallback callback) &#123; _postFrameCallbacks.add(callback); &#125; Completer&lt;void&gt; _nextFrameCompleter; // ========== 当前Frame结束 ========== ///返回在帧完成后完成的Future。 ///如果在帧之间调用此帧，则会在必要时立即调度帧。 如果在帧期间调用此函数，则Future将在当前帧之后完成。 ///如果设备的屏幕当前已关闭，则可能需要等待很长时间，因为在设备屏幕关闭时未安排帧。 Future&lt;void&gt; get endOfFrame &#123; if (_nextFrameCompleter == null) &#123; if (schedulerPhase == SchedulerPhase.idle) scheduleFrame(); _nextFrameCompleter = Completer&lt;void&gt;(); addPostFrameCallback((Duration timeStamp) &#123; _nextFrameCompleter.complete(); _nextFrameCompleter = null; &#125;); &#125; return _nextFrameCompleter.future; &#125; // ========== 当前Frame开始 ========== /// 此调度程序是否已请求尽快调用[handleBeginFrame]。 bool get hasScheduledFrame =&gt; _hasScheduledFrame; bool _hasScheduledFrame = false; /// 调度程序当前正在运行的阶段。 SchedulerPhase get schedulerPhase =&gt; _schedulerPhase; SchedulerPhase _schedulerPhase = SchedulerPhase.idle; /// 调用[scheduleFrame]时是否正在调度帧。 /// 该值取决于[lifecycleState]的值。 bool get framesEnabled =&gt; _framesEnabled; bool _framesEnabled = true; void _setFramesEnabledState(bool enabled) &#123; if (_framesEnabled == enabled) return; _framesEnabled = enabled; if (enabled) scheduleFrame(); &#125; // ========== 3种Frame开始方法 ========== ///如果此对象当前未生成帧，则使用[scheduleFrame]计划新帧。 ///调用此方法可确保最终调用[handleDrawFrame]，除非它已在进行中。 ///如果[schedulerPhase]是[SchedulerPhase.transientCallbacks]或[SchedulerPhase.midFrameMicrotasks]（因为在这种情况下已经准备好了帧）或[SchedulerPhase.persistentCallbacks]（因为正在积极地渲染帧），这没有任何效果 在这种情况下）。 如果[schedulerPhase]是[SchedulerPhase.idle]（在帧之间）或[SchedulerPhase.postFrameCallbacks]（在帧之后），它将调度帧。 void ensureVisualUpdate() &#123; switch (schedulerPhase) &#123; case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; &#125; &#125; // ========== 最普通的Frame开始方法 ========== ///如有必要，可以通过调用[Window.scheduleFrame]来调度新帧。 ///调用此函数后，引擎将（最终）调用[handleBeginFrame]。 （此呼叫可能会延迟，例如，如果设备的屏幕关闭，它通常会延迟，直到屏幕打开且应用程序可见。）在帧期间调用此部分会强制安排另一帧，即使当前帧已有尚未完成。 ///由操作系统提供的“Vsync”信号触发时，服务预定帧。 “Vsync”信号或垂直同步信号在历史上与显示器刷新有关，此时硬件在显示器的更新之间物理地移动电子束。当代硬件的操作稍微复杂一些，但概念性的“Vsync”刷新信号继续用于指示应用程序何时应更新其渲染。 ///要在此函数调度帧的任何时候打印到控制台的堆栈跟踪，请将[debugPrintScheduleFrameStacks]设置为true。 /// 也可以看看： /// * [scheduleForcedFrame]，忽略[lifecycleState]的时候 ///安排一个框架。 /// * [scheduleWarmUpFrame]，它完全忽略“Vsync”信号并立即触发帧。 void scheduleFrame() &#123; if (_hasScheduledFrame || !_framesEnabled) return; assert(() &#123; if (debugPrintScheduleFrameStacks) debugPrintStack(label: 'scheduleFrame() called. Current phase is $schedulerPhase.'); return true; &#125;()); window.scheduleFrame(); _hasScheduledFrame = true; &#125; // ========== 强制Frame开始方法 ========== ///通过schedule[Window.scheduleFrame]来安排新帧。 ///调用此函数后，引擎将调用[handleBeginFrame]，即使[scheduleFrame]通常不会调度帧（例如，即使设备的屏幕已关闭）。 ///框架使用它来强制在旋转手机时以正确的大小渲染帧，以便在重新打开屏幕时可以使用正确大小的渲染。 ///要在此函数调度帧的任何时候打印到控制台的堆栈跟踪，请将[debugPrintScheduleFrameStacks]设置为true。 ///首选使用[scheduleFrame]，除非必须立即调度帧，因为使用[scheduleForceFrame]会导致设备空闲时电池使用量显着增加。 ///如果目标是尽快更新渲染（例如在应用程序启动时），请考虑使用[scheduleWarmUpFrame]。 void scheduleForcedFrame() &#123; if (_hasScheduledFrame) return; assert(() &#123; if (debugPrintScheduleFrameStacks) debugPrintStack(label: 'scheduleForcedFrame() called. Current phase is $schedulerPhase.'); return true; &#125;()); window.scheduleFrame(); _hasScheduledFrame = true; &#125; bool _warmUpFrame = false; // ========== 预渲染Frame开始方法 ========== ///安排帧尽快运行，而不是等待引擎响应系统“Vsync”信号请求帧。 ///在应用程序启动期间使用它，以便第一帧（可能非常昂贵）运行几毫秒。 ///锁定事件调度，直到计划的帧完成。 ///如果已经使用[scheduleFrame]或[scheduleForcedFrame]调度了一个帧，则此调用可能会延迟该帧。 ///如果任何已调度的帧已经开始或者已经调用了另一个[scheduleWarmUpFrame]，则将忽略此调用。 ///首选[scheduleFrame]在正常操作中更新显示。 void scheduleWarmUpFrame() &#123; if (_warmUpFrame || schedulerPhase != SchedulerPhase.idle) return; _warmUpFrame = true; Timeline.startSync('Warm-up frame'); final bool hadScheduledFrame = _hasScheduledFrame; // 我们在这里使用定时器来确保微任务在两者之间冲洗。 Timer.run(() &#123; assert(_warmUpFrame); handleBeginFrame(null); &#125;); Timer.run(() &#123; assert(_warmUpFrame); handleDrawFrame(); //我们在此帧之后调用resetEpoch()，以便在热重载情况下，下一帧假装在此预热帧(warm-up frame)之后立即发生。 //预热帧的时间戳通常会在过去（最后一个真实帧的时间），所以如果我们没有重置时期，我们会看到从预热帧中的旧时间突然跳转到 “真实”frame中的新时间。 //最大的问题是隐式动画最终会在过去被触发，然后跳过每一帧并在新时间结束。 resetEpoch(); _warmUpFrame = false; if (hadScheduledFrame) scheduleFrame(); &#125;); // 锁定事件，因此触摸事件等不会插入自己，直到计划的帧完成。 lockEvents(() async &#123; await endOfFrame; Timeline.finishSync(); &#125;); &#125; Duration _firstRawTimeStampInEpoch; Duration _epochStart = Duration.zero; Duration _lastRawTimeStamp = Duration.zero; ///准备Schedule程序，以便对计算时间戳的方式进行非单调更改。 ///从Schedule程序收到的回调假设它们的时间戳是单调递增的。 传递给[handleBeginFrame]的原始时间戳是单调的，但Schedule程序可能会调整这些时间戳以提供[timeDilation]。 如果不小心处理，这些调整可能会导致时间倒流。 /// [resetEpoch]函数通过将用于将来时间戳调整的基本时间戳重置为当前值来确保时间戳是单调的。 例如，如果[timeDilation]减小，而不是从时间开始缩小[持续时间]，[resetEpoch]将确保我们只缩小自调用[resetEpoch]以来的持续时间。 ///设置[timeDilation]自动调用[resetEpoch]。 您不需要自己调用[resetEpoch]。 void resetEpoch() &#123; _epochStart = _adjustForEpoch(_lastRawTimeStamp); _firstRawTimeStampInEpoch = null; &#125; ///将给定的时间戳调整为当前时期。 ///这两者都抵消了纪元开始时的时间戳（原始时间和纪元自己的时间线），并缩放时间戳以反映当前时期的时间膨胀。 ///这些机制结合起来确保我们在帧回调期间给出的持续时间是单调递增的。 Duration _adjustForEpoch(Duration rawTimeStamp) &#123; final Duration rawDurationSinceEpoch = _firstRawTimeStampInEpoch == null ? Duration.zero : rawTimeStamp - _firstRawTimeStampInEpoch; return Duration(microseconds: (rawDurationSinceEpoch.inMicroseconds / timeDilation).round() + _epochStart.inMicroseconds); &#125; ///当前正在处理的帧的时间戳。 ///这仅在[handleBeginFrame]的开始和相应的[handleDrawFrame]的结尾之间有效，即在生成帧时。 Duration get currentFrameTimeStamp &#123; assert(_currentFrameTimeStamp != null); return _currentFrameTimeStamp; &#125; Duration _currentFrameTimeStamp; ///由引擎提供给当前正在处理的帧的[Window.onBeginFrame]的原始时间戳。 ///与[currentFrameTimeStamp]不同，此时间戳既不会在纪元开始时调整为偏移，也不会缩放以反映当前纪元中的[timeDilation]。 ///在大多数平台上，这是一个或多或少的任意值，通常应该被忽略。 在Fuchsia上，这对应于系统提供的演示时间，可用于确保在不同进程中运行的动画是同步的。 Duration get currentSystemFrameTimeStamp &#123; assert(_lastRawTimeStamp != null); return _lastRawTimeStamp; &#125; int _debugFrameNumber = 0; String _debugBanner; bool _ignoreNextEngineDrawFrame = false; void _handleBeginFrame(Duration rawTimeStamp) &#123; if (_warmUpFrame) &#123; assert(!_ignoreNextEngineDrawFrame); _ignoreNextEngineDrawFrame = true; return; &#125; handleBeginFrame(rawTimeStamp); &#125; void _handleDrawFrame() &#123; if (_ignoreNextEngineDrawFrame) &#123; _ignoreNextEngineDrawFrame = false; return; &#125; handleDrawFrame(); &#125; // ========== 处理开始Frame方法 ========== /// 由引擎调用以准备框架以生成新frame。 /// /// 此函数调用[scheduleFrameCallback]注册的所有瞬态帧回调。 /// 然后返回，运行任何预定的微任务（例如，通过瞬时帧回调解析的任何[Future]的处理程序），并调用[handleDrawFrame]继续该帧。 /// 如果给定的时间戳为空，则重复使用最后一帧的时间戳。 /// /// 要在调试模式的每一帧的开头显示横幅，请将[debugPrintBeginFrameBanner]设置为true。 /// 横幅将使用[debugPrint]打印到控制台，并包含帧编号（每帧增加1）和帧的时间戳。 /// 如果给定的时间戳为空，则显示字符串“预热帧”而不是时间戳。 /// 这允许框架急切推动的帧与响应来自操作系统的“Vsync”信号的引擎所请求的帧区分开。 /// /// 您还可以通过将[debugPrintEndFrameBanner]设置为true来在每个帧的末尾显示横幅。 /// 这允许您区分帧中打印的日志语句与帧之间打印的日志语句（例如，响应事件或计时器）。 void handleBeginFrame(Duration rawTimeStamp) &#123; Timeline.startSync('Frame', arguments: timelineWhitelistArguments); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; assert(() &#123; _debugFrameNumber += 1; if (debugPrintBeginFrameBanner || debugPrintEndFrameBanner) &#123; final StringBuffer frameTimeStampDescription = StringBuffer(); if (rawTimeStamp != null) &#123; _debugDescribeTimeStamp(_currentFrameTimeStamp, frameTimeStampDescription); &#125; else &#123; frameTimeStampDescription.write('(warm-up frame)'); &#125; _debugBanner = '▄▄▄▄▄▄▄▄ Frame $&#123;_debugFrameNumber.toString().padRight(7)&#125; $&#123;frameTimeStampDescription.toString().padLeft(18)&#125; ▄▄▄▄▄▄▄▄'; if (debugPrintBeginFrameBanner) debugPrint(_debugBanner); &#125; return true; &#125;()); assert(schedulerPhase == SchedulerPhase.idle); _hasScheduledFrame = false; try &#123; // TRANSIENT FRAME CALLBACKS Timeline.startSync('Animate', arguments: timelineWhitelistArguments); _schedulerPhase = SchedulerPhase.transientCallbacks; final Map&lt;int, _FrameCallbackEntry&gt; callbacks = _transientCallbacks; _transientCallbacks = &lt;int, _FrameCallbackEntry&gt;&#123;&#125;; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) &#123; if (!_removedIds.contains(id)) _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack); &#125;); _removedIds.clear(); &#125; finally &#123; _schedulerPhase = SchedulerPhase.midFrameMicrotasks; &#125; &#125; /// 由引擎调用以生成新帧。 /// 在[handleBeginFrame]之后立即调用此方法。 /// 它调用[addPersistentFrameCallback]注册的所有回调，它通常驱动渲染管道，然后调用[addPostFrameCallback]注册的回调。 /// 有关调试hooks的讨论，请参阅[handleBeginFrame]，这些钩子在处理帧回调时可能很有用。 void handleDrawFrame() &#123; assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks); Timeline.finishSync(); // end the "Animate" phase try &#123; // PERSISTENT FRAME CALLBACKS _schedulerPhase = SchedulerPhase.persistentCallbacks; for (FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); // POST-FRAME CALLBACKS _schedulerPhase = SchedulerPhase.postFrameCallbacks; final List&lt;FrameCallback&gt; localPostFrameCallbacks = List&lt;FrameCallback&gt;.from(_postFrameCallbacks); _postFrameCallbacks.clear(); for (FrameCallback callback in localPostFrameCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); &#125; finally &#123; _schedulerPhase = SchedulerPhase.idle; Timeline.finishSync(); // end the Frame assert(() &#123; if (debugPrintEndFrameBanner) debugPrint('▀' * _debugBanner.length); _debugBanner = null; return true; &#125;()); _currentFrameTimeStamp = null; &#125; &#125; void _profileFramePostEvent(int frameNumber, FrameTiming frameTiming) &#123; postEvent('Flutter.Frame', &lt;String, dynamic&gt;&#123; 'number': frameNumber, 'startTime': frameTiming.timestampInMicroseconds(FramePhase.buildStart), 'elapsed': frameTiming.totalSpan.inMicroseconds, 'build': frameTiming.buildDuration.inMicroseconds, 'raster': frameTiming.rasterDuration.inMicroseconds, &#125;); &#125; static void _debugDescribeTimeStamp(Duration timeStamp, StringBuffer buffer) &#123; if (timeStamp.inDays &gt; 0) buffer.write('$&#123;timeStamp.inDays&#125;d '); if (timeStamp.inHours &gt; 0) buffer.write('$&#123;timeStamp.inHours - timeStamp.inDays * Duration.hoursPerDay&#125;h '); if (timeStamp.inMinutes &gt; 0) buffer.write('$&#123;timeStamp.inMinutes - timeStamp.inHours * Duration.minutesPerHour&#125;m '); if (timeStamp.inSeconds &gt; 0) buffer.write('$&#123;timeStamp.inSeconds - timeStamp.inMinutes * Duration.secondsPerMinute&#125;s '); buffer.write('$&#123;timeStamp.inMilliseconds - timeStamp.inSeconds * Duration.millisecondsPerSecond&#125;'); final int microseconds = timeStamp.inMicroseconds - timeStamp.inMilliseconds * Duration.microsecondsPerMillisecond; if (microseconds &gt; 0) buffer.write('.$&#123;microseconds.toString().padLeft(3, "0")&#125;'); buffer.write('ms'); &#125; //使用[timestamp]作为参数调用给定的[callback]。 //在try / catch中包装回调并将任何错误转发给[debugSchedulerExceptionHandler]（如果已设置）。 如果未设置，则只需打印错误。 void _invokeFrameCallback(FrameCallback callback, Duration timeStamp, [ StackTrace callbackStack ]) &#123; assert(callback != null); assert(_FrameCallbackEntry.debugCurrentCallbackStack == null); assert(() &#123; _FrameCallbackEntry.debugCurrentCallbackStack = callbackStack; return true; &#125;()); try &#123; callback(timeStamp); &#125; catch (exception, exceptionStack) &#123; FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: exceptionStack, library: 'scheduler library', context: ErrorDescription('during a scheduler callback'), informationCollector: (callbackStack == null) ? null : () sync* &#123; yield DiagnosticsStackTrace( '\nThis exception was thrown in the context of a scheduler callback. ' 'When the scheduler callback was _registered_ (as opposed to when the ' 'exception was thrown), this was the stack', callbackStack, ); &#125;, )); &#125; assert(() &#123; _FrameCallbackEntry.debugCurrentCallbackStack = null; return true; &#125;()); &#125;&#125; callback(timeStamp) 说明 123/// 从scheduler签名与帧相关的回调。///`timeStamp`是自scheduler的纪元开始以来的毫秒数。 使用timeStamp确定推进动画时间轴的距离，以便系统中的所有动画同步到公共时基。typedef FrameCallback = void Function(Duration timeStamp);]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-注解]]></title>
    <url>%2FFlutter-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@protected]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Element]]></title>
    <url>%2FFlutter-Element%2F</url>
    <content type="text"><![CDATA[Flutter-Element ElementElement类中的部分构造：123456789101112131415161718192021222324252627282930313233343536373839404142434445abstract class Element extends DiagnosticableTree implements BuildContext &#123; ///由父设置的信息，用于定义此子项在其父项子列表中的位置。 ///只有一个子元素的Element的子类应该为该子节点的插槽使用null。 dynamic get slot =&gt; _slot; dynamic _slot; ///保证大于父级的整数（如果有的话）。 ///树根处的元素必须具有大于0的深度。 int get depth =&gt; _depth; int _depth; ///此元素的配置。 @override Widget get widget =&gt; _widget; Widget _widget; ///管理此元素生命周期的对象。 @override BuildOwner get owner =&gt; _owner; BuildOwner _owner; bool _active = false; ///树中此位置（或下方）的渲染对象。 ///如果此对象是[RenderObjectElement]，则渲染对象是树中此位置的对象。 否则，此getter将沿树向下走，直到找到[RenderObjectElement]。 RenderObject get renderObject &#123; RenderObject result; void visit(Element element) &#123; assert(result == null); // this verifies that there's only one child if (element is RenderObjectElement) result = element.renderObject; else element.visitChildren(visit); &#125; visit(this); return result; &#125; //这用于验证Element对象是否以有序的方式在生命中移动。 _ElementLifecycle _debugLifecycleState = _ElementLifecycle.initial;&#125; 重要方法visitChildren()1234///为每一个孩子调用参数。 必须由支持子项的子类重写。///没有保证可以访问孩子的顺序，尽管它应该随着时间的推移而保持一致。///在构建期间调用此方法很危险：子列表可能仍在更新，因此可能尚未构建子项，或者可能是要替换的旧子项。 只有在可以证明孩子有空的情况下才应该调用此方法。void visitChildren(ElementVisitor visitor) &#123; &#125; reassemble()1234567891011121314151617/// &#123;@template flutter.widgets.reassemble&#125;在调试期间重新组装应用程序时调用，例如在热重新加载期间。 ///此方法应重新运行依赖于全局状态的任何初始化逻辑，例如，从资产包中加载图像（因为资产包可能已更改）。 ///此功能仅在开发期间调用。在发布版本中，`ext.flutter.reassemble`钩子不可用，因此这段代码永远不会执行。 ///在启动热重新加载后，实施者不应依赖任何热重新加载源更新，重组和构建方法的顺序。附加到隔离的[Timer]（例如[Animation]）或调试会话可能会触发带有重新加载的代码的构建_before_ reassemble被调用。期望在热重新加载之后通过重新组装来设置前提条件的代码必须具有弹性以便无序调用，例如，通过嘶嘶声而不是投掷。也就是说，一旦调用reassemble，就会在它之后调用build至少一次。 /// &#123;@endtemplate&#125; /// 也可以看看： /// * [State.reassemble] /// * [BindingBase.reassembleApplication] /// * [Image]，使用它来重新加载图像。@mustCallSuper@protectedvoid reassemble() &#123; markNeedsBuild(); visitChildren((Element child) &#123; child.reassemble(); &#125;);&#125; Widget系统核心方法 - updateChild()：使用给定的新配置更新给定的子项。这个方法是小部件系统的核心。每次我们根据更新的配置添加，更新或删除子项时都会调用它。如果child为null，并且newWidget不为null，那么我们有一个新的子节点，我们需要创建一个[Element]，配置为newWidget。如果newWidget为null，并且child不为null，那么我们需要删除它，因为它不再有配置。如果两者都不为null，那么我们需要将child的配置更新为newWidget给出的新配置。如果newWidget可以给现有的子节点（由[Widget.canUpdate]确定），那么就给出了它。否则，需要处理旧子项并为新配置创建新子项。如果两者都为null，那么我们没有孩子，也没有孩子，所以我们什么都不做。 [updateChild]方法返回新的子节点，如果必须创建一个子节点，或者传入的子节点，如果它只是必须更新子节点，则返回null，如果它删除了子节点并且没有替换它。下表总结了上述内容： newWidget == null newWidget != null child == null 返回null 返回新的[Element] child != null 删除旧子，返回null 如果可能，更新旧子，返回子或新[元素] 方法名描述： 1Element updateChild(Element child, Widget newWidget, dynamic newSlot) 方法体描述 123456789101112131415161718192021222324252627282930313233343536@protectedElement updateChild(Element child, Widget newWidget, dynamic newSlot) &#123; assert(() &#123; if (newWidget != null &amp;&amp; newWidget.key is GlobalKey) &#123; final GlobalKey key = newWidget.key; key._debugReserveFor(this); &#125; return true; &#125;()); if (newWidget == null) &#123; if (child != null) deactivateChild(child); return null; &#125; if (child != null) &#123; if (child.widget == newWidget) &#123; if (child.slot != newSlot) updateSlotForChild(child, newSlot); return child; &#125; if (Widget.canUpdate(child.widget, newWidget)) &#123; if (child.slot != newSlot) updateSlotForChild(child, newSlot); child.update(newWidget); assert(child.widget == newWidget); assert(() &#123; child.owner._debugElementWasRebuilt(child); return true; &#125;()); return child; &#125; deactivateChild(child); assert(child._parent == null); &#125; return inflateWidget(newWidget, newSlot);&#125; Element生命周期123456enum _ElementLifecycle &#123; initial, active, inactive, defunct,&#125; Element是元素模型中所有元素的基类。一般来说，元素模型是程序的语义模型，它表示用名称声明的事物，因此可以在代码的其他地方引用。 一般情况有两个例外： 首先元素模型中的元素是为了方便各种分析而创建的，但在源代码中没有任何相应的声明。这些元素被标记为合成&lt;/ i&gt;。合成元素的示例包括未定义任何显式构造函数的类中的默认构造函数，由显式字段声明引起的 getter和setter，由getter和setter的显式声明引起的字段，以及表示初始化表达式的函数对于变量。 其次，元素模型中有一些没有名称的元素。这些对应于未命名的函数并且存在是为了更准确地表示程序的语义结构。 树中特定位置的Widget实例化。 Widget描述了如何配置子树，但同一Widget可用于同时配置多个子树，因为Widget是不可变的。元素表示使用Widget来配置树中的特定位置。随着时间的推移，与给定元素关联的Widget可以更改，例如，如果父Widget重建并为此位置创建新Widget。 元素形成一棵树。大多数元素都有一个唯一的子元素，但是一些Widget（例如，RenderObjectElement的子类）可以有多个子元素。 Element具有以下生命周期： 创建：框架通过在Widget上调用Widget.createElement来创建元素，该Widget将用作元素的初始配置。 安装/激活：框架调用mount以将新创建​​的元素添加到给定父级中给定插槽（slot）的树中。mount()负责对任何子Widget进行填充，并根据需要调用attachRenderObject（将renderObject添加到slot指定的位置的渲染树中。此函数的默认实现只是在其子项上递归调用attachRenderObject。）以将任何关联的渲染对象附加到渲染树。 此时，该元素被视为“active（_active = true）”并可能出现在屏幕上。 更新：在某些时候，父级可能决定更改用于配置此元素的Widget，例如，因为父级使用新状态重建。发生这种情况时，框架将使用新Widget调用update()。新Widget将始终具有与旧Widget相同的runtimeType和key。如果父级希望在树中的此位置更改Widget的runtimeType或key，则可以通过卸载 此元素并在**此位置**填充新Widget来实现。 删除：在某些时候，祖先可能会决定从树中删除此元素（或中间祖先），祖先通过自己调用deactivateChild()来执行此操作。取消激活中间祖先将从渲染树中删除``该元素的渲染对象，并将此元素添加到所有者的非活动元素列表中，从而导致框架对此元素调用deactivate()。 此时，该元素被视为“无效”，不会出现在屏幕上。元素只能保持在非活动状态即：inactive，直到当前动画帧结束。在动画帧结束时，将卸载仍处于非活动状态的所有元素。 复活：如果元素被重新并入树中（例如，因为它或其祖先之一具有重用的全局key），框架将从所有者的非活动元素列表中删除该元素，对元素调用activate()，并将元素的渲染对象重新附加到渲染树。 （此时，该元素再次被视为“活动”即：active并可能出现在屏幕上。） 卸载：如果元素在当前动画帧结束时没有重新并入树中，则框架将在元素上调用unmount()。此时，该元素被视为“已不存在”即：defunct，并且将来不会合并到树中。 按照惯例：Widget构造函数仅使用命名参数。可以使用@required将命名参数标记为必需。按照惯例：第一个参数是key，最后一个参数是child、children或等价物。 RenderObjectElement一个Element使用RenderObjectWidget作为其配置。 RenderObjectElement 对象在渲染树(render tree)中具有关联的 RenderObject widget，该widget处理布局、绘制和命中测试等具体操作。 与ComponentElement(构成其他[Element]的[Element]。)对比。 编写 RenderObjectElement 子类大多数 RenderObject 使用三种常见的子模型： 叶子渲染(Leaf render)对象，没有子节点：LeafRenderObjectElement 类处理这种情况。 单个子项(A single child)：SingleChildRenderObjectElement 类处理此案例。 子链接列表(A linked list of children)：MultiChildRenderObjectElement 类处理这种情况。 但是，有时渲染对象的子 模型更复杂，也许它有一个二维儿童阵列。 也许它按需建造孩子。 也许它有多个列表。 在这种情况下，配置RenderObject的Widget的相应Element将是RenderObjectElement的新子类。 这样的子类负责管理孩子，特别是Element这个对象的子节点，以及它的RenderObject子节点对应的RenderObject。 专门化的gettersRenderObjectElement 对象花费大量时间 充当 widget 和 renderObject 他们之间的 中介。 为了使它更容易处理，大多数 RenderObjectElement子类 重写 这些 getter，以便它们 返回元素所需的特定类型，例如： 12345678910class FooElement extends RenderObjectElement &#123; @override Foo get widget =&gt; super.widget; @override RenderFoo get renderObject =&gt; super.renderObject; ...&#125; 插槽每个 子元素(Element) 对应一个 RenderObject，这个 RenderObject 应作为 子元素 附加到 此元素 的 渲染对象。 但是，元素的直接子元素可能不是最终生成它们对应的实际[RenderObject]的元素。 例如，[StatelessElement]（[StatelessWidget]的元素）简单地对应于其子项（由其[StatelessWidget.build]方法返回的元素）对应的任何[RenderObject]。 因此，为每个子项分配一个 _slot_标记(token)。 这是一个 标识符，其含义对于此RenderObjectElement 节点是 私有 的。 当准备将最终生成的 RenderObject 后代 附加(attached) 到 此节点 的 RenderObject 时，它会将该 _slot_标记(token) 传递回 此节点，并允许此节点方便地识别 子渲染对象相对于其他对象在父渲染对象中的 放置位置 。 更新 children在元素生命周期的早期，框架调用[mount]方法。此方法应为每个子项调用[updateChild]，传入该子项的窗口小部件以及该子项的插槽，从而获取子项[Element]的列表。 随后，框架将调用[update]方法。在这个方法中，[RenderObjectElement]应该为每个子节点调用[updateChild]，传递n [在[mount]期间获得的[Element]或者最后一次[update]运行时（最近发生的那个），新的[Widget] ]和插槽。这为对象提供了[Element]对象的新列表。 在可能的情况下，[update]方法应尝试将最后一个传递中的元素映射到新传递中的小部件。例如，如果最后一个传递中的一个元素配置了特定的[Key]，并且此新传递中的一个小部件具有相同的键，则它们应该配对，并且旧元素应该使用小部件（以及与新小部件的新位置对应的插槽）。在这方面，[updateChildren]方法可能很有用。 应按逻辑顺序为子项调用[updateChild]。订单很重要;例如，如果两个孩子在他们的构建方法中使用[PageStorage]的writeState特性（并且没有[Widget.key]），那么第一个孩子写的状态将被第二个覆盖。 Dynamically determining the children during the build phaseThe child widgets need not necessarily come from this element’s widgetverbatim. They could be generated dynamically from a callback, or generatedin other more creative ways. Dynamically determining the children during layoutIf the widgets are to be generated at layout time, then generating them whenthe [update] method won’t work: layout of this element’s render objecthasn’t started yet at that point. Instead, the [update] method can mark therender object as needing layout (see [RenderObject.markNeedsLayout]), andthen the render object’s [RenderObject.performLayout] method can call backto the element to have it generate the widgets and call [updateChild]accordingly. For a render object to call an element during layout, it must use[RenderObject.invokeLayoutCallback]. For an element to call [updateChild]outside of its [update] method, it must use [BuildOwner.buildScope]. The framework provides many more checks in normal operation than it doeswhen doing a build during layout. For this reason, creating widgets withlayout-time build semantics should be done with great care. Handling errors when buildingIf an element calls a builder function to obtain widgets for its children,it may find that the build throws an exception. Such exceptions should becaught and reported using [FlutterError.reportError]. If a child is neededbut a builder has failed in this way, an instance of [ErrorWidget] can beused instead. Detaching childrenIt is possible, when using [GlobalKey]s, for a child to be proactivelyremoved by another element before this element has been updated.(Specifically, this happens when the subtree rooted at a widget with aparticular [GlobalKey] is being moved from this element to an elementprocessed earlier in the build phase.) When this happens, this element’s[forgetChild] method will be called with a reference to the affected childelement. The [forgetChild] method of a [RenderObjectElement] subclass must remove thechild element from its child list, so that when it next [update]s itschildren, the removed child is not considered. For performance reasons, if there are many elements, it may be quicker totrack which elements were forgotten by storing them in a [Set], rather thanproactively mutating the local record of the child list and the identitiesof all the slots. For example, see the implementation of[MultiChildRenderObjectElement]. Maintaining the render object treeOnce a descendant produces a render object, it will call[insertChildRenderObject]. If the descendant’s slot changes identity, itwill call [moveChildRenderObject]. If a descendant goes away, it will call[removeChildRenderObject]. These three methods should update the render tree accordingly, attaching,moving, and detaching the given child render object from this element’s ownrender object respectively. Walking the childrenIf a [RenderObjectElement] object has any children [Element]s, it mustexpose them in its implementation of the [visitChildren] method. This methodis used by many of the framework’s internal mechanisms, and so should befast. It is also used by the test framework and [debugDumpApp]. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318abstract class RenderObjectElement extends Element &#123; /// Creates an element that uses the given widget as its configuration. RenderObjectElement(RenderObjectWidget widget) : super(widget); @override RenderObjectWidget get widget =&gt; super.widget; /// The underlying [RenderObject] for this element. @override RenderObject get renderObject =&gt; _renderObject; RenderObject _renderObject; RenderObjectElement _ancestorRenderObjectElement; RenderObjectElement _findAncestorRenderObjectElement() &#123; Element ancestor = _parent; while (ancestor != null &amp;&amp; ancestor is! RenderObjectElement) ancestor = ancestor._parent; return ancestor; &#125; ParentDataElement&lt;RenderObjectWidget&gt; _findAncestorParentDataElement() &#123; Element ancestor = _parent; while (ancestor != null &amp;&amp; ancestor is! RenderObjectElement) &#123; if (ancestor is ParentDataElement&lt;RenderObjectWidget&gt;) return ancestor; ancestor = ancestor._parent; &#125; return null; &#125; @override void mount(Element parent, dynamic newSlot) &#123; super.mount(parent, newSlot); _renderObject = widget.createRenderObject(this); assert(() &#123; _debugUpdateRenderObjectOwner(); return true; &#125;()); assert(_slot == newSlot); attachRenderObject(newSlot); _dirty = false; &#125; @override void update(covariant RenderObjectWidget newWidget) &#123; super.update(newWidget); assert(widget == newWidget); assert(() &#123; _debugUpdateRenderObjectOwner(); return true; &#125;()); widget.updateRenderObject(this, renderObject); _dirty = false; &#125; void _debugUpdateRenderObjectOwner() &#123; assert(() &#123; _renderObject.debugCreator = DebugCreator(this); return true; &#125;()); &#125; @override void performRebuild() &#123; widget.updateRenderObject(this, renderObject); _dirty = false; &#125; /// Updates the children of this element to use new widgets. /// /// Attempts to update the given old children list using the given new /// widgets, removing obsolete elements and introducing new ones as necessary, /// and then returns the new child list. /// /// During this function the `oldChildren` list must not be modified. If the /// caller wishes to remove elements from `oldChildren` re-entrantly while /// this function is on the stack, the caller can supply a `forgottenChildren` /// argument, which can be modified while this function is on the stack. /// Whenever this function reads from `oldChildren`, this function first /// checks whether the child is in `forgottenChildren`. If it is, the function /// acts as if the child was not in `oldChildren`. /// /// This function is a convenience wrapper around [updateChild], which updates /// each individual child. When calling [updateChild], this function uses the /// previous element as the `newSlot` argument. @protected List&lt;Element&gt; updateChildren(List&lt;Element&gt; oldChildren, List&lt;Widget&gt; newWidgets, &#123; Set&lt;Element&gt; forgottenChildren &#125;) &#123; assert(oldChildren != null); assert(newWidgets != null); Element replaceWithNullIfForgotten(Element child) &#123; return forgottenChildren != null &amp;&amp; forgottenChildren.contains(child) ? null : child; &#125; // This attempts to diff the new child list (newWidgets) with // the old child list (oldChildren), and produce a new list of elements to // be the new list of child elements of this element. The called of this // method is expected to update this render object accordingly. // The cases it tries to optimize for are: // - the old list is empty // - the lists are identical // - there is an insertion or removal of one or more widgets in // only one place in the list // If a widget with a key is in both lists, it will be synced. // Widgets without keys might be synced but there is no guarantee. // The general approach is to sync the entire new list backwards, as follows: // 1. Walk the lists from the top, syncing nodes, until you no longer have // matching nodes. // 2. Walk the lists from the bottom, without syncing nodes, until you no // longer have matching nodes. We'll sync these nodes at the end. We // don't sync them now because we want to sync all the nodes in order // from beginning to end. // At this point we narrowed the old and new lists to the point // where the nodes no longer match. // 3. Walk the narrowed part of the old list to get the list of // keys and sync null with non-keyed items. // 4. Walk the narrowed part of the new list forwards: // * Sync non-keyed items with null // * Sync keyed items with the source if it exists, else with null. // 5. Walk the bottom of the list again, syncing the nodes. // 6. Sync null with any items in the list of keys that are still // mounted. int newChildrenTop = 0; int oldChildrenTop = 0; int newChildrenBottom = newWidgets.length - 1; int oldChildrenBottom = oldChildren.length - 1; final List&lt;Element&gt; newChildren = oldChildren.length == newWidgets.length ? oldChildren : List&lt;Element&gt;(newWidgets.length); Element previousChild; // Update the top of the list. while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123; final Element oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; assert(oldChild == null || oldChild._debugLifecycleState == _ElementLifecycle.active); if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) break; final Element newChild = updateChild(oldChild, newWidget, previousChild); assert(newChild._debugLifecycleState == _ElementLifecycle.active); newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; &#125; // Scan the bottom of the list. while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123; final Element oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenBottom]); final Widget newWidget = newWidgets[newChildrenBottom]; assert(oldChild == null || oldChild._debugLifecycleState == _ElementLifecycle.active); if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) break; oldChildrenBottom -= 1; newChildrenBottom -= 1; &#125; // Scan the old children in the middle of the list. final bool haveOldChildren = oldChildrenTop &lt;= oldChildrenBottom; Map&lt;Key, Element&gt; oldKeyedChildren; if (haveOldChildren) &#123; oldKeyedChildren = &lt;Key, Element&gt;&#123;&#125;; while (oldChildrenTop &lt;= oldChildrenBottom) &#123; final Element oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); assert(oldChild == null || oldChild._debugLifecycleState == _ElementLifecycle.active); if (oldChild != null) &#123; if (oldChild.widget.key != null) oldKeyedChildren[oldChild.widget.key] = oldChild; else deactivateChild(oldChild); &#125; oldChildrenTop += 1; &#125; &#125; // Update the middle of the list. while (newChildrenTop &lt;= newChildrenBottom) &#123; Element oldChild; final Widget newWidget = newWidgets[newChildrenTop]; if (haveOldChildren) &#123; final Key key = newWidget.key; if (key != null) &#123; oldChild = oldKeyedChildren[key]; if (oldChild != null) &#123; if (Widget.canUpdate(oldChild.widget, newWidget)) &#123; // we found a match! // remove it from oldKeyedChildren so we don't unsync it later oldKeyedChildren.remove(key); &#125; else &#123; // Not a match, let's pretend we didn't see it for now. oldChild = null; &#125; &#125; &#125; &#125; assert(oldChild == null || Widget.canUpdate(oldChild.widget, newWidget)); final Element newChild = updateChild(oldChild, newWidget, previousChild); assert(newChild._debugLifecycleState == _ElementLifecycle.active); assert(oldChild == newChild || oldChild == null || oldChild._debugLifecycleState != _ElementLifecycle.active); newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; &#125; // We've scanned the whole list. assert(oldChildrenTop == oldChildrenBottom + 1); assert(newChildrenTop == newChildrenBottom + 1); assert(newWidgets.length - newChildrenTop == oldChildren.length - oldChildrenTop); newChildrenBottom = newWidgets.length - 1; oldChildrenBottom = oldChildren.length - 1; // Update the bottom of the list. while ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123; final Element oldChild = oldChildren[oldChildrenTop]; assert(replaceWithNullIfForgotten(oldChild) != null); assert(oldChild._debugLifecycleState == _ElementLifecycle.active); final Widget newWidget = newWidgets[newChildrenTop]; assert(Widget.canUpdate(oldChild.widget, newWidget)); final Element newChild = updateChild(oldChild, newWidget, previousChild); assert(newChild._debugLifecycleState == _ElementLifecycle.active); assert(oldChild == newChild || oldChild == null || oldChild._debugLifecycleState != _ElementLifecycle.active); newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; &#125; // Clean up any of the remaining middle nodes from the old list. if (haveOldChildren &amp;&amp; oldKeyedChildren.isNotEmpty) &#123; for (Element oldChild in oldKeyedChildren.values) &#123; if (forgottenChildren == null || !forgottenChildren.contains(oldChild)) deactivateChild(oldChild); &#125; &#125; return newChildren; &#125; @override void deactivate() &#123; super.deactivate(); assert(!renderObject.attached, 'A RenderObject was still attached when attempting to deactivate its ' 'RenderObjectElement: $renderObject'); &#125; @override void unmount() &#123; super.unmount(); assert(!renderObject.attached, 'A RenderObject was still attached when attempting to unmount its ' 'RenderObjectElement: $renderObject'); widget.didUnmountRenderObject(renderObject); &#125; void _updateParentData(ParentDataWidget&lt;RenderObjectWidget&gt; parentData) &#123; parentData.applyParentData(renderObject); &#125; @override void _updateSlot(dynamic newSlot) &#123; assert(slot != newSlot); super._updateSlot(newSlot); assert(slot == newSlot); _ancestorRenderObjectElement.moveChildRenderObject(renderObject, slot); &#125; @override void attachRenderObject(dynamic newSlot) &#123; assert(_ancestorRenderObjectElement == null); _slot = newSlot; _ancestorRenderObjectElement = _findAncestorRenderObjectElement(); _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot); final ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement(); if (parentDataElement != null) _updateParentData(parentDataElement.widget); &#125; @override void detachRenderObject() &#123; if (_ancestorRenderObjectElement != null) &#123; _ancestorRenderObjectElement.removeChildRenderObject(renderObject); _ancestorRenderObjectElement = null; &#125; _slot = null; &#125; /// Insert the given child into [renderObject] at the given slot. /// /// The semantics of `slot` are determined by this element. For example, if /// this element has a single child, the slot should always be null. If this /// element has a list of children, the previous sibling is a convenient value /// for the slot. @protected void insertChildRenderObject(covariant RenderObject child, covariant dynamic slot); /// Move the given child to the given slot. /// /// The given child is guaranteed to have [renderObject] as its parent. /// /// The semantics of `slot` are determined by this element. For example, if /// this element has a single child, the slot should always be null. If this /// element has a list of children, the previous sibling is a convenient value /// for the slot. @protected void moveChildRenderObject(covariant RenderObject child, covariant dynamic slot); /// Remove the given child from [renderObject]. /// /// The given child is guaranteed to have [renderObject] as its parent. @protected void removeChildRenderObject(covariant RenderObject child); @override void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123; super.debugFillProperties(properties); properties.add(DiagnosticsProperty&lt;RenderObject&gt;('renderObject', renderObject, defaultValue: null)); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-State相关]]></title>
    <url>%2FFlutter-State%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Flutter-State相关 StateState可以提供如下信息： 可以在构建窗口Widget时同步读取 可能会在Widget的生命周期中发生变化 Widget实现者有责任确保在状态发生变化时使用State.setState及时通知State。 State对象由框架通过调用StatefulWidget.createState()方法来创建。在填充StatefulWidget时将其插入树中。因为给定的StatefulWidget实例可以多次填充（例如，窗口小部件一次合并到多个位置的树中），所以可能有多个State对象与给定的StatefulWidget实例关联。类似地，如果StatefulWidget从树中删除并稍后再次插入到树中，框架将再次调用StatefulWidget.createState()来创建一个新的State对象，从而简化State对象的生命周期。 Build()描述此窗口Widget表示的用户界面部分。框架在许多不同的情况下调用此方法： 调用 initState() 后; 调用 didChangeDependencies() 后; 调用 didUpdateWidget() 后。 调用 deactivate() 然后将 State 对象 重新插 入另一个位置的树中。 调用 setState() 后。 该框架使用此方法返回的窗口小部件替换此窗口小部件下方的子树，通过更新现有子树或删除子树并填充新子树，通过调用Widget.canUpdate()来确定此方法返回的窗口小部件是否可以更新现有子树的根。 通常，实现返回一个新创建的小部件集合，这些小部件配置信息有来自此小部件的构造函数给定的BuildContext以及此State对象的内部状态的信息。 给定的BuildContext包含有关构建此窗口小部件的树中的位置信息。例如，上下文为树中的此位置提供了一组继承的小部件。 为什么 Build() 在State类中而不是 StatefulWidget？把 build(BuildContext context) 放在 State 而不是放在build(BuildContext context, State state) 在 StatefulWidget，目的是在继承StatefulWidget时为开发人员提供了更大的灵活性。 从概念上讲，StatelessWidget也可以以类似的方式实现为StatefulWidget的子类。如果build()是在StatefulWidget而不是State上，那就不可能了。 将build()放在State而不是StatefulWidget上也有助于避免与隐式捕获它的闭包相关的一类错误。 安装概念安装指的是 State&lt;T&gt;#mounted参数。当此参数为ture时，表示这个执行完createState()但是还未执行initState()的State对象已经被添加到tree中，获得了BuildContext对象。 安装之后表示：State对象保持挂载，直到框架调用State#dispose()后，框架将永远不会再次要求State对象#build()。 可以通过 检查mounted属性 是否为 true 来确定调用State对象中的方法是否合法。 State对象生命周期概述 创建。框架通过调用StatefulWidget.createState()来创建一个State对象。 安装。新创建的State对象与BuildContext相关联。此关联是 永久性 的：State对象永远不会更改其BuildContext。但是，BuildContext本身可以与子树一起在树中移动。此时，State对象被认为已安装（mounted()）。 123mounted()表示此State对象当前是否在树中。在创建State对象“之后”并在调用initState()“之前”，框架通过将State对象与BuildContext相关联来“安装” 它 。State对象保持挂载，直到框架调用dispose()，之后框架永远不会要求State对象再次构建。 初始化。该框架调用initState()。State的子类应覆盖initState()以执行依赖于BuildContext或Widget的一次性初始化，当调用initState()方法时，它们分别可用作context(树构建这个小部件的位置)和窗口widget属性。 更改依赖。该框架调用didChangeDependencies()(在initState()之后也会立即调用此方法。子类很少重写此方法，因为框架始终在依赖项更改后调用构建。一些子类确实覆盖了这种方法，因为当它们的依赖关系发生变化时，它们需要做一些耗时的工作（例如，网络提取）)。State的子类应覆盖didChangeDependencies()以执行涉及InheritedWidgets(小部件的基类，可以有效地在树中传播信息)的初始化。如果BuildContext.inheritFromWidgetOfExactType()被调用，如果随后的窗口Widget更改或窗口Widget在树中移动，则将再次调用didChangeDependencies()方法。 123此时，State对象已完全初始化，并且框架可能会多次调用其构建方法以获取此子树的用户界面的描述。状态对象可以通过调用setState方法自发地请求重建其子树。这表明它们的某些内部状态已经以可能影响此子树中的用户界面的方式发生了更改。 重建/更新：在此期间，父窗口小部件可能会重建并请求树中的此位置更新以显示具有相同runtimeType(表示对象的运行时类型)和Widget.key(控制一个小部件如何替换树中的另一个小部件)的新窗口小部件。发生这种情况时，框架将更新窗口Widget.属性以引用新窗口Widget，然后使用前一个窗口Widget作为参数调用didUpdateWidget()方法。State对象应覆盖didUpdateWidget()以响应其关联窗口Widget中的更改（例如，开始隐式动画）。框架总是在调用didUpdateWidget()后调用build()，这意味着在didUpdateWidget()中对setState()的任何调用都是多余的。 在开发期间，如果发生热加载（无论是通过按 r 或从IDE启动命令行 flutter工具 ），都会调用reassemble(在调试期间重新组装应用程序时调用)。这提供了重新初始化在initState()中准备的任何数据的机会。 删除：如果从树中删除包含State对象的子树（例如，因为父级构建了具有不同runtimeType或Widget.key的小部件），则框架调用deactivate()方法。子类应该重写此方法以清除此对象与树中其他元素之间的任何链接。 此时，框架可能会将此子树重新插入树的另一部分。如果发生这种情况，框架将确保它调用build以使State对象有机会适应树中的新位置。如果框架重新插入此子树，它将在子树从树中删除的动画帧结束之前执行此操作。因此，State对象可以推迟释放大多数资源，直到框架调用其dispose()方法。 释放资源：如果框架没有在当前动画帧的末尾重新插入此子树，框架将调用dispose()，表示此State对象永远不会再次构建。子类应重写此方法以释放此对象保留的任何资源（例如，停止任何活动的动画）。 在框架调用dispose()之后，State对象被认为是已卸载且mount属性为false。生命周期的这个阶段是终端：没有办法重新安装已经处置的State对象。 State对象生命状态：4种1234567891011121314151617enum _StateLifecycle &#123; /// The [State] object has been created. [State.initState] is called at this /// time. created, /// The [State.initState] method has been called but the [State] object is /// not yet ready to build. [State.didChangeDependencies] is called at this time. initialized, /// The [State] object is ready to build and [State.dispose] has not yet been /// called. ready, /// The [State.dispose] method has been called and the [State] object is /// no longer able to build. defunct,&#125; State对象生命周期函数：6个 createState() initState() 12345@protected@mustCallSuper void initState() &#123; assert(_debugLifecycleState == _StateLifecycle.created);&#125; 如果重写此方法，请确保在方法开头中调用 super.initState()。 当State对象 已经添加到tree中后，掉用此方法。该框架将为它创建的每个State对象调用此方法一次。 在 initState() 中，订阅 该对象。 在 didUpdateWidget() 中 取消订阅旧对象，如果 更新 的小部件配置需要替换对象，则 订阅到新对象。 为什么需要先取消订阅，再重新订阅？因为： 在Flutter框架中，对与Widget状态的更新不是完全的更新，而是仅仅根据tree中这个Widget所表述的元素是否被标记为dirty，如果是true则表示当前tree中的这个位置上的Widget所表示的元素需要被更新，由于Widget的对象每个对象中都有key属性，所以能判断出更新前后的元素。简而言之就： 取消就旧对象的订阅，完成新对象的订阅 在 dispose() 中，取消订阅 该对象。 didChangeDependencies() 12345@protected @mustCallSuper void initState() &#123; assert(_debugLifecycleState == _StateLifecycle.created); &#125; 当 State对象的依赖关系发生更改时调用。 在 initState()之后也会 立即调用 此方法。从此方法调用BuildContext.inheritFromWidgetOfExactType() 是安全的。 注意： 子类很少覆盖此方法，因为在依赖项更改后，框架 始终调用 build()。 有些子类会覆盖这个方法是因为：当它们的依赖项发生变化时，它们需要做一些 昂贵耗时的工作（例如，网络抓取），而且每次构建的工作量都很大。 didUpdateWidget() 123@mustCallSuper @protected void didUpdateWidget(covariant T oldWidget) &#123; &#125; 每当Widget小部件配置更改时调用。 覆盖此方法以在Widget更改时进行响应（例如，开始隐式动画）。 注意： 在调用 didUpdateWidget()之后，框架 总是 调用 build()，这就表示在 didUpdateWidget() 中调用 setState() 的任何调用都是多余的。 setState() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@protectedvoid setState(VoidCallback fn) &#123; assert(fn != null); assert(() &#123; if (_debugLifecycleState == _StateLifecycle.defunct) &#123; throw FlutterError( &apos;setState() called after dispose(): $this\n&apos; &apos;This error happens if you call setState() on a State object for a widget that &apos; &apos;no longer appears in the widget tree (e.g., whose parent widget no longer &apos; &apos;includes the widget in its build). This error can occur when code calls &apos; &apos;setState() from a timer or an animation callback. The preferred solution is &apos; &apos;to cancel the timer or stop listening to the animation in the dispose() &apos; &apos;callback. Another solution is to check the &quot;mounted&quot; property of this &apos; &apos;object before calling setState() to ensure the object is still in the &apos; &apos;tree.\n&apos; &apos;This error might indicate a memory leak if setState() is being called &apos; &apos;because another object is retaining a reference to this State object &apos; &apos;after it has been removed from the tree. To avoid memory leaks, &apos; &apos;consider breaking the reference to this object during dispose().&apos; ); &#125; if (_debugLifecycleState == _StateLifecycle.created &amp;&amp; !mounted) &#123; throw FlutterError( &apos;setState() called in constructor: $this\n&apos; &apos;This happens when you call setState() on a State object for a widget that &apos; &apos;hasn\&apos;t been inserted into the widget tree yet. It is not necessary to call &apos; &apos;setState() in the constructor, since the state is already assumed to be dirty &apos; &apos;when it is initially created.&apos; ); &#125; return true; &#125;()); final dynamic result = fn() as dynamic; assert(() &#123; if (result is Future) &#123; throw FlutterError( &apos;setState() callback argument returned a Future.\n&apos; &apos;The setState() method on $this was called with a closure or method that &apos; &apos;returned a Future. Maybe it is marked as &quot;async&quot;.\n&apos; &apos;Instead of performing asynchronous work inside a call to setState(), first &apos; &apos;execute the work (without updating the widget state), and then synchronously &apos; &apos;update the state inside a call to setState().&apos; ); &#125; // We ignore other types of return values so that you can do things like: // setState(() =&gt; x = 3); return true; &#125;()); _element.markNeedsBuild();&#125; 通知框架此对象的内部状态已更改。 每当更改State对象的内部状态时，在传递给 setState() 的函数中进行更改，这可能影响此子树中的用户界面发生更改，这会导致框架会调用State对象调用build()。 如果在不调用setState()的情况下直接更改状态，则框架可能不会调用build()，并且可能不会更新此子树的用户界面以反映新状态。 提供的回调会 立即同步调用。它不能返回Future（回调不能是async），因为那时不清楚状态是否实际被设置。 通常，建议只使用setState方法将实际更改 包装 到 状态，而不是任何可能与更改相关的计算。 deactivate() 123@protected@mustCallSupervoid deactivate() &#123; &#125; 从树中删除此对象时调用。 如果从树中永久删除小部件，则在deactivate()之后调用dispose()。 子类应该重写此方法以 清除此对象与树中其他元素之间的 任何链接。 dispose() 123456@protected@mustCallSupervoid dispose() &#123; assert(_debugLifecycleState == _StateLifecycle.ready); assert(() &#123; _debugLifecycleState = _StateLifecycle.defunct; return true; &#125;());&#125; 永久地从树中删除此对象时调用。 子类应重写此方法以释放此对象保留的任何资源（例如，停止任何活动动画）。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Widgets2：Widget与Flutter引擎]]></title>
    <url>%2FFlutter-Widget2%EF%BC%9AWidget%E4%B8%8EFlutter%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[Flutter-Widgets2：Widget与Flutter引擎 方法：runApp(Widget app)将给定的widget 充气(inflate) 并 附加(attach) 到屏幕上。 小部件在Layout(布局)期间被赋予约束，迫使它填充整个屏幕。如果希望将widget对齐到屏幕的一侧（例如，顶部），请考虑使用 Align widget。如果您希望将窗口小部件居中，也可以使用 Center widget。 widget更新再次调用runApp()将从屏幕上分离(detach)上一个根小部件( root widget)并将给定小部件附加到其位置。将新widget树与先前窗口widget树进行 比较，并将任何差异应用于 基础渲染树(render tree)，类似于在调用State.setState()后StatefulWidget重建时发生的情况。 如有必要，使用WidgetsFlutterBinding 进行 初始化绑定。也可以看看： WidgetsBinding.attachRootWidget()，它为 widget层次结构 创建 根widget。 RenderObjectToWidgetAdapter.attachToRenderTree()，它为 element层次结构创 建 根element。 WidgetsBinding.handleBeginFrame()，它抽取widget管道(pipeline)以确保构建widget树、elemen树t 和 render树。 12345void runApp(Widget app) &#123; WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame();&#125; WidgetsFlutterBinding - 将框架绑定到Flutter引擎的粘合剂 基于 Widgets框架 的应用程序的 具体绑定。 12345678910class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding &#123; /// 返回[WidgetsBinding]的实例，必要时创建并初始化它。 如果创建了一个，它将是[WidgetsFlutterBinding]。 如果之前已初始化，那么它至少会实现[WidgetsBinding]。 /// 如果在调用[runApp]之前需要初始化绑定，则只需要调用此方法。 static WidgetsBinding ensureInitialized() &#123; if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance; &#125;&#125; WidgetsBinding - Widget层和Flutter引擎之间的粘合剂。WidgetsBinding类签名说明：只有是 BindingBase、SchedulerBinding、GestureBinding、RendererBinding、SemanticsBinding 的子类才能使用 WidgetsBinding公共类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123; @override void initInstances() &#123; super.initInstances(); _instance = this; buildOwner.onBuildScheduled = _handleBuildScheduled; window.onLocaleChanged = handleLocaleChanged; window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged; SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation); SystemChannels.system.setMessageHandler(_handleSystemMessage); FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator); &#125; /// 当前[WidgetsBinding]，如果已经创建了一个。 /// 如果在调用[runApp]之前需要构造绑定，可以通过调用`WidgetsFlutterBinding.ensureInitialized（）`函数来确保构造Widget绑定。 static WidgetsBinding get instance =&gt; _instance; static WidgetsBinding _instance; /// 初始化服务扩展 @override void initServiceExtensions() &#123; super.initServiceExtensions(); if (!kReleaseMode) &#123; registerSignalServiceExtension( name: 'debugDumpApp', callback: () &#123; debugDumpApp(); return debugPrintDone; &#125;, ); registerBoolServiceExtension( name: 'showPerformanceOverlay', getter: () =&gt; Future&lt;bool&gt;.value(WidgetsApp.showPerformanceOverlayOverride), setter: (bool value) &#123; if (WidgetsApp.showPerformanceOverlayOverride == value) return Future&lt;void&gt;.value(); WidgetsApp.showPerformanceOverlayOverride = value; return _forceRebuild(); &#125;, ); registerServiceExtension( name: 'didSendFirstFrameEvent', callback: (_) async &#123; return &lt;String, dynamic&gt;&#123; // This is defined to return a STRING, not a boolean. // Devtools, the Intellij plugin, and the flutter tool all depend // on it returning a string and not a boolean. 'enabled': _needToReportFirstFrame ? 'false' : 'true', &#125;; &#125;, ); // This returns 'true' when the first frame is rasterized, and the trace // event 'Rasterized first useful frame' is sent out. registerServiceExtension( name: 'didSendFirstFrameRasterizedEvent', callback: (_) async &#123; return &lt;String, dynamic&gt;&#123; // This is defined to return a STRING, not a boolean. // Devtools, the Intellij plugin, and the flutter tool all depend // on it returning a string and not a boolean. 'enabled': firstFrameRasterized ? 'true' : 'false', &#125;; &#125;, ); // Expose the ability to send Widget rebuilds as [Timeline] events. registerBoolServiceExtension( name: 'profileWidgetBuilds', getter: () async =&gt; debugProfileBuildsEnabled, setter: (bool value) async &#123; if (debugProfileBuildsEnabled != value) debugProfileBuildsEnabled = value; &#125;, ); &#125; assert(() &#123; registerBoolServiceExtension( name: 'debugAllowBanner', getter: () =&gt; Future&lt;bool&gt;.value(WidgetsApp.debugAllowBannerOverride), setter: (bool value) &#123; if (WidgetsApp.debugAllowBannerOverride == value) return Future&lt;void&gt;.value(); WidgetsApp.debugAllowBannerOverride = value; return _forceRebuild(); &#125;, ); // This service extension is deprecated and will be removed by 12/1/2018. // Use ext.flutter.inspector.show instead. registerBoolServiceExtension( name: 'debugWidgetInspector', getter: () async =&gt; WidgetsApp.debugShowWidgetInspectorOverride, setter: (bool value) &#123; if (WidgetsApp.debugShowWidgetInspectorOverride == value) return Future&lt;void&gt;.value(); WidgetsApp.debugShowWidgetInspectorOverride = value; return _forceRebuild(); &#125;, ); WidgetInspectorService.instance.initServiceExtensions(registerServiceExtension); return true; &#125;()); &#125; Future&lt;void&gt; _forceRebuild() &#123; if (renderViewElement != null) &#123; buildOwner.reassemble(renderViewElement); return endOfFrame; &#125; return Future&lt;void&gt;.value(); &#125; /// [BuildOwner]负责执行以此绑定为根的窗口小部件树的构建管道。 BuildOwner get buildOwner =&gt; _buildOwner; final BuildOwner _buildOwner = BuildOwner(); /// 负责焦点树的对象。 ///很少直接使用 相反，请考虑使用[FocusScope.of]获取给定[BuildContext]的[FocusScopeNode]。 ///有关详细信息，请参阅[FocusManager]。 FocusManager get focusManager =&gt; _buildOwner.focusManager; final List&lt;WidgetsBindingObserver&gt; _observers = &lt;WidgetsBindingObserver&gt;[]; /// 将给定对象注册为绑定观察者。 当各种应用程序事件发生时，例如当系统区域设置发生更改时，会通知绑定观察者。 通常，窗口小部件树中的一个窗口小部件将自身注册为绑定观察器，并将系统状态转换为继承的窗口小部件。 /// 例如，[WidgetsApp]小部件注册为绑定观察者，并在每次构建时将屏幕大小传递给[MediaQuery]小部件，这使得其他小部件可以使用[MediaQuery.of]静态方法和（隐式） ）每当屏幕大小改变时（例如，每当屏幕旋转时）通知的[InheritedWidget]机制。 /// 也可以看看： /// * [removeObserver]，释放此方法保留的资源。 /// * [WidgetsBindingObserver]，它有一个使用此方法的示例。 void addObserver(WidgetsBindingObserver observer) =&gt; _observers.add(observer); /// Unregisters the given observer. This should be used sparingly as it is relatively expensive (O(N) in the number of registered observers). bool removeObserver(WidgetsBindingObserver observer) =&gt; _observers.remove(observer); @override void handleMetricsChanged() &#123; super.handleMetricsChanged(); for (WidgetsBindingObserver observer in _observers) observer.didChangeMetrics(); &#125; @override void handleTextScaleFactorChanged() &#123; super.handleTextScaleFactorChanged(); for (WidgetsBindingObserver observer in _observers) observer.didChangeTextScaleFactor(); &#125; @override void handlePlatformBrightnessChanged() &#123; super.handlePlatformBrightnessChanged(); for (WidgetsBindingObserver observer in _observers) observer.didChangePlatformBrightness(); &#125; @override void handleAccessibilityFeaturesChanged() &#123; super.handleAccessibilityFeaturesChanged(); for (WidgetsBindingObserver observer in _observers) observer.didChangeAccessibilityFeatures(); &#125; /// Called when the system locale changes. /// /// Calls [dispatchLocaleChanged] to notify the binding observers. /// /// See [Window.onLocaleChanged]. @protected @mustCallSuper void handleLocaleChanged() &#123; dispatchLocalesChanged(window.locales); &#125; /// Notify all the observers that the locale has changed (using /// [WidgetsBindingObserver.didChangeLocales]), giving them the /// `locales` argument. /// /// This is called by [handleLocaleChanged] when the [Window.onLocaleChanged] /// notification is received. @protected @mustCallSuper void dispatchLocalesChanged(List&lt;Locale&gt; locales) &#123; for (WidgetsBindingObserver observer in _observers) observer.didChangeLocales(locales); &#125; /// Notify all the observers that the active set of [AccessibilityFeatures] /// has changed (using [WidgetsBindingObserver.didChangeAccessibilityFeatures]), /// giving them the `features` argument. /// /// This is called by [handleAccessibilityFeaturesChanged] when the /// [Window.onAccessibilityFeaturesChanged] notification is received. @protected @mustCallSuper void dispatchAccessibilityFeaturesChanged() &#123; for (WidgetsBindingObserver observer in _observers) observer.didChangeAccessibilityFeatures(); &#125; /// Called when the system pops the current route. /// /// This first notifies the binding observers (using /// [WidgetsBindingObserver.didPopRoute]), in registration order, until one /// returns true, meaning that it was able to handle the request (e.g. by /// closing a dialog box). If none return true, then the application is shut /// down by calling [SystemNavigator.pop]. /// /// [WidgetsApp] uses this in conjunction with a [Navigator] to /// cause the back button to close dialog boxes, return from modal /// pages, and so forth. /// /// This method exposes the `popRoute` notification from /// [SystemChannels.navigation]. @protected Future&lt;void&gt; handlePopRoute() async &#123; for (WidgetsBindingObserver observer in List&lt;WidgetsBindingObserver&gt;.from(_observers)) &#123; if (await observer.didPopRoute()) return; &#125; SystemNavigator.pop(); &#125; /// Called when the host tells the app to push a new route onto the /// navigator. /// /// This notifies the binding observers (using /// [WidgetsBindingObserver.didPushRoute]), in registration order, until one /// returns true, meaning that it was able to handle the request (e.g. by /// opening a dialog box). If none return true, then nothing happens. /// /// This method exposes the `pushRoute` notification from /// [SystemChannels.navigation]. @protected @mustCallSuper Future&lt;void&gt; handlePushRoute(String route) async &#123; for (WidgetsBindingObserver observer in List&lt;WidgetsBindingObserver&gt;.from(_observers)) &#123; if (await observer.didPushRoute(route)) return; &#125; &#125; Future&lt;dynamic&gt; _handleNavigationInvocation(MethodCall methodCall) &#123; switch (methodCall.method) &#123; case 'popRoute': return handlePopRoute(); case 'pushRoute': return handlePushRoute(methodCall.arguments); &#125; return Future&lt;dynamic&gt;.value(); &#125; @override void handleAppLifecycleStateChanged(AppLifecycleState state) &#123; super.handleAppLifecycleStateChanged(state); for (WidgetsBindingObserver observer in _observers) observer.didChangeAppLifecycleState(state); &#125; /// Called when the operating system notifies the application of a memory /// pressure situation. /// /// Notifies all the observers using /// [WidgetsBindingObserver.didHaveMemoryPressure]. /// /// This method exposes the `memoryPressure` notification from /// [SystemChannels.system]. void handleMemoryPressure() &#123; for (WidgetsBindingObserver observer in _observers) observer.didHaveMemoryPressure(); &#125; Future&lt;void&gt; _handleSystemMessage(Object systemMessage) async &#123; final Map&lt;String, dynamic&gt; message = systemMessage; final String type = message['type']; switch (type) &#123; case 'memoryPressure': handleMemoryPressure(); break; &#125; return; &#125; bool _needToReportFirstFrame = true; int _deferFirstFrameReportCount = 0; bool get _reportFirstFrame =&gt; _deferFirstFrameReportCount == 0; final Completer&lt;void&gt; _firstFrameCompleter = Completer&lt;void&gt;(); /// Whether the Flutter engine has rasterized the first frame. /// /// &#123;@macro flutter.frame_rasterized_vs_presented&#125; /// /// See also: /// /// * [waitUntilFirstFrameRasterized], the future when [firstFrameRasterized] /// becomes true. bool get firstFrameRasterized =&gt; _firstFrameCompleter.isCompleted; /// A future that completes when the Flutter engine has rasterized the first /// frame. /// /// &#123;@macro flutter.frame_rasterize_vs_presented&#125; /// /// See also: /// /// * [firstFrameRasterized], whether this future has completed or not. Future&lt;void&gt; get waitUntilFirstFrameRasterized =&gt; _firstFrameCompleter.future; /// Whether the first frame has finished building. /// /// Only useful in profile and debug builds; in release builds, this always /// return false. This can be deferred using [deferFirstFrameReport] and /// [allowFirstFrameReport]. The value is set at the end of the call to /// [drawFrame]. /// /// This value can also be obtained over the VM service protocol as /// `ext.flutter.didSendFirstFrameEvent`. /// /// See also: /// /// * [firstFrameRasterized], whether the first frame has finished rendering. bool get debugDidSendFirstFrameEvent =&gt; !_needToReportFirstFrame; /// Tell the framework not to report the frame it is building as a "useful" /// first frame until there is a corresponding call to [allowFirstFrameReport]. /// /// This is used by [WidgetsApp] to avoid reporting frames that aren't useful /// during startup as the "first frame". void deferFirstFrameReport() &#123; if (!kReleaseMode) &#123; assert(_deferFirstFrameReportCount &gt;= 0); _deferFirstFrameReportCount += 1; &#125; &#125; ////在[deferFirstFrameReport]之后调用时：告诉框架将其构建的帧报告为“有用的”第一帧。 ///对于[deferFirstFrameReport]的每次相应调用，只能调用此方法一次。 /// [WidgetsApp]使用它来报告绘制第一个有用帧的时间。 void allowFirstFrameReport() &#123; if (!kReleaseMode) &#123; assert(_deferFirstFrameReportCount &gt;= 1); _deferFirstFrameReportCount -= 1; &#125; &#125; void _handleBuildScheduled() &#123; // 如果我们正在构建脏元素，那么更改不应该触发新框架。 assert(() &#123; if (debugBuildingDirtyElements) &#123; throw FlutterError( 'Build scheduled during frame.\n' 'While the widget tree was being built, laid out, and painted, ' 'a new frame was scheduled to rebuild the widget tree. ' 'This might be because setState() was called from a layout or ' 'paint callback. ' 'If a change is needed to the widget tree, it should be applied ' 'as the tree is being built. Scheduling a change for the subsequent ' 'frame instead results in an interface that lags behind by one frame. ' 'If this was done to make your build dependent on a size measured at ' 'layout time, consider using a LayoutBuilder, CustomSingleChildLayout, ' 'or CustomMultiChildLayout. If, on the other hand, the one frame delay ' 'is the desired effect, for example because this is an ' 'animation, consider scheduling the frame in a post-frame callback ' 'using SchedulerBinding.addPostFrameCallback or ' 'using an AnimationController to trigger the animation.' ); &#125; return true; &#125;()); ensureVisualUpdate(); &#125; ///我们目前是否在一个框架中。 这用于验证帧是否未被冗余调度。 ///这是公开的，以便测试框架可以改变它。 ///此标志未在发布版本中使用。 @protected bool debugBuildingDirtyElements = false; /// 抽取 构建(build) 和 渲染管道(rendering pipeline) 以生成 框架(frame)。 /// 这个方法由[handleDrawFrame]调用，当它需要布局和绘制框架时，引擎会自动调用它。 /// /// 每个框架(frame)包含以下阶段： /// /// 1.动画阶段(Animation phase)：[handleBeginFrame]方法，使用[Window.onBeginFrame]注册，以注册顺序调用[scheduleFrameCallback]注册的所有瞬态帧回调。 /// 这包括驱动[AnimationController]对象的所有[Ticker]实例，这意味着此时所有活动的[Animation]对象都会勾选。 /// /// 2.微任务(Microtasks phase)：在[handleBeginFrame]返回后，由 瞬态帧(transient frame)回调调度的任何微任务都可以运行。 /// 这通常包括完成此框架(frame)的[Ticker]和[AnimationController]的期货回调。 /// /// 在[handleBeginFrame]之后，调用[Window.onDrawFrame]注册的[handleDrawFrame]，调用所有持久帧回调，其中最值得注意的是此方法[drawFrame]，其执行如下： /// /// 3.构建阶段(build phase)：重建窗口小部件树(widget tree)中的所有脏[元素](dirty [Element])（参见[State.build]）。 /// 有关将构建脏标记为脏(marking a widget)的详细信息，请参阅[State.setState]。 /// 有关此步骤的更多信息，请参见[BuildOwner]。 /// /// 4.布局阶段(layout phase)：布局系统中所有脏[RenderObject]（参见[RenderObject.performLayout]）。 /// 有关为布局标记脏对象的更多详细信息，请参见[RenderObject.markNeedsLayout]。 /// /// 5.合成位阶段(compositing bits phase)：更新任何脏[RenderObject]对象上的合成位(compositing bits)。 /// 请参见[RenderObject.markNeedsCompositingBitsUpdate]。 /// /// 6.绘制阶段(paint phase)：系统中所有脏的[RenderObject]都被重新绘制（参见[RenderObject.paint]）。 这会生成[Layer]树。 /// 有关将画图(paint)标记为脏的对象的更多详细信息，请参见[RenderObject.markNeedsPaint]。 /// /// 7.合成阶段(compositing phase)：图层树(layer tree)变为[Scene(场景)]并发送到GPU。 /// /// 8.语义阶段(semantics phase)：系统中所有脏[RenderObject]的语义都已更新（参见[RenderObject.semanticsAnnotator]）。 这会生成[SemanticsNode]树。 有关为语义标记脏对象的更多详细信息，请参见[RenderObject.markNeedsSemanticsUpdate]。 /// /// 有关步骤 4-8 的更多详细信息，请参阅[PipelineOwner]。 /// /// 9.窗口小部件层中的完成阶段(finalization phase in the widgets layer)：widgets tree 已完成。 /// 框架从widgets tree中删除任何对象时，[State.dispose]将会被调用。 /// 有关详细信息，请参阅[BuildOwner.finalizeTree]。 /// /// 10.调度程序层中的最终确定阶段：在[drawFrame]返回之后，[handleDrawFrame]然后调用后帧回调(post-frame callbacks)（使用[addPostFrameCallback]注册）。 // // 编辑上面的内容时，还要更新rendering / binding.dart的副本。 @override void drawFrame() &#123; assert(!debugBuildingDirtyElements); assert(() &#123; debugBuildingDirtyElements = true; return true; &#125;()); if (_needToReportFirstFrame &amp;&amp; _reportFirstFrame) &#123; assert(!_firstFrameCompleter.isCompleted); // TODO(liyuqian): use a broadcast stream approach final TimingsCallback oldCallback = WidgetsBinding.instance.window.onReportTimings; WidgetsBinding.instance.window.onReportTimings = (List&lt;FrameTiming&gt; timings) &#123; if (!kReleaseMode) &#123; developer.Timeline.instantSync('Rasterized first useful frame'); developer.postEvent('Flutter.FirstFrame', &lt;String, dynamic&gt;&#123;&#125;); &#125; if (oldCallback != null) &#123; oldCallback(timings); &#125; WidgetsBinding.instance.window.onReportTimings = oldCallback; _firstFrameCompleter.complete(); &#125;; &#125; try &#123; if (renderViewElement != null) buildOwner.buildScope(renderViewElement); super.drawFrame(); buildOwner.finalizeTree(); &#125; finally &#123; assert(() &#123; debugBuildingDirtyElements = false; return true; &#125;()); &#125; if (!kReleaseMode) &#123; if (_needToReportFirstFrame &amp;&amp; _reportFirstFrame) &#123; developer.Timeline.instantSync('Widgets built first useful frame'); &#125; &#125; _needToReportFirstFrame = false; &#125; /// [Element]是层次结构的根（并将[RenderView]对象包装在渲染层次结构(rendering hierarchy)的根下）。 ///这是在第一次调用[runApp]时初始化的。 Element get renderViewElement =&gt; _renderViewElement; Element _renderViewElement; /// 获取一个widget并将其附加(attaches)到[renderViewElement]，必要时创建它。 /// [runApp]调用它来配置小部件树。 ///另见[RenderObjectToWidgetAdapter.attachToRenderTree]。 void attachRootWidget(Widget rootWidget) &#123; _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;( container: renderView, debugShortDescription: '[root]', child: rootWidget, ).attachToRenderTree(buildOwner, renderViewElement); &#125; ///是否已初始化[renderViewElement]。 ///在调用[runApp]（或在[TestWidgetsFlutterBinding]的上下文中调用[WidgetTester.pumpWidget]）之前，这将是false。 bool get isRootWidgetAttached =&gt; _renderViewElement != null; @override Future&lt;void&gt; performReassemble() &#123; assert(() &#123; WidgetInspectorService.instance.performReassemble(); return true; &#125;()); deferFirstFrameReport(); if (renderViewElement != null) buildOwner.reassemble(renderViewElement); return super.performReassemble().then((void value) &#123; allowFirstFrameReport(); &#125;); &#125;&#125; RenderObjectToWidgetAdapter从 RenderObject 到 Element树 的 桥。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/// 给定的容器是应该插入[Element]树的[RenderObject]。 它必须是[RenderObject]，它实现[RenderObjectWithChildMixin]协议。 类型参数`T`是容器期望作为其子类的[RenderObject]类型。/// 由[runApp]用于引导应用程序。class RenderObjectToWidgetAdapter&lt;T extends RenderObject&gt; extends RenderObjectWidget &#123; /// 从[RenderObject]到[Element]树创建一个桥。 /// 由[WidgetsBinding]用于将根小部件附加到[RenderView]。 RenderObjectToWidgetAdapter(&#123; this.child, this.container, this.debugShortDescription, &#125;) : super(key: GlobalObjectKey(container)); /// 树中此widget下面的widget。 /// &#123;@macro flutter.widgets.child&#125; final Widget child; /// [RenderObject]，它是由此widget创建的[Element]的父级。 final RenderObjectWithChildMixin&lt;T&gt; container; /// 调试辅助工具使用的此widget的简短描述(short description)。 final String debugShortDescription; @override RenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(this); @override RenderObjectWithChildMixin&lt;T&gt; createRenderObject(BuildContext context) =&gt; container; @override void updateRenderObject(BuildContext context, RenderObject renderObject) &#123; &#125; /// 填充这个widget并将[RenderObject]的实际设置结果作为[container]的子节点。 /// 如果`element`为null，则此函数将创建一个新element。 否则，给定element将安排更新以切换到此widget。 /// 由[runApp]用于引导应用程序。 RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt; element ]) &#123; if (element == null) &#123; owner.lockState(() &#123; element = createElement(); assert(element != null); element.assignOwner(owner); &#125;); owner.buildScope(element, () &#123; element.mount(null, null); &#125;); &#125; else &#123; element._newWidget = this; element.markNeedsBuild(); &#125; return element; &#125; @override String toStringShort() =&gt; debugShortDescription ?? super.toStringShort();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/// 由[RenderObject]托管的[RootRenderObjectElement]。////// 此element类是[RenderObjectToWidgetAdapter] Widget的实例化。/// 它只能用作[Element]树的根（它不能挂载到另一个[Element];它的父元素必须为null）。/// 在典型用法中，它将被实例化为[RenderObjectToWidgetAdapter]，其容器是连接到Flutter引擎的[RenderView]。 /// 在这种用法中，它通常由[runApp]创建的[WidgetsFlutterBinding]单例中的引导逻辑实例化。class RenderObjectToWidgetElement&lt;T extends RenderObject&gt; extends RootRenderObjectElement &#123; ///创建由[RenderObject]托管的元素。 ///由此元素创建的[RenderObject]不会自动设置为托管[RenderObject]的子级。 要将此元素实际附加到渲染树，请调用[RenderObjectToWidgetAdapter.attachToRenderTree]。 RenderObjectToWidgetElement(RenderObjectToWidgetAdapter&lt;T&gt; widget) : super(widget); @override RenderObjectToWidgetAdapter&lt;T&gt; get widget =&gt; super.widget; Element _child; static const Object _rootChildSlot = Object(); @override void visitChildren(ElementVisitor visitor) &#123; if (_child != null) visitor(_child); &#125; @override void forgetChild(Element child) &#123; assert(child == _child); _child = null; &#125; @override void mount(Element parent, dynamic newSlot) &#123; assert(parent == null); super.mount(parent, newSlot); _rebuild(); &#125; @override void update(RenderObjectToWidgetAdapter&lt;T&gt; newWidget) &#123; super.update(newWidget); assert(widget == newWidget); _rebuild(); &#125; // 当我们分配一个新的Widget时，我们将它存储在此处，直到我们准备好更新它。 Widget _newWidget; @override void performRebuild() &#123; if (_newWidget != null) &#123; // 例如，如果由于reassemble而重建了我们，则_newWidget可以为null。 final Widget newWidget = _newWidget; _newWidget = null; update(newWidget); &#125; super.performRebuild(); assert(_newWidget == null); &#125; void _rebuild() &#123; try &#123; _child = updateChild(_child, widget.child, _rootChildSlot); assert(_child != null); &#125; catch (exception, stack) &#123; final FlutterErrorDetails details = FlutterErrorDetails( exception: exception, stack: stack, library: 'widgets library', context: ErrorDescription('attaching to the render tree'), ); FlutterError.reportError(details); final Widget error = ErrorWidget.builder(details); _child = updateChild(null, error, _rootChildSlot); &#125; &#125; @override RenderObjectWithChildMixin&lt;T&gt; get renderObject =&gt; super.renderObject; @override void insertChildRenderObject(RenderObject child, dynamic slot) &#123; assert(slot == _rootChildSlot); assert(renderObject.debugValidateChild(child)); renderObject.child = child; &#125; @override void moveChildRenderObject(RenderObject child, dynamic slot) &#123; assert(false); &#125; @override void removeChildRenderObject(RenderObject child) &#123; assert(renderObject.child == child); renderObject.child = null; &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-channel]]></title>
    <url>%2FFlutter-channel%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Dart-关键字]]></title>
    <url>%2FDart-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Dart-关键字 12345import 'dart:async';import 'dart:convert' show json;import 'dart:developer' as developer;import 'dart:io' show exit;import 'dart:ui' as ui show saveCompilationTrace, Window, window; 12345678910111213141516171819/// A constant that is true if the application was compiled in release mode.////// More specifically, this is a constant that is true if the application was/// compiled in Dart with the '-Ddart.vm.product=true' flag.////// Since this is a const value, it can be used to indicate to the compiler that/// a particular block of code will not be executed in release mode, and hence/// can be removed.const bool kReleaseMode = bool.fromEnvironment('dart.vm.product', defaultValue: false);/// 如果应用程序是在发布模式下编译的，则为常量////// More specifically, this is a constant that is true if the application was/// compiled in Dart with the '-Ddart.vm.profile=true' flag.////// Since this is a const value, it can be used to indicate to the compiler that/// a particular block of code will not be executed in profle mode, an hence/// can be removed.const bool kProfileMode = bool.fromEnvironment('dart.vm.profile', defaultValue: false);]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-isolate]]></title>
    <url>%2FFlutter-isolate%2F</url>
    <content type="text"><![CDATA[Flutter-isolate 闭包：内部函数。类：含有行为的数据类型；闭包：含有数据的行为。 函数式编程（Functional Programming）—— 一种编程范式：将大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程程序设计的基本单元。 函数式编程就是一种抽象程度很高的编程范式。 纯粹的函数式编程：编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。 非纯粹：而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 测试： 客户端上传-1 客户端上传-2 PicGo]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-点击事件+手势]]></title>
    <url>%2FFlutter-%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%2B%E6%89%8B%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[点击事件+手势 参考：https://www.jianshu.com/p/dd6554e1e3e3参考：https://segmentfault.com/a/1190000011555283]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-渲染相关3]]></title>
    <url>%2FFlutter-%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B33%2F</url>
    <content type="text"><![CDATA[Flutter-渲染相关3 RenderObject源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792abstract class RenderObject extends AbstractNode with DiagnosticableTreeMixin implements HitTestTarget &#123; /// 初始化子类的内部字段 RenderObject() &#123; _needsCompositing = isRepaintBoundary || alwaysNeedsCompositing; &#125; // 在构造函数中初始化 bool _needsCompositing; ///此渲染对象是否与其父对象分开重新绘制。 ///在子类中重写此项以指示您的类的实例应该独立重绘。 例如，经常重绘的渲染对象可能想要重绘自己而不需要重绘它们的父级。 ///如果此getter返回true，则[paintBounds]将应用于此对象和所有后代。 ///警告：此getter不得在此对象的生命周期内更改值。 bool get isRepaintBoundary =&gt; false; ///估计此渲染对象将绘制的边界。 ///用于调试[debugPaintLayerBordersEnabled]等标志。 ///这些也是[showOnScreen]用于在屏幕上显示[RenderObject]的边界。 Rect get paintBounds; ///这个渲染对象是否总是需要合成。 ///在子类中重写此项以指示您的绘制函数始终创建至少一个合成图层。 例如，如果视频使用硬件解码器，则视频应返回true。 ///如果此getter的值发生更改，则必须调用[markNeedsCompositingBitsUpdate]。 （当调用[adoptChild]或[dropChild]时暗示这一点。） @protected bool get alwaysNeedsCompositing =&gt; false; ///导致以给定[RenderObject]为根的整个子树被标记为脏，用于布局，绘制等，以便可以看到热重载的效果，或者更改全局调试标志的效果（例如 可以应用[debugPaintSizeEnabled]）。 ///由[RendererBinding]调用，以响应`ext.flutter.reassemble`钩子，当应用程序代码发生变化时，开发工具使用它来使窗口小部件树获取任何已更改的实现。 ///这很昂贵，不应该在开发期间调用。 /// 也可以看看： /// * [BindingBase.reassembleApplication] void reassemble()&#123; markNeedsLayout(); markNeedsCompositingBitsUpdate(); markNeedsPaint(); markNeedsSemanticsUpdate(); visitChildren((RenderObject child)&#123; child.reassemble(); &#125;); &#125; // ======== 布局 LAYOUT ======== ///父渲染对象使用的数据。 ///父数据由渲染对象使用，该对象布置此对象（通常是渲染树中此对象的父对象）以存储与其自身相关的信息以及恰好知道数据意味着什么的任何其他节点。 父数据对孩子不透明。 /// *除用[setupParentData]之外，不能直接设置父数据字段。 /// *通过在未来的父节点上调用[setupParentData]，可以在将子项添加到父项之前设置父数据。 /// *使用父数据的约定取决于父和子之间使用的布局协议。 例如，在Box布局中，父数据完全不透明，但在扇区布局中，允许子读取父数据的某些字段。 ParentData parentData; ///override为您的孩子正确设置父数据。 ///在将子项添加到父项子列表之前，您可以调用此函数来设置子项的父数据。 void setupParentData(covariant RenderObject child) &#123; assert(_debugCanPerformMutations); if (child.parentData is! ParentData) child.parentData = ParentData(); &#125; ///当子类决定渲染对象是child对象时由子类调用。 ///仅在更改子列表(child lists)时由子类使用。 在其他情况下调用此方法将导致树不一致并可能导致崩溃。 @override void adoptChild(RenderObject child) &#123; assert(_debugCanPerformMutations); assert(child != null); setupParentData(child); markNeedsLayout(); markNeedsCompositingBitsUpdate(); markNeedsSemanticsUpdate(); super.adoptChild(child); &#125; ///当子类决定渲染对象再是子对象时由子类调用。 ///仅在更改子列表时由子类使用。 在其他情况下调用此方法将导致树不一致并可能导致崩溃。 @override void dropChild(RenderObject child) &#123; assert(_debugCanPerformMutations); assert(child != null); assert(child.parentData != null); child._cleanRelayoutBoundary(); child.parentData.detach(); child.parentData = null; super.dropChild(child); markNeedsLayout(); markNeedsCompositingBitsUpdate(); markNeedsSemanticsUpdate(); &#125; ///为此渲染对象的每个直接子节点(immediate child)调用访问者(calls visitor)。 ///Override带子节点(children)的子类并为每个子节点(children)调用访问者(calls visitor)。 void visitChildren(RenderObjectVisitor visitor) &#123;&#125; ///这个对象的责任是为了创建此渲染对象。 ///用于调试消息。 dynamic debugCreator; ……省略的断言调试代码见下文 @override PipelineOwner get owner =&gt; super.owner; @override void attach(PipelineOwner owner) &#123; super.attach(owner); //如果节点在未连接时以某种方式被弄脏，请确保在所有者可用时将其添加到适当的脏列表中 if (_needsLayout &amp;&amp; _relayoutBoundary != null) &#123; //如果我们根本没有布局，请不要进入这个街区; scheduleInitialLayout（）将处理它 _needsLayout = false; markNeedsLayout(); &#125; if (_needsCompositingBitsUpdate) &#123; _needsCompositingBitsUpdate = false; markNeedsCompositingBitsUpdate(); &#125; if (_needsPaint &amp;&amp; _layer != null) &#123; // Don't enter this block if we've never painted at all; // scheduleInitialPaint() will handle it _needsPaint = false; markNeedsPaint(); &#125; if (_needsSemanticsUpdate &amp;&amp; _semanticsConfiguration.isSemanticBoundary) &#123; // Don't enter this block if we've never updated semantics at all; // scheduleInitialSemantics() will handle it _needsSemanticsUpdate = false; markNeedsSemanticsUpdate(); &#125; &#125; bool _needsLayout = true; RenderObject _relayoutBoundary; bool _doingThisLayoutWithCallback = false; //当一个child被添加时，设置为true bool _needsCompositingBitsUpdate = false; ///最近由父级提供的布局约束。 @protected Constraints get constraints =&gt; _constraints; Constraints _constraints; ///将此渲染对象的布局信息标记为脏，并使用其[PipelineOwner]注册此对象，或者根据此对象是否为重新布局边界而延迟到父对象。 /// /// ## Background /// 我们不是急切地更新布局信息以响应写入渲染对象，而是将布局信息标记为脏，从而调度可视更新。 /// 作为可视更新的一部分，渲染管道更新渲染对象的布局信息。 /// /// 此机制批处理布局工作，以便合并多个顺序写入，从而消除冗余计算。 /// /// 如果渲染对象的父节点在计算其布局信息时，指明它使用其渲染对象子节点之一的大小，则此函数在为子节点调用时也会将父节点标记为需要布局。 /// 在这种情况下，由于父节点和子节点都需要重新计算其布局，因此仅向管道所有者通知父节点;当父母被布置时，它将调用孩子的layout()，因此孩子也将被布置。 /// /// 一旦在渲染对象上调用markNeedsLayout()，debugNeedsLayout()将为该渲染对象返回true，直到管道所有者在渲染对象上调用layout()之后。 /// /// ## 特别案例 /// /// [RenderObject]的某些子类，特别是[RenderBox]，还有其他情况，如果孩子被弄脏，父母需要得到通知。 /// 在正常情况下，这样的子类覆盖markNeedsLayout()并调用`super.markNeedsLayout()`，或者在需要布局父元素以及子元素的情况下调用[markParentNeedsLayout]。 /// as well as the child. /// /// If [sizedByParent] has changed, calls [markNeedsLayoutForSizedByParentChange] instead of [markNeedsLayout]. void markNeedsLayout() &#123; assert(_debugCanPerformMutations); if (_needsLayout) &#123; assert(_debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout()); return; &#125; assert(_relayoutBoundary != null); if (_relayoutBoundary != this) &#123; markParentNeedsLayout(); &#125; else &#123; _needsLayout = true; if (owner != null) &#123; assert(() &#123; if (debugPrintMarkNeedsLayoutStacks) debugPrintStack(label: 'markNeedsLayout() called for $this'); return true; &#125;()); owner._nodesNeedingLayout.add(this); owner.requestVisualUpdate(); &#125; &#125; &#125; /// 将此渲染对象的布局信息标记为脏，然后推迟到父级。 /// /// 只应从子类的markNeedsLayout()或markNeedsLayoutForSizedByParentChange()实现调用此函数，这些实现引入了将脏布局处理延迟到父级的更多原因。 /// /// 如果[parent]不为null，则仅调用此方法 @protected void markParentNeedsLayout() &#123; _needsLayout = true; final RenderObject parent = this.parent; if (!_doingThisLayoutWithCallback) &#123; parent.markNeedsLayout(); &#125; else &#123; assert(parent._debugDoingThisLayout); &#125; assert(parent == this.parent); &#125; /// 将此渲染对象的布局信息标记为脏（如[markNeedsLayout]），另外还处理任何必要的工作来处理[sizeByParent]更改值的情况。 /// 只要[sizeByParent]可能已更改，就应调用此方法。 /// 如果[parent]不为null，则仅调用此方法。 void markNeedsLayoutForSizedByParentChange() &#123; markNeedsLayout(); markParentNeedsLayout(); &#125; void _cleanRelayoutBoundary() &#123; if (_relayoutBoundary != this) &#123; _relayoutBoundary = null; _needsLayout = true; visitChildren((RenderObject child) &#123; child._cleanRelayoutBoundary(); &#125;); &#125; &#125; ///通过调度第一个布局来引导渲染管道。 ///需要附加此渲染对象，并且此渲染对象是渲染树的根。 ///有关如何使用此函数的示例，请参见[RenderView]。 void scheduleInitialLayout() &#123; assert(attached); assert(parent is! RenderObject); assert(!owner._debugDoingLayout); assert(_relayoutBoundary == null); _relayoutBoundary = this; assert(() &#123; _debugCanParentUseSize = false; return true; &#125;()); owner._nodesNeedingLayout.add(this); &#125; void _layoutWithoutResize() &#123; assert(_relayoutBoundary == this); RenderObject debugPreviousActiveLayout; assert(!_debugMutationsLocked); assert(!_doingThisLayoutWithCallback); assert(_debugCanParentUseSize != null); assert(() &#123; _debugMutationsLocked = true; _debugDoingThisLayout = true; debugPreviousActiveLayout = _debugActiveLayout; _debugActiveLayout = this; if (debugPrintLayouts) debugPrint('Laying out (without resize) $this'); return true; &#125;()); try &#123; performLayout(); markNeedsSemanticsUpdate(); &#125; catch (e, stack) &#123; _debugReportException('performLayout', e, stack); &#125; assert(() &#123; _debugActiveLayout = debugPreviousActiveLayout; _debugDoingThisLayout = false; _debugMutationsLocked = false; return true; &#125;()); _needsLayout = false; markNeedsPaint(); &#125; /// 计算此渲染对象的布局。 /// /// 此方法是父母要求孩子更新其布局信息的主要入口点。 /// 父传递一个约束对象，该对象通知子项允许哪些布局。孩子必须遵守给定的约束。 /// /// 如果父级读取子级布局期间计算的信息，则父级必须为“parentUsesSize”传递true。 /// 在这种情况下，只要孩子被标记为需要布局，父母就会被标记为需要布局，因为父母的布局信息取决于孩子的布局信息。 /// 如果父对象使用`parentUsesSize`的默认值（false），则子进程可以更改其布局信息（受限于给定的约束），而不通知父进程。 /// /// 子类不应直接覆盖 layout()。 相反，他们应该覆盖 performResize() 和/或 performLayout()。 layout() 方法将实际工作委托给 performResize()和 performLayout()。 /// /// parent的performLayout()方法应无条件地调用其所有子节点的layout()。 如果孩子不需要做任何工作来更新其布局信息，那么layout()方法的责任（如此实现）可以提前返回。 void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123; assert(constraints != null); assert(constraints.debugAssertIsValid( isAppliedConstraint: true, informationCollector: () sync* &#123; final List&lt;String&gt; stack = StackTrace.current.toString().split('\n'); int targetFrame; final Pattern layoutFramePattern = RegExp(r'^#[0-9]+ +RenderObject.layout \('); for (int i = 0; i &lt; stack.length; i += 1) &#123; if (layoutFramePattern.matchAsPrefix(stack[i]) != null) &#123; targetFrame = i + 1; break; &#125; &#125; if (targetFrame != null &amp;&amp; targetFrame &lt; stack.length) &#123; final Pattern targetFramePattern = RegExp(r'^#[0-9]+ +(.+)$'); final Match targetFrameMatch = targetFramePattern.matchAsPrefix(stack[targetFrame]); final String problemFunction = (targetFrameMatch != null &amp;&amp; targetFrameMatch.groupCount &gt; 0) ? targetFrameMatch.group(1) : stack[targetFrame].trim(); // TODO(jacobr): this case is similar to displaying a single stack frame. yield ErrorDescription( 'These invalid constraints were provided to $runtimeType\'s layout() ' 'function by the following function, which probably computed the ' 'invalid constraints in question:\n' ' $problemFunction' ); &#125; &#125;, )); assert(!_debugDoingThisResize); assert(!_debugDoingThisLayout); RenderObject relayoutBoundary; if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123; relayoutBoundary = this; &#125; else &#123; final RenderObject parent = this.parent; relayoutBoundary = parent._relayoutBoundary; &#125; assert(() &#123; _debugCanParentUseSize = parentUsesSize; return true; &#125;()); if (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123; assert(() &#123; // in case parentUsesSize changed since the last invocation, set size // to itself, so it has the right internal debug values. _debugDoingThisResize = sizedByParent; _debugDoingThisLayout = !sizedByParent; final RenderObject debugPreviousActiveLayout = _debugActiveLayout; _debugActiveLayout = this; debugResetSize(); _debugActiveLayout = debugPreviousActiveLayout; _debugDoingThisLayout = false; _debugDoingThisResize = false; return true; &#125;()); return; &#125; _constraints = constraints; _relayoutBoundary = relayoutBoundary; assert(!_debugMutationsLocked); assert(!_doingThisLayoutWithCallback); assert(() &#123; _debugMutationsLocked = true; if (debugPrintLayouts) debugPrint('Laying out ($&#123;sizedByParent ? "with separate resize" : "with resize allowed"&#125;) $this'); return true; &#125;()); if (sizedByParent) &#123; assert(() &#123; _debugDoingThisResize = true; return true; &#125;()); try &#123; performResize(); assert(() &#123; debugAssertDoesMeetConstraints(); return true; &#125;()); &#125; catch (e, stack) &#123; _debugReportException('performResize', e, stack); &#125; assert(() &#123; _debugDoingThisResize = false; return true; &#125;()); &#125; RenderObject debugPreviousActiveLayout; assert(() &#123; _debugDoingThisLayout = true; debugPreviousActiveLayout = _debugActiveLayout; _debugActiveLayout = this; return true; &#125;()); try &#123; performLayout(); markNeedsSemanticsUpdate(); assert(() &#123; debugAssertDoesMeetConstraints(); return true; &#125;()); &#125; catch (e, stack) &#123; _debugReportException('performLayout', e, stack); &#125; assert(() &#123; _debugActiveLayout = debugPreviousActiveLayout; _debugDoingThisLayout = false; _debugMutationsLocked = false; return true; &#125;()); _needsLayout = false; markNeedsPaint(); &#125; /// 如果一个子类有一个“大小”（由`parentUsesSize`控制的状态，无论它在子类中是什么，例如[RenderBox]的实际`size`属性），子类在检查模式(checked mode)下验证这个“ 如果未设置[debugCanParentUseSize]，则不使用size“属性，那么该子类应覆盖[debugResetSize]以将[debugCanParentUseSize]的当前值重新应用于该状态。 @protected void debugResetSize() &#123;&#125; /// 约束是否是调整算法的唯一输入（特别是，子节点没有影响）。 /// /// 返回false总是正确的，但是在计算此渲染对象的大小时返回true会更有效，因为如果约束没有改变，我们不需要重新计算大小。 /// /// 通常，子类将始终返回相同的值。 如果值可以更改，那么，当它发生更改时，子类应确保调用[markNeedsLayoutForSizedByParentChange]。 @protected bool get sizedByParent =&gt; false; /// 仅使用约束更新渲染对象大小。 /// /// 不要直接调用此函数：改为调用layout()。 /// 当布局期间实际要由此渲染对象完成工作时，layout()将调用此函数。s父级提供的布局约束可通过[constraints] getter获得。 /// /// 将sizeByParent设置为true的子类应覆盖此方法以计算其大小。 /// /// 仅当sizesByParent为true时才调用此函数。 @protected void performResize(); /// 为此渲染对象计算布局的工作。 /// /// 不要直接调用此函数：改为调用layout()。当布局期间实际要由此渲染对象完成工作时，layout()将调用此函数。您的父级提供的布局约束可通过[constraints] getter获得。 /// /// 如果sizeByParent为true，则此函数实际上不应更改此渲染对象的尺寸。 /// 相反，这项工作应该由performResize()完成。如果sizeByParent为false，则此函数应更改此渲染对象的尺寸并指示其子项进行布局。 /// /// 在实现此功能时，您必须在每个子项上调用layout()，如果您的布局信息取决于child的布局信息，则为parentUsesSize传递true。 /// 对于parentUsesSize传递true可确保在子项进行布局时此渲染对象将进行布局。 /// 否则，子节点可以在不通知此渲染对象的情况下更改其布局信息。 @protected void performLayout(); /// 允许对此对象的子列表（以及任何后代）以及与此对象相同的[PipelineOwner]拥有的渲染树中的任何其他脏节点进行突变。 同时调用`callback`参数，并且仅在回调执行期间允许突变。 /// /// 这样可以允许在布局期间按需构建子列表（例如，基于对象的大小），并且在这种情况下允许节点在树周围移动（例如，处理[GlobalKey]重新显示），同时 仍然确保每帧只布置一个特定节点。 /// /// 调用此函数会禁用许多旨在捕获可能错误的断言。 因此，通常不鼓励使用此功能。 /// /// 此功能只能在布局期间调用。 @protected void invokeLayoutCallback&lt;T extends Constraints&gt;(LayoutCallback&lt;T&gt; callback) &#123; assert(_debugMutationsLocked); assert(_debugDoingThisLayout); assert(!_doingThisLayoutWithCallback); _doingThisLayoutWithCallback = true; try &#123; owner._enableMutationsToDirtySubtrees(() &#123; callback(constraints); &#125;); &#125; finally &#123; _doingThisLayoutWithCallback = false; &#125; &#125; // ======== 绘制 PAINTING ======== ///此渲染对象是否与其父对象分开重新绘制。 ///在子类中重写此项以指示您的类的实例应该独立重绘。 例如，经常重绘的渲染对象可能想要重绘自己而不需要重绘它们的父级。 ///如果此getter返回true，则[paintBounds]将应用于此对象和所有后代。 ///警告：此getter不得在此对象的生命周期内更改值。 bool get isRepaintBoundary =&gt; false; ///在已检查模式(checked mode)下调用，如果[isRepaintBoundary]为true，则此渲染对象或其父对象尝试绘制时。 ///这可以用于记录节点是否应该实际上是重绘边界的度量。 void debugRegisterRepaintBoundaryPaint（&#123;bool includedParent = true，bool includedChild = false&#125;）&#123;&#125; ///这个渲染对象是否总是需要合成。 ///在子类中重写此项以指示您的绘制函数始终创建至少一个合成图层。 例如，如果视频使用硬件解码器，则视频应返回true。 ///如果此getter的值发生更改，则必须调用[markNeedsCompositingBitsUpdate]。 （当调用[adoptChild]或[dropChild]时暗示这一点。） @protected bool get alwaysNeedsCompositing =&gt; false; ///此渲染对象用于重绘的合成图层。 ///仅在[isRepaintBoundary]为真且渲染对象已绘制时调用。 ///要在调试代码中访问该层，即使它可能不适合访问它（例如因为它是脏的），请考虑[debugLayer]。 OffsetLayer get layer &#123; assert(isRepaintBoundary, 'You can only access RenderObject.layer for render objects that are repaint boundaries.'); assert(!_needsPaint); return _layer; &#125; // 添加子项时设置为true bool _needsCompositingBitsUpdate = false; /// 将此渲染对象的合成状态标记为脏。 /// /// 这被调用以指示[needsCompositing]的值需要在下一个[flushCompositingBits]引擎阶段重新计算。 /// /// 当子树发生变异时，我们需要重新计算[needsCompositing]位，并且我们的一些祖先需要做同样的事情（如果我们的变化以某种方式改变它们的话）。 /// 为此，[adoptChild]和[dropChild]调用此方法，并且根据需要，此方法调用父类等，沿树向上移动以标记需要更新的所有节点。 /// /// 这个方法没有安排渲染帧(rendering frame)，因为不可能是_only_合成位发生了变化，其他东西也会为我们安排一个帧。 void markNeedsCompositingBitsUpdate() &#123; if (_needsCompositingBitsUpdate) return; _needsCompositingBitsUpdate = true; if (parent is RenderObject) &#123; final RenderObject parent = this.parent; if (parent._needsCompositingBitsUpdate) return; if (!isRepaintBoundary &amp;&amp; !parent.isRepaintBoundary) &#123; parent.markNeedsCompositingBitsUpdate(); return; &#125; &#125; assert(() &#123; final AbstractNode parent = this.parent; if (parent is RenderObject) return parent._needsCompositing; return true; &#125;()); // parent is fine (or there isn't one), but we are dirty if (owner != null) owner._nodesNeedingCompositingBitsUpdate.add(this); &#125; //在构造函数中初始化 bool _needsCompositing; /// 我们或我们的一个后代是否有合成层。 /// 如果此节点需要按此位指示进行合成，则所有祖先节点也需要合成。 /// 只有在调用[PipelineOwner.flushLayout]和[PipelineOwner.flushCompositingBits]后调用才合法。 bool get needsCompositing &#123; assert(!_needsCompositingBitsUpdate); // make sure we don't use this bit when it is dirty return _needsCompositing; &#125; void _updateCompositingBits() &#123; if (!_needsCompositingBitsUpdate) return; final bool oldNeedsCompositing = _needsCompositing; _needsCompositing = false; visitChildren((RenderObject child) &#123; child._updateCompositingBits(); if (child.needsCompositing) _needsCompositing = true; &#125;); if (isRepaintBoundary || alwaysNeedsCompositing) _needsCompositing = true; if (oldNeedsCompositing != _needsCompositing) markNeedsPaint(); _needsCompositingBitsUpdate = false; &#125; /// 将此渲染对象标记为已更改其视觉外观。 /// 我们不是急切地更新此渲染对象的显示列表以响应写入，而是将渲染对象标记为需要绘制，这会调度可视更新。 /// 作为可视更新的一部分，渲染管道将为此渲染对象提供更新其显示列表的机会。 /// 此机制批量绘制工作，以便合并多个顺序写入，从而消除冗余计算。 /// 一旦在渲染对象上调用了markNeedPaint()，debugNeedsPaint()就会为该渲染对象返回true，直到管道所有者在渲染对象上调用paint()之后。 /// /// 也可以看看： /// * [RepaintBoundary]，将渲染对象的子树范围限定到它们自己的层，从而限制[markNeedsPaint]必须标记为脏的节点数。 void markNeedsPaint() &#123; assert(owner == null || !owner.debugDoingPaint); if (_needsPaint) return; _needsPaint = true; if (isRepaintBoundary) &#123; assert(() &#123; if (debugPrintMarkNeedsPaintStacks) debugPrintStack(label: 'markNeedsPaint() called for $this'); return true; &#125;()); // 如果我们总是拥有自己的图层，那么我们可以在不涉及任何其他节点的情况下重新绘制自己。 assert(_layer != null); if (owner != null) &#123; owner._nodesNeedingPaint.add(this); owner.requestVisualUpdate(); &#125; &#125; else if (parent is RenderObject) &#123; // 我们没有自己的图层; 我们的一个祖先将负责更新我们所在的层，当他们这样做时，我们将调用我们的paint()方法。 assert(_layer == null); final RenderObject parent = this.parent; parent.markNeedsPaint(); assert(parent == this.parent); &#125; else &#123; assert(() &#123; if (debugPrintMarkNeedsPaintStacks) debugPrintStack(label: 'markNeedsPaint() called for $this (root of render tree)'); return true; &#125;()); //如果我们是渲染树的根（可能是RenderView），那么我们必须自己画画，因为没有其他人可以画我们。 // 在这种情况下，我们不会将自己添加到_nodesNeedingPaint，因为无论如何都始终告诉root绘制。 if (owner != null) owner.requestVisualUpdate(); &#125; &#125; //当flushPaint()试图让我们paint,但我们的图层被分离时调用。 //为了确保我们的子树在最终重新连接时重新绘制，即使在某些祖先层本身从未标记为脏的情况下，我们必须将整个分离的子树标记为脏并需要重新绘制。 这样，我们最终会被重新粉刷。 void _skippedPaintingOnLayer() &#123; assert(attached); assert(isRepaintBoundary); assert(_needsPaint); assert(_layer != null); assert(!_layer.attached); AbstractNode ancestor = parent; while (ancestor is RenderObject) &#123; final RenderObject node = ancestor; if (node.isRepaintBoundary) &#123; if (node._layer == null) break; // looks like the subtree here has never been painted. let it handle itself. if (node._layer.attached) break; // it's the one that detached us, so it's the one that will decide to repaint us. node._needsPaint = true; &#125; ancestor = node.parent; &#125; &#125; ///通过安排第一个绘制来引导渲染管道。 ///需要附加此渲染对象，是渲染树的根，并且具有合成图层。 ///有关如何使用此函数的示例，请参见[RenderView]。 void scheduleInitialPaint(ContainerLayer rootLayer) &#123; assert(rootLayer.attached); assert(attached); assert(parent is! RenderObject); assert(!owner._debugDoingPaint); assert(isRepaintBoundary); assert(_layer == null); _layer = rootLayer; assert(_needsPaint); owner._nodesNeedingPaint.add(this); &#125; ///替换图层。 这仅对渲染对象子树的根有效（无论对象[scheduleInitialPaint]是否被调用）。 ///如果例如设备像素比率发生变化，则可能会调用此方法。 void replaceRootLayer(OffsetLayer rootLayer) &#123; assert(rootLayer.attached); assert(attached); assert(parent is! RenderObject); assert(!owner._debugDoingPaint); assert(isRepaintBoundary); //第一次使用scheduleInitialPaint() assert(_layer != null); _layer.detach(); _layer = rootLayer; markNeedsPaint(); &#125; void _paintWithContext(PaintingContext context, Offset offset) &#123; assert(() &#123; if (_debugDoingThisPaint) &#123; throw FlutterError.fromParts(&lt;DiagnosticsNode&gt;[ ErrorSummary('Tried to paint a RenderObject reentrantly.'), describeForError( 'The following RenderObject was already being painted when it was ' 'painted again' ), ErrorDescription( 'Since this typically indicates an infinite recursion, it is ' 'disallowed.' ) ]); &#125; return true; &#125;()); // 如果我们仍然需要布局，那就意味着我们被跳过了 // 布局阶段，因此不需要绘画。 // 我们可能还不知道（也就是说，我们的图层可能还没有被分离），因为在布局中跳过我们的相同节点在树上（显然）在我们之上，因此可能没有机会绘制（ 因为树以相反的顺序绘制）。 // 特别是如果它们具有不同的层，则会发生这种情况，因为我们之间存在重新划分的边界。 if (_needsLayout) return; assert(() &#123; if (_needsCompositingBitsUpdate) &#123; throw FlutterError.fromParts(&lt;DiagnosticsNode&gt;[ ErrorSummary( 'Tried to paint a RenderObject before its compositing bits were ' 'updated.' ), describeForError( 'The following RenderObject was marked as having dirty compositing ' 'bits at the time that it was painted', ), ErrorDescription( 'A RenderObject that still has dirty compositing bits cannot be ' 'painted because this indicates that the tree has not yet been ' 'properly configured for creating the layer tree.' ), ErrorHint( 'This usually indicates an error in the Flutter framework itself.' ) ]); &#125; return true; &#125;()); RenderObject debugLastActivePaint; assert(() &#123; _debugDoingThisPaint = true; debugLastActivePaint = _debugActivePaint; _debugActivePaint = this; assert(!isRepaintBoundary || _layer != null); return true; &#125;()); _needsPaint = false; try &#123; paint(context, offset); assert(!_needsLayout); // check that the paint() method didn't mark us dirty again assert(!_needsPaint); // check that the paint() method didn't mark us dirty again &#125; catch (e, stack) &#123; _debugReportException('paint', e, stack); &#125; assert(() &#123; debugPaint(context, offset); _debugActivePaint = debugLastActivePaint; _debugDoingThisPaint = false; return true; &#125;()); &#125; /// 估计此渲染对象将绘制的边界。 /// 用于调试[debugPaintLayerBordersEnabled]等标志。 /// 这些也是[showOnScreen]用于在屏幕上显示[RenderObject]的边界。 Rect get paintBounds; ///重写此方法以绘制调试信息。 void debugPaint（PaintingContext context，Offset offset）&#123;&#125; /// 将此渲染对象绘制到给定偏移量的给定上下文中。 /// 子类应重写此方法以为其自身提供可视外观。 渲染对象的局部坐标系与上下文画布的坐标系轴对齐，渲染对象的本地原点（即x = 0和y = 0）放置在上下文画布中的给定偏移处。 /// 不要直接调用此函数。 如果您想自己画画，请调用[markNeedsPaint]来安排对此功能的调用。 如果你想绘制你的一个孩子，请在给定的`context`上调用[PaintingContext.paintChild]。 /// 在绘制一个孩子时（通过给定上下文中的paint子函数），上下文保持的当前画布可能会更改，因为绘制子项之前和之后的绘制操作可能需要记录在单独的合成图层上。 void paint（PaintingContext context，Offset offset）&#123;&#125; /// 应用将给定子绘制到给定矩阵时应用的变换。 /// 由坐标转换函数用于将一个渲染对象的局部坐标转换为另一个渲染对象的局部坐标。 void applyPaintTransform(covariant RenderObject child, Matrix4 transform) &#123; assert(child.parent == this); &#125; /// Applies the paint transform up the tree to `ancestor`. /// /// Returns a matrix that maps the local paint coordinate system to the /// coordinate system of `ancestor`. /// /// If `ancestor` is null, this method returns a matrix that maps from the /// local paint coordinate system to the coordinate system of the /// [PipelineOwner.rootNode]. For the render tree owner by the /// [RendererBinding] (i.e. for the main render tree displayed on the device) /// this means that this method maps to the global coordinate system in /// logical pixels. To get physical pixels, use [applyPaintTransform] from the /// [RenderView] to further transform the coordinate. Matrix4 getTransformTo(RenderObject ancestor) &#123; assert(attached); if (ancestor == null) &#123; final AbstractNode rootNode = owner.rootNode; if (rootNode is RenderObject) ancestor = rootNode; &#125; final List&lt;RenderObject&gt; renderers = &lt;RenderObject&gt;[]; for (RenderObject renderer = this; renderer != ancestor; renderer = renderer.parent) &#123; assert(renderer != null); // Failed to find ancestor in parent chain. renderers.add(renderer); &#125; final Matrix4 transform = Matrix4.identity(); for (int index = renderers.length - 1; index &gt; 0; index -= 1) &#123; renderers[index].applyPaintTransform(renderers[index - 1], transform); &#125; return transform; &#125; // ======== 语义 SEMANTICS ======== 跳过，参考：https://www.jianshu.com/p/8e547f5a12ce // ======== 事件 EVENTS ======== /// 重写此方法以处理命中此渲染对象的指针事件。 @override void handleEvent(PointerEvent event, covariant HitTestEntry entry) &#123; &#125; // ======== 命中测试 HIT TESTING - Diagnostic 诊断 ======== // 期望RenderObject子类具有如下方法（签名是此特定类的坐标的任何传递）： // // bool hitTest（HitTestResult result，&#123;Offset position&#125;）&#123; // // 如果给定位置不在此节点内，则返回false。 // // 除此以外： // // 对于每个与位置相交的子项，从顶部开始按z顺序，为该子项调用hitTest（），传递/ result /，并将坐标转换为子坐标原点，并在第一个返回true的孩子停止 。 // // 然后，将自己添加到/ result /，并返回true。 // &#125; // // 如果您将自己添加到/ result /并仍然返回false，那么这意味着您将看到事件，但您下方的对象也将如此。 /// 尝试在屏幕上显示此部分或后代[RenderObject]（的一部分）。 /// /// 如果提供了`descendant`，则[RenderObject]可见。 如果省略`descendant`，则使[RenderObject]可见。 /// 可选的`rect`参数描述了应该在屏幕上显示[RenderObject]的哪个区域。 如果`rect`为null，则将显示整个[RenderObject]（由其[paintBounds]定义）。 如果提供了该参数，则相对于`descendant`的坐标系解释`rect`参数，否则相对于此[RenderObject]。 /// /// 可以将`duration`参数设置为非零值，使目标对象在由'curve`定义的动画中显示在屏幕上。 void showOnScreen(&#123; RenderObject descendant, Rect rect, Duration duration = Duration.zero, Curve curve = Curves.ease, &#125;) &#123; if (parent is RenderObject) &#123; final RenderObject renderParent = parent; renderParent.showOnScreen( descendant: descendant ?? this, rect: rect, duration: duration, curve: curve, ); &#125; &#125;&#125; 断言调试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// ======== 布局 LAYOUT ========///此渲染对象的[performResize]当前是否正在运行。 ///仅在启用断言时有效，在发布版本中，始终返回falsebool get debugDoingThisResize =&gt; _debugDoingThisResize;bool _debugDoingThisResize = false;///此渲染对象的[performLayout]当前是否正在运行。 ///仅在启用断言时有效，在发布版本中，始终返回false。bool get debugDoingThisLayout =&gt; _debugDoingThisLayout;bool _debugDoingThisLayout = false;///正在积极计算布局的渲染对象。 /// 仅在启用断言时有效。 在发布版本中，始终返回null。static RenderObject get debugActiveLayout =&gt; _debugActiveLayout;static RenderObject _debugActiveLayout;///是否允许父渲染对象使用此渲染对象的大小。 ///由`parentUsesSize`参数确定为[layout]。 ///仅在启用断言时有效。 在发布版本中，始终返回null。bool get debugCanParentUseSize =&gt; _debugCanParentUseSize;bool _debugCanParentUseSize;///调试突变锁定bool _debugMutationsLocked = false;///渲染对象的布局信息是否脏。 ///仅在调试模式下设置。 通常，渲染对象不应该根据它们是否脏而来调整它们的运行时行为，因为它们只应在布局和绘制之前立即标记为脏。 ///它旨在供测试和断言使用。bool get debugNeedsLayout &#123; bool result; assert(() &#123; result = _needsLayout; return true; &#125;()); return result;&#125;///验证是否满足对象的约束。 在子类中重写此函数以验证您的状态是否与约束对象匹配。 ///此函数仅在checked模式下调用，且仅在needsLayout为false时调用。 如果不满足约束，则应断言或抛出异常。@protectedvoid debugAssertDoesMeetConstraints();///如果为true，则debugAssertDoesMeetConstraints（）当前正在执行断言以验证内部维度方法的一致行为。 ///这应该只由debugAssertDoesMeetConstraints（）实现设置。 测试使用它来有选择地忽略自定义布局回调。 它不应该在debugAssertDoesMeetConstraints（）之外设置，也不应该在发布模式下检查（它始终为false）。static bool debugCheckingIntrinsics = false;bool _debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout() &#123; if (_relayoutBoundary == null) return true; // we haven't yet done layout even once, so there's nothing for us to do RenderObject node = this; while (node != _relayoutBoundary) &#123; assert(node._relayoutBoundary == _relayoutBoundary); assert(node.parent != null); node = node.parent; if ((!node._needsLayout) &amp;&amp; (!node._debugDoingThisLayout)) return false; &#125; assert(node._relayoutBoundary == node); return true;&#125;// ======== 绘制 PAINTING ======== /// Whether [paint] for this render object is currently running.///此渲染对象的[paint]当前是否正在运行。 ///仅在启用断言时有效。 在发布版本中，始终返回false。bool get debugDoingThisPaint =&gt; _debugDoingThisPaint;bool _debugDoingThisPaint = false;///正在绘制的渲染对象。 ///仅在启用断言时有效。 在发布版本中，始终返回null。 static RenderObject get debugActivePaint =&gt; _debugActivePaint; static RenderObject _debugActivePaint;///在调试模式下，此渲染对象用于重绘的合成图层。 ///此getter仅用于调试目的。 在发布版本中，它始终返回null。 在调试版本中，即使图层是脏的，它也会返回图层。 ///对于生产代码，请考虑[layer]。OffsetLayer get debugLayer &#123; OffsetLayer result; assert(() &#123; result = _layer; return true; &#125;()); return result;&#125;///渲染对象的绘制信息是否脏。 ///仅在调试模式下设置。 通常，渲染对象不应该根据它们是否脏而来调整它们的运行时行为，因为它们只应在布局和绘制之前立即标记为脏。 ///它旨在供测试和断言使用。 /// [debugNeedsPaint]可能（实际上很常见）为false，[debugNeedsLayout]为true。 在这种情况下，渲染对象仍将在下一帧中重新绘制，因为在绘制渲染对象之后，在绘制阶段之前，框架会隐式调用[markNeedsPaint]方法。bool get debugNeedsPaint &#123; bool result; assert(() &#123; result = _needsPaint; return true; &#125;()); return result;&#125;bool _needsPaint = true;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-渲染相关2]]></title>
    <url>%2FFlutter-%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B32%2F</url>
    <content type="text"><![CDATA[Flutter-渲染相关2 HitTestTarget12345678/// 一个可以处理事件的对象。abstract class HitTestTarget &#123; //此类旨在用作implements关键字的接口，不应直接扩展。 factory HitTestTarget._() =&gt; null; ///重写此方法以接收事件。 void handleEvent(PointerEvent event, HitTestEntry entry);&#125; AbstractNode概览树 中的 抽象节点。 AbstractNode 中有 深度(depth)，附件(attachment)和父级(parent)的概念，但没有儿童模型(a model for children)。 父级(parent)当一个子类改变一个子类的父类(parent of a child)时，它应该适当地调用parent.adoptChild（child）或parent.dropChild（child）。 如果需要，子类可以公开用于操作树的API（例如，用于child属性的setter，或用于操作列表的add()方法）。 当前父节点 由 parent属性 对外暴露。 附件(attachment)附件(attachment) 显示当前 附件状态。应该通过调用 attach() 手动附加要考虑附加的任何树的根。除此之外，不应直接调用 attach()和 detach()，附件(attachment) 由上述 adoptChild() 和 dropChild() 自动管理。 具有 子节点(children) 的 子类 必须覆盖 attach() 和 detach()。 深度(depth)节点(node) 的 深度(depth) 总是比他们的祖先更大。但是兄弟姐妹之间的深度无法保证。节点的深度 用于确保：按 深度顺序处理节点。 一个child的深度可以比父亲的深度大1个以上，因为：深度值永远不会减少，重要的是它比父亲更大。 考虑具有根节点A，子B和孙子C的树。最初，A将具有[深度] 0，B [深度] 1和C [深度] 2。如果C被移动为A的child，B的兄弟，那么数字不会改变。 C的[深度]仍为2. [depth]由[adoptChild]和[dropChild]方法自动维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class AbstractNode &#123; int get depth =&gt; _depth; int _depth = 0; ///将给定[child]的[depth]调整为大于此节点自己的[depth]。 ///只能从[redepthChildren]的覆盖中调用此方法。 @protected void redepthChild(AbstractNode child) &#123; assert(child.owner == owner); if (child._depth &lt;= _depth) &#123; child._depth = _depth + 1; child.redepthChildren(); &#125; &#125; ///调整此节点的子节点的[深度]（如果有）。 ///在具有子节点的子类中重写此方法，为每个子节点调用[redepthChild]。 不要直接调用此方法。 void redepthChildren() &#123; &#125; ///此节点的所有者（如果未附加，则为null）。 ///此节点所属的整个子树将具有相同的所有者。 Object get owner =&gt; _owner; Object _owner; /// 此节点是否位于其根连接到某个树的树中。 /// 在调用[attach]期间，这变为true。 /// 在调用[detach]期间，这会变为false。 bool get attached =&gt; _owner != null; /// 将此节点标记为附加到给定所有者。 /// 通常仅从[parent]的[attach]方法调用，并由[owner]标记为附加的树的根。 /// 带子项的子类应重写此方法，以首先调用其继承的[attach]方法，然后将所有子项[attach]连接到同一[owner]。 @mustCallSuper void attach(covariant Object owner) &#123; assert(owner != null); assert(_owner == null); _owner = owner; &#125; ///将此节点标记为已分离。 ///通常仅从[parent]的[detach]和[owner]中调用，以将树的根标记为已分离。 ///带子节点的子类应该重写此方法，首先调用它们的继承[detach]方法，然后[分离]所有子节点。 @mustCallSuper void detach() &#123; assert(_owner != null); _owner = null; assert(parent == null || attached == parent.attached); &#125; ///树中此节点的父节点。 AbstractNode get parent =&gt; _parent; AbstractNode _parent; ///将给定节点标记为此节点的子节点。 /// ///子类在获取新child时应调用此函数。 @protected @mustCallSuper void adoptChild(covariant AbstractNode child) &#123; assert(child != null); assert(child._parent == null); assert(() &#123; AbstractNode node = this; while (node.parent != null) node = node.parent; //表示即将创建一个循环 assert(node != child); return true; &#125;()); child._parent = this; if (attached) child.attach(_owner); redepthChild(child); &#125; ///从此节点断开给定节点。 ///子类在失去孩子时应调用此函数。 @protected @mustCallSuper void dropChild(covariant AbstractNode child) &#123; assert(child != null); assert(child._parent == this); assert(child.attached == attached); child._parent = null; if (attached) child.detach(); &#125;&#125; RenderObject概览RenderObject释义RenderObject是渲染树 中的 对象。 [RenderObject]类层次结构 是呈现库(rendering library)存在的核心。[RenderObject]有一个[parent]，并有一个名为[parentData]的槽(slot)，其中父[RenderObject]可以存储子特定的数据，例如子位置。 [RenderObject]类还实现了 基本布局(basic layout) 和 绘制协议(paint protocols) 。 然而，[RenderObject]类没有定义子模型（例如，节点是否有零个，一个或多个子节点）。它也没有定义坐标系（例如，孩子是否位于笛卡尔坐标，极坐标等）或特定的布局协议（例如布局是否是高度宽，或大小约束-out，或者父母是否在孩子放置之前或之后设置孩子的大小和位置等;或者实际上是否允许孩子读取他们父母的[parentData]插槽）。但是 [RenderBox]子类 引入了 布局系统 —— 笛卡尔坐标 的观点。 编写RenderObject子类在大多数情况下，[RenderObject]子类本身是过度的，而 [RenderBox](2D笛卡尔坐标系中的渲染对象，其继承自：RenderObject) 将是一个更好 的起点(定义了笛卡尔坐标系)。但是，如果渲染对象不想使用笛卡尔坐标系，那么直接从[RenderObject]继承即可。这允许它通过使用[Constraints]的新子类而不是使用 [BoxConstraints]([RenderBox]布局的不可变布局约束，其继承自：Constraints) 来定义自己的布局协议，并且可能使用一组全新的对象和值来表示输出的结果而不仅仅是[Size] ]。 这种增加的灵活性是以 不能依赖[RenderBox] 的功能为代价的。例如，[RenderBox]实现了一个内在的大小调整协议，允许您在不完全布局的情况下测量子项，这样如果该 子项改变大小，父项将再次布局（考虑新的维度）的孩子）。这是一个微妙且容易出错的功能。 编写 [RenderBox]的大多数方面 也适用于编写[RenderObject]，因此[RenderBox]的讨论是推荐的背景阅读。主要区别在于 布局 和 命中测试，因为这些是 [RenderBox]主要专注的方面。 布局(layout)布局协议以[Constraints]的子类开始的。有关如何编写[Constraints]子类的更多信息，请参见[Constraints]文档描述。 performLayout() 应该采用[constraints]，然后应用它们。布局算法的输出是在对象上设置的字段，用于描述父对象布局的对象几何。例如，使用[RenderBox]，输出是[RenderBox.size]字段。如果父项在子项上调用 layout() 时指定parentUsesSize为true，则只应由父项读取此输出。 任何时候 渲染对象 上的 任何变化 会 影响该对象 的 布局，它应该调用 markNeedsLayout()。 命中测试(Hit Testing)命中测试比布局更开放。没有方法可以覆盖，您需要提供一个方法。命中测试方法的一般行为应与[RenderBox]描述的行为类似。主要区别在于输入不必是[Offset]。在向[HitTestResult]添加条目时，还允许您使用[HitTestEntry]的不同子类。当调用[handleEvent]方法时，将传入添加到[HitTestResult]的相同对象，因此它可用于跟踪命中的精确坐标等信息，无论新的坐标系使用何种坐标系。布局协议。 适应从一种协议到另一种协议通常，Flutter渲染对象树 的 根(root) 是 RenderView。该对象具有 单个子对象，该子对象 必须是 RenderBox。因此，如果您想在渲染树中拥有自定义RenderObject子类，有两个选择： 需要替换 RenderView 本身; 需要一个自定义类作为 其子级的RenderBox。（更常见的情况。） 这个 RenderBox子类 从 框协议 转换为 类协议。 特别是，这意味着对于 命中测试，它会覆盖 RenderBox.hitTest()，并调用类中的任何方法进行命中测试。 同样，它会覆盖 performLayout() 以创建适合你的类的 Constraints对象，并将其传递给 child的layout()方法。 渲染对象之间的布局交互通常，渲染对象 的 布局 应仅取决于其 子布局的输出，并且只有在 layout() 调用中将 parentUsesSize设置为 true 时才应如此。此外，如果将其设置为true，则父项 必须 在要渲染 子项 时调用 子项的layout()，否则在子项更改其布局输出时将不会通知父项。 可以设置 传输附加信息 的 渲染对象协议。例如，在 RenderBox 协议中，您可以查询 children 的内在尺寸和基线几何。但是，如果这样做，那么如果 parent 在 最后一个布局阶段 使用它，则 Child 必须在 parent 的任何时候调用markNeedsLayout。有关如何实现此操作的示例，请参阅[RenderBox.markNeedsLayout]方法。它会覆盖[RenderObject.markNeedsLayout]，这样如果父级查询了内部或基线信息，则只要子级的几何体发生更改，它就会被标记为脏。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-渲染相关1]]></title>
    <url>%2FFlutter-%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B31%2F</url>
    <content type="text"><![CDATA[Flutter-渲染相关1 RenderObject渲染树中的对象。 RenderObject类层次结构是渲染库的核心。RenderObjects有一个父级（树中此节点的父节点。），并有一个名为parentData（父渲染对象使用的数据。）的槽，其中父RenderObject可以存储子级特定的数据，例如子位置。RenderObject类还实现了基本布局和绘制协议。 但是，RenderObject类不定义子模型（例如，节点是否具有零个，一个或多个子节点）。它也没有定义坐标系（例如，儿童是否位于笛卡尔坐标，极坐标等）或特定的布局协议（如：布局是否为高度宽，或大小限制，或者父级是否在子布局之前或之后设置子级的大小和位置，实际上是否允许孩子读取他们的父数据槽）。 RenderBox子类引入了布局系统使用笛卡尔坐标的观点。 ParentData父类与[RenderObject]关联的数据的基类。一些渲染对象希望将数据存储在其子节点上，例如它们对父节点布局算法的输入参数或它们相对于其他子节点的位置。 123456789class ParentData &#123; /// Called when the RenderObject is removed from the tree. @protected @mustCallSuper void detach() &#123; &#125; @override String toString() =&gt; '&lt;none&gt;';&#125; PaintingContext一个画画的地方 [RenderObject]使用绘画上下文(painting context)绘画，而不是直接使用画布。 绘制上下文(painting context)有一个[Canvas]，它接收 单独 的绘制操作，还具有 绘制子渲染对象 的功能。 在绘制子渲染对象时，绘制上下文(painting context)保持的画布可以更改，因为绘制子项 之前 和 之后 发出的 绘制操作 可能会记录在 **单独**的合成图层 中。 因此，不要在可能绘制子渲染对象的操作之间保持对画布的引用。 使用PaintingContext.repaintCompositedChild和[pushLayer]时会自动创建新的[PaintingContext]对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253class PaintingContext extends ClipContext &#123; ///创建绘画上下文。 ///通常只由[PaintingContext.repaintCompositedChild]和[pushLayer]调用。 @protected PaintingContext(this._containerLayer, this.estimatedBounds) : assert(_containerLayer != null), assert(estimatedBounds != null); final ContainerLayer _containerLayer; final Rect estimatedBounds; /// 重绘给定的渲染对象 /// 渲染对象必须附加到[PipelineOwner]，必须具有合成图层(composited layer)，并且必须需要绘制。 渲染对象的图层（如果有）将被重复使用，以及子树中不需要重新绘制的任何图层。 /// 另请参阅：* [RenderObject.isRepaintBoundary]，它确定[RenderObject]是否具有合成图层。 static void repaintCompositedChild(RenderObject child, &#123; bool debugAlsoPaintedParent = false &#125;) &#123; assert(child._needsPaint); _repaintCompositedChild( child, debugAlsoPaintedParent: debugAlsoPaintedParent, ); &#125; static void _repaintCompositedChild( RenderObject child, &#123; bool debugAlsoPaintedParent = false, PaintingContext childContext, &#125;) &#123; …… childContext ??= PaintingContext(child._layer, child.paintBounds); child._paintWithContext(childContext, Offset.zero); childContext.stopRecordingIfNeeded(); &#125; void _paintWithContext(PaintingContext context, Offset offset) &#123; RenderObject debugLastActivePaint; assert(() &#123; _debugDoingThisPaint = true; debugLastActivePaint = _debugActivePaint; _debugActivePaint = this; assert(!isRepaintBoundary || _layer != null); return true; &#125;()); _needsPaint = false; try &#123; paint(context, offset); assert(!_needsLayout); // 检查paint（）方法是否再次标记为脏 assert(!_needsPaint); // 检查paint（）方法是否再次标记为脏 &#125; catch (e, stack) &#123; _debugReportException('paint', e, stack); &#125; assert(() &#123; debugPaint(context, offset); _debugActivePaint = debugLastActivePaint; _debugDoingThisPaint = false; return true; &#125;()); &#125; ///绘制子项[RenderObject]。 ///如果子项具有自己的合成图层，则子项将合成到与此绘制上下文关联的图层子树中。 否则，将为此上下文将子绘制到当前 void paintChild(RenderObject child, Offset offset) &#123; …… if (child.isRepaintBoundary) &#123; // 方法1：停止记录 stopRecordingIfNeeded(); // 方法1：合成子对象 _compositeChild(child, offset); &#125; else &#123; child._paintWithContext(this, offset); &#125; …… &#125; ///如果录制已开始，则停止录制到画布。 ///不要直接调用此函数：此类中的函数将根据需要调用此方法。 内部调用此函数以确保在添加图层或完成绘制结果之前停止记录。 ///需要自定义如何执行对画布的录制的子类应覆盖此方法以保存自定义画布录制的结果。 @protected @mustCallSuper void stopRecordingIfNeeded() &#123; if (!_isRecording) return; assert(() &#123; if (debugRepaintRainbowEnabled) &#123; final Paint paint = Paint() ..style = PaintingStyle.stroke ..strokeWidth = 6.0 ..color = debugCurrentRepaintColor.toColor(); canvas.drawRect(estimatedBounds.deflate(3.0), paint); &#125; if (debugPaintLayerBordersEnabled) &#123; final Paint paint = Paint() ..style = PaintingStyle.stroke ..strokeWidth = 1.0 ..color = const Color(0xFFFF9800); canvas.drawRect(estimatedBounds, paint); &#125; return true; &#125;()); _currentLayer.picture = _recorder.endRecording(); _currentLayer = null; _recorder = null; _canvas = null; &#125; void _compositeChild(RenderObject child, Offset offset) &#123; assert(!_isRecording); assert(child.isRepaintBoundary); //返回保存堆栈上的项目数，包括初始状态。 这意味着它为一个干净的画布返回1，并且每次调用[save]和[saveLayer]都会增加它，并且对[restore]的每个匹配调用都会减少它。 //这个数字不能低于1。 assert(_canvas == null || _canvas.getSaveCount() == 1); //为我们的孩子创建一个图层，并将孩子绘制到其中。 if (child._needsPaint) &#123; repaintCompositedChild(child, debugAlsoPaintedParent: true); &#125; else &#123; assert(child._layer != null); assert(() &#123; //注册RepaintBoundary指标的调用 child.debugRegisterRepaintBoundaryPaint( includedParent: true, includedChild: false, ); child._layer.debugCreator = child.debugCreator ?? child; return true; &#125;()); &#125; assert(child._layer != null); child._layer.offset = offset; appendLayer(child._layer); &#125; ///在记录中添加一个图层，要求记录已经停止。 ///不要直接调用此函数：改为调用[addLayer]或[pushLayer]。 当添加未从[canvas]生成的所有图层时，将在内部调用此函数。 ///需要自定义图层添加方式的子类应覆盖此方法。 @protected void appendLayer(Layer layer) &#123; assert(!_isRecording); layer.remove(); // 添加至Layer _containerLayer.append(layer); &#125; ///要绘制的画布。 ///使用此上下文绘制子项时，当前画布可能会更改，这意味着保持对此getter返回的画布的引用很脆弱。 @override Canvas get canvas &#123; if (_canvas == null) _startRecording(); return _canvas; &#125; void _startRecording() &#123; assert(!_isRecording); _currentLayer = PictureLayer(estimatedBounds); _recorder = ui.PictureRecorder(); _canvas = Canvas(_recorder); _containerLayer.append(_currentLayer); &#125; ///将合成的叶子图层添加到录制内容中。 ///调用此函数后，[canvas]属性将更改为引用在给定图层之上绘制的新[Canvas]。 ///使用此函数的[RenderObject]很可能要求其[RenderObject.alwaysNeedsCompositing]属性返回true。 通知祖先渲染对象，此渲染对象将包含合成图层，例如，这会使它们使用合成剪辑。 /// 也可以看看： /// * [pushLayer]，用于添加图层并使用其画布绘制该图层。 void addLayer(Layer layer) &#123; stopRecordingIfNeeded(); appendLayer(layer); &#125; ///将给定图层附加到录制内容，并使用该图层调用`painter`回调，将`childPaintBounds`作为子画面的估计绘制范围。 `childPaintBounds`可以用于调试，但对绘画没有影响。 ///给定的图层必须是一个未连接的孤儿。 （提供新创建的对象，而不是重用现有层，满足该要求。） ///“offset”是传递给`painter`的偏移量。 ///如果未指定`childPaintBounds`，则使用当前图层的绘制边界。 如果子图层不对其内容应用任何变换或剪裁，则这是合适的。 如果指定，`childPaintBounds`必须位于新图层的坐标系中，并且不应超出当前图层的绘图边界。 /// 也可以看看： /// * [addLayer]，用于推送未使用画布的叶子图层。 void pushLayer(ContainerLayer childLayer, PaintingContextCallback painter, Offset offset, &#123; Rect childPaintBounds &#125;) &#123; assert(!childLayer.attached); assert(childLayer.parent == null); assert(painter != null); stopRecordingIfNeeded(); appendLayer(childLayer); final PaintingContext childContext = createChildContext(childLayer, childPaintBounds ?? estimatedBounds); painter(childContext, offset); childContext.stopRecordingIfNeeded(); &#125; ///使用矩形剪辑进一步绘画。 /// *`needsCompositing`是孩子是否需要合成。 通常匹配调用者的[RenderObject.needsCompositing]值。 /// *`offset`是从画布坐标系原点到调用者坐标系原点的偏移量。 /// *`clipRect`是矩形（在调用者的坐标系中），用于剪切[painter]完成的绘画。 /// *`painter`是一个回调，它将在应用[clipRect]时绘制。 此函数同步调用[painter]。 /// *`clipBehavior`控制矩形的剪裁方式。 void pushClipRect(bool needsCompositing, Offset offset, Rect clipRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.hardEdge &#125;) &#123; final Rect offsetClipRect = clipRect.shift(offset); if (needsCompositing) &#123; pushLayer(ClipRectLayer(clipRect: offsetClipRect, clipBehavior: clipBehavior), painter, offset, childPaintBounds: offsetClipRect); &#125; else &#123; clipRectAndPaint(offsetClipRect, clipBehavior, offsetClipRect, () =&gt; painter(this, offset)); &#125; &#125; void pushClipRRect()&#123;&#125; void pushClipPath()&#123;&#125; void pushColorFilter()&#123;&#125; ///使用矩阵转换进一步绘画。 /// *`needsCompositing`是孩子是否需要合成。 通常匹配调用者的[RenderObject.needsCompositing]值。 /// *`offset`是从画布坐标系原点到调用者坐标系原点的偏移量。 /// *`transform`是应用于`painter`完成的绘画的矩阵。 /// *`painter`是一个回调，它将使用`transform`进行绘制。 这个函数同步调用`painter`。 void pushTransform(bool needsCompositing, Offset offset, Matrix4 transform, PaintingContextCallback painter) &#123; final Matrix4 effectiveTransform = Matrix4.translationValues(offset.dx, offset.dy, 0.0) ..multiply(transform)..translate(-offset.dx, -offset.dy); if (needsCompositing) &#123; pushLayer( TransformLayer(transform: effectiveTransform), painter, offset, childPaintBounds: MatrixUtils.inverseTransformRect(effectiveTransform, estimatedBounds), ); &#125; else &#123; canvas ..save() ..transform(effectiveTransform.storage); painter(this, offset); canvas ..restore(); &#125; &#125; ///使用alpha值混合进一步绘画。 /// *`offset`是从画布坐标系原点到调用者坐标系原点的偏移量。 /// *`alpha`是混合由`painter`完成的绘画时使用的alpha值。 alpha值为0表示绘画完全透明，alpha值为255表示绘画完全不透明。 /// *`painter`是一个回调，它将使用`alpha`绘制。 这个函数同步调用`painter`。 ///使用此函数的[RenderObject]很可能需要它 /// [RenderObject.alwaysNeedsCompositing]属性返回true。 通知祖先渲染对象，此渲染对象将包含合成图层，例如，这会使它们使用合成剪辑。 void pushOpacity(Offset offset, int alpha, PaintingContextCallback painter) &#123; pushLayer(OpacityLayer(alpha: alpha, offset: offset), painter, Offset.zero); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445///重写此方法以绘制调试信息。 void debugPaint(PaintingContext context, Offset offset) &#123;&#125; ///将此渲染对象绘制到给定偏移量的给定上下文中。 ///子类应重写此方法以为其自身提供可视外观。 渲染对象的局部坐标系与上下文画布的坐标系轴对齐，渲染对象的本地原点（即x = 0和y = 0）放置在上下文画布中的给定偏移处。 ///不要直接调用此函数。 如果您想自己画画，请调用[markNeedsPaint]来安排对此功能的调用。 如果你想绘制你的一个孩子，请在给定的`context`上调用[PaintingContext.paintChild]。 ///在绘制一个孩子时（通过给定上下文中的paint子函数），上下文保持的当前画布可能会更改，因为绘制子项之前和之后的绘制操作可能需要记录在单独的合成图层上。 void paint（PaintingContext context，Offset offset）&#123;&#125; ///应用将给定子绘制到给定矩阵时应用的变换。 ///由坐标转换函数用于将一个渲染对象的局部坐标转换为另一个渲染对象的局部坐标。 void applyPaintTransform(covariant RenderObject child, Matrix4 transform) &#123; assert(child.parent == this); &#125; ///如果录制已开始，则停止录制到画布。 ///不要直接调用此函数：此类中的函数将根据需要调用此方法。 内部调用此函数以确保在添加图层或完成绘制结果之前停止记录 ///需要自定义如何执行对画布的录制的子类应覆盖此方法以保存自定义画布录制的结果。 @protected @mustCallSuper void stopRecordingIfNeeded() &#123; if (!_isRecording) return; assert(() &#123; if (debugRepaintRainbowEnabled) &#123; final Paint paint = Paint() ..style = PaintingStyle.stroke ..strokeWidth = 6.0 ..color = debugCurrentRepaintColor.toColor(); canvas.drawRect(estimatedBounds.deflate(3.0), paint); &#125; if (debugPaintLayerBordersEnabled) &#123; final Paint paint = Paint() ..style = PaintingStyle.stroke ..strokeWidth = 1.0 ..color = const Color(0xFFFF9800); canvas.drawRect(estimatedBounds, paint); &#125; return true; &#125;()); _currentLayer.picture = _recorder.endRecording(); _currentLayer = null; _recorder = null; _canvas = null; &#125; Constraints一组抽象的布局约束。具体布局模型（如框）将创建具体的子类，以传达父项和子项之间的布局约束。 ##编写一个Constraints子类当使用新的布局协议创建新的[RenderObject]子类时，通常需要创建一个新的[Constraints]子类来表示布局算法的输入。 [Constraints]子类应该是不可变的（所有字段都是final）。除了可以找到对特定布局协议有用的任何字段，构造函数和帮助器方法之外，还有几个要实现的成员： [isTight] getter，如果对象表示[RenderObject]类没有选择如何自己放置的情况，则应该返回true。例如，当最小和最大宽度以及最小和最大高度相等时，[BoxConstraints]为[isTight]返回true。 [isNormalized] getter，如果对象以其规范形式表示其数据，则应返回true。有时，字段可能彼此冗余，因此几个不同的表示具有相同的含义。例如，最小宽度大于最大宽度的[BoxConstraints]实例等于最大宽度设置为最小宽度的实例（2 &lt;w &lt;1相当于2 &lt;w &lt;2，因为最小约束具有优先权）。这个getter由[debugAssertIsValid]的默认实现使用。 [debugAssertIsValid]方法，如果约束对象有任何问题，应该断言。 （我们使用这种方法而不是在构造函数中断言，以便我们的构造函数可以是const，因此可以在构建有效约束时临时创建无效约束。）请参阅[BoxConstraints.debugAssertIsValid]的实现，以获取示例。可以进行的详细检查。 [==]运算符和[hashCode] getter，以便可以比较约束的相等性。如果渲染对象具有相等的约束，则渲染库将避免在不脏的情况下再次放置对象。 [toString]方法，它应该描述约束，以便它们在[debugDumpRenderTree]的输出中以有用的可读形式出现。 12345678910111213141516171819@immutableabstract class Constraints &#123; ///抽象const构造函数。 此构造函数使子类能够提供const构造函数，以便它们可以在const表达式中使用。 const Constraints(); ///给定这些约束条件是否只有一种尺寸可能 bool get isTight; ///约束是否以一致的方式表达。 bool get isNormalized; bool debugAssertIsValid(&#123; bool isAppliedConstraint = false, InformationCollector informationCollector, &#125;) &#123; assert(isNormalized); return isNormalized; &#125;&#125; 123///为每个[RenderObject]调用的函数的签名。///由[RenderObject.visitChildren]和[RenderObject.visitChildrenForSemantics]使用。typedef RenderObjectVisitor = void Function（RenderObject child）; 123///在布局期间调用的函数的签名。///由[RenderObject.invokeLayoutCallback]使用。typedef LayoutCallback &lt;T extends Constraints&gt; = void Function（T constraints）; SemanticsHandle对语义树的引用。框架仅在至少有一个客户端持有open [SemanticsHandle]时才维护语义树（用于可访问性和索引）。框架通过调用[listener]回调来通知客户端它已更新了语义树。当客户端不再需要语义树时，客户端可以在[SemanticsHandle]上调用[dispose]，这会停止这些回调并关闭[SemanticsHandle]。当所有未完成的[SemanticsHandle]对象都关闭时，框架将停止更新语义树。要获得[SemanticsHandle]，请在[PipelineOwner]上为要从中读取语义的渲染树调用[PipelineOwner.ensureSemantics]。您可以使用[RenderObject.owner]属性获取[PipelineOwner]。 12345678910111213141516171819202122232425262728293031323334353637class SemanticsHandle &#123; SemanticsHandle._(this._owner, this.listener) : assert(_owner != null) &#123; if (listener != null) _owner.semanticsOwner.addListener(listener); &#125; PipelineOwner _owner; /// The callback that will be notified when the semantics tree updates. final VoidCallback listener; /// Closes the semantics handle and stops calling [listener] when the /// semantics updates. /// /// When all the outstanding [SemanticsHandle] objects for a given /// [PipelineOwner] are closed, the [PipelineOwner] will stop updating the /// semantics tree. @mustCallSuper void dispose() &#123; assert(() &#123; if (_owner == null) &#123; throw FlutterError( 'SemanticsHandle has already been disposed.\n' 'Each SemanticsHandle should be disposed exactly once.' ); &#125; return true; &#125;()); if (_owner != null) &#123; if (listener != null) _owner.semanticsOwner.removeListener(listener); _owner._didDisposeSemanticsHandle(); _owner = null; &#125; &#125;&#125; PipelineOwner管道所有者 管理 渲染管道(rendering pipeline)。管道所有者 提供了一个界面，用于驱动 渲染管道，并在管道的每个阶段 存储 渲染对象请求访问的状态。要刷新管道，请调用以下命令，按顺序运行： [flushLayout]更新需要计算其布局的任何渲染对象。在此阶段期间，计算每个渲染对象的大小和位置。在此阶段，渲染对象可能会弄脏(dirty)其绘画或合成状态(compositing state)。 [flushCompositingBits]更新具有 脏合成位(dirty compositing bits) 的任何渲染对象。在此阶段，每个渲染对象都会了解其子项是否需要合成。在绘制阶段使用此信息时，选择如何实现剪裁等视觉效果。如果渲染对象具有合成子对象，则需要使用[图层]创建剪辑，以便将剪辑应用于合成子对象（将其绘制到自己的[图层]中）。 [flushPaint]访问需要绘制的任何渲染对象。在此阶段，渲染对象有机会将绘制命令记录到[PictureLayer]并构建其他合成的[Layer]。 最后，如果启用了语义，[flushSemantics]将编译渲染对象的语义。辅助技术使用该语义信息来改进渲染树的可访问性。 [RendererBinding] 保存 屏幕上可见 的渲染对象的管道所有者。您可以创建其他管道所有者来管理屏幕外对象，这些对象可以独立于屏幕渲染对象刷新其管道。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240class PipelineOwner &#123; ///创建管道所有者。 ///通常由绑定创建（例如，[RendererBinding]），但可以与绑定分开创建，以通过渲染管道驱动屏幕外渲染对象。 PipelineOwner(&#123; this.onNeedVisualUpdate, this.onSemanticsOwnerCreated, this.onSemanticsOwnerDisposed, &#125;); ///与此管道所有者关联的渲染对象希望更新其视觉外观时调用。 ///此函数的典型实现将调度任务以刷新管道的各个阶段。 可以快速连续多次调用此函数。 实现应该注意快速丢弃重复的调用。 final VoidCallback onNeedVisualUpdate; ///每当此管道所有者创建语义对象时调用。 ///典型的实现将安排创建初始语义树。 final VoidCallback onSemanticsOwnerCreated; ///每当此管道所有者处置其语义所有者时调用。 ///典型的实现将拆除语义树。 final VoidCallback onSemanticsOwnerDisposed; ///如果[onNeedVisualUpdate]不为null，则调用[onNeedVisualUpdate]。 ///用于通知管道所有者关联的渲染对象希望更新其视觉外观。 void requestVisualUpdate() &#123; if (onNeedVisualUpdate != null) onNeedVisualUpdate(); &#125; ///由此管道管理的唯一对象没有父对象。 ///此对象不必是[RenderObject]。 AbstractNode get rootNode =&gt; _rootNode; AbstractNode _rootNode; set rootNode(AbstractNode value) &#123; if (_rootNode == value) return; _rootNode?.detach(); _rootNode = value; _rootNode?.attach(this); &#125; List&lt;RenderObject&gt; _nodesNeedingLayout = &lt;RenderObject&gt;[]; ///此管道当前是否处于布局阶段。 ///具体来说，[flushLayout]当前是否正在运行。 ///仅在启用断言时有效。 bool get debugDoingLayout =&gt; _debugDoingLayout; bool _debugDoingLayout = false; ///更新所有脏(dirty)渲染对象的布局信息。 ///此函数是渲染管道的核心阶段之一。 在绘制之前清除布局信息，以便渲染对象将在其最新位置的屏幕上显示。 ///有关如何使用此函数的示例，请参见[RendererBinding]。 void flushLayout() &#123; ///如果应用程序是在发布模式下编译的，则为常量。 ///更具体地说，如果应用程序是使用'-Ddart.vm.product = true'标志在Dart中编译的，那么这是一个常量。 ///由于这是一个const值，它可以用来向编译器指示特定的代码块不会在发布模式下执行，因此可以删除。 if (!kReleaseMode) &#123; Timeline.startSync('Layout', arguments: timelineWhitelistArguments); &#125; assert(() &#123; _debugDoingLayout = true; return true; &#125;()); try &#123; // TODO（ianh）：断言我们不允许以前脏节点自己重做 while (_nodesNeedingLayout.isNotEmpty) &#123; final List&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout; _nodesNeedingLayout = &lt;RenderObject&gt;[]; for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123; if (node._needsLayout &amp;&amp; node.owner == this) node._layoutWithoutResize(); &#125; &#125; &#125; finally &#123; assert(() &#123; _debugDoingLayout = false; return true; &#125;()); if (!kReleaseMode) &#123; Timeline.finishSync(); &#125; &#125; &#125; // 此标志用于在重建LayoutBuilder时允许由GlobalKey重新执行的各种突变，并且这样做会尝试从另一个尚未更新的LayoutBuilder子树移动节点。 要设置它，请调用[_enableMutationsToDirtySubtrees]，它由[RenderObject.invokeLayoutCallback]调用。 // 调试允许突变到脏的子树 bool _debugAllowMutationsToDirtySubtrees = false; // See [RenderObject.invokeLayoutCallback]. void _enableMutationsToDirtySubtrees(VoidCallback callback) &#123; assert(_debugDoingLayout); bool oldState; assert(() &#123; oldState = _debugAllowMutationsToDirtySubtrees; _debugAllowMutationsToDirtySubtrees = true; return true; &#125;()); try &#123; callback(); &#125; finally &#123; assert(() &#123; _debugAllowMutationsToDirtySubtrees = oldState; return true; &#125;()); &#125; &#125; final List&lt;RenderObject&gt; _nodesNeedingCompositingBitsUpdate = &lt;RenderObject&gt;[]; ///更新[RenderObject.needsCompositing]位。 ///在[flushLayout]之后和[flushPaint]之前作为渲染管道的一部分调用。 void flushCompositingBits() &#123; if (!kReleaseMode) &#123; Timeline.startSync('Compositing bits'); &#125; _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth); for (RenderObject node in _nodesNeedingCompositingBitsUpdate) &#123; if (node._needsCompositingBitsUpdate &amp;&amp; node.owner == this) node._updateCompositingBits(); &#125; _nodesNeedingCompositingBitsUpdate.clear(); if (!kReleaseMode) &#123; Timeline.finishSync(); &#125; &#125; List&lt;RenderObject&gt; _nodesNeedingPaint = &lt;RenderObject&gt;[]; ///此管道当前是否处于绘制阶段。 ///具体来说，[flushPaint]当前是否正在运行。 ///仅在启用断言时有效。 bool get debugDoingPaint =&gt; _debugDoingPaint; bool _debugDoingPaint = false; ///更新所有渲染对象的显示列表。 ///此函数是渲染管道的核心阶段之一。 ///绘画在布局(layout)之后和场景重新组合(the scene is recomposited)之前进行，以便场景与每个渲染对象的最新显示列表合成。 ///有关如何使用此函数的示例，请参见[RendererBinding]。 void flushPaint() &#123; if (!kReleaseMode) &#123; Timeline.startSync('Paint', arguments: timelineWhitelistArguments); &#125; assert(() &#123; _debugDoingPaint = true; return true; &#125;()); try &#123; final List&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint; _nodesNeedingPaint = &lt;RenderObject&gt;[]; // Sort the dirty nodes in reverse order (deepest first). for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123; assert(node._layer != null); if (node._needsPaint &amp;&amp; node.owner == this) &#123; if (node._layer.attached) &#123; PaintingContext.repaintCompositedChild(node); &#125; else &#123; node._skippedPaintingOnLayer(); &#125; &#125; &#125; assert(_nodesNeedingPaint.isEmpty); &#125; finally &#123; assert(() &#123; _debugDoingPaint = false; return true; &#125;()); if (!kReleaseMode) &#123; Timeline.finishSync(); &#125; &#125; &#125; ///管理此管道所有者 语义的对象（如果有）。 ///所有者由[ensureSemantics]创建。 只要[ensureSemantics]返回的[SemanticsHandle]尚未处理，所有者就有效。 一旦处理完最后一个句柄，[semanticsOwner]字段将恢复为null，并且将释放前一个所有者。 ///当[semanticsOwner]为null时，[PipelineOwner]会跳过与语义相关的所有步骤。 SemanticsOwner get semanticsOwner =&gt; _semanticsOwner; SemanticsOwner _semanticsOwner; ///注册侦听语义的客户端数量。 ///无论何时调用[ensureSemantics]都会增加数量，而在调用[SemanticsHandle.dispose]时减少数量。 /// ---调试优秀的语义句柄--- int get debugOutstandingSemanticsHandles =&gt; _outstandingSemanticsHandles; int _outstandingSemanticsHandles = 0; ///打开[SemanticsHandle]并在语义树更新时调用[listener]。 ///只有当客户端希望使用语义树时，[PipelineOwner]才会更新语义树。 这些客户端通过持有[SemanticsHandle]对象来表达他们的兴趣，这些对象在语义树更新时通知它们。 ///客户端可以通过调用SemanticsHandle.dispose来关闭它们的[SemanticsHandle]。 一旦给定[PipelineOwner]的所有未完成的[SemanticsHandle]对象都关闭，[PipelineOwner]就会停止维护语义树。 SemanticsHandle ensureSemantics(&#123; VoidCallback listener &#125;) &#123; _outstandingSemanticsHandles += 1; if (_outstandingSemanticsHandles == 1) &#123; assert(_semanticsOwner == null); _semanticsOwner = SemanticsOwner(); if (onSemanticsOwnerCreated != null) onSemanticsOwnerCreated(); &#125; return SemanticsHandle._(this, listener); &#125; void _didDisposeSemanticsHandle() &#123; assert(_semanticsOwner != null); _outstandingSemanticsHandles -= 1; if (_outstandingSemanticsHandles == 0) &#123; _semanticsOwner.dispose(); _semanticsOwner = null; if (onSemanticsOwnerDisposed != null) onSemanticsOwnerDisposed(); &#125; &#125; bool _debugDoingSemantics = false; final Set&lt;RenderObject&gt; _nodesNeedingSemantics = &lt;RenderObject&gt;&#123;&#125;; ///更新标记为需要语义更新的渲染对象的语义。 ///最初，只有[RenderObject.scheduleInitialSemantics]调度的根节点需要语义更新。 ///此函数是渲染管道的核心阶段之一。 语义在绘制后编译，并且仅在调用[RenderObject.scheduleInitialSemantics]之后编译。 ///有关如何使用此函数的示例，请参见[RendererBinding]。 void flushSemantics() &#123; if (_semanticsOwner == null) return; if (!kReleaseMode) &#123; Timeline.startSync('Semantics'); &#125; assert(_semanticsOwner != null); assert(() &#123; _debugDoingSemantics = true; return true; &#125;()); try &#123; final List&lt;RenderObject&gt; nodesToProcess = _nodesNeedingSemantics.toList() ..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth); _nodesNeedingSemantics.clear(); for (RenderObject node in nodesToProcess) &#123; if (node._needsSemanticsUpdate &amp;&amp; node.owner == this) node._updateSemantics(); &#125; _semanticsOwner.sendSemanticsUpdate(); &#125; finally &#123; assert(_nodesNeedingSemantics.isEmpty); assert(() &#123; _debugDoingSemantics = false; return true; &#125;()); if (!kReleaseMode) &#123; Timeline.finishSync(); &#125; &#125; &#125;&#125; ClipContextPaintingContext和TestRecordingPaintingContext使用的剪辑实用程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647abstract class ClipContext &#123; ///要绘制的画布。 Canvas get canvas; void _clipAndPaint(void canvasClipCall(bool doAntiAlias), Clip clipBehavior, Rect bounds, void painter()) &#123; assert(canvasClipCall != null); canvas.save(); switch (clipBehavior) &#123; case Clip.none: break; case Clip.hardEdge: canvasClipCall(false); break; case Clip.antiAlias: canvasClipCall(true); break; case Clip.antiAliasWithSaveLayer: canvasClipCall(true); canvas.saveLayer(bounds, Paint()); break; &#125; painter(); if (clipBehavior == Clip.antiAliasWithSaveLayer) &#123; canvas.restore(); &#125; canvas.restore(); &#125; ///根据[Clip]使用[Path]剪辑[canvas]然后绘画。 [canvas]之后恢复到剪辑前状态。 ///`bounds`是用于[Clip.antiAliasWithSaveLayer]的saveLayer边界。 void clipPathAndPaint(Path path, Clip clipBehavior, Rect bounds, void painter()) &#123; _clipAndPaint((bool doAntiAias) =&gt; canvas.clipPath(path, doAntiAlias: doAntiAias), clipBehavior, bounds, painter); &#125; ///根据[RRect]用[Path]剪辑[canvas]然后绘画。 [canvas]之后恢复到剪辑前状态。 ///`bounds`是用于[Clip.antiAliasWithSaveLayer]的saveLayer边界。 void clipRRectAndPaint(RRect rrect, Clip clipBehavior, Rect bounds, void painter()) &#123; _clipAndPaint((bool doAntiAias) =&gt; canvas.clipRRect(rrect, doAntiAlias: doAntiAias), clipBehavior, bounds, painter); &#125; ///根据[Rect]使用[Path]剪切[canvas]然后绘制。 [canvas]之后恢复到剪辑前状态。 ///`bounds`是用于[Clip.antiAliasWithSaveLayer]的saveLayer边界。 void clipRectAndPaint(Rect rect, Clip clipBehavior, Rect bounds, void painter()) &#123; _clipAndPaint((bool doAntiAias) =&gt; canvas.clipRect(rect, doAntiAlias: doAntiAias), clipBehavior, bounds, painter); &#125;&#125; RenderObjectWithChildMixin具有一个子项的渲染对象的通用mixin。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/// 为具有唯一子项的呈现对象子类提供子模型。mixin RenderObjectWithChildMixin&lt;ChildType extends RenderObject&gt; on RenderObject &#123; ///检查给定的渲染对象是否具有正确的[runtimeType]作为此渲染对象的子对象。 ///如果断言被禁用则不执行任何操作。 ///始终返回true。 bool debugValidateChild(RenderObject child) &#123; assert(() &#123; if (child is! ChildType) &#123; throw FlutterError.fromParts(&lt;DiagnosticsNode&gt;[ ErrorSummary( 'A $runtimeType expected a child of type $ChildType but received a ' 'child of type $&#123;child.runtimeType&#125;.' ), ErrorDescription( 'RenderObjects expect specific types of children because they ' 'coordinate with their children during layout and paint. For ' 'example, a RenderSliver cannot be the child of a RenderBox because ' 'a RenderSliver does not understand the RenderBox layout protocol.', ), ErrorSpacer(), DiagnosticsProperty&lt;dynamic&gt;( 'The $runtimeType that expected a $ChildType child was created by', debugCreator, style: DiagnosticsTreeStyle.errorProperty, ), ErrorSpacer(), DiagnosticsProperty&lt;dynamic&gt;( 'The $&#123;child.runtimeType&#125; that did not match the expected child type ' 'was created by', child.debugCreator, style: DiagnosticsTreeStyle.errorProperty, ) ]); &#125; return true; &#125;()); return true; &#125; ChildType _child; ///渲染对象的唯一子对象 ChildType get child =&gt; _child; set child(ChildType value) &#123; if (_child != null) dropChild(_child); _child = value; if (_child != null) adoptChild(_child); &#125; @override void attach(PipelineOwner owner) &#123; super.attach(owner); if (_child != null) _child.attach(owner); &#125; @override void detach() &#123; super.detach(); if (_child != null) _child.detach(); &#125; @override void redepthChildren() &#123; if (_child != null) redepthChild(_child); &#125; @override void visitChildren(RenderObjectVisitor visitor) &#123; if (_child != null) visitor(_child); &#125; @override List&lt;DiagnosticsNode&gt; debugDescribeChildren() &#123; return child != null ? &lt;DiagnosticsNode&gt;[child.toDiagnosticsNode(name: 'child')] : &lt;DiagnosticsNode&gt;[]; &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Window]]></title>
    <url>%2FFlutter-window%2F</url>
    <content type="text"><![CDATA[Flutter-Window window.dart文件在源码中的路径为：bin⁩ ▸ ⁨cache⁩ ▸ ⁨pkg⁩ ▸ ⁨sky_engine⁩ ▸ ⁨lib⁩ ▸ ⁨ui⁩ window.dart文件中的类源码概括 FramePhase：帧的4个阶段 FrameTiming：绘制一帧与时间相关的性能指标 AppLifecycleState：应用生命周期状态 WindowPadding：窗口填充 Locale：多语言本地化设置 Window：窗口显示、属性、时间 FramePhase-帧的4个阶段1234567891011121314151617enum FramePhase &#123; /// 当UI线程开始构建框架时。 /// See also [FrameTiming.buildDuration]. buildStart, /// 当UI线程完成构建框架时。 /// See also [FrameTiming.buildDuration]. buildFinish, /// 当GPU线程开始栅(shan)格化(rasterizing，即像素)帧时。， /// See also [FrameTiming.rasterDuration]. rasterStart, /// 当GPU线程完成栅格化(rasterizing)帧时。 /// See also [FrameTiming.rasterDuration]. rasterFinish,&#125; FrameTiming- 绘制一帧与时间相关的性能指标有关如何获取此信息，请参见[Window.onReportTimings]。由于调试开销，调试模式下的指标（没有任何标志的“颤动运行”）可能与配置文件和释放模式中的指标非常不同。因此，建议仅在配置文件和发布模式下监视和分析性能指标。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class FrameTiming &#123; /// 使用以微秒为单位的原始时间戳构造[FrameTiming]。 /// To get the [FrameTiming] of your app, see [Window.onReportTimings]. FrameTiming(List&lt;int&gt; timestamps) : assert(timestamps.length == FramePhase.values.length), _timestamps = timestamps; int timestampInMicroseconds(FramePhase phase) =&gt; _timestamps[phase.index]; Duration _rawDuration(FramePhase phase) =&gt; Duration(microseconds: _timestamps[phase.index]); /// 他在UI线程上构建框架的持续时间。 /// 大致在调用[Window.onBeginFrame]时开始构建。 /// [Window.onBeginFrame]回调中的[Duration]正是`Duration（微秒:timestampInMicroseconds（FramePhase.buildStart））`。 /// /// 调用[Window.render]时，构建完成。 /// /// &#123;@ template dart.ui.FrameTiming.fps_smoothness_milliseconds&#125; ///为了确保X fps的平滑动画，这不应超过1000 / X毫秒。 /// &#123;@endtemplate&#125; /// &#123;@template dart.ui.FrameTiming.fps_milliseconds&#125; /// 60fps约为16ms，120fps约为8ms。 /// &#123;@endtemplate&#125; Duration get buildDuration =&gt; _rawDuration(FramePhase.buildFinish) - _rawDuration(FramePhase.buildStart); /// 在GPU线程上栅格化帧的持续时间。 /// /// &#123;@macro dart.ui.FrameTiming.fps_smoothness_milliseconds&#125; /// &#123;@macro dart.ui.FrameTiming.fps_milliseconds&#125; Duration get rasterDuration =&gt; _rawDuration(FramePhase.rasterFinish) - _rawDuration(FramePhase.rasterStart); /// 构建开始和光栅完成之间的时间跨度。 /// /// To achieve the lowest latency on an X fps display, this should not exceed /// 1000/X milliseconds. /// &#123;@macro dart.ui.FrameTiming.fps_milliseconds&#125; /// /// See also [buildDuration] and [rasterDuration]. Duration get totalSpan =&gt; _rawDuration(FramePhase.rasterFinish) - _rawDuration(FramePhase.buildStart); final List&lt;int&gt; _timestamps; // in microseconds String _formatMS(Duration duration) =&gt; '$&#123;duration.inMicroseconds * 0.001&#125;ms'; @override String toString() &#123; return '$runtimeType(buildDuration: $&#123;_formatMS(buildDuration)&#125;, rasterDuration: $&#123;_formatMS(rasterDuration)&#125;, totalSpan: $&#123;_formatMS(totalSpan)&#125;)'; &#125;&#125; AppLifecycleState-应用生命周期状态也可以看看：[WidgetsBindingObserver]，用于从小部件层观察生命周期状态的机制。 12345678910111213141516171819202122232425262728enum AppLifecycleState &#123; /// 应用程序可见并响应用户输入。 resumed, /// 应用程序处于非活动状态，并且未接收用户输入。 /// /// On iOS, this state corresponds to an app or the Flutter host view running /// in the foreground inactive state. Apps transition to this state when in /// a phone call, responding to a TouchID request, when entering the app /// switcher or the control center, or when the UIViewController hosting the /// Flutter app is transitioning. /// /// 在Android上，这对应于在前台非活动状态下运行的应用程序或Flutter主机视图。 /// 当其他活动聚焦时，应用程序会转换到此状态，例如分屏应用，电话，画中画应用，系统对话或其他窗口。 /// /// 处于此状态的应用程序应假设它们可能随时[paused]。 inactive, /// 该应用程序当前对用户不可见，不响应用户输入，并在后台运行。 /// 当应用程序处于此状态时，引擎将不会调用[Window.onBeginFrame]和[Window.onDrawFrame]回调。 /// 处于此状态的Android应用程序应假设他们可以随时进入[挂起(suspending)]状态。 paused, /// 申请将暂停。 /// 当应用程序处于此状态时，引擎将不会调用[Window.onBeginFrame]和[Window.onDrawFrame]回调。 /// 在iOS上，此状态目前尚未使用。 suspending,&#125; WidgetsBindingObserver(binding.dart文件)-从Widget层观察生命周期状态的机制用于 注册Widgets图层 绑定的类 的 接口。当用作mixin时，提供无操作方法实现。请参阅 WidgetsBinding.addObserver() 和 WidgetsBinding.removeObserver()。这个类可以直接扩展，以获得所有处理程序的默认行为，或者可以与implements关键字一起使用，在这种情况下必须实现所有处理程序（并且分析器将列出已被省略的那些） ）。 使用 WidgetsBindingObserver 的1个示例：这个StatefulWidget实现了对应用程序生命周期消息 作出反应所必需的 State 和 WidgetsBindingObserver 协议的各个部分。请参阅didChangeAppLifecycleState()。 1234567891011121314151617181920212223242526272829303132class AppLifecycleReactor extends StatefulWidget &#123; const AppLifecycleReactor(&#123; Key key &#125;) : super(key: key); @override _AppLifecycleReactorState createState() =&gt; _AppLifecycleReactorState();&#125;class _AppLifecycleReactorState extends State&lt;AppLifecycleReactor&gt; with WidgetsBindingObserver &#123; @override void initState() &#123; super.initState(); WidgetsBinding.instance.addObserver(this); &#125; @override void dispose() &#123; WidgetsBinding.instance.removeObserver(this); super.dispose(); &#125; AppLifecycleState _notification; @override void didChangeAppLifecycleState(AppLifecycleState state) &#123; setState(() &#123; _notification = state; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Text('Last notification: $_notification'); &#125;&#125; 要响应其他通知，请将上面的 didChangeAppLifecycleState() 替换为此类中的 其他方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354abstract class WidgetsBindingObserver &#123; /// 当系统告诉应用弹出当前路线（路由）时调用。 /// 例如，在Android上，当用户按下后退按钮时会调用此方法 — 返回键监听。 /// /// 观察员按注册顺序通知，直到一个返回true。 如果没有返回true，则应用程序退出。 /// /// 观察者如果能够处理通知，则返回true，例如关闭活动对话框，否则返回false。 /// [WidgetsApp]小部件使用此机制通知[Navigator]小部件，如果可能，它应该弹出当前路由。 /// /// 此方法从SystemChannels.navigation]暴露出`popRoute`通知。 Future&lt;bool&gt; didPopRoute() =&gt; Future&lt;bool&gt;.value(false); /// 当宿主（手机主机）告诉应用程序将新路由推送到导航器时调用。 /// /// 如果观察者能够处理通知，则应该返回true。 观察员按注册顺序通知，直到一个返回true。 /// /// 此方法公开来自[SystemChannels.navigation]的`pushRoute`通知。 Future&lt;bool&gt; didPushRoute(String route) =&gt; Future&lt;bool&gt;.value(false); /// 当App的尺寸发生变化时调用。 例如，当手机旋转时。 /// 此方法公开来自[Window.onMetricsChanged]的通知。 /// 这个[StatefulWidget]实现了[State]和[WidgetsBindingObserver]协议的部分，这些协议是在设备旋转（或以其他方式改变尺寸）时作出反应所必需的。 /// 通常，这是不必要的，因为布局系统负责在应用程序大小更改时自动重新计算应用程序几何。 /// See also: /// [MediaQuery.of]，它提供类似的服务，具有较少的样板。 void didChangeMetrics() &#123; &#125; /// 当平台的文本比例因子发生变化时调用。 /// 这通常是用户更改系统首选项的结果，它应该影响应用程序中的所有文本大小。 /// 此方法公开来自[Window.onTextScaleFactorChanged]的通知。 /// [MediaQuery.of]，提供类似的服务，具有较少的样板。 void didChangeTextScaleFactor() &#123; &#125; /// 屏幕亮度 void didChangePlatformBrightness() &#123; &#125; /// 当系统告诉应用程序，用户的语言环境已更改时调用。 例如，如果用户更改了系统语言设置。 /// 此方法公开来自[Window.onLocaleChanged]的通知。 void didChangeLocales(List&lt;Locale&gt; locale) &#123; &#125; ///当系统将应用程序 置于后台 或将应用程序 返回到前台 时调用。 /// [WidgetsBindingObserver]类的类级文档中提供了实现此方法的示例。 ///此方法公开来自[SystemChannels.lifecycle]的通知。 void didChangeAppLifecycleState(AppLifecycleState state) &#123; &#125; ///当系统内存不足时调用。 ///此方法公开来自[SystemChannels.system]的`memoryPressure`通知。 void didHaveMemoryPressure() &#123; &#125; ///当系统更改当前活动的辅助功能集时调用。 ///此方法公开来自[Window.onAccessibilityFeaturesChanged]的通知。 void didChangeAccessibilityFeatures() &#123; &#125;&#125; WindowPadding-窗口填充矩形的四个边中的每一个的距离表示，用于编码应用程序应放置在其用户界面周围的视图插入和填充，如[Window.viewInsets]和[Window.padding]所示。 优选地通过[MediaQuery.of]读取视图插入和填充。 对于表示矩形周围距离的泛型类，请参阅[EdgeInsets]类。 也可以看看： [WidgetsBindingObserver]，用于在填充更改时接收通知的窗口小部件层机制。 [MediaQuery.of]，用于访问这些值的首选机制。 [Scaffold]，可在材料设计应用中自动应用填充。 1234567891011121314151617181920212223class WindowPadding &#123; const WindowPadding._(&#123; this.left, this.top, this.right, this.bottom &#125;); /// 物理像素中从左边缘到第一个未填充像素的距离。 final double left; /// The distance from the top edge to the first unpadded pixel, in physical pixels. final double top; /// The distance from the right edge to the first unpadded pixel, in physical pixels. final double right; /// The distance from the bottom edge to the first unpadded pixel, in physical pixels. final double bottom; /// A window padding that has zeros for each edge. static const WindowPadding zero = WindowPadding._(left: 0.0, top: 0.0, right: 0.0, bottom: 0.0); @override String toString() &#123; return 'WindowPadding(left: $left, top: $top, right: $right, bottom: $bottom)'; &#125;&#125; Locale-多语言本地化设置1234567891011121314151617181920class Locale &#123; const Locale( this._languageCode, [ this._countryCode, ]) : assert(_languageCode != null), assert(_languageCode != ''), scriptCode = null; const Locale.fromSubtags(&#123; String languageCode = 'und', this.scriptCode, String countryCode, &#125;) : assert(languageCode != null), assert(languageCode != ''), _languageCode = languageCode, assert(scriptCode != ''), assert(countryCode != ''), _countryCode = countryCode;&#125; Window-窗口主机操作系统用户界面的最基本界面。 它公开了display大小，核心调度程序API，输入事件回调，图形绘制API和其他此类核心服务。 系统中有一个Window实例，您可以从WidgetsBinding.instance.window获取。 如果WidgetsBinding不可用，dart：ui中也有一个[window]单例对象。但我们强烈建议避免静态引用它。有关应该避免的原因的更多详细信息，请参见[window]的文档。 //Insets(插入、插页、镶嵌) 和 Padding（填充） 动画演示地址：https://flutter.github.io/assets-for-api-docs/assets/widgets/window_padding.mp4 在此图中：黑色区域表示应用无法绘制的系统UI。红色区域表示应用程序可能无法检测到手势并且可能不想绘制的视图填充。灰色区域表示系统键盘，可以在可见时覆盖底部视图填充。 [Window.viewInsets]是操作系统为系统UI保留的物理像素，例如键盘，它会完全遮盖在该区域中绘制的任何内容。 [Window.viewPadding]是显示器每一侧的物理像素，可能被系统UI或物理入侵显示器部分遮挡，例如电视上的过扫描区域或者电视上的“凹口”。电话。与插图不同，这些区域可以具有向用户应用绘制像素而不被遮挡的部分，诸如仅覆盖该区域的子集的电话顶部的凹口。另一方面，Insets部分或完全遮挡窗口，例如不透明键盘或部分半透明状态栏，其覆盖没有间隙的区域。 [Window.padding]属性是从[Window.viewInsets]和[Window.viewPadding]计算的。它将允许视图插入在适当的情况下使用视图填充，例如当手机的键盘覆盖底部视图填充并因此“吸收”它时。 无论viewInsets是什么，想要相对于viewPadding定位元素的客户端都应使用[Window.viewPadding]属性，例如：如果您希望在屏幕中央绘制相对于iPhone“安全区域”的小部件，无论键盘是否显示。 [Window.padding]对于想要知道应该考虑多少填充而不考虑当前插入状态的客户端是有用的，例如，确定是否应该考虑手势以用于滚动目的。此值根据insets的当前状态而变化。例如，无论如何，可见键盘将消耗[Window.viewPadding]底部的所有手势，因此无需在[Window.padding]中考虑到这一点，这对于此类计算始终是安全的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330class Window &#123; Window._() &#123; _setNeedsReportTimings = _nativeSetNeedsReportTimings; &#125; /// 每个逻辑像素的设备像素数。 这个数字可能不是两个人的权力。 实际上，它甚至可能不是整数。 例如，Nexus 6的设备像素比为3.5。 /// 设备像素也称为物理像素。 逻辑像素也称为与设备无关或与分辨率无关的像素。 /// 根据定义，物理显示器每厘米大约有38个逻辑像素，或每英寸大约96个逻辑像素。 [devicePixelRatio]返回的值最终是从硬件本身，设备驱动程序或存储在操作系统或固件中的硬编码值获得的，并且可能不准确，有时可能会有很大的余量。 /// Flutter框架以逻辑像素运行，因此很少需要直接处理此属性。 /// 当此更改时，将调用[onMetricsChanged]。 double get devicePixelRatio =&gt; _devicePixelRatio; double _devicePixelRatio = 1.0; ///应用于绘制应用程序的矩形的尺寸，以物理像素为单位。 ///当此更改时，将调用[onMetricsChanged]。 ///启动时，在运行Dart代码之前，可能无法知道应用程序窗口的大小。 如果在应用程序生命周期的早期观察到此值，则可能会报告[Size.zero]。 ///此值不考虑任何屏幕键盘或其他系统UI。 [padding]和[viewInsets]属性提供了一个视图，表明系统UI可以隐藏应用程序的每一侧。 ///也可以看看： [WidgetsBindingObserver]，用于窗口小部件层的机制，以观察此值何时更改。 Size get physicalSize =&gt; _physicalSize; Size _physicalSize = Size.zero; ///物理深度是Window允许的最大elevation。 ///在此elevation或高于该elevation绘制的物理层将其elevation限制为此值。 如果物理层本身的elevation大于可用深度，或者图层的某个祖先导致其累积elevation大于可用深度，则会发生这种情况。 ///默认值为[double.maxFinite]，用于未指定最大elevation的平台。 此属性当前预计将在Fuchsia上设置为非默认值。 double get physicalDepth =&gt; _physicalDepth; double _physicalDepth = double.maxFinite; ///应用程序可以呈现的显示矩形每侧的物理像素数，但操作系统可能会放置系统UI，例如键盘，完全遮盖任何内容。 ///当此更改时，将调用[onMetricsChanged]。 ///[Window.viewInsets]，[Window.viewPadding]和[Window.padding]之间的关系在[Window]的文档中有更详细的描述。 /// 也可以看看： /// * [WidgetsBindingObserver]，用于窗口小部件层的机制，以观察此值何时更改。 /// * [MediaQuery.of]，一个更简单的机制。 /// * [Scaffold]，它自动在材质设计应用程序中应用视图插入。 WindowPadding get viewInsets =&gt; _viewInsets; WindowPadding _viewInsets = WindowPadding.zero; ///应用程序可以呈现的显示矩形每一侧的物理像素数，但可能被系统UI（例如系统通知区域）或显示中的物理入侵（例如过扫描）部分遮盖电视屏幕或手机传感器外壳上的区域）。 ///与[Window.padding]不同，此值相对于[Window.viewInsets]不会改变。例如，在iPhone X上，它不会响应软键盘可见或隐藏而改变，而[Window.padding]会。 ///当此更改时，将调用[onMetricsChanged]。 WindowPadding get viewPadding =&gt; _viewPadding; WindowPadding _viewPadding = WindowPadding.zero; ///应用程序可以呈现的显示矩形每一侧的物理像素数，但可能被系统UI（例如系统通知区域）或显示中的物理入侵（例如过扫描）部分遮盖电视屏幕或手机传感器外壳上的区域）。 ///这个值是通过'max（0.0，Window.viewPadding - Window.viewInsets）`来计算的。这将处理一个系统IME，它会增加底部插入消耗大部分底部填充。例如，在iPhone X上，当没有绘制软键盘时[Window.padding.bottom]与[Window.viewPadding.bottom]相同（占底部软按钮区域），但是为“0.0”。当软键盘可见时。 ///当此更改时，将调用[onMetricsChanged]。 WindowPadding get padding =&gt; _padding; WindowPadding _padding = WindowPadding.zero; ///每当[devicePixelRatio]，[physicalSize]，[padding]或[viewInsets]值发生变化时调用的回调，例如当设备被旋转或应用程序调整大小时（例如，当显示应用程序时） - 在Android上）。 ///引擎在设置回调的同一区域中调用此回调。 ///框架注册此回调并适当更新布局。 /// 也可以看看： /// * [WidgetsBindingObserver]，用于小部件层的一种机制，用于在调用此方法时注册通知。 /// * [MediaQuery.of]，一个更简单的机制。 VoidCallback get onMetricsChanged =&gt; _onMetricsChanged; VoidCallback _onMetricsChanged; Zone _onMetricsChangedZone; set onMetricsChanged(VoidCallback callback) &#123; _onMetricsChanged = callback; _onMetricsChangedZone = Zone.current; &#125; ///系统报告的设备默认语言环境。 ///这确定了应用程序应尽可能用于呈现其用户界面的语言和格式约定。 ///这是用户选择的第一个区域设置，是用户的主要区域设置（设备UI显示的区域设置） ///这相当于`locales.first`，如果[locales]列表尚未设置或为空，它将提供一个空的非空语言环境。 Locale get locale &#123; if (_locales != null &amp;&amp; _locales.isNotEmpty) &#123; return _locales.first; &#125; return null; &#125; ///完整的系统报告支持的设备区域设置。 ///这确定了应用程序应尽可能用于呈现其用户界面的语言和格式约定。 ///列表按优先级顺序排序，较低索引的语言环境优先于较高索引的语言环境。 第一个元素是主要[locale]。 ///只要此值发生变化，就会调用[onLocaleChanged]回调。 /// 也可以看看： /// * [WidgetsBindingObserver]，用于窗口小部件层的机制，以观察此值何时更改。 List&lt;Locale&gt; get locales =&gt; _locales; List&lt;Locale&gt; _locales; ///每当[locale]更改值时调用的回调。 ///框架在设置回调的同一区域中调用此回调。 /// 也可以看看： /// * [WidgetsBindingObserver]，用于小部件层的机制，以观察何时调用此回调。 VoidCallback get onLocaleChanged =&gt; _onLocaleChanged; VoidCallback _onLocaleChanged; Zone _onLocaleChangedZone; set onLocaleChanged(VoidCallback callback) &#123; _onLocaleChanged = callback; _onLocaleChangedZone = Zone.current; &#125; /// dart isolate 初始化后的生命周期状态。 ///随着生命周期的变化，不会更新此属性。 ///它用于在启动时使用任何缓冲的生命周期状态事件初始化[SchedulerBinding.lifecycleState]。 String get initialLifecycleState &#123; _initialLifecycleStateAccessed = true; return _initialLifecycleState; &#125; String _initialLifecycleState; ///跟踪是否已访问初始状态。 ///一旦访问，我们将停止更新[initialLifecycleState]，因为它不是访问该状态的首选方式。 bool _initialLifecycleStateAccessed = false; ///系统报告的 text scale。 ///这将根据用户的平台首选项确定在呈现文本时使用的文本缩放因子。 ///只要此值发生变化，就会调用[onTextScaleFactorChanged]回调。 /// 也可以看看： /// * [WidgetsBindingObserver]，用于窗口小部件层的机制，以观察此值何时更改。 double get textScaleFactor =&gt; _textScaleFactor; double _textScaleFactor = 1.0; /// 指示是否应始终以24小时格式显示时间的设置。 /// [showTimePicker]使用此选项。 bool get alwaysUse24HourFormat =&gt; _alwaysUse24HourFormat; bool _alwaysUse24HourFormat = false; ///每当[textScaleFactor]更改值时调用的回调。 ///框架在设置回调的同一区域中调用此回调。 /// 也可以看看： /// * [WidgetsBindingObserver]，用于小部件层的机制，以观察何时调用此回调。 VoidCallback get onTextScaleFactorChanged =&gt; _onTextScaleFactorChanged; VoidCallback _onTextScaleFactorChanged; Zone _onTextScaleFactorChangedZone; set onTextScaleFactorChanged(VoidCallback callback) &#123; _onTextScaleFactorChanged = callback; _onTextScaleFactorChangedZone = Zone.current; &#125; ///表示主机平台当前亮度模式的设置。 ///如果平台没有首选项，[platformBrightness]默认为[Brightness.light]。 Brightness get platformBrightness =&gt; _platformBrightness; Brightness _platformBrightness = Brightness.light; ///每当[platformBrightness]更改值时调用的回调。 ///框架在设置回调的同一区域中调用此回调。 /// 也可以看看： /// * [WidgetsBindingObserver]，用于小部件层的机制，以观察何时调用此回调。 VoidCallback get onPlatformBrightnessChanged =&gt; _onPlatformBrightnessChanged; VoidCallback _onPlatformBrightnessChanged; Zone _onPlatformBrightnessChangedZone; set onPlatformBrightnessChanged(VoidCallback callback) &#123; _onPlatformBrightnessChanged = callback; _onPlatformBrightnessChangedZone = Zone.current; &#125; ///调用的回调函数通知应用程序使用[SceneBuilder] API和[render]方法提供场景是合适的时间。 如果可能，这是由硬件VSync信号驱动的。 只有在自上次调用此回调以来调用[scheduleFrame]时才会调用此方法。 /// [onBeginFrame]之后立即调用[onDrawFrame]回调，排除任何由[onBeginFrame]处理程序排队的微任务（例如任何[Future] s的完成）。 ///框架在设置回调的同一区域中调用此回调。 /// 也可以看看： /// * [SchedulerBinding]，Flutter框架类，用于管理帧的调度。 /// * [RendererBinding]，Flutter框架类，用于管理布局和绘制。 FrameCallback get onBeginFrame =&gt; _onBeginFrame; FrameCallback _onBeginFrame; Zone _onBeginFrameZone; set onBeginFrame(FrameCallback callback) &#123; _onBeginFrame = callback; _onBeginFrameZone = Zone.current; &#125; ///在[onBeginFrame]完成之后和微任务队列排空之后为每个帧调用的回调。 这可以用于实现在[onBeginFrame]阶段排队的任何延迟工作之后发生的帧渲染的第二阶段。 ///框架在设置回调的同一区域中调用此回调。 /// 也可以看看： /// * [SchedulerBinding]，Flutter框架类，用于管理帧的调度。 /// * [RendererBinding]，Flutter框架类，用于管理布局和绘制。 VoidCallback get onDrawFrame =&gt; _onDrawFrame; VoidCallback _onDrawFrame; Zone _onDrawFrameZone; set onDrawFrame(VoidCallback callback) &#123; _onDrawFrame = callback; _onDrawFrameZone = Zone.current; &#125; ///被调用以报告最近栅格化帧的[FrameTiming]的回调。 ///这可用于查看应用程序是否丢失帧（通过[FrameTiming.buildDuration]和[FrameTiming.rasterDuration]），或高延迟（通过[FrameTiming.totalSpan]）。 ///与[Timeline]不同，此处的时序信息在发布模式下可用（除了配置文件和调试模式）。 因此，这可用于监控应用程序在野外的性能。 /// &#123;@macro dart.ui.TimingsCallback.list&#125;如果为null，则不会执行任何其他工作。 如果这不是null，Flutter每1秒花费不到0.1ms来报告时间（在iPhone6S上测量）。 0.1ms约为16ms的0.6％（60fps的帧预算），或每秒0.01％的CPU使用率。 TimingsCallback get onReportTimings =&gt; _onReportTimings; TimingsCallback _onReportTimings; Zone _onReportTimingsZone; set onReportTimings(TimingsCallback callback) &#123; if ((callback == null) != (_onReportTimings == null)) &#123; _setNeedsReportTimings(callback != null); &#125; _onReportTimings = callback; _onReportTimingsZone = Zone.current; &#125; _SetNeedsReportTimingsFunc _setNeedsReportTimings; void _nativeSetNeedsReportTimings(bool value) native 'Window_setNeedsReportTimings'; ///指针数据可用时调用的回调。 ///框架在设置回调的同一区域中调用此回调。 /// 也可以看看： /// * [GestureBinding]，Flutter框架类，用于管理指针事件。 PointerDataPacketCallback get onPointerDataPacket =&gt; _onPointerDataPacket; PointerDataPacketCallback _onPointerDataPacket; Zone _onPointerDataPacketZone; set onPointerDataPacket(PointerDataPacketCallback callback) &#123; _onPointerDataPacket = callback; _onPointerDataPacketZone = Zone.current; &#125; ///启动应用程序时嵌入器请求的路由或路径。 ///如果没有请求特定路由，这将是字符串“`/`”。 /// Android ///在Android上，调用[`FlutterView.setInitialRoute`]（/ javadoc / io / flutter / view / FlutterView.html＃setInitialRoute-java.lang.String-）将设置此值。该值必须足够早地设置，即在Dart中执行[runApp]调用之前，这对框架有任何影响。 `FlutterActivity`子类中的`createFlutterView`方法是设置值的合适时间。应用程序的'AndroidManifest.xml`文件也必须更新为具有合适的[`&lt;intent-filter&gt;`]（https://developer.android.com/guide/topics/manifest/intent-filter-element.html） 。 /// ## iOS ///在iOS上，调用[`FlutterViewController.setInitialRoute`]（/ objcdoc / Classes / FlutterViewController.html＃/ c：objc％28cs％29FlutterViewController％28im％29setInitialRoute :)将设置此值。该值必须足够早地设置，即在Dart中执行[runApp]调用之前，这对框架有任何影响。 `application：didFinishLaunchingWithOptions：`方法是设置此值的合适时间。 /// 也可以看看： /// * [Navigator]，一个处理路由的小部件。 /// * [SystemChannels.navigation]，它处理来自嵌入器的后续导航请求。 String get defaultRouteName =&gt; _defaultRouteName(); String _defaultRouteName() native 'Window_defaultRouteName'; /// 请求在下一个适当的时机调用[onBeginFrame]和[onDrawFrame]回调。 /// 也可以看看： /// * [SchedulerBinding]，Flutter框架类，用于管理帧的调度。 void scheduleFrame() native 'Window_scheduleFrame'; ///使用新提供的[Scene]更新应用程序在GPU上的渲染。必须在被调用的[onBeginFrame]或[onDrawFrame]回调的范围内调用此函数。如果在单个[onBeginFrame] / [onDrawFrame]回调序列中第二次调用此函数，或者在这些回调范围之外调用此函数，则将忽略该调用。 ///要记录图形操作，首先创建一个[PictureRecorder]，然后构造一个[Canvas]，将[PictureRecorder]传递给它的构造函数。 ///发出所有图形操作后，调用[PictureRecorder]上的[PictureRecorder.endRecording]功能，获取代表已发布图形操作的最终[Picture]。 ///接下来，创建一个[SceneBuilder]，并使用[SceneBuilder.addPicture]将[Picture]添加到它。使用[SceneBuilder.build]方法，您可以获得[Scene]对象，您可以通过此[render]函数向用户显示该对象。 /// 也可以看看： /// * [SchedulerBinding]，Flutter框架类，用于管理帧的调度。 /// * [RendererBinding]，Flutter框架类，用于管理布局和绘制。 void render(Scene scene) native 'Window_render'; ///当窗口的语义内容发生变化时，用户是否请求调用[update Semantics]。 ///只要此值发生变化，就会调用[onSemanticsEnabled Changed]回调。 bool get semanticsEnabled =&gt; _semanticsEnabled; bool _semanticsEnabled = false; ///当[semanticsEnabled]的值发生变化时调用的回调。 ///框架在设置回调的同一区域中调用此回调。 VoidCallback get onSemanticsEnabledChanged =&gt; _onSemanticsEnabledChanged; VoidCallback _onSemanticsEnabledChanged; Zone _onSemanticsEnabledChangedZone; set onSemanticsEnabledChanged(VoidCallback callback) &#123; _onSemanticsEnabledChanged = callback; _onSemanticsEnabledChangedZone = Zone.current; &#125; ///每当用户请求执行操作时调用的回调。 ///当用户根据[updateSemantics]提供的语义表达他们希望执行的操作时，将使用此回调。 ///框架在设置回调的同一区域中调用此回调。 SemanticsActionCallback get onSemanticsAction =&gt; _onSemanticsAction; SemanticsActionCallback _onSemanticsAction; Zone _onSemanticsActionZone; set onSemanticsAction(SemanticsActionCallback callback) &#123; _onSemanticsAction = callback; _onSemanticsActionZone = Zone.current; &#125; ///平台可以启用的其他辅助功能。 AccessibilityFeatures get accessibilityFeatures =&gt; _accessibilityFeatures; AccessibilityFeatures _accessibilityFeatures; /// [accessibilityFeatures]的值更改时调用的回调。 /// 框架在设置回调的同一区域中调用此回调。 VoidCallback get onAccessibilityFeaturesChanged =&gt; _onAccessibilityFeaturesChanged; VoidCallback _onAccessibilityFeaturesChanged; Zone _onAccessibilityFlagsChangedZone; set onAccessibilityFeaturesChanged(VoidCallback callback) &#123; _onAccessibilityFeaturesChanged = callback; _onAccessibilityFlagsChangedZone = Zone.current; &#125; ///更改有关此窗口的保留语义数据。 ///如果[semanticsEnabled]为true，则只要该窗口的语义内容发生变化，用户就会请求调用此函数。 ///在任何一种情况下，此函数都会处理给定的更新，这意味着无法进一步使用语义更新。 void updateSemantics(SemanticsUpdate update) native 'Window_updateSemantics'; ///设置与此窗口的根isolate关联的调试名称。 ///通常，调试名称是从Dart端口，入口点和源文件自动生成的。 例如：`main.dart $ main-1234`。 ///这可以与flutter工具`--isolate-filter`标志结合使用来调试特定的根isolate。 例如：`flutter attach --isolate-filter = [name]`。 ///请注意，这不会重命名根的任何子isolate。 void setIsolateDebugName(String name) native 'Window_setIsolateDebugName'; ///向特定于平台的插件发送消息。 ///`name`参数确定哪个插件接收消息。 `data`参数包含消息有效负载，通常是UTF-8编码的JSON，但可以是任意数据。 如果插件回复消息，将使用响应调用`callback`。 ///框架在调用此方法的同一区域中调用[callback]。 void sendPlatformMessage(String name, ByteData data, PlatformMessageResponseCallback callback) &#123; final String error = _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data); if (error != null) throw Exception(error); &#125; String _sendPlatformMessage(String name, PlatformMessageResponseCallback callback, ByteData data) native 'Window_sendPlatformMessage'; ///每当此窗口收到来自特定于平台的插件的消息时调用。 ///`name`参数确定哪个插件发送了消息。 `data`参数是有效载荷，通常是UTF-8编码的JSON，但可以是任意数据。 ///消息处理程序必须调用`callback`参数中给出的函数。 ///如果处理程序不需要响应，则处理程序应将null传递给回调。 ///框架在设置回调的同一区域中调用此回调。 PlatformMessageCallback get onPlatformMessage =&gt; _onPlatformMessage; PlatformMessageCallback _onPlatformMessage; Zone _onPlatformMessageZone; set onPlatformMessage(PlatformMessageCallback callback) &#123; _onPlatformMessage = callback; _onPlatformMessageZone = Zone.current; &#125; ///由[_dispatchPlatformMessage]调用。 void _respondToPlatformMessage(int responseId, ByteData data) native 'Window_respondToPlatformMessage'; ///在另一个回调函数中包含给定的[callback]，以确保该回调 ///在其注册的区域中调用原始回调。 static PlatformMessageResponseCallback _zonedPlatformMessageResponseCallback(PlatformMessageResponseCallback callback) &#123; if (callback == null) return null; //存储正在注册回调的区域。 final Zone registrationZone = Zone.current; return (ByteData data) &#123; registrationZone.runUnaryGuarded(callback, data); &#125;; &#125;&#125; 简单总结：相关类：[WidgetsBindingObserver]，用于窗口小部件层的机制，以观察此值何时更改 – 全局[MediaQuery.of]，一个更简单的机制。适用于屏幕显示相关属性[SchedulerBinding.lifecycleState]，生命周期状态事件[SceneBuilder] API和[render]方法，[scheduleFrame][SchedulerBinding]，Flutter框架类，用于管理帧的调度。[RendererBinding]，Flutter框架类，用于管理布局和绘制。[FrameTiming]，栅格化帧[GestureBinding]，Flutter框架类，用于管理指针事件。[Navigator]，一个处理路由的小部件。[SystemChannels.navigation]，它处理来自嵌入器的后续导航请求。 Window.dart 控制的属性// 设备无关像素devicePixelRatio // 绘制应用程序矩形尺寸、的物理像素physicalSize // 应用程序可以呈现的显示矩形每侧的物理像素数viewInsets // 应用程序可以呈现的显示矩形每一侧的物理像素数viewPadding // 应用程序可以呈现的显示矩形每一侧的物理像素数padding // 每当[devicePixelRatio]，[physicalSize]，[padding]或[viewInsets]值发生变化时调用的回调onMetricsChanged // Window所允许的最大elevationphysicalDepth ///系统报告的设备默认语言环境。locale ///完整的系统报告支持的设备区域设置。locales ///每当[locale]更改值时调用的回调。onLocaleChanged /// dart isolate 初始化后的生命周期状态。initialLifecycleState ///跟踪是否已访问初始状态。_initialLifecycleStateAccessed ///系统报告的 text scale。textScaleFactor ///每当[textScaleFactor]更改值时调用的回调onTextScaleFactorChanged /// 指示是否应始终以24小时格式显示时间的设置。alwaysUse24HourFormat ///表示主机平台当前亮度模式的设置platformBrightness ///每当[platformBrightness]更改值时调用的回调。onPlatformBrightnessChanged ///调用的回调函数通知应用程序使用[SceneBuilder] API和[render]方法提供场景是合适的时间。onBeginFrame ///在[onBeginFrame]完成之后和微任务队列排空之后为每个帧调用的回调。onDrawFrame ///请求在下一个适当的时机调用[onBeginFrame]和[onDrawFrame]回调。scheduleFrame() ///使用新提供的[Scene]更新应用程序在GPU上的渲染。render(Scene scene) ///被调用以报告最近栅格化帧的[FrameTiming]的回调，可用于查看应用程序是否丢失帧onReportTimings ///指针数据可用时调用的回调。阅读[GestureBinding]onPointerDataPacket ///启动应用程序时嵌入器请求的路由或路径。defaultRouteName ///当窗口的语义内容发生变化时，用户是否请求调用[update Semantics]。semanticsEnabled ///当[semanticsEnabled]的值发生变化时调用的回调。onSemanticsEnabledChanged ///更改有关此窗口的保留语义数据。updateSemantics(SemanticsUpdate update) ///每当用户请求执行操作时调用的回调。onSemanticsActio ///平台可以启用的其他辅助功能。accessibilityFeatures ///[accessibilityFeatures]的值更改时调用的回调。onAccessibilityFeaturesChanged ///设置与此窗口的根isolate关联的调试名称。setIsolateDebugName(String name) ///向特定于平台的插件发送消息。sendPlatformMessage(String name, ByteData data, PlatformMessageResponseCallback callback) ///每当此窗口收到来自特定于平台的插件的消息时调用。onPlatformMessage ///由[_dispatchPlatformMessage]调用。_respondToPlatformMessage(int responseId, ByteData data) ///在另一个回调函数中包含给定的[callback]，以确保该回调_zonedPlatformMessageResponseCallback]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-跨平台]]></title>
    <url>%2FFlutter-%E8%B7%A8%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[Flutter跨平台相关 参考：https://flutter-io.cn/docs/development/platform-integration/platform-channels 介绍基础Flutter 的平台相关 API 支持不依赖于代码生成，而是依赖于灵活的消息传递（Flutter’s platform-specific API support does not rely on code generation, but rather on a flexible message passing style:）： 应用程序中的 客户端（Flutter 部分） 通过平台通道（platform channel）向其 宿主（应用程序中的 iOS 或 Android 部分）发送 消息。 宿主 通过监听 平台通道（platform channel） 并接收 消息。然后，它使用 原生编程语言（宿主使用的编程语言）来调用任意数量的相关平台 API，并将 响应 发送回 客户端（Flutter 部分）。 平台通道（platform channel）架构概述消息（Message）使用平台通道（platform channel）在客户端（UI）和宿主（平台）之间传递，如下图所示： 注意： 消息和响应以异步的形式进行传递，以确保用户界面能够保持响应。即便如此，当你调用一个宿主方法时，也需要在主线程上做调用。 支持的数据类型标准平台通道使用标准消息编、解码器，它支持简单的类似 JSON 值的高效二进制序列化，例如布尔值、数字、字符串、字节缓冲区及这些类型的列表和映射。当你发送和接收值时，它会 自动 对这些值进行序列化和反序列化。 平台通信种类 - 3种 BasicMessageChannel：支持字符串和半结构化的数据传递，可以通过它来获取Native项目的图标等资源 MethodChannel：传递方法调用，既可以从Flutter与平台之间可以相互调用，并获取相应的返回值 EventChannel：支持数据流通信，传递事件。收到消息后无法回复此次消息，通常用于Native向Dart的通信]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-使用问题总结]]></title>
    <url>%2FFlutter-%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Flutter开发问题总结 1. 终端提示：Waiting for another flutter command to release the startup lock问题产生原因： 这个错误发生在终端中输入命令：get package，等了很久没有获取到package之后，关掉了AS，再次打开AS后，在终端中输入：flutter doctor后出现了这个错误。 解决： 找到：flutter的安装目录/bin/cache/ 。 删除lockfile文件 重启AS 2. 注意Flutter中获取当前App运行版本环境的方法，方便于在不同的运行环境下执行不同（是否要显示）的显示信息：包：constants.dart 12345678910111213141516171819202122232425262728293031323334353637383940///如果应用程序是在发布模式下编译的，则为常量。///更具体地说，如果应用程序是使用&apos;-Ddart.vm.product = true&apos;标志在Dart中编译的，那么这是一个常量。///由于这是一个const值，它可以用来向编译器指示特定的代码块不会在发布模式下执行，因此可以删除。const bool kReleaseMode = bool.fromEnvironment(&apos;dart.vm.product&apos;, defaultValue: false);/// A constant that is true if the application was compiled in profile mode.////// More specifically, this is a constant that is true if the application was/// compiled in Dart with the &apos;-Ddart.vm.profile=true&apos; flag.////// Since this is a const value, it can be used to indicate to the compiler that/// a particular block of code will not be executed in profle mode, an hence/// can be removed.const bool kProfileMode = bool.fromEnvironment(&apos;dart.vm.profile&apos;, defaultValue: false);/// A constant that is true if the application was compiled in debug mode.////// More specifically, this is a constant that is true if the application was/// not compiled with &apos;-Ddart.vm.product=true&apos; and &apos;-Ddart.vm.profile=true&apos;.////// Since this is a const value, it can be used to indicate to the compiler that/// a particular block of code will not be executed in debug mode, and hence/// can be removed.const bool kDebugMode = !kReleaseMode &amp;&amp; !kProfileMode;/// The epsilon of tolerable double precision error.////// This is used in various places in the framework to allow for floating point/// precision loss in calculations. Differences below this threshold are safe to/// disregard.const double precisionErrorTolerance = 1e-10;/// A constant that is true if the application was compiled to run on the web.////// This implementation takes advantage of the fact that JavaScript does not/// support integers. In this environment, Dart&apos;s doubles and ints are/// backed by the same kind of object. Thus a double `0.0` is identical/// to an integer `0`. This is not true for Dart code running in AOT or on the/// VM.const bool kIsWeb = identical(0, 0.0);]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-国际化]]></title>
    <url>%2FFlutter-%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Flutter国际化相关 参考：https://flutter-io.cn/docs/development/accessibility-and-localization/internationalization参考：https://flutter-io.cn/docs/development/accessibility-and-localization/internationalization#dart-tools参考：https://www.jianshu.com/p/8356a3bc8f6c Flutter库 本身就是国际化的，提供了 widgets 和 类。默认情况下，Flutter 只提供美式英语的本地化。 简单说明： 在下文中提及到的Localizations类是一个Widget，这真的是充分体现了：flutter一切都是Widget，此类的定义为： 1class Localizations extends StatefulWidget&#123;&#125; 由声明可见，还是一个动态Widget，其State具体实现类为_LocalizationsState： 1class _LocalizationsState extends State&lt;Localizations&gt; &#123;&#125; 在Localizations类中最为重要的方法是of()： 123456static T of&lt;T&gt;(BuildContext context, Type type) &#123; assert(context != null); assert(type != null); final _LocalizationsScope scope = context.inheritFromWidgetOfExactType(_LocalizationsScope); return scope?.localizationsState?.resourcesFor&lt;T&gt;(type);&#125; 这个方法在下文的自定义国际化语言类中经常用到此方法。在此提出注意。在这个方法中，有一个变量localizationsState，它就是_LocalizationsState的对象。 设置国际化通过 MaterialApp 配置国际化实现步骤： pubspec.yaml 文件 中添加依赖 ： 12345678dependencies: flutter: sdk: flutter # Android国际化包 flutter_localizations: sdk: flutter # iOS国际化包 flutter_cupertino_localizations: ^1.0.1 引入 flutter_localizations 库后，为 MaterialApp 指定 localizationsDelegates属性和 supportedLocales属性 ： 12345678910111213141516171819class MainWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( // 特定于应用的本地化代表[] localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, GlobalCupertinoLocalizations.delegate, ], // 应用程序支持的区域设置 supportedLocales: [ const Locale(&apos;en&apos;), const Locale(&apos;he&apos;), const Locale.fromSubtags(languageCode: &apos;zh&apos;), ], ); &#125;&#125; GlobalMaterialLocalizations类：使用intl包进行日期和时间格式化的MaterialWidget的本地化字符串的实现 。 GlobalWidgetsLocalizations类：文本阅读方向 GlobalCupertinoLocalizations：使用intl包实现CupertinoWidget的本地化字符串以进行日期和时间格式化。 localizationDelegates[]: 是用于生成本地化值集合的工厂。 GlobalMaterialLocalizations.delegate 为 Material组件库提供本地化的字符串和一些其他的值。 GlobalWidgetsLocalizations.delegate 为 widgets库定义了默认的文本排列方向，由左到右或者由右到左。 虽然 Locale 默认的构造函数是完全没有问题的，但是还是建议大家使用 Locale.fromSubtags 的构造函数，因为它支持设置scriptCode。 区别： 以上配置是基于MaterialApp Widget进行配置的，如果使用基于WidgetsApp构建的 app 在添加语言环境时，除了 GlobalMaterialLocalizations.delegate 不需要之外，其他的操作是类似的。 高级 locale definition 设置 — supportedLocales[]属性supportedLocales[]属性：表示此应用已本地化的区域设置列表。 默认情况下，仅支持美式英语语言环境。app应配置此列表以匹配其支持的区域设置。同时此列表不能为空，它的默认值是： [const Locale(&#39;en&#39;, &#39;US&#39;)]。 一般来说：一些具有着多个变种语言仅仅用一种语言代码是不能做适当区分。 以中文为例，要能 完全区分 具有 多个语言变种 - 中文 需要指定： 语言代码（language code） 文字代码（script code） 国家代码（country code）。 这是因为有些语言本身就存在着简体和繁体的文字系统，而且同时使用相同文字系统写的字符又有地域性差别。 因此，为了让 CN，TW 和 HK 三个不同的地区代码能够完整地表达每个变种的中文，你应该包括以下支持的语言环境: 1234567891011121314151617supportedLocales: [ const Locale(&apos;en&apos;), const Locale(&apos;he&apos;), /// 多语言变种的具体设置 // 通用中文 ：&apos;zh&apos; const Locale.fromSubtags(languageCode: &apos;zh&apos;), // 简体-通用中文 ：&apos;zh_Hans&apos; const Locale.fromSubtags(languageCode:&apos;zh&apos;, scriptCode:&apos;Hans&apos;), // 繁体-通用中文 ：&apos;zh_Hant&apos; const Locale.fromSubtags(languageCode:&apos;zh&apos;, scriptCode:&apos;Hant&apos;), // 大陆-简体-通用中文 ：&apos;zh_Hans_CN&apos; const Locale.fromSubtags(languageCode:&apos;zh&apos;, scriptCode:&apos;Hans&apos;, countryCode:&apos;CN&apos;), // 台湾-繁体-通用中文 ：&apos;zh_Hant_CN&apos; const Locale.fromSubtags(languageCode:&apos;zh&apos;, scriptCode:&apos;Hant&apos;, countryCode:&apos;TW&apos;), // 香港-繁体-通用中文 ：&apos;zh_Hant_CN&apos; const Locale.fromSubtags(languageCode:&apos;zh&apos;, scriptCode:&apos;Hant&apos;, countryCode:&apos;HK&apos;),], 如果用户没有指定首选的语言环境，那么我们就会使用最近的匹配。Flutter 只会解析定义在 supportedLocales 里面的语言环境。对于那些常用语言，Flutter 为本地化内容提供了文字代码级别的区分。查看 Localizations 了解 Flutter 是如何解析支持的语言环境和首选的语言环境的。 获取获取app 当前的语言环境 Locale 类用来识别用户的语言。 Localizations widget 定义了它的子节点的语言环境和依赖的本地化的资源。WidgetsApp 创建了一个本地化的 widget，如果系统的语言环境变化了，它会重建这个 widget。 加载和获取本地化值最基本的获取方法： 1Localizations.of&lt;MaterialLocalizations&gt;(context, MaterialLocalizations); 因为这个特定的 Localizations.of() 表达式经常使用，所以 MaterialLocalizations 类提供了一个快捷访问： 123456static MaterialLocalizations of(BuildContext context) &#123; return Localizations.of&lt;MaterialLocalizations&gt;(context, MaterialLocalizations);&#125;/// 引用时为tooltip: MaterialLocalizations.of(context).backButtonTooltip, 实现方式1. 项目文件1.1 定义多语言文件123456789101112131415161718192021222324252627282930313233343536373839import &apos;dart:ui&apos;;import &apos;package:flutter/widgets.dart&apos;;class MyLocalizationsMaps&#123; final Locale locale; MyLocalizationsMaps(&#123;this.locale&#125;); static MyLocalizationsMaps of(BuildContext buildContext)&#123; return Localizations.of(buildContext, MyLocalizationsMaps); &#125; // 方式1：定义国际化语言-基于map static Map&lt;String, Map&lt;String, String&gt;&gt; _localizedValues = &#123; &apos;en&apos;: &#123; &apos;task title&apos;: &apos;Flutter Demo&apos;, &apos;titlebar title&apos;: &apos;Flutter Demo Home Page&apos;, &apos;click tip&apos;: &apos;You have pushed the button this many times:&apos;, &#125;, &apos;zh&apos;: &#123; &apos;task title&apos;: &apos;Flutter 示例&apos;, &apos;titlebar title&apos;: &apos;Flutter 示例主页面&apos;, &apos;click tip&apos;: &apos;你一共点击了这么多次按钮：&apos;, &#125; &#125;; get taskTitle&#123; return _localizedValues[locale.languageCode][&apos;task title&apos;]; &#125; get titlebarTitle&#123; return _localizedValues[locale.languageCode][&apos;titlebar title&apos;]; &#125; get clickTip&#123; return _localizedValues[locale.languageCode][&apos;click tip&apos;]; &#125;&#125; 1.2 实例化多语言文件123456789101112131415161718192021222324252627import &apos;package:flutter/foundation.dart&apos;;import &apos;package:flutter/widgets.dart&apos;;import &apos;MyLocalizationsMaps.dart&apos;;/// 初始化MyLocalizationsclass MyLocalizationsDelegateMaps extends LocalizationsDelegate&lt;MyLocalizationsMaps&gt;&#123; const MyLocalizationsDelegateMaps(); @override bool isSupported(Locale locale) &#123; return [&apos;en&apos;,&apos;zh&apos;].contains(locale.languageCode); &#125; @override Future&lt;MyLocalizationsMaps&gt; load(Locale locale) &#123; // MyLocalizations的获取方式应该是&quot;异步&quot;的，因为数据来源并不确定——导致耗时。 return SynchronousFuture&lt;MyLocalizationsMaps&gt;(MyLocalizationsMaps(locale: locale)); &#125; @override bool shouldReload(LocalizationsDelegate&lt;MyLocalizationsMaps&gt; old) &#123; return false; &#125;&#125; 1.3 使用配置1234567891011121314151617181920212223242526272829303132import &apos;package:flutter/material.dart&apos;;import &apos;package:flutter_localizations/flutter_localizations.dart&apos;;import &apos;package:xflutter/generated/i18n.dart&apos;;import &apos;IntlLocalizations.dart&apos;;import &apos;IntlLocalizationsDelegate.dart&apos;;void main() =&gt; runApp(new MainWidget());class MainWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( /// ----- 本地化多语言配置 开始 ----- // 特定于应用的本地化代表[] localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, GlobalCupertinoLocalizations.delegate, ], // 应用程序支持的区域设置 supportedLocales: [ // 注意：Lcoale中的2个参数一定要都声明，及时是空也要写：&apos;&apos;， // 否则报错：The getter &apos;isEmpty&apos; was called on null. const Locale(&apos;en&apos;,&apos;&apos;), const Locale(&apos;zh&apos;,&apos;&apos;), ], home: DemoApp(), ); &#125;&#125; 1.4 使用12345678return MaterialApp( // 注意：此处直接使用本地化报错，因为不能获取最近一个父类Widget的context //title: MyLocalizations.of(buildContext).taskTitle, // 修改为 onGenerateTitle: (BuildContext context) &#123; return IntlLocalizations.of(context).appName; &#125;,); 2. intl包2.1 添加依赖12345dependencies: intl: ^0.15.7dev_dependencies: intl_translation: ^0.17.3 2.2 创建语言文件12345678910111213141516import &apos;package:flutter/widgets.dart&apos;;import &apos;package:intl/intl.dart&apos;;class IntlLocalizations &#123; static IntlLocalizations of(BuildContext buildContext) &#123; return Localizations.of(buildContext, IntlLocalizations); &#125; String get appTitle &#123; return Intl.message(&quot;Flutter 示例主页面&quot;); &#125; String get appBarTitle &#123; return Intl.message(&apos;你一共点击了这么多次按钮：&apos;); &#125;&#125; 2.3 初始化源语言文件123456789101112131415161718192021222324import &apos;package:flutter/widgets.dart&apos;;import &apos;IntlLocalizations.dart&apos;;class IntlLocalizationsDelegate extends LocalizationsDelegate&lt;IntlLocalizations&gt;&#123; const IntlLocalizationsDelegate(); @override bool isSupported(Locale locale) &#123; return [&apos;en&apos;,&apos;zh&apos;].contains(locale.languageCode); &#125; @override Future&lt;IntlLocalizations&gt; load(Locale locale) &#123; return IntlLocalizations.load(locale); &#125; @override bool shouldReload(LocalizationsDelegate old) &#123; return false; &#125;&#125; 2.4 通过命令生成-多语言基础文件：执行命令 1flutter pub pub run intl_translation:extract_to_arb --output-dir=/Users/yannischeng/XFlutter/xflutter lib/localization/IntlLocalizations.dart 这条命令中有2个参数： /Users/yannischeng/XFlutter/xflutter lib/：生成文件所在的目录 lib/localization/IntlLocalizations.dart：项目中的源文件所在目录 注意：各个参数中间有一个空格作区分。 执行生成多文件命令后，在项目中指定的路径下生成了一个intl_messages.arb文件（arb即：Application Resource Bundle） 源文件内容： 12345678910111213141516import &apos;package:flutter/widgets.dart&apos;;import &apos;package:intl/intl.dart&apos;;class IntlLocalizations &#123; static IntlLocalizations of(BuildContext buildContext) &#123; return Localizations.of(buildContext, IntlLocalizations); &#125; String get appTitle &#123; return Intl.message(&quot;Flutter 示例主页面&quot;); &#125; String get appBarTitle &#123; return Intl.message(&apos;你一共点击了这么多次按钮：&apos;); &#125;&#125; 生成文件内容： 12345678910111213&#123; &quot;@@last_modified&quot;: &quot;2019-08-14T14:40:58.671243&quot;, &quot;Flutter 示例主页面&quot;: &quot;Flutter 示例主页面&quot;, &quot;@Flutter 示例主页面&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: &#123;&#125; &#125;, &quot;你一共点击了这么多次按钮：&quot;: &quot;你一共点击了这么多次按钮：&quot;, &quot;@你一共点击了这么多次按钮：&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: &#123;&#125; &#125;&#125; 2.5 手动翻译所需多语言文件将 intl_messages.arb文件复制2份： 1份命名为：intl_zh.arb，作为中文版本使用。 1份命名为：intl_en.arb，作为英文版本使用。 将 intl_en.arb文件中的中文内容翻译为对应英文： 12345678910111213&#123; &quot;@@last_modified&quot;: &quot;2019-08-14T14:40:58.671243&quot;, &quot;Flutter 示例主页面&quot;: &quot;Flutter Demo Home Page&quot;, &quot;@Flutter 示例主页面&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: &#123;&#125; &#125;, &quot;你一共点击了这么多次按钮：&quot;: &quot;You have pushed the button this many times:&quot;, &quot;@你一共点击了这么多次按钮：&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: &#123;&#125; &#125;&#125; 2.6 通过命令生成-对应local的message文件1flutter pub run intl_translation:generate_from_arb --output-dir=/Users/yannischeng/XFlutter/xflutter --no-use-deferred-loading lib/localization/IntlLocalizations.dart /Users/yannischeng/XFlutter/xflutter/intl_*.arb 这个命令中共有4个参数： /Users/yannischeng/XFlutter/xflutter：新生成文件的输出目录 --no-use-deferred-loading lib/localization/IntlLocalizations.dart：源文件 /Users/yannischeng/XFlutter/xflutter/intl_*.arb：新生成的各个message文件路径 注意：各个参数中间有一个空格作区分。 命令执行成功后，目录下的新生成文件（红色）： 2.7 修改配置12345678910111213localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, //intl包方式，多语言调用 const IntlLocalizationsDelegate()],supportedLocales: [ /// 最简单的设置 // 注意：Lcoale中的2个参数一定要都声明，及时是空也要写：&apos;&apos;， 否则报错：The getter &apos;isEmpty&apos; was called on null. const Locale(&apos;en&apos;,&apos;&apos;), const Locale(&apos;zh&apos;,&apos;&apos;),], 3. 插件 flutter_i18n使用参考：https://juejin.im/post/5c6d12596fb9a049d132b889#heading-4使用参考：https://www.jianshu.com/p/3e4cedba697a 3.1 安装Android Studio（IDEA）上有一款名为 flutter_i18n 的插件，可以帮助简化这个过程，其原理是通过 .arb文件 来自动生成所需要的代码。 安装后会出现一个新的按钮，如下图所示： 安装此插件后，就会默认生成 res/values 文件夹，并且在文件中包含一个默认 strings_en.arb 文件： 每当你修改.arb 文件后，在自动生成的 lib/generated 文件夹中会自动生成 i18n.dart文件 代码： 3.2 使用步骤在此插件的帮助下，我们只需要通过2步即可完成语言本地化的处理 3.2.1 创建对应地区语言文件/修改已存在的语言文件创建： 如果项目中已有的语言文件并不能满足需要，那么可以自己创建一个 strings_xxx.arb 文件。 创建方式：直接复制原有文件或者直接new新.arb文件都可以。 修改： string_xxx.arb文件 中的具体内容，以string_en.arb文件为例（其他语言文件同理，只不过是要对对应内容进行翻译而已）-json格式： 1234&#123; &quot;appName&quot;: &quot;App Name&quot;, &quot;hello&quot;: &quot;Hello $name&quot;&#125; 自动更新 一般情况下，当修改了string_xxx.arb文件后，执行 com+s后，il8n.dart文件就自动更新。 异常： 有时安装完 flutter_i18n插件后，AS工具栏中的插件按钮是灰色的，那样是用不了的。解决办法：可以先将此插件禁用，重启AS。然后再启用此插件，再重启AS。这时这个插件的图标就是彩色的了，功能也可以正常使用了。 通过以上步骤，在插件的帮助下国际化文件的处理已经完成了，下面将在项目中应用这些文件。 3.2.2 项目配置在你的项目中，进行一下配置： 12345678910111213141516171819class MainWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( // 特定于应用的本地化代表[] localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, // flutter插件方式 S.delegate ], // 应用程序支持的区域设置 // flutter插件方式，使用这种方式，依赖中的&apos;intl_translation: ^0.17.3&apos; 可以省略 supportedLocales: S.delegate.supportedLocales, home: DemoApp(), ); &#125;&#125; 使用： 12345678910111213class DemoApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(S.of(context).appName), ), body: Center( child: Text(S.of(context).hello(&quot;程文佳&quot;)), ), ); &#125;&#125; 在使用了插件后，依赖中的 intl_translation 可以删掉了。 自定义国际化控件 与 全局Key 的使用]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2FMaven%2F</url>
    <content type="text"><![CDATA[文件夹nexus-3.14.0-04-win64中有两个文件夹nexus-3.14.0-04和sonatype-work。nexus-3.14.0-04是程序，sonatype-work是工作目录，如果以后要备份数据，只要备份sonatype-work就行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter-框架特性]]></title>
    <url>%2FFlutter-%E6%A1%86%E6%9E%B6%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Flutter-框架特性 延伸阅读：声明式 UI延伸阅读：暂时 (ephemeral) 和应用 (app) 状态的区别 Flutter中使用的编程范式 组合 (composition): 这也是 Flutter 的 主要开发范式，使用 简单、行为有限 的 小对象 进行 组合，从而实现更 复杂的效果。 绝大多数 Flutter widget 都是用这种方法构建的。比如 Material FlatButton 类是基于 MaterialButton 类构建的，而这个类则是由 IconTheme、InkWell、Padding、Center、Material、AnimatedDefaultTextStyle 以及 ConstrainedBox 组合而成的。而 InkWell 则是由 GestureDetector 组成，Material 则是由 AnimatedDefaultTextStyle、NotificationListener 和 AnimatedPhysicalModel 组成。如此等等。 函数式编程 (functional programming): 整个应用都可以只用 StatelessWidget 来构建，它 本质上就是一些方法，用来描述如何将参数传送给其他方法，以及在布局区域内计算布局以及绘制图像。当然这样的应用一般也不会包含状态，所以通常也无法进行交互。 比如，Icon widget 就只是一个将其元素 (颜色、图标、尺寸) 罗列在布局区域内的方法。另外，当这个范式被重度使用时，则会使用不可变的数据结构，如整个 Widget 类及其派生，以及一些辅助类，如 Rect 和 TextStyle。 另外，从一个较小的尺度来看的话，Dart 的 Iterable API 也重度使用了这个范式 (如 map, reduce, where 等方法)，它在框架中经常被用来处理一序列的值。 事件驱动编程 (event-driven programming): 用户的 交互操作 被包装成 事件对象，这些对象发送给被各个 eventhandler 注册的回调方法。 屏幕内容的更新使用的也是类似的回调机制。比如，被做为动画系统构建基础的 Listenable 类，就采用了包含多个 事件监听者的订阅模型。 面向类编程 (class-based programming，是面向对象编程的一种方式): 框架内绝大多数的 API 是由包含各种继承关系的类来组成的。我们在 基本类 中定义较高级别的 API，然后在 其子类 中对 这些 API 进行特化处理。 比如，我们的渲染对象就有一个基本类 RenderObject，它对坐标系的细节并不关心，但它的子类 RenderBox 就引入了笛卡尔坐标系的概念 (x/y 坐标值，以及宽度高度的概念)。 原型编程 (prototype-based programming，面向对象编程的一种方式): SrollPhysics 类在运行时``动态链接那些会组成滚动逻辑的实例。这就使得系统无需在编译时提前选择平台的情况下，也能组合出符合平台特性的翻页滚动效果。 指令式编程 (imperative programming): 简单直白的指令式编程，通常和对象内封装的状态 (state) 搭配使用，这种范式能提供最符合直觉的解法。 比如，测试就是使用指令式编程实现的，首先描述出测试的环境，然后给出测试需要满足的定量，最后开始步进，或者根据测试需要插入事件。 响应式编程 (reactive programming): Widget 和 元素树 有时候被描述为 响应式 的，因为随 widget 构造方法引入的新输入会随着其 build 方法传播给更低等级的 widget；而底层 widget 中出现的修改 (如响应用户的输入) 也会沿着结构树通过 eventhandler 向上传播。 在整个框架中，函数-响应式以 及 指令-响应式 的实现都有出现，具体取决于 widget 的功能需求： 如果 Widget 的 build() 只是包含其针对变化如何响应的表达式的话，就是 函数-响应式 widget (如 Material Divider 类)； 如果 widget 的 build() 包含一系列的表达式，用于描述该 widget 如何响应变化的话，那它就是 指令-响应式 widget (如 Chip 类)。 声明式编程 (declarative programming): Widget 的 build() 通常都是 一个单一表达式，它包含 多级嵌套的构造函数，且使用 Dart 严格的 声明式子集 编写。这些 嵌套表达式可以被机械地与合适的 标记语言互相转换。 比如，UserAccountsDrawerHeader 这个 widget 就有一个很长的 build 方法 (20 多行)，由一个嵌套的表达式构成。这种范式也可以和指令式混合使用，以实现某些很难用纯声明式的方法实现的 UI。 泛型程序设计 (generic programming): 类型可以帮助开发者更早地抓到错误，基于这一点，Flutter 框架也采用了 泛型开发。比如： State类 就是如此，其 关联的widget 就是 类型参数，如此一来 Dart 分析器就能捕获到 state 和 widget 不匹配的情况。 类似的，GlobalKey 类就接受 一个类型参数，从而类型安全地访问一个 widget 的 state (会使用运行时检查)。 Route接口 也在被 pop() 时接受类型参数，另外 List, Map, Set 这些集合也都如此，这样就可以在分析或者运行时尽早发现 类型不匹配的错误。 并发 (concurrent programming): Flutter 大量使用诸如 Future 等 异步API。比如： 动画系统就会在动画执行完 future 时进行事件告知； 图片加载系统也会使用 future 告知读取完毕。 约束编程 (constraint programming): Flutter 的 布局系统 使用了 约束编程的简化形态 来描述一个场景的几何性质。 约束值 (比如一个笛卡尔矩形允许的最大 / 最小宽高值) 会从 父元素 传递给 子元素，子元素最终选择一个能满足上面所有约束条件的最终尺寸。这种做法也使得 Flutter 能不依赖太多输入的情况下快速完成一个全新的布局。 命令式与声明式区分命令式从 Win32 到 Web 再到 Android 和 iOS，框架通常使用一种命令式的编程风格来完成 UI 编程。比如： 12你手动构建一个全功能的 UI 实例，比如一个通过 findViewById() 创建一个View实例 。在随后 UI 发生变化时，使用 其内置的方法 根据业务需要去修改它。 在这个过程中所执行的与view相关的函数就是命令式的编程风格。 声明式状态管理中的声明式编程思维 Flutter应用是 声明式 的，这也就意味着 Flutter构建的用户界面就是应用的 当前状态。 如果你是从命令式框架转到 Flutter 应用，那么，你需要开始从一个新的角度来考虑 app 开发了。 Flutter应用开发 与 命令式框架 相反，它让开发人员 只描述 当前UI的 视图配置，然后将具体的 转换 操作 交给框架 来执行。 在声明式风格中，视图配置（如 Flutter 的 Widget ）是 不可变 的，它只是轻量的“蓝图”。如： 123456789101112131415161718192021Row(&#123; Key key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[], &#125;) : super( children: children, key: key, direction: Axis.horizontal, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline, );&#125; 问题：Flutter 怎么没有标记语言 (markup language) 和语法？Flutter的 UI 是由 指令式 的 面向对象语言Dart 构建的，本身不包含 声明式的标记语言。 问题：什么是编程语言、什么是标记语言？ 编程语言 (programming language)，有逻辑和行为能力，如 c, perl, javascript 标记语言( markup language )，无逻辑和行为能力，是被用来被读取的，如：xml, html, xhtml ( xml 和 html 的合体 ) 问题：为什么要使用代码构建UI？ 使用代码构建UI会带来的 更多的灵活性，因为 标记语言 很难表达一个：从 视觉 到 行为 都 完全定制 的Widget。 代码优先 的开发方式能使得 热重载 和 动态环境配置等特性 更好的实现。 那么……开发人员在更改 视图配置蓝图 的具体实现后，视图是如何 更新 的呢？ Widget更新Widget 会在自身上触发重建（在 Flutter 中最常见的方法是在 StatefulWidgets 组件上调用 setState()）并构造一个 新 Widget子树。即：当用户界面发生变化时， Flutter 不修改旧实例 ，而是 构造新 Widget 实例。 也可以理解为：widget是不可变的。因为它们会直接被替换。 框架使用RenderObjects管理传统UI对象的许多职责（例如维护布局的状态）。 RenderObjects在帧之间保持不变，Flutter的轻量级Widgets告诉框架在状态之间改变RenderObjects。 Flutter框架处理其余部分。 （Here, rather than mutating an old instance b when the UI changes, Flutter constructs new Widget instances. The framework manages many of the responsibilities of a traditional UI object (such as maintaining the state of the layout) behind the scenes with RenderObjects. RenderObjects persist between frames and Flutter’s lightweight Widgets tell the framework to mutate the RenderObjects between states. The Flutter framework handles the rest.） Flutter框架源码阅读范围 flutter框架-flutter包.png flutter框架-sky引擎包.png 状态管理暂时（短时）状态短时状态 (有时也称 用户界面(UI)状态 或者 局部状态) 是你可以完全包含在一个独立widget 中 的状态，widget 树中其他部分不需要访问这种状态。如： 一个 PageView 组件中的当前页面 一个复杂动画中当前进度 一个 BottomNavigationBar 中当前被选中的 tab 换句话说：不需要使用 状态管理架构（例如 ScopedModel, Redux）去管理这种状态。你需要用的只是一个 StatefulWidget。 应用（共享）状态如果你想在你的应用中的 多个部分之间共享 一个非短时状态，并且在用户会话期间保留这个状态， 我们称之为 应用状态（有时也称共享状态）。 例如： 用户选项 登录信息 一个社交应用中的通知 一个电商应用中的购物车 一个新闻应用中的文章已读/未读状态 如何区分、定义状态？没有一个明确、普遍的规则来区分一个变量属于短时状态还是应用状态，有时你不得不在此之间重构。比如，刚开始你认为一些状态是短时状态， 但随着应用不断增加功能，有些状态需要被改变为应用状态。 因此，请有保留地遵循以下这张流程图： 存储状态的对象应该置于何处？提高状态的层级 —— 在 Flutter 中，有必要将存储状态的对象置于 widget 树中对应 widget 的 上层 为什么？ 因为：在 Flutter 中，每次当 widget 内容发生改变的时候，你就需要构造一个新的。你会调用 MyCart(contents)（构造函数），而不是 MyCart.updateWith(somethingNew)（调用方法）。因为你 只能 通过父类的 build() 来构建新 widget，如果你想修改 存储状态的变量，就需要调用 MyCart的父类甚至更高一级的类。 如何读取状态？Flutter 在 Widget 中存在一种 机制：能够为其子孙节点提供数据和服务。换言之，不仅仅是它的子节点，所有在它下层的 widget 都可以）。这种机制包括 ： widget底层类：InheritedWidget、InheritedNotifier、InheritedModel； provider package：和些底层widget 打交道的package。 Widget底层类provider package ChangeNotifier ChangeNotifierProvider Consumer ChangeNotifier观察者模式。可以扩展或混合的类，使用 VoidCallback() 为 通知 提供更改通知API。它用于向监听器发送通知。换言之，如果被定义为 ChangeNotifier，你可以订阅它的状态变化。 ChangeNotifier 针对 少数（一个或两个）侦听器 进行了优化。添加和删除侦听器是O(N)，调度通知是O(N²)（其中N是侦听器的数量）。 源码基本实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class ChangeNotifier implements Listenable &#123; ObserverList&lt;VoidCallback&gt; _listeners = ObserverList&lt;VoidCallback&gt;(); @protected bool get hasListeners &#123; assert(_debugAssertNotDisposed()); return _listeners.isNotEmpty; &#125; @override void addListener(VoidCallback listener) &#123; assert(_debugAssertNotDisposed()); _listeners.add(listener); &#125; @override void removeListener(VoidCallback listener) &#123; assert(_debugAssertNotDisposed()); _listeners.remove(listener); &#125; @mustCallSuper void dispose() &#123; assert(_debugAssertNotDisposed()); _listeners = null; &#125; @protected @visibleForTesting void notifyListeners() &#123; assert(_debugAssertNotDisposed()); if (_listeners != null) &#123; final List&lt;VoidCallback&gt; localListeners = List&lt;VoidCallback&gt;.from(_listeners); for (VoidCallback listener in localListeners) &#123; try &#123; if (_listeners.contains(listener)) listener(); &#125; catch (exception, stack) &#123; //异常处理 &#125; &#125; &#125; &#125; &#125; 其实现可以概括为：通过 ObserverList&lt;VoidCallback&gt; 对 VoidCallback进行一系列的管理，包括：通过 hasListeners()是否为空判断、通过addListener(VoidCallback listener)进行添加、通过removeListener(VoidCallback listener)、通过dispose()清空资源、通过 notifyListeners()进行遍历。 ChangeNotifierProvider/MultiProviderConsumer参考： https://www.wandouip.com/t5i285410/]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-动画]]></title>
    <url>%2FFlutter-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[动画介绍]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-具体Widget使用实例]]></title>
    <url>%2FFlutter-%E5%85%B7%E4%BD%93Widget%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Flutter 中 Everything is a Widget。 Flutter Widget索引Flutter Widget目录 基础Widgets Container：容器 Row：横向 Column：纵向 Image：图片 Text：文本 RaisedButton：凸起button Scaffold：Material Design布局结构的基本实现 Appbar：Material Design应用程序栏，由工具栏和其他可能的widget（如TabBar和FlexibleSpaceBar）组成。 Placeholder：占位符 Expanded：缩放空间1234567891011Expanded( child: Container( color: Colors.orange, width: 700.0, height: 40.0, margin: EdgeInsets.all(10.0), alignment: Alignment.center, child: new Text(&apos;Hello cheng&apos;), transform: Matrix4.rotationX(0.0), ),), Expanded在行、列中的使用方式，控制某一行、某一列的控件大小： 123456789101112131415161718192021222324252627282930313233343536373839children: &lt;Widget&gt;[ Expanded( child: Container( width: double.infinity, color: Color(0xFFFF0000), child: Text( &quot;Text1&quot;, style: TextStyle(fontSize: 30.0), ), )), Expanded( child: Container( width: double.infinity, color: Color(0xFFFFFF00), child: Text( &quot;Text2&quot;, style: TextStyle(fontSize: 30.0), ), )), Expanded( child: Container( width: double.infinity, color: Color(0xFF00FF00), child: Text( &quot;Text3&quot;, style: TextStyle(fontSize: 30.0), ), )), Expanded( flex: 2, child: Container( width: double.infinity, color: Color(0xFF0000FF), child: Text( &quot;Text4&quot;, style: TextStyle(fontSize: 30.0), ), )),], 效果： Container：容器 参考：https://blog.csdn.net/zgcqflqinhao/article/details/85064014 123456789child: Container( color: Colors.orange, width: 700.0, height: 40.0, margin: EdgeInsets.all(10.0), alignment: Alignment.center, child: new Text(&apos;Hello cheng&apos;), transform: Matrix4.rotationX(0.0), ), Center 填充 对齐 行 列 网格 Row：行123456789101112Row( //verticalDirection: VerticalDirection.down, crossAxisAlignment: CrossAxisAlignment.center, textDirection: TextDirection.ltr, children: &lt;Widget&gt;[ new RaisedButton( onPressed: _increment, child: new Text(&apos;Increment&apos;), ), new _CounterSteless(_counter), ],) Column：列 Flutter 将 Android 中一个 LinearLayout 横、纵向拆成了两个组件。 使用参考：https://blog.csdn.net/zgcqflqinhao/article/details/85239084 12345678910111213141516171819202122232425Column( mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ Text( &apos;第一列&apos;, textAlign: TextAlign.justify, textScaleFactor: 1.5, ), Text.rich( TextSpan(text: &quot;第二行&quot;, children: &lt;TextSpan&gt;[ TextSpan( text: &apos;中间值&apos;, style: TextStyle(fontStyle: FontStyle.italic), ), TextSpan( text: &apos;结束值&apos;, style: TextStyle( fontStyle: FontStyle.normal, color: Colors.deepOrangeAccent), ), ]), ), Text(&apos;第一列&apos;) ],), DecorationDecoration 的实现类：BoxDecoration、FlutterLogoDecoration、ShapeDecoration、UnderlineTabIndicator。 列表View中的多布局参考：https://www.jianshu.com/p/4a0185b5a8f5 123456789101112131415static Widget GetListWidget(BuildContext context, dynamic data) &#123; Widget widget; if(data.runtimeType == Feed) &#123; if (data.indexType != null) &#123; widget = NewsListWidget(context, data); &#125; else if (data.type == 2) &#123; widget = ListImageTop(context, data); &#125; else if (data.type == 0) &#123; widget = ActivityWidget(context, data); &#125; else if (data.type == 1) &#123; widget = ListImageRight(context, data); &#125; &#125;else&#123; widget = ColumnsListWidget(id: data[&apos;id&apos;],showType: data[&apos;showType&apos;],); &#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Future与FutureBuilder]]></title>
    <url>%2FFlutter-Future%E4%B8%8EFutureBuilder%2F</url>
    <content type="text"><![CDATA[Future与FutureBuilder 1. FutureFuture本身是异步操作。如果我们要将异步转同步，那么可以借助async 与await来完成。 Future有3种状态： pending ： 执行中； completed with value ： 执行结束-成功 completed with error：执行结束-失败； 1.1 操作符Future 本身拥有4种操作符。这4种操作符就可以对数据操作进行一系列完整的操作。 .then then这个操作中有2个参数，第1个参数会回调成功的结果，第2个参数onError 可选表示执行出现异常。 .catchError 如果catchError与onError同时存在，则会只调用onError； .timeout 完成一个异步操作可能需要很长的时间，比如：网络请求，但有时我们需要为异步操作单独设置一个超时时间，那么就是用到了Future中的timeout来设置超时时间。 .whenComplete 有时候我们需要在Future 结束 的时候做些事情，我们知道then().catchError()的模式类似于try-catch，但是try-catch有个finally{}代码块，而future.whenComplete就是Future的finally{}。 一个示例 1234567891011121314151617Future&lt;List&lt;Data&gt;&gt; getJokeDataByJson(String type) async &#123; Dio dio = new Dio(baseOptions); await dio.get(&quot;&quot;, queryParameters: params) .then&lt;List&lt;Data&gt;&gt;((data) &#123; Map&lt;String, dynamic&gt; news = jsonDecode(data.toString()); print(&quot;news is $&#123;news.toString()&#125;&quot;); &#125;, onError: (error) &#123; print(&apos;error is $&#123;error&#125;&apos;); &#125;). catchError((error) &#123; print(&apos;error is $&#123;error&#125;&apos;); &#125;) .whenComplete(() &#123; print(&apos;request over!&apos;); &#125;) .timeout(new Duration(seconds: 20));&#125; 1.2 执行顺序问题1.2.1 对象执行这里的执行顺序指的是：当有多个Future对象依次创建后，在执行时这多个对象的彼此之间的执行顺序。 123456789101112131415161718void orderTest()&#123; Future f1 = new Future(() =&gt; null); Future f2 = new Future(() =&gt; null); Future f3 = new Future(() =&gt; null); f2.then((_) &#123; print(&apos;f2&apos;); &#125;); f1.then((_) &#123; print(&apos;f1&apos;); &#125;); f3.then((_) &#123; print(&apos;f3&apos;); &#125;);&#125; 结果： 123f1f2f3 1.2.2 then执行123456789101112131415161718192021222324252627282930313233void orderTest()&#123; Future f1 = new Future(() =&gt; null); Future f2 = new Future(() =&gt; null); Future f3 = new Future(() =&gt; null); f2.then((_) &#123; f1.then((_)&#123; print(&apos;f2-&gt;f1&apos;); &#125;); print(&apos;f2&apos;); &#125;); f1.then((_) &#123; print(&apos;f1-&gt;f1&apos;); f2.then((_)&#123; print(&apos;f1-&gt;f2&apos;); &#125;); f3.then((_)&#123; print(&apos;f1-&gt;f3&apos;); &#125;); &#125;); f3.then((_) &#123; f1.then((_)&#123; print(&apos;f3-&gt;f1&apos;); &#125;); print(&apos;f3&apos;); f2.then((_)&#123; print(&apos;f3-&gt;f2&apos;); &#125;); &#125;);&#125; 结果： 12345678f1-&gt;f1f2f1-&gt;f2f2-&gt;f1f3f1-&gt;f3f3-&gt;f1f3-&gt;f2 结论： 简单的 执行顺序 和 创建Future对象 的 先后顺序 有关； 当 多个then嵌套执行 时 先外后内：先 按对象的创建顺序 执行 自身then，然后再执行已运行对象then中对当前对象then的调用 1.2.3 在then中创建Future对象123456789101112131415161718192021222324252627282930f2.then((_) &#123; f1.then((_)&#123; print(&apos;f2-&gt;f1&apos;); &#125;); print(&apos;f2&apos;); new Future(() =&gt; null).then((_)&#123; print(&apos;f2:this is the new Future&apos;); &#125;);&#125;);f1.then((_) &#123; print(&apos;f1&apos;); f2.then((_)&#123; print(&apos;f1-&gt;f2&apos;); &#125;); f3.then((_)&#123; print(&apos;f1-&gt;f3&apos;); &#125;);&#125;);f3.then((_) &#123; f1.then((_)&#123; print(&apos;f3-&gt;f1&apos;); &#125;); print(&apos;f3&apos;); f2.then((_)&#123; print(&apos;f3-&gt;f2&apos;); &#125;);&#125;); 结果： 123456789f1f2f1-&gt;f2f2-&gt;f1f3f1-&gt;f3f3-&gt;f1f3-&gt;f2f2:this is the new Future 2. FutureBuilderFutureBuilder 是一个将异步操作和异步UI更新 结合 在一起的类，通过它我们可以将网络请求、数据库读取等的结果更新在指定UI上。官方文档的描述是：它基于与[Future]交互的快照（snapshot）构建自己（which builds itself based on a snapshot from interacting with a [Future].）。 2.1 基本构造函数： 1234567const FutureBuilder(&#123; Key key, this.future, this.initialData, @required this.builder,&#125;) : assert(builder != null), super(key: key); 参数说明： future： Future的对象。表示此构建器当前连接的异步计算； initialData： 非null future完成之前的数据的初始快照。 builder： 是一个基于异步交互构建widget的函数； 即：FutureBuilder = Future + widget的封装。在FutureBuilder中，既对State的各个生命周期函数进行的重写，又通过Future中的各种操作符对数据进行处理，并在处理过程中提供了的结果处理的回调函数，供外界使用。 builder函数说明： 此函数有2个参数BuildContext context和AsyncSnapshot&lt;T&gt; snapshot，并返回一个Widget。AsyncSnapshot包含异步计算信息。它具有以下属性： connectionState 表示异步计算连接状态的枚举值，有四个值： none waiting active done data 异步计算接收的最新数据。 error 异步计算接收的最新错误对象。 2.2 源码###2.2.1 Future数据处理 与 State生命周期 Future的操作符处理的数据在State生命周期中的调用： 123456789101112131415161718192021222324252627282930313233343536373839class _FutureBuilderState&lt;T&gt; extends State&lt;FutureBuilder&lt;T&gt;&gt; &#123; Object _activeCallbackIdentity; AsyncSnapshot&lt;T&gt; _snapshot; @override void initState() &#123; super.initState(); _snapshot = AsyncSnapshot&lt;T&gt;.withData(ConnectionState.none, widget.initialData); _subscribe(); &#125; @override void didUpdateWidget(FutureBuilder&lt;T&gt; oldWidget) &#123; super.didUpdateWidget(oldWidget); if (oldWidget.future != widget.future) &#123; if (_activeCallbackIdentity != null) &#123; _unsubscribe(); _snapshot = _snapshot.inState(ConnectionState.none); &#125; _subscribe(); &#125; &#125; @override Widget build(BuildContext context) =&gt; widget.builder(context, _snapshot); @override void dispose() &#123; _unsubscribe(); super.dispose(); &#125; void _subscribe() &#123;&#125; void _unsubscribe() &#123; _activeCallbackIdentity = null; &#125;&#125; 源码中使用到的Sfate生命周期有3个，且都是调用了_subscribe()： initState() didUpdateWidget dispose() _subscribe() 源码：通过Future的操作符处理数据 1234567891011121314151617181920void _subscribe() &#123; if (widget.future != null) &#123; final Object callbackIdentity = Object(); _activeCallbackIdentity = callbackIdentity; widget.future.then&lt;void&gt;((T data) &#123; if (_activeCallbackIdentity == callbackIdentity) &#123; setState(() &#123; _snapshot = AsyncSnapshot&lt;T&gt;.withData(ConnectionState.done, data); &#125;); &#125; &#125;, onError: (Object error) &#123; if (_activeCallbackIdentity == callbackIdentity) &#123; setState(() &#123; _snapshot = AsyncSnapshot&lt;T&gt;.withError(ConnectionState.done, error); &#125;); &#125; &#125;); _snapshot = _snapshot.inState(ConnectionState.waiting); &#125;&#125; 在这个_subscribe() 中，调用了 future对象中的.then()并且重写了有数据的方法、onError()，重写的同时调用了State的setState()，使得Widget能够及时作出更新。 _snapshot 内部私有属性 通过对以上源码的阅读，可以发现在每一个State的生命周期方法中以及在_subscribe()数据处理方法中都用到了_snapshot这个内部私有属性，而且最重要的是在FutureBuilder这个类为我们的提供的暴露接口widget.builder(context, _snapshot)中，也用到了这个内部私有属性，而这个暴露给我的build()接口就是这个类中数据处理的终点，在供我们开发者具体使用时以达到： 1数据驱动布局。 总结： 在以上3个生命周期中对_subscribe()进行调用后，最终通过重写：widget.builder(context, _snapshot)，对外界暴露接口。 当我们自己在实现一个FutureBuilder对象时，除了编写一个Future实例，用来处理数据的操作之外，另一个重要的实现就是对widget.builder(context, _snapshot) 暴露的_snapshot根据业务需要进行处理。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart-const和final]]></title>
    <url>%2FDart-const%E5%92%8Cfinal%2F</url>
    <content type="text"><![CDATA[const和final 声明1234567891011121314151617181920void main() &#123; final name = &apos;Bob&apos;; // 正确 // name = &apos;Alice&apos;; // 错误。在编辑时报错：final 变量只能赋值一次 // const name1; // 错误。在编辑时报错：const变量是编译时常量，必须在声明时进行赋值初始化 // final name1; // 错误。在编辑时报错：final变量需要在声明时赋值进行初始化 const name2 = &apos;Alice&apos;; // 正确 // const name3 = name; // 错误。在编辑时报错：name是个变量，不能赋给const，只能使用常量进行赋值 final name4 = name2; // 正确，可以把const 常量赋给 final 变量 // final names1 = const[name, 3, 4]; // 错误。在编辑时报错：name是个变量，不能赋给const final names2 = const [name2, &apos;Allen&apos;, &apos;Brian&apos;]; const names3 = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]; // 正确。 const names4 = const [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; // 正确。 print(names3[1]); print(names4[1]);&#125; 相同点 声明的类型可以省略 12final (String 省略) str=&apos;123&apos;const (String 省略) str=&apos;123&apos; 初始化后不能再赋值 不能和var同时使用 不同点finalfinal：是运行时常量 — 只能被初始化一次，这个值可以在运行时确定当final修饰的是一个引用时，只是引用的值不能被改变，而引用指向的对象的属性如果不是常量的话是可以被任意改变的（这一点非常重要） constconst：是编译时常量 — 声明时就要赋一个具体的值 类中只有静态成员才能用const修饰，即：类级别常量使用：static const const需要是编译时常量 123final fl=DateTIme.now();const fl=DateTIme.now();//编译后报错//DateTime.now是运行时才能确定的常量，但const要求的是编译前就能确定 const可以用其它const常量来初始化值 123const a=1;const b=2;const sum=a*b; 使用const赋值声明，const可以省略 12const list=const [];const list=[];//也可 可以改非final、非const 变量值，即使曾经是const值 123456var list1= const [1,2,3];const list2= const [1,2,3];fial list3= const [1,2,3];list1=[1];list2=[2];//编译器直接报错list3=[3];//编译器直接报错 const导致的不可变性，是可以传递的 const变量的声明方式 1const names4 = const [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; 可以简写为： 1const names3 = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]; 参考以上： 12345final List ls=[1,2,3];ls[1]=0;//正确可以修改const List ls=[1,2,3];ls[1]=0;//编译后报错，不可以修改const的不可变性传递给了它的子元素 就说明 const List ls=[1,2,3] 实际上就是对变量：ls 和 值：[1,2,3]，都是用了const，都进行了约束。 相同的const常量不会在内存中重复创建 123456final List ls=[1,2,3];final List ls2=[1,2,3];//打印后不相等两内存不同const List ls=[1,2,3];const List ls2=[1,2,3];//打印后不相等两内存相同]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-导航与路由]]></title>
    <url>%2FFlutter-%E5%AF%BC%E8%88%AA%E4%B8%8E%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[Navigator、Router 与 Path 的概念 Flutter的路由（Router）和导航（Navigator）功能可帮助你管理应用中屏幕之间的命名和过渡。 管理多个页面时有两个核心概念和类：Route和 Navigator： route 是一个屏幕或页面的 抽象； Navigator 是管理route的Widget。Navigator可以通过route 入栈（push） 和 出栈（pop） 来实现页面之间的 跳转。 RouterMaterialPageRoute：关使用平台自适应转换替换整个屏幕的路由OverlayEntry： 由导航器管理的条目的抽象。 此类定义导航器和路径之间的抽象接口，这些接口被压入并从导航器中弹出。大多数路线都具有视觉功能，它们使用一个或多个OverlayEntry对象放置在导航器Overlay中。 Navigator一个小部件，用于管理具有堆栈规则的一组子小部件。 许多应用程序在其窗口小部件层次结构的顶部附近有一个导航器，以便使用Overlay显示其逻辑历史记录，最近访问过的页面可视化地显示在旧页面之上。使用此模式，导航器可以通过在叠加层中移动小部件来直观地从一个页面转换到另一个页面。类似地，导航器可用于通过将对话框小部件定位在当前页面上方来显示对话框。 使用导航器移动应用程序通常通过称为“屏幕”或“页面”的全屏元素显示其内容。在Flutter中，这些元素称为路径，它们由Navigator小部件管理。导航器管理一堆Route对象，并提供管理堆栈的方法，如Navigator.push()和Navigator.pop()。 例子： 12345678910111213141516onTap: () &#123; Navigator.push(context, MaterialPageRoute&lt;void&gt;(builder: (BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text(&quot;界面跳转了&quot;)), body: Center( child: FlatButton( onPressed: () &#123; Navigator.pop(context); &#125;, child: Text(&quot;退出&quot;)), ), ); &#125;)); tapListener(index, data); &#125;, 说明： 在使用Navigator.push()时，通常可以添加Navigator.pop()，因为 Scaffold 会自动向AppBar添加返回按钮，而此按钮执行的代码就是Navigator.pop() 在Android上，按下系统后退按钮也可以做同样的事情。 全屏Route虽然您可以直接创建导航器，但最常见的是使用由WidgetsApp或MaterialApp小部件创建的导航器。您可以使用Navigator.of引用该导航器。 命名式Route移动应用程序通常管理大量路由，通常最容易通过名称引用它们。按照惯例，路径名称使用类似路径的结构（例如，&#39;/ a / b / c&#39;）。应用程序的主页路由默认名为“/”。 可以使用Map&lt;String，WidgetBuilder&gt;创建MaterialApp，它将路径名称 映射到将创建它的builder函数。MaterialApp使用此 映射 为其导航器的onGenerateRoute回调创建值。 带返回值的Route弹出式Route自定义Route]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Widget]]></title>
    <url>%2FFlutter-Widget1%2F</url>
    <content type="text"><![CDATA[Widget相关 StatefulWidget StatelessWidget InheritedWidget Widget BuildContext RenderObjectWidget RenderObject 动画帧? KeyKey是Widgets，Elements和SemanticsNodes的标识符。如果新窗口小部件的Key与该元素关联的当前窗口小部件的Key相同，则新窗口小部件将仅用于更新现有元素。Key必须在具有相同父级的元素中是唯一的。Key的子类应该是LocalKey或GlobalKey的子类。 可以使用key来控制框架将在widget重建时与哪些其他widget匹配。默认情况下，框架根据它们的runtimeType和它们的显示顺序来匹配。 使用key时，框架要求两个widget具有相同的key和runtimeType。 Key在构建相同类型widget的多个实例时很有用。例如，ShoppingList构建足够的ShoppingListItem实例以填充其可见区域： 如果没有key，当前构建中的第一个条目将始终与前一个构建中的第一个条目同步，即使在语义上，列表中的第一个条目如果滚动出屏幕，那么它将不会再在窗口中可见。 通过给列表中的每个条目分配为“语义” key，无限列表可以更高效，因为框架将同步条目与匹配的语义key并因此具有相似（或相同）的可视外观。 此外，语义上同步条目意味着在有状态子widget中，保留的状态将附加到相同的语义条目上，而不是附加到相同数字位置上的条目。 子类： abstract LocalKey：在具有相同父级的Element中，键必须是唯一的。 ValueKey：使用特定类型的 值 来标识自身的Key UniqueKey：一个只与自身相等的Key。 ObjectKey：从用作其值的对象获取其标识的Key。 abstract GlobalKey：在整个应用中必须是唯一的。 LabeledGlobalKey：该标签纯粹用于调试，不用于比较密钥的标识 GlobalObjectKey：一个全局Key，它从用作其值的对象中获取其标识。 由于Key的runtimeType是其标识的一部分，因此这将防止与其他 GlobalObjectKey 的冲突，即使它们具有相同的值。 GlobalKey可以使用GlobalKey来唯一标识子widget。GlobalKey在整个widget层次结构中必须是全局唯一的，这与局部key不同，后者只需要在同级中唯一。由于它们是全局唯一的，因此可以使用GlobalKey来检索与widget关联的状态。 InheritedWidget小部件的基类，可以有效地在树中传播信息。 要从构建上下文获取特定类型的继承窗口小部件的最近实例，请使用BuildContext.inheritFromWidgetOfExactType。 Widget 描述( Element)元素的配置。 1Describes the configuration for an Element. （为Element提供配置信息） 实际上，Flutter中的大多数Widget都只是其他更简单的Widget的组合。组合而不是继承 是构建小部件的 主要机制。 Widget是Flutter框架中的中心类等级，是用户界面的一部分的不可变描述，可以填充为元素，这些元素管理底层渲染树。 Widget本身没有可变状态（所有字段必须是final的），如果你希望将可变状态与窗口Widget相关联，可以考虑使用StatefulWidget，它会在它填充成元素并合并到树中时创建一个State对象（通过StatefulWidget.createState）。 Widget是不可变的。因为它们会直接被替换。 为什么 StatefulWidget与State是单独的对象？在Flutter中，这2种类型的对象具有不同的生命周期： Widget 是 临时 对象，用于构造应用程序 当前状态的表示 —— 这也是为什么在Widget中的字段变量并定义为final的原因。 State 对象在调用 build() 之前是持久的 ，允许它们记住信息。 给定的Widget可以0次或多次包含在树中，特别地，给定的窗口小部件可以多次放置在树中。每次将小部件放置在树中时，它都会填充为元素，这意味着多次合并到树中的小部件将被多次填充。 key属性控制一个小部件如何替换树中的另一个小部件。如果两个小部件的runtimeType和key属性分别是operator ==，则新小部件通过更新底层元素（即，通过使用新小部件调用Element.update）来替换旧小部件。否则，将从树中删除旧元素，将新窗口小部件扩展为元素，并将新元素插入树中。 StatefulWidget具有可变状态的小部件。 描述的用户界面部分可以动态更改，是一个有状态窗口小部件，它通过构建一个更具体地描述用户界面的其他窗口小部件来描述用户界面的一部分。构建过程以递归方式继续，直到用户界面的描述完全具体（例如，完全由RenderObjectWidget组成，其描述具体的RenderObject）。 StatefulWidget 实例本身是不可变的，它们的可变状态存储在由createState()方法创建的单独State对象中 ，或者存储在State订阅的对象中，例如Stream或ChangeNotifier对象，其引用存储在StatefulWidget本身的final字段中。 框架在填充StatefulWidget时调用createState()，这意味着如果该窗口小部件已插入到多个位置的树中，则多个State对象可能与同一StatefulWidget关联。同样，如果StatefulWidget从树中移除，后来在树再次插入时，框架将调用createState()再创建一个新的State目标，简化State对象的生命周期。 如果StatefulWidget的创建者使用GlobalKey作为其key，则StatefulWidget在从树中的一个位置移动到另一个位置时保持相同的State对象。由于具有GlobalKey的窗口小部件可以在树中的至多一个位置使用，因此使用GlobalKey的窗口小部件最多只有一个关联元素。当使用GlobalKey从树中的一个位置移动窗口小部件时，框架利用此属性，方法是将与该窗口小部件关联的（唯一）子树从旧位置移植（而不是在新位置重新创建子树）到新位置。与StatefulWidget关联的State对象与子树的其余部分一起被移植，这意味着State对象在新位置被重用（而不是被重新创建）。但是为了有资格进行嫁接，必须将窗口小部件插入到从旧位置移除它的同一动画帧中的新位置。 性能考虑因素StatefulWidget有两个主要类别。 第一类是在State.initState()中分配资源并在State.dispose()中处理它们的，但它不依赖于InheritedWidgets或调用State.setState()。此类窗口小部件通常在应用程序或页面的根目录中使用，并通过ChangeNotifiers，Streams或其他此类对象与子窗口小部件进行通信。遵循这种模式的有状态小部件相对便宜（就CPU和GPU周期而言），因为它们构建一次然后永不更新。因此，它们可能有一些复杂和深刻的构建方法。 第二类是使用State.setState()或依赖于InheritedWidgets的小部件。这些通常会在应用程序的生命周期内重建多次，因此最小化(尽量减少)重建此类窗口小部件的影响非常重要（他们也可以使用State.initState或State.didChangeDependencies并分配资源，但重要的是他们重建。）。 可以使用一下几种技术来最小化重建有状态窗口小部件的影响： 将状态推到树叶上。例如，如果您的页面有一个滴答时钟，应该创建一个仅更新自身的专用时钟小部件，而不是将状态置于页面顶部并在每次时钟滴答时重建整个页面。 最小化构建方法及其创建的任何窗口小部件传递创建的节点数。理想情况下，有状态窗口小部件只会创建一个窗口小部件，而该窗口小部件将是一个RenderObjectWidget（显然这并不总是实用的，但是小部件越接近这个理想，它就越有效率。）。 如果子树没有改变，缓存表示该子树的小部件，并每次当它可用时可以使用重新使用它。对于要重新使用的窗口小部件而言，要比创建新的（但配置相同的）窗口小部件更有效。将有状态部分分解为带有子参数的小部件是执行此操作的常用方法。 尽可能使用const小部件。 （这相当于缓存窗口小部件并重新使用它。） 避免更改任何创建的子树的深度或更改子树中任何窗口小部件的类型。这是因为更改子树的深度、布局和绘制整个子树需要重建，而只更改属性将需要对渲染树进行尽可能少的更改。 如果由于某种原因必须改变深度，考虑在具有GlobalKey的小部件中包装子树的公共部分，这对状态小部件的生命保持一致（如果没有其他小部件可以方便地分配key，则KeyedSubtree小部件可能对此有用。）。 StatelessWidget一个不需要可变状态的小部件。 无状态窗口小部件是一个窗口小部件，它通过构建一个更具体地描述用户界面的其他窗口小部件来描述用户界面的一部分。构建过程以递归方式继续，直到用户界面的描述完全具体（例如，完全由RenderObjectWidget组成，其描述具体的RenderObject）。 当描述的用户界面部分不依赖于对象本身的配置信息以及窗口小部件填充的BuildContext时，无状态窗口小部件非常有用。对于可以动态更改的组合，例如由于具有内部时钟驱动状态或依赖于某些系统状态，请考虑使用StatefulWidget。 性能考虑因素无状态窗口小部件的构建方法通常仅在以下3种情况下调用： 第1次将窗口小部件插入树中时； 窗口小部件的父窗口更改其配置时； 何时依赖于更改的InheritedWidget。 如果窗口小部件的父级将定期更改窗口小部件的配置，或者它依赖于经常更改的继承窗口小部件，则优化构建方法的性能以保持流畅的呈现性能非常重要： 最小化构建方法及其创建的任何窗口小部件传递创建的节点数。例如，考虑使用Align或CustomSingleChildLayout，而不是精心安排Rows、Columns、Paddings和SizedBoxes来以特别奇特的方式定位单个child。考虑单个CustomPaint小部件，而不是多个容器的复杂分层和装饰以绘制恰当的图形效果。 尽可能使用const小部件，并为小部件提供const构造函数，以便小部件的用户也可以这样做。 考虑将无状态窗口小部件重构为有状态窗口小部件，以便它可以使用StatefulWidget中描述的一些技术，例如缓存子树的公共部分以及在更改树结构时使用GlobalKeys。 如果由于使用InheritedWidgets而可能经常重建窗口小部件，请考虑将无状态窗口小部件重构为多个窗口小部件，并将更改的树部分推送到树叶。例如，不是构建具有四个小部件的树，而是取决于主题的最内部小部件，考虑将构建函数的部分分解出来 RenderObjectWidgetRenderObjectWidgets提供RenderObjectElement的配置，它包装RenderObject，它提供应用程序的实际呈现。 12345678910111213141516171819202122232425abstract class RenderObjectWidget extends Widget &#123; /// 抽象const构造函数。 /// 此构造函数使子类能够提供const构造函数，以便它们可以在const表达式中使用。 const RenderObjectWidget(&#123; Key key &#125;) : super(key: key); /// RenderObjectWidgets总是膨胀为[RenderObjectElement]子类。 @override RenderObjectElement createElement(); ///使用此[RenderObjectWidget]描述的配置创建此[RenderObjectWidget]表示的[RenderObject]类的实例。 /// 此方法不应对渲染对象的子项执行任何操作。 /// 应该由覆盖此对象的[createElement]方法呈现的对象中的[RenderObjectElement.mount]的方法来处理。 例如，请参见[SingleChildRenderObjectElement.mount]。 @protected RenderObject createRenderObject(BuildContext context); /// 将此[RenderObjectWidget]描述的配置复制到给定的[RenderObject]，该类型与此对象的[createRenderObject]返回的类型相同。 /// 此方法不应执行任何操作来更新渲染对象的子项。 相反，应该由覆盖此对象的[createElement]方法呈现的对象中的[RenderObjectElement.update]的方法来处理。 例如，参见[SingleChildRenderObjectElement.update]。 @protected void updateRenderObject(BuildContext context, covariant RenderObject renderObject) &#123; &#125; /// 以前与此窗口小部件关联的渲染对象已从树中删除。 /// 给定的[RenderObject]与此对象的[createRenderObject]返回的类型相同。 @protected void didUnmountRenderObject(covariant RenderObject renderObject) &#123; &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart-网络]]></title>
    <url>%2FDart-%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[网络 Dio]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart/Flutter-JSON使用]]></title>
    <url>%2FDart%3AFlutter-JSON%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JSON使用 JSON序列化方式选择使用JSON的两种常规策略： 手动序列化 使用代码生成进行自动序列化 较小的项目：手动序列化手动JSON解码是指使用内置的JSON解码器 dart:convert（JSON和UTF-8的转换器（JSON需要的字符编码））。 它涉及将原始JSON字符串传递给jsonDecode()函数，然后在结果中查找所需的值 Map&lt;String, dynamic&gt;。它没有外部依赖性或特定的设置过程，它有利于快速验证概念。 当项目变大时，手动解码效果不佳。手动编写解码逻辑可能变得难以管理且容易出错。 中大型项目：自动序列化使用代码生成的JSON序列化意味着有一个外部库来生成代码样板。进行一些初始设置后，运行一个 文件监视器，从模型类生成代码。例如， json_serializable 和 built_value 就是这些类型的库。 json_serializable：易于使用的代码生成包。添加一些元数据据注释并使用此包提供的builder（构建器）时，Dart构建系统会为您生成序列化和反序列化代码，此外代码生成的需要一些初始设置。 built_value：强大、json_serializable的替代品 Flutter中有 GSON/Jackson/Moshi 等价产物吗？没有 –&gt; 在 Flutter中禁用反射 –&gt; 影响 tree shaking（树抖动） –&gt; 影响App大小优化 Such a library would require using runtime reflection, which is disabled in Flutter. Runtime reflection interferes with tree shaking, which Dart has supported for quite a long time. With tree shaking, you can “shake off” unused code from your release builds. This optimizes the app’s size significantly. 由于反射使得默认情况下隐式使用所有代码，因此使tree shaking（树摇动）变得困难。这些工具无法知道运行时哪些部分未使用，因此冗余代码很难被删除。使用反射时，无法轻松优化应用程序大小。 Flutter 不支持 reflection（反射），但是Dart支持。在Dart中有 dartson ，这个库使用的就是 运行时反射。这使得它与Flutter不兼容。 手动序列化JSON - dart:convertFlutter有一个内置的dart:convert，包括一个简单的JSON编码器和解码器。 一个用于测试的用户model 1234&#123; &quot;name&quot;: &quot;John Smith&quot;, &quot;email&quot;: &quot;john@example.com&quot;&#125; 通过“内联”序列化JSON实现： 123456void convertWithInLine(String userModel) &#123; // JSON的数据格式本质：Map的&quot;键值对&quot;类型 Map&lt;String, dynamic&gt; user = jsonDecode(userModel); print(&apos;user name is : $&#123;user[&apos;name&apos;]&#125;&apos;); print(&apos;user name is : $&#123;user.toString()&#125;&apos;);&#125; 结果： 12user name is : 张三user name is : &#123;name: 张三, age: 24&#125; 不幸的是，jsonDecode()返回一个Map&lt;String，dynamic&gt;，这意味着在运行时之前你不知道值的类型。而且使用这种方法，您将丢失大多数静态类型语言功能： 类型安全性； 自动完成； 最重要的：编译时异常。 最终代码将立即变得更容易出错。 说的明白一点就是：这样虽然在转化的过程简单、快速，不用自己创建User bean类，但是潜在的问题也在这个地方，正是因为不知道bean类的内部数据结构，所以在使用这个json转化的结果时，是无法准确的描述要使用的字段。 简言之：前期转换省事，后期使用费事 通过“内置Model类”序列化JSON这种转换方式就是：通过引入名为User Model类来解决前面提到的问题。使用User Model类，你可以： 使用 User.fromJson()构造函数，用于从map结构构造新的User实例。 一个toJson()方法，它将User实例转换为map。 使用这种方法，调用代码可以具有：类型安全性，name和age字段的自动完成以及编译时异常。此外：如果因为输入拼写错误或将字段类型错误，那么应用程序将无法编译，而不是在运行时崩溃。 User.dart 123456789101112131415class User &#123; final String name; final int age; User(this.name, this.age); User.formJson(Map&lt;String, dynamic&gt; json) : name = json[&apos;name&apos;], age = json[&apos;age&apos;]; Map&lt;String, dynamic&gt; toJson() =&gt; &#123; &apos;name&apos;: name, &apos;age&apos;: age, &#125;;&#125; 解码逻辑的责任现在在Model本身内部，使用这种新方法，您可以轻松解码userModel。 解码转换： 123456void convertWithInLine(String userModel) &#123; Map userTemp = jsonDecode(userModel); var user2 = User.formJson(userTemp); print(&apos;user2 name is : $&#123;user2.name&#125;&apos;); print(user2.toString());&#125; 结果： 12user2 name is : 张三User&#123;name: 张三, age: 24&#125; 在这种方式中，获取name属性的方式也不同了，使用的是user2.name而不是user[&#39;name&#39;]的方式。 编码转换： 123456void convertWithInLine(String userModel) &#123; var json = jsonEncode(user2); print(&apos;json by jsonEncode is : $&#123;json&#125;&apos;); var json2 = user2.toJson(); print(&apos;json by user.toJson() is : $&#123;json2&#125;&apos;);&#125; 结果为： 12json by jsonEncode is : &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:24&#125;json by user.toJson() is : &#123;name: 张三, age: 24&#125; 要对user2进行编码，将User对象传递给jsonEncode()函数。你不需要调用toJson()方法，因为jsonEncode()已经为你做了。既然这2中方式都能实现编码，那么直接使用jsonEncode()有什么好处呢？ 使用这种方法，调用代码根本不必担心JSON序列化.但是，model类仍然必须设置。因为在生产应用程序中需要确保序列化正常工作。实际上，User.fromJson()和User.toJson()方法都需要进行单元测试以验证正确的行为。 缺点：自己只能手动编写一些简单的 JSON Model类，一旦复杂就容易出错。 但是，现实场景通常不那么简单。您不太可能使用如此小的JSON响应。嵌套的JSON对象也是常用的。如果有一些东西可以为你处理JSON编码和解码，那就太好了。幸运的是，有！ 使用代码生成库自动序列化JSONjson_serializable包，这是一个自动生成的源代码生成器，可为生成JSON序列化样板。 由于序列化代码不再是手动或手动维护的，因此可以最大限度地降低在运行时出现JSON序列化异常的风险。 在项目中设置“json_serializable”要在项目中包含json_serializable，您需要一个常规依赖项和两个dev依赖项。简而言之：dev依赖项是我们的应用程序源代码中未包含的依赖项 - 它们仅在开发环境中使用。 添加： 123456dependencies: json_annotation: ^2.0.0dev_dependencies: build_runner: ^1.0.0 json_serializable: ^2.0.0 然后运行 flutter pub get 来使这些新的依赖项在您的项目中可用。 以“json_serializable”方式创建Model类注意：Model类名一定要和其所在的文件名相同，否则不能执行生成代码操作 User.dart 1234567891011121314151617181920212223import &apos;package:json_annotation/json_annotation.dart&apos;;// 这允许`User`类访问私有成员生成的文件——*.g.dart，其中*表示源文件名。part &apos;User.g.dart&apos;;// 代码生成器的注释，知道此类需要生成的JSON序列化逻辑。@JsonSerializable()class User&#123; final String userName; final int userAge; User(this.userName, this.userAge); // 用于从map创建新User实例的必要工厂构造函数。 // 将映射传递给生成的`_$UserFromJson()`构造函数。 // 构造函数以源类命名，在本例中为User。 factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json); // toJson()是类的约定，用于声明对JSON的序列化支持。 // 该实现只是调用私有的,生成的辅助方法`_$UserToJson`。 Map&lt;String,dynamic&gt; toJson() =&gt; _$UserToJson(this);&#125; 通过此设置，源代码生成器就能对来自于JSON的name和age字段进行编码和解码 运行代码生成实用程序在第一次创建json_serializable类时，将得到类似于下图所示的错误。 无需慌张，这些错误完全正常，仅仅是因为Model类的生成代码尚不存在。要解决此问题，运行生成序列化样板的代码生成器即可。 有两种运行代码生成器的方法： 一次性代码生成 通过在项目根目录中运行flutter pub run build_runner build（首次运行命令，需要自动下载相关Dart SDK），可以在需要时为Model生成JSON序列化代码。 这会触发一次性构建，该构建：遍历源文件、选择相关文件，并为它们生成必要的序列化代码。 然这很方便，但如果不必每次在Model类中进行更改时都必须手动运行构建，那将会更加方便！ 不断生成代码 观察者使我们的源代码生成过程更加方便。它会监视项目文件中的更改，并在需要时自动构建必要的文件。 通过在项目根目录中运行flutter pub run build_runner watch（首次运行命令，需要自动下载相关Dart SDK）来启动观察程序。启动一次观察器并使其在后台运行是安全的。 当执行成功之后，在终端将会显示： 12345678910111213[INFO] Starting Build[INFO] Updating asset graph...[INFO] Updating asset graph completed, took 17ms[INFO] Running build...[INFO] Running build completed, took 143ms[INFO] Caching finalized dependency graph...[SEVERE] The outputs field in xflutter|lib/json_test/User.g.dart references a non-existent asset xflutter|lib/json_test/JsonAutoConvert.json_serializable.g.part and will corrupt the asset graph. If you encounter this error please copy the details from this message and add them to https://github.com/dart-lang/build/issues/1804.[INFO] Caching finalized dependency graph completed, took 10ms[INFO] Succeeded after 173ms with 2 outputs (3 actions) 同时在 Model类的同级目录下将会生成在Model类文件中配置part &#39;User.g.dart&#39;;中的User.g.dart文件： 12345678910111213141516// GENERATED CODE - DO NOT MODIFY BY HANDpart of &apos;User.dart&apos;;// **************************************************************************// JsonSerializableGenerator// **************************************************************************User _$UserFromJson(Map&lt;String, dynamic&gt; json) &#123; return User(json[&apos;userName&apos;] as String, json[&apos;userAge&apos;] as int);&#125;Map&lt;String, dynamic&gt; _$UserToJson(User instance) =&gt; &lt;String, dynamic&gt;&#123; &apos;userName&apos;: instance.userName, &apos;userAge&apos;: instance.userAge &#125;; 观察 _$UserToJson(User instance) 方法后就会发现这个代码实现和我们自己手动的代码是一样的。这是我们手动编写的： 123456789101112131415class User &#123; final String name; final int age; User(this.name, this.age); User.formJson(Map&lt;String, dynamic&gt; json) : name = json[&apos;name&apos;], age = json[&apos;age&apos;]; Map&lt;String, dynamic&gt; toJson() =&gt; &#123; &apos;name&apos;: name, &apos;age&apos;: age, &#125;;&#125; 使用json_serializable模型不管是手动处理还是自动处理其使用方式都是一样的： 123456var map = jsonDecode(userModel);var result = User.formJson(map);print(&apos;Json Serializable result is : $&#123;result.name&#125;&apos;);var encode = jsonEncode(result);print(&apos;encode is $&#123;encode&#125;&apos;); 结果为： 12Json Serializable result is : 张三encode is &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:24&#125; 第三方处理方式一个网址 来源：https://flutter.dev/docs/development/data-and-backend/json]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart-异步支持]]></title>
    <url>%2FDart-%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[Dart-异步支持：Future与Stream Dart中的异步编程以Future和Stream类为特征，而且Dart库中包含许多返回Future对象或Stream对象的异步函数：它们在设置可能耗时的操作（例如I/O）后返回，而不等待该操作完成。 Future与Streams的区别： 一个Future表示：不立即完成的计算。 在普通函数返回结果的地方，异步函数返回一个包含结果的Future。当结果准备好之后future对象将会告诉你。 一个 stream 是一系列异步事件。它就像一个异步的Iterable-where，而不是在你要求它时获得下一个事件，在它准备就绪一个事件时流会告诉你。（It is like an asynchronous Iterable—where, instead of getting the next event when you ask for it, the stream tells you that there is an event when it is ready. ） 异步编程：Future与async-await说明： Future：Dart中的异步操作结果接收类 async：Dart中的关键字 await：Dart中的关键字，其修饰的是一个表达式。 isolate：Dart中进行同时运行的类 要点 Dart代码运行在一个单一的执行线程中 阻止执行线程的代码可以使程序冻结。 Future 代表 异步操作 的 结果（处理任务或I/O任务稍后完成）。 要暂停执行直到将来完成，请在异步函数中使用await。 要捕获错误，请在异步函数中使用try-catch表达式。 要同时运行代码，请创建isolate(隔离)（或Web应用程序，工作者）。 异步操作可让程序在等待操作完成时完成其他工作。Dart使用Future对象（future）来表示异步操作的结果。要使用future，可以使用async和await或Future API，async和await关键字支持异步编程，能够编写出看起来类似于同步代码的异步代码。。 注意： 所有Dart代码都在isolate的上下文中运行，该isolate拥有Dart代码使用的所有内存。 如果希望Dart代码的多个部分同时运行，您可以在单独的isolate中运行它们。（Web应用程序使用workers而不是isolates。）多个isolate同时运行，通常每个isolate都在自己的CPU核心上运行。isolate不共享内存，它们可以互动的唯一方式是通过彼此发送消息。 future是什么？一个 future 是Future &lt;T&gt;对象，表示产生类型T的异步操作的结果。如果结果是不可用值，则future的类型为Future &lt;void&gt;。当调用返回future的函数时，会发生两件事： 该函数将要完成的工作排队并返回未完成的Future对象。 稍后，当操作完成时，Future对象将以值或错误完成。 那么，编写依赖于 future 的代码时，你有两种选择： 使用async和await 组合 使用 Future API async与awaitasync和await关键字是Dart语言异步支持的一部分。它们允许你编写看起来像同步代码的异步代码，而不使用Future API。 异步函数是在其正文之前具有async关键字的函数。 await关键字仅适用于异步函数。 注意：在Dart 1.x中，异步函数立即暂停执行；在Dart 2中，异步函数不是立即挂起，而是同步执行，直到第一个等待或返回。 以下应用程序模拟使用async读取新闻并等待读取此站点上文件的内容 12345678910111213141516171819202122232425262728293031323334import &apos;dart:async&apos;;void main()&#123; printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore();&#125;Future&lt;void&gt; printDailyNewsDigest() async &#123; var newsDigest = await gatherNewsReports(); print(newsDigest);&#125;const news = &quot;this is the news&quot;;const oneSecond = Duration(seconds: 1);Future&lt;String&gt; gatherNewsReports() &#123; return Future.delayed(oneSecond, () =&gt; news);&#125;printWinningLotteryNumbers() &#123; print(&apos;Winning lotto numbers: [23, 63, 87, 26, 2]&apos;);&#125;printWeatherForecast() &#123; print(&quot;Tomorrow&apos;s forecast: 70F, sunny.&quot;);&#125;printBaseballScore() &#123; print(&apos;Baseball score: Red Sox 10, Yankees 0&apos;);&#125; 运行结果： 12345Winning lotto numbers: [23, 63, 87, 26, 2]Tomorrow&apos;s forecast: 70F, sunny.Baseball score: Red Sox 10, Yankees 0// 注意：“this is the news” 这条结果是经过 1s 的延时后打印出来的。this is the news 值得注意的是：printDailyNewsDigest()是第一个被调用的函数，但即使文件只包含一行，新闻也是最后要打印的内容。这是因为读取和打印文件的代码是异步运行的。 其运行步骤为； 描述： 该应用程序开始执行。 main() 函数调用 异步函数printDailyNewsDigest()，它开始 执行同步。 printDailyNewsDigest() 使用 await 来调用开始执行的函数 gatherNewsReports()。 gatherNewsReports() 函数返回未完成的 future（Future 的实例）。 因为 printDailyNewsDigest() 是一个异步函数并且正在等待一个值，所以它会暂停执行并将未完成的future（在本例中为Future 的实例）返回给它的调用者（main()）。 执行剩余的打印功能。因为它们是同步的，所以在继续下一个打印功能之前，每个功能都会完全执行。例如，在打印天气预报之前打印中奖彩票号码。 当main() 完成执行时，异步函数可以恢复执行。首先，通过完成gatherNewsReports()函数返回future。然后printDailyNewsDigest()继续执行，打印新闻。 当printDailyNewsDigest() 函数体完成执行时，它最初返回的future完成，并且应用程序退出 注意，异步功能立即开始执行（同步）。它达到以下任何一个第一次出现的情形时，该函数暂停执行并返回未完成的future： 函数的第一个await表达式（在函数从该表达式获取未完成的future之后）。 函数中的任何return语句。 函数体的结束。 处理错误如果Future-returns函数因错误而完成，您可能希望捕获该错误。异步函数可以使用try-catch处理错误： 12345678Future&lt;void&gt; printDailyNewsDigest() async &#123; try &#123; var newsDigest = await gatherNewsReports(); print(newsDigest); &#125;catch (e) &#123; print(e); &#125;&#125; try-catch代码的异步代码的行为方式与同步代码的行为方式相同：如果try块中的代码抛出异常，则catch子句中的代码将执行。 await特性可以使用多个await表达式来确保每个语句在执行下一个语句之前完成： 12345main() async &#123; await expensiveA(); await expensiveB(); doSomethingWith(await expensiveC());&#125; 在 expensiveA() 完成之前expensiveB()函数不会执行，依此类推。 在await表达式中，表达式的值通常是Future;如果不是，那么该值将自动包装在Future中。此Future对象表示返回对象的承诺。await表达式的值是返回的对象。 await表达式使执行暂停，直到该对象可用。 如果在使用await时遇到编译时错误，请确保await在异步函数中。例如，要在应用程序的main()函数中使用await，main()的主体必须标记为async： 1234Future main() async &#123; checkVersion(); print(&apos;In main: version is $&#123;await lookUpVersion()&#125;&apos;);&#125; 注意：await 修饰的是一个表达式。一个例子： 123Future&lt;void&gt; printDailyNewsDigest() async &#123; print(&apos;get the news data is : $&#123;await gatherNewsReports()&#125;&apos;);&#125; print(&#39;get the news data is : ${await gatherNewsReports()}&#39;); 就说明了 await 修饰的就是一个表达式。 异步编程：Streams要点： Streams提供异步数据序列。 数据序列包括用户生成的事件和从文件读取的数据。 您可以使用来自Stream API的await for或listen()来处理流。 Streams提供了一种响应错误的方法。 有两种流：单一订阅和广播。 从流中获取事件，有2种方式： 使用async和异步for循环（‘await for’）。 使用Stream API 接收流事件Streams可以通过多种方式创建，但它们都可以以相同的方式使用：异步for循环（通常称为 &#39;await for&#39;）迭代流的事件，就像for循环迭代Iterable一样。 一个例子，该函数使用async关键字标记，这在使用await for循环时是必需的。： 1234567Future&lt;int&gt; sumStream(Stream&lt;int&gt; streams) async &#123; var sum = 0; await for(var value in streams)&#123; sum += value; &#125; return sum;&#125; 此代码只接收整数事件流的每个事件，将它们相加，然后返回总和。循环体结束时，函数暂停，直到下一个事件到达或流完成。 使用async *函数生成简单的整数流来测试上面这个用例： 12345Stream&lt;int&gt; countStream(int to) async* &#123; for (int i = 1; i &lt; to; i++) &#123; yield i; &#125;&#125; 使用流Stream类包含许多辅助方法，可以为您在流上执行常见操作，类似于Iterable上的方法。例如，可以使用Stream API中的lastWhere()在流中找到最后一个正整数。 1Future&lt;int&gt; lastPositives(Stream&lt;int&gt; stream) =&gt; stream.lastWhere((x) =&gt; x &gt;= 0); 两种流单个订阅流 最常见的流包含一系列事件，这些事件是更大整体的一部分。事件需要以正确的顺序传递，而不会遗漏任何事件。 这样的流 只能被听一次。稍后再次倾听可能意味着错过了初始事件，然后流的其余部分毫无意义。当您开始收听时，将获取数据并以块的形式提供。 例子一个，这个例子描述的是上面例子的总和： 123456789101112131415161718192021222324Future&lt;int&gt; sumStream(Stream&lt;int&gt; streams) async &#123; var sum = 0; await for(var value in streams)&#123; sum += value; &#125; return sum;&#125;// 生成StreamStream&lt;int&gt; countStream(int to) async* &#123; for (int i = 1; i &lt; to; i++) &#123; yield i; &#125;&#125;Future&lt;int&gt; lastPositives(Stream&lt;int&gt; stream) =&gt; stream.lastWhere((x) =&gt; x &gt;= 0);void main() async&#123; var countStreamVal = countStream(10); var sumStreamVal = await sumStream(countStreamVal); print(sumStreamVal); var lastPositivesVal = await lastPositives(countStreamVal); print(lastPositivesVal);&#125; 结果是什么呢？ 结果是： 123456789101112131445Unhandled exception:Bad state: Stream has already been listened to.#0 _StreamController._subscribe (dart:async/stream_controller.dart:668:7)#1 _ControllerStream._createSubscription (dart:async/stream_controller.dart:818:19)#2 _StreamImpl.listen (dart:async/stream_impl.dart:472:9)#3 Stream.lastWhere (dart:async/stream.dart:1352:25)#4 lastPositives (package:xflutter/async/StreamsTest.dart:17:57)#5 main (package:xflutter/async/StreamsTest.dart:23:32)&lt;asynchronous suspension&gt;#6 _startIsolate.&lt;anonymous closure&gt; (dart:isolate-patch/isolate_patch.dart:301:19)#7 _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:172:12)Process finished with exit code 255 在结果中，我们看到了具体的异常：Bad state: Stream has already been listened to.。意思是说这个流已经被监听过 一次了，所以报了这个错误。而这个错误的产生就是因为这个流是： 单个订阅流。 要这个main()正常运行，我们就要根据单个订阅流的特点进行修改： 1234567void main() async&#123; var countStreamVal = countStream(10); //var sumStreamVal = await sumStream(countStreamVal); //print(sumStreamVal); var lastPositivesVal = await lastPositives(countStreamVal); print(lastPositivesVal);&#125; 结果为： 19 或者 1234567void main() async&#123; var countStreamVal = countStream(10); var sumStreamVal = await sumStream(countStreamVal); print(sumStreamVal); //var lastPositivesVal = await lastPositives(countStreamVal); //print(lastPositivesVal);&#125; 结果为： 145 广播流另一种流用于可以一次处理一个的单个消息。例如，这种流可以用于浏览器中的鼠标事件。 您可以随时开始监听此类流，并获得当你在监听时触发的事件。多个监听者可以同时监听，而且可以在取消之前的订阅后再次收听。 流的处理方法-返回值 FutureStream 中的以下方法处理流并返回结果： 1234567891011121314151617181920Future&lt;T&gt; get first;Future&lt;bool&gt; get isEmpty;Future&lt;T&gt; get last;Future&lt;int&gt; get length;Future&lt;T&gt; get single;Future&lt;bool&gt; any(bool Function(T element) test);Future&lt;bool&gt; contains(Object needle);Future&lt;E&gt; drain&lt;E&gt;([E futureValue]);Future&lt;T&gt; elementAt(int index);Future&lt;bool&gt; every(bool Function(T element) test);Future&lt;T&gt; firstWhere(bool Function(T element) test, &#123;T Function() orElse&#125;);Future&lt;S&gt; fold&lt;S&gt;(S initialValue, S Function(S previous, T element) combine);Future forEach(void Function(T element) action);Future&lt;String&gt; join([String separator = &quot;&quot;]);Future&lt;T&gt; lastWhere(bool Function(T element) test, &#123;T Function() orElse&#125;);Future pipe(StreamConsumer&lt;T&gt; streamConsumer);Future&lt;T&gt; reduce(T Function(T previous, T element) combine);Future&lt;T&gt; singleWhere(bool Function(T element) test, &#123;T Function() orElse&#125;);Future&lt;List&lt;T&gt;&gt; toList();Future&lt;Set&lt;T&gt;&gt; toSet(); 除了drain()和pipe()之外的所有这些函数都对应于Iterable上的类似函数。通过使用具有await for循环的异步函数（或仅使用其他方法之一），可以轻松地编写每个函数。一下是几个简化之后的例子： 123456789101112131415161718192021Future&lt;bool&gt; contains(Object needle) async &#123; await for (var event in this) &#123; if (event == needle) return true; &#125; return false;&#125;Future forEach(void Function(T element) action) async &#123; await for (var event in this) &#123; action(event); &#125;&#125;Future&lt;List&lt;T&gt;&gt; toList() async &#123; final result = &lt;T&gt;[]; await this.forEach(result.add); return result;&#125;Future&lt;String&gt; join([String separator = &quot;&quot;]) async =&gt; (await this.toList()).join(separator); 流的修改方法-返回值 Stream&lt;&gt;Stream中的以下方法基于原始流返回新流。每个人都等待，直到有人在收听原始流之前收听新流（Each one waits until someone listens on the new stream before listening on the original.）。 123456789Stream&lt;R&gt; cast&lt;R&gt;();Stream&lt;S&gt; expand&lt;S&gt;(Iterable&lt;S&gt; Function(T element) convert);Stream&lt;S&gt; map&lt;S&gt;(S Function(T event) convert);Stream&lt;R&gt; retype&lt;R&gt;();Stream&lt;T&gt; skip(int count);Stream&lt;T&gt; skipWhile(bool Function(T element) test);Stream&lt;T&gt; take(int count);Stream&lt;T&gt; takeWhile(bool Function(T element) test);Stream&lt;T&gt; where(bool Function(T event) test); 这些方法对应于Iterable上的类似方法，它将iterable转换为另一个iterable。所有这些都可以使用带有await for循环的异步函数轻松编写； 123Stream&lt;E&gt; asyncExpand&lt;E&gt;(Stream&lt;E&gt; Function(T event) convert);Stream&lt;E&gt; asyncMap&lt;E&gt;(FutureOr&lt;E&gt; Function(T event) convert);Stream&lt;T&gt; distinct([bool Function(T previous, T next) equals]); asyncExpand()和asyncMap()函数类似于expand()和map()，但允许其函数参数为异步函数。 1234Stream&lt;T&gt; handleError(Function onError, &#123;bool test(error)&#125;);Stream&lt;T&gt; timeout(Duration timeLimit, &#123;void Function(EventSink&lt;T&gt; sink) onTimeout&#125;);Stream&lt;S&gt; transform&lt;S&gt;(StreamTransformer&lt;T, S&gt; streamTransformer); 注意： 最后3个功能更加特殊。它们涉及错误处理，到达循环的第1个错误将 结束 循环及在流上的订阅。这是没有办法恢复的。但是你可以在await for 循环之前使用handleError()，这样可以从流中删除错误。 例如： 123456789Stream&lt;S&gt; mapLogErrors&lt;S, T&gt;( Stream&lt;T&gt; stream, S Function(T event) convert,) async* &#123; var streamWithoutErrors = stream.handleError((e) =&gt; log(e)); await for (var event in streamWithoutErrors) &#123; yield convert(event); &#125;&#125; transform()transform() 函数不仅用于错误处理：它是使Stream更加通用的“map”。一个普通的map仅能处理一种输入事件，但是尤其是对于 I/O 流的操作，可能需要多个输入事件才能得到一个输出事件。 而 Stream Transformer 就是用来处理这个问题的。像是 Utf8Decoder 这样的就是 transformers(变换器)。 变换器只需要一个函数bind()，它可以通过异步函数轻松实现。 读取和解码文件以下代码读取编写这个程序的Dart源码文件，并在流上运行2个转换。它首先从UTF8转换数据，然后通过LineSplitter运行它。 12345678910111213import &apos;dart:convert&apos;;import &apos;dart:io&apos;;void main() async &#123; var file = File(&apos;/Users/yannischeng/XFlutter/xflutter/lib/async/ReadFile.dart&apos;); var lines = file.openRead().transform(utf8.decoder).transform(LineSplitter()); await for(var line in lines )&#123; if (!line.startsWith(&apos;#&apos;)) &#123; print(line); &#125; &#125;&#125; 结果为： 12345678910111213import &apos;dart:convert&apos;;import &apos;dart:io&apos;;void main() async &#123; var file = File(&apos;/Users/yannischeng/XFlutter/xflutter/lib/async/ReadFile.dart&apos;); var lines = file.openRead().transform(utf8.decoder).transform(LineSplitter()); await for(var line in lines )&#123; if (!line.startsWith(&apos;#&apos;)) &#123; print(line); &#125; &#125;&#125; listen() 方法listen() 是Stream上的根方法，因为他是最底层调用的方法： 所有其他流函数都是根据listen() 定义的。 12StreamSubscription&lt;T&gt; listen(void Function(T event) onData, &#123;Function onError, void Function() onDone, bool cancelOnError&#125;); 要创建新的Stream类型，只需 extend Stream类并 implement listen()即可。listen()方法允许您开始监听流。在这样做之前，流是一个惰性对象，描述你想要查看的事件。监听时，将返回StreamSubscription对象，该对象表示生成事件的活动流。这类似于Iterable只是一个对象集合。 StreamSubscription(流订阅)允许：暂停订阅，暂停后恢复它，也可以完全取消订阅。可以为每个数据事件或错误事件以及关闭流时设置回调。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart-包概念]]></title>
    <url>%2FDart-%E5%8C%85%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Dart之“包概念”说明 参考链接： pubspec.yaml说明Dart 包YAML 1. pub包管理器是什么？Dart生态系统使用包来管理共享软件，如库和工具。其中包可以来自：Pub站点的公开包；可以从本地文件系统或者其他位置。使用包管理器的好处是：pub会对依赖性进行版本管理。 包中包含：元数据、依赖项、Dart库、应用程序、资源、测试、图像、示例。 pub的使用： 创建 一个pubspec，实际就是一个pubspec.yaml文件。一个最为简单的pubspec中仅仅只有一个name: my_app 使用pub来 获取包 的依赖关系 下图展示了，在Flutter开发过程中，常用到的 pub 管理命令。 在 pubspec.yaml 文件中添加 需要的依赖库之后，pub会创建一个 .packages 文件。该文件将 应用程序所依赖的每个程序包名 映射到 系统缓存中的相应程序包。每当修改一次pubspec.yaml文件执行flutter命令之后，该文件就会更新。 如果在编写Dart代码的过程中需要依赖包中的库，则在代码中 导入该库，就像我们之前编写Java代码那样。 升级 依赖项 当在pubspec.yaml文件中第一次添加依赖项后，pub会下载与其他依赖项兼容的最新版本。在生成 .packages 文件的同时，还会生成一个名为 pubspec.lock 的pub文件。它列出了程序包使用的每个依赖项（即时和传递）的特定版本。当想要将依赖项升级到最新的版本时，执行命令： 1flutter upgrade 如果只想升级一个依赖项，则执行命令： 1flutter upgrade 依赖项 说明：虽然Flutter SDK 使用的是pub包，但是不能直接使用pub命令来管理Flutter代码中的包，而是使用Flutter命令。 pub管理的文件目录 .metadata：自动生成的文件。应该被加入版本控制 中。 .packages：自动生成的文件。不应该被加入版本控制 中。 pubspec.lock： 这个文件的作用是：记录 每个程序包所引用的具体的版本号，而不是.yaml文件中的记录的 约束范围。 它指定程序包所依赖的每个直接和传递依赖项的具体版本和其他标识信息。与仅列出直接依赖关系并允许版本范围的pubspec不同，锁文件将整个依赖关系图全面地固定到特定版本的包。锁定文件可确保您可以重新创建应用程序使用的包的确切配置。应该被加入到版本控制中。 pubspec.yaml：项目管理文件。 pub名词名词解释 2. pubspec.yaml文件格式实例 pubspec.yaml是由YAML语言编写的文件。 一个flutter项目的pubspec.yaml文件： 12345678910111213141516name: xflutterdescription: A new Flutter application.version: 1.0.0+1environment: sdk: &quot;&gt;=2.2.0 &lt;3.0.0&quot;dependencies: flutter: sdk: flutter dio: 2.1.0dev_dependencies: flutter_test: sdk: flutter flutter: uses-material-design: true 一个简单但是完整的pubspec文件 1234567891011121314151617name: newtifyversion: 1.2.3description: &gt;- Have you been turned into a newt? Would you like to be? This package can help. It has all of the newt-transmogrification functionality you have been looking for.author: Natalie Weizenbaum &lt;nweiz@google.com&gt;homepage: https://example-pet-store.com/newtifydocumentation: https://example-pet-store.com/newtify/docsenvironment: sdk: &apos;&gt;=2.0.0 &lt;3.0.0&apos;dependencies: efts: ^2.0.4 transmogrify: ^0.4.0dev_dependencies: test: &apos;&gt;=0.6.0 &lt;0.12.0&apos; 属性字段说明 属性字段 基本说明 name（必有） version（必有） description（必有） environment 从Dart 2开始要求 dependencies 如果没有包依赖项，则可以省略 dev_dependencies 如果没有dev包依赖项，则可以省略 dependency_overrides 如果不需要覆盖任何依赖项，则可以省略 author/authors（可选） homepage（可选） 指向包的主页（或源代码存储库）的URL repository（可选） 指向包的源代码存储库的URL issue_tracker（可选） 指向包的问题跟踪器的URL documentation（可选） 指向包的文档的URL executables（可选） 用于将包的可执行文件放在PATH上 publish_to（可选） 指定发布包的位置 name每个包都需要一个名字。如果将这个包对外发布，这将是它的对外展示以及其他软件包引用它的名字。 命名规则： 名称应全部小写， 下划线用于分隔单词 仅使用基本拉丁字母和阿拉伯数字： [a-z0-9_]。 确保该名称是有效的Dart标识符 它不以数字开头且不是保留字。 version每个包都有一个version。在Pub站点上托管您的包需要版本号，但对于仅限本地的包可以省略。如果省略它，则会对包进行隐式版本控制0.0.0，每次发布包时，都应设定特定版号。 版本格式： 主版本号.次版本号.修订号。由 点 分隔的三个数字，还可以选择具有build（+hotfix.oopsie）或pre-release（-alpha.12）后缀。 版本号递增规则： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正。 先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 description这对于自己的个人包而言是可选不写的，但如果打算发布包，则必须提供说明，描述是纯文本：没有markdown或HTML，且该说明应为英文。描述应该相对较短–60到180个字符。 SDK constraints（SDK约束）一个包可以使用SDK约束所添加依赖的指定版本。此约束位于pubspec中的单独顶级字段environment内，并使用与依赖项相同的 版本约束语法，基本使用如下： 12environment: sdk: &apos;&gt;=2.0.0 &lt;3.0.0&apos; 注意： 在 SDK约束 中不要使用^，也不要包含上限&lt;3.0.0，更多详细信息参考。 具体约束规则参考：dependencies Flutter SDK约束在 Dart 1.19.0 之后，pub支持在顶级environment字段下添加 Flutter SDK约束 字段，例如： 123environment: sdk: &apos;&gt;=1.19.0 &lt;3.0.0&apos; flutter: ^0.1.2 执行 Flutter SDK约束 的条件： 当pub在flutter可执行文件的上下文中运行； Flutter SDK的version文件与给定的版本约束匹配 满足这2点才能满足Flutter SDK 约束。否则，将不会选择包。 dependencies依赖是pub包管理器 的核心概念之一，dependencies关系体现了pubspec的存在理由。一般分为2种依赖： 依赖来源SDK释义： SDK源 用于随软件包一起提供的任何SDK，这些SDK本身可能是依赖项。目前，Flutter是唯一受支持的SDK。 用法： 1234dependencies: flutter_driver: sdk: flutter version: ^0.0.1 sdk之后的标识符：表示包来自哪个SDK。如果是flutter，它的依赖性只要满足以下条件即可： pub正在flutter可执行文件的上下文中运行 Flutter SDK包含具有给定名称的包 该软件包的版本与版本约束匹配 如果它是未知标识符，则始终认为依赖关系不满足。具有sdk依赖关系的包必须具有Dart SDK约束，最小版本至少为1.19.0。此约束确保旧版本的pub不会安装具有sdk依赖项的包。 托管包（Hosted packages）托管包是可以从Pub站点（或使用相同API的其他HTTP服务器）下载的包。一个示例： 12dependencies: transmogrify: ^1.4.0 此示例指定您的程序包依赖于名为transmogrify的托管程序包，并且可以使用1.4.0到2.0.0之间的任何版本（但不包含2.0.0本身）。 如果要使用自己的包服务器，可以使用指定其URL的描述： 123456dependencies: transmogrify: hosted: name: transmogrify url: http://your-package-server.com version: ^1.4.0 Git包（Git packages）有时你的工作处在最前沿，需要使用尚未正式发布的包装。也许你的软件包本身仍在开发中，并且正在同时使用其他正在开发的软件包。为了使这更容易，你可以直接依赖存储在Git存储库中的包。 使用方式1 - 直连 123dependencies: kittens: git: git://github.com/munificent/kittens.git 这里的git说这个包是使用Git找到的，之后的URL是可以用来克隆包的Git URL。 使用方式2 - 私有库SSH连接 即使包repo是 私有 的，如果你可以使用SSH连接到repo，那么你可以使用repo的SSH URL依赖包 123dependencies: kittens: git: git@github.com:munificent/kittens.git 使用方式3 - ref参数 如果要依赖特定的提交，分支或标记，请添加ref参数： 12345dependencies: kittens: git: url: git://github.com/munificent/kittens.git ref: some-branch 其中，ref可以是Git允许识别提交的任何内容。 使用方式4 - path参数 Pub假定包位于Git存储库的根目录中。要在repo中指定其他位置，请使用path参数： 12345dependencies: kittens: git: url: git://github.com/munificent/cats.git path: path/to/kittens 该path相对于Git repo的根目录。 路径包（Path packages）有时你会发现自己同时处理多个相关的包，可能你是在同时使用它们来构建一个项目框架。在这种开发情况下，你确实希望依赖本地文件系统上各个包的实时版本，这样，一个包中的更改会立即被依赖它的一个包中取出。为了解决这个问题，pub支持路径依赖。 123dependencies: transmogrify: path: /Users/me/transmogrify 这表示transmogrify的根目录是/Users/me/transmogrify。对于此依赖项，pub直接生成符号链接到引用的包目录的lib目录。你立即可以看到对依赖包所做的任何更改。每次更改依赖包时都不需要运行pub。 允许相对路径，并将其视为相对于包含pubspec的目录。 特点：路径依赖关系对于本地开发很有用，但在与外部共享代码时不起作用 —— 并非所有人都可以访问你的文件系统。因此，如果 包在pubspec中有任何路径依赖性，则无法将包上传到Pub站点 。 相反，典型工作流程： 在本地编辑pubspec以使用路径依赖项； 处理主程序包及其所依赖的程序包； 一旦它们都工作，发布依赖包； 将pubspec更改为指向其依赖项的现在托管版本。 如果需要，也可以发布主程序包。 版本限制（约束规则）- 符号表示 any 该字符串any允许任何版本。这相当于空版本约束，但更明确。虽然any允许，但出于性能原因，不建议使用它。 1.2.3 具体的版本号将依赖项固定为仅允许该 确切版本。尽可能避免使用它，因为它可能导致用户的版本锁定，并使他们难以使用您的包以及依赖它的其他包。 &gt;=1.2.3 使用概率最大的，允许给定版本或任何更大版本。 &gt;1.2.3 允许任何大于指定版本但不是该版本本身的版本。 &lt;=1.2.3 通常不会使用，允许任何低于或等于指定版本的版本。 &lt;1.2.3 允许任何低于指定版本但不是该版本的版本。这就是你通常会使用，因为它可以让你指定你知道不上的版本不会与你的包工作（因为它是引进一些重大变化的第一个版本）。 版本相交 您可以根据需要指定版本部件，并将它们的范围相交。例如，&#39;&gt;=1.2.3 &lt;2.0.0&#39;允许从任何版本1.2.3，以及排除2.0.0本身。表达此范围的更简单方法是使用插入符号语法，或 ^1.2.3。 说明：如果&gt;字符在版本约束中，请确保引用 约束字符串，否则该字符不会被解释为YAML语法。例如，永远不要使用&gt;=1.2.3 &lt;2.0.0，而是使用&#39;&gt;=1.2.3 &lt;2.0.0&#39;或^1.2.3。 版本限制（约束规则）- Caret语法Creat语法 表示的是一种更为 紧凑 的常见版本约束的表现形式，是在 Dart 1.8.3 中添加的。较早版本的Dart不支持。因此在使用插入语法时要注意： 12environment: sdk: &apos;&gt;=1.8.3 &lt;3.0.0&apos; ^version 表示 所有版本的范围 保证与 指定版本 向后兼容。 例如 ^1.2.3 等同于 &#39;&gt;=1.2.3 &lt;2.0.0&#39;；^0.1.2 等同于 &#39;&gt;=0.1.2 &lt;0.2.0&#39;。 依赖：dev_dependenciesPub支持 2种类型的依赖 方式： 常规依赖 dev依赖：Dev依赖项与常规依赖项不同的是，当前项目 依赖项 中的 dev依赖项将被忽略。说的在详细一点就是： 123我在本项目Pro-A内引用了1个依赖项a，而且这个依赖项a只想在项目Pro-A内使用。当项目Pro-B想要依赖Pro-A项目中的依赖时，发现依赖项a是 “dev-依赖”，那么Pro-B将跳过这项依赖。 2种依赖方式的决策的规则 如果从 lib 或 bin 目录中的某些内容导入依赖项，则它 必须 是 常规依赖项 。 如果只是从 test， example 等等导入它可以而且应该是 开发依赖项。 使用 dev依赖关系 会使 依赖关系图更小，这使得 pub运行速度更快，并且更容易找到满足所有约束的一组包版本。 依赖：dependency_overrides你可能会需要使用 dependency_overrides 来 临时 覆盖一项依赖的所有引用。例如：可能你想要更新一个已经发布的library包的本地副本，但是这个library已经在你的依赖图中被其他的包使用了。但是你又不想再去克隆一份到本地并且去单独修改这本地的副本，那么在这个时候，你就可以使用 dependency_overrides来表名这个特殊的路径： 123456name: my_appdependencies: transmogrify: ^1.2.0dependency_overrides: transmogrify: path: ../transmogrify_patch/ 当你运行 pub get 时，pubspec.lock 文件将会更新你所有依赖项的引用路径，这样一来，无论这个库在什么地方使用，pub都会使用本地版本的依赖来 替代 之前的引用路径。 author/authors说明作者并提供联系信息，例如 123authors:- Natalie Weizenbaum &lt;nweiz@google.com&gt;- Bob Nystrom &lt;rnystrom@google.com&gt; homepage这是属性应该是一个指向发布包所在网站的URL。它可以帮助用户了解您的软件包的来源。 repository该属性是一个指向 包源码的 仓库地址URL，它可以帮助用户了解您的软件包的来源。 issue tracker该字段应包含程序包的问题跟踪器的URL，其中可以查看现有错误并可以归档新错误。Pub站点尝试使用此字段的值显示指向每个包的问题跟踪器的链接。 documentation某些软件包具有托管文档的站点，与主页和Pub生成的API参考分开。如果你的包有其他文档，则应该添加包含该URL字段的documentation; pub在您的包的页面上显示了该文档的链接。 executables一个包可以将其一个或多个脚本公开为可以直接从命令行运行的可执行（executables）文件。要使脚本公开，请在该executables字段下列出，格式为键/值对： 1&lt;name-of-executable&gt;: &lt;Dart-script-from-bin&gt; publish_to默认使用Pub站点。指定none以防止发布包。 3. 包文件、目录公约（Package layout conventions）pub包布局公约 描述的是：如何组织包中的 文件 和 目录 以及 如何命名。 注意：Flutter应用程序可以使用 自定义目录 作为其资产。 一个完整的 pub包 的目录结构为： 123456789101112131415161718192021222324252627282930313233enchilada/ .dart_tool/ * .packages * pubspec.yaml pubspec.lock ** LICENSE README.md CHANGELOG.md benchmark/ make_lunch.dart bin/ enchilada doc/ api/ *** getting_started.md example/ main.dart lib/ enchilada.dart tortilla.dart guacamole.css src/ beans.dart queso.dart test/ enchilada_test.dart tortilla_test.dart tool/ generate_docs.dart web/ index.html main.dart style.css 说明： .dart_tool目录 和 .packages文件 是在 pub get 命令运行之后生成的。不要将他们纳入版本控制中。 pubspec.lock文件 也是在 pub get 命令之后生成的，如果你的包是一个应用程序包，那么应该将其置于 版本控制 中。 doc/api 是运行 dart doc 后生成的，该目录存在于本地 。 不要将api目录检查到源代码管理中。 pubspec123包名/ pubspec.yaml pubspec.lock 任何一个包都含有一个pubspec，一个文件是：pubspec.yaml，在包的顶级目录之下。这就是它成为一个包的原因。 另一个文件是叫：pubspec.lock 的 锁文件，这个文件的产生是在运行命令：pub get、pub upgrade、pub downgrade 后。如果你的包是一个应用程序包，那么应该将其置于 版本控制 中。 公共目录包中的两个目录对其他包是公共的：lib/ 和 bin/。你可以将 公共 libraries 放置在 lib/，将 公共 tools 放置在 bin/。 公共 libraries以下目录结构显示了包的lib部分： 123包名/ lib/ XXX.dart 许多软件包都是库软件包：它们定义了其他软件包可以导入和使用的 Dart库。这些公共Dart库文件位于名为lib的目录中。 公共 tools123包名/ bin/ XXX.dart 放置在bin目录中的Dart脚本是公共的。可以使用pub run从包依赖的任何其他包的bin目录运行脚本。在任何目录中，您都可以使用pub global run命令来运行经过pub global activate命令激活过的包中的脚本。 内部工具和脚本123包名/ tool/ generate_docs.dart 与bin/中的脚本不同，tool/ 中放置的是一些不适用于供外部包使用的命令。 4. 包版本（pub管理器原理）pub包管理器 的主要工作之一 是帮助处理 版本控制。 name+version当依赖某些外部代码时不只是说“我的应用程序使用widgets”。而是说：“我的应用程序使用 widgets 2.0.5”。其中这个 名称 和 版本号 的组合 唯一地标识 了一个 不可变的代码块。 widgets包 的开发人员更新时可以进行他们想要的所有更改，但绝对不会触及任何已发布的版本。只要你引用的版本号不改变，那么即时他们推出2.0.6或者3.0.0也不会影响到你。 解决“共享依赖项”场景： 如果你的项目中有一堆的依赖项，而这些依赖项又有着自己的依赖关系，那么只要这些依赖关系不重叠（交点），程序就将正常工作。 当时如果像是如下这种关系：my_app 引用了依赖项 widgets 和 templates ，而这2者又同时依赖collection。这种情况下我们将collection称为共享依赖项。 那么问题来了：现在widgets想要使用collection 2.3.5，与此同时templates想要使用 collection 2.3.7，版本不同时怎么办？ 方式1：非共享库（node.js的npm法）一种选择是让应用程序使用2种版本collection。它将有2个不同版本的库副本，widgets和templates每个副本都会得到他们想要的副本。 但是至于Dart而言，collection 2.3.5 与 collection 2.3.7 是完全无关的库。如果从一个包2.3.5中获取Dictionary类的实例并将其传递给另一个包2.3.7中的方法，则这是一种 完全不同 的 Dictionary类型。这意味着它将无法匹配接收库中的Dictionary类。正因为如此，npm的模型不适合。 方式2：版本锁死（死胡同）有了第1种方式的错误尝试，那么第2种方式就是：尝试升级其中一个。templates想要 collection 2.3.7，是否有widgets可以升级到适用于该版本的更新版本？在许多情况下，答案是没有。 每个人都希望将他们的依赖关系向前推进，但是没有人可以迈出第一步，因为它也会强迫其他人。而这就叫版本锁死。 方式3：版本约束（Dart 方法）为了解决版本锁定，我们放松了包对其依赖项的约束。如果widgets和templates都可以指出他们使用collection的版本范围，那么这给了我们足够的摆动空间来将我们的依赖关系转移到更新的版本——只要它们的范围有重叠，那么这个问题就解决了。 而这种问题的解决方式就是 Gem Bundler（捆绑器） 和 pub 的模型。在pubspec.yaml中添加依赖项时，可以指定可以接受的版本范围。 就这个问题而言，其解决方式就是： 12dependencies: collection: &apos;&gt;=2.3.5 &lt;2.4.0&apos; 这样就都能满足 widgets 和 templates 的使用。 约束解决（约束选择）步骤： 当你定在义包时，你会列出其 直接依赖项 - 它自己使用的包。对于每个依赖项，你指定它 允许的版本范围。 每个依赖包都可以依次拥有自己的依赖关系（称为传递依赖关系），Pub遍历这些依赖关系并为您的应用程序 构建整个 深度依赖关系图。 对于这个深度依赖关系图中的 每个包，pub会查看依赖于它的所有内容，它 收集所有版本约束 并尝试 同时解决（基本上是它们彼此的相交范围）它们。 然后，它查看已为该程序包发布的 实际版本，并选择满足所有这些约束的 最佳（最新）版本。 实例： 例如，假设我们的依赖图包含collection，并且三个包依赖于它。他们的版本限制是： 123&gt;=1.7.0^1.4.0&lt;1.9.0 collection开发人员已经发布的版本： 1234561.7.01.7.11.8.01.8.11.8.21.9.0 所以pub选择适合所有这些范围的 最高版本号 是 1.8.2。这意味着你的应用和你的应用使用的每个包都将使用 collection 1.8.2。 约束上下文（包内）选择包版本的事实考虑了依赖于它的每个包具有重要的后果：将为包选择的特定版本是使用该包的应用程序的全局属性。 以下示例显示了这意味着什么。假设我们有两个应用程序。这是他们的pubspecs： 123name: my_appdependencies: widgets: 1234name: other_appdependencies: widgets: collection: &apos;&lt;1.5.0&apos; 它们都依赖于widgets，其pubspec是： 123name: widgetsdependencies: collection: &apos;&gt;=1.0.0 &lt;2.0.0&apos; other_app包直接依赖于 collection 本身。但是，它碰巧与widgets有不同的版本约束。 这意味着你不能单独查看widgets包以确定它将使用的collection版本。这取决于具体情况。在my_app中，小部件将使用collection 1.9.9。但是在other_app中，widgets将会受到collection1.4.9的影响，因为其他的约束条件会对其产生影响。 这就是为什么每个应用程序都有自己的*.packages*文件：为每个包选择的具体版本取决于包含应用程序的整个依赖关系图。 导出依赖项时的约束解决方案包的作者必须谨慎定义包装约束。请考虑以下情形： bookshelf包取决于widgets包。widgets包（目前为1.2.0）通过export &#39;package:collection/collection.dart&#39;导出collection 2.4.0。 pubspec文件如下： 123name: bookshelfdependencies: widgets: ^1.2.0 123name: widgetsdependencies: collection: ^2.4.0 然后将collection包更新为2.5.0。2.5.0版本的collection包括一个名为sortBackwards的新方法。bookshelf包可以调用sortBackwards方法，因为它是widgets公开的API的一部分，尽管bookshelf只对collection具有传递依赖性。 于widgets包的API未反映在其版本号中，因此使用bookshelf包并调用sortBackwards的应用程序可能会崩溃。 导出API会将API视为在包本身中定义，但在API添加功能时不能增加版本号。这意味着bookshelf包无法声明它需要支持sortBackwards的widgets包版本。 因此，在处理导出的包时，建议包的作者对依赖关系的上限和下限保持更严格的限制。 123name: bookshelfdependencies: widgets: &apos;&gt;=1.2.0 &lt;1.3.0&apos; 123name: widgetsdependencies: collection: &apos;&gt;=2.4.0 &lt;2.5.0&apos; 这转换为widgets的下限1.2.0和 collection 的下限为 2.4.0。当发布 collection 2.5.0 版本的时，widgets也会更新到1.3.0，并且也会 更新相应的约束。 使用此约定可确保用户拥有2个软件包的正确版本，即使这些软件包不是直接依赖项。 锁文件(Lockfiles)所以书接上文，一旦pub管理器解决了你的app的版本约束，那么然后呢？结果是您的应用程序直接或间接依赖的每个程序包的完整列表，以及适用于您的应用程序约束的该程序包的最佳版本。 然后，pub管理器将接受得到的结果并将其写入应用程序目录中名为pubspec.lock的lockfile（锁文件）。当pub为你的应用程序构建.packages文件时，它使用lockfile来了解要引用的每个程序包的版本。 （如果您想知道它选择了哪个版本，您可以阅读锁定文件以查找。） 所以 pubspec.yaml文件、 pubspec.lock文件 与 .packages文件之间的关系为： pubspec.yaml 版本约束 –(pub get/ pub upgrade)–&gt; pubspec.lock 具体版本号 –&gt; .packages 每个程序包的版本. pub的下一个重要事情是它 停止触摸 Lockfiles。一旦你有一个你应用程序的Lockfiles，pub将不会触摸它，直到你告诉它。这个很重要。这意味着你不会毫不犹豫地开始在你的应用程序中使用 新版本的随机软件包。一旦你的应用程序 被锁定，它将 保持锁定状态，直到你手动告诉它 更新 锁定文件。 —— 简而言之：应用程序中的程序包将在一个稳定、具体版本的依赖关系下被开发者开发。 如果你的软件包适用于某个应用程序，请将你的lockfile检入到源代码管理系统！这样，团队中的每个人在构建应用时都会使用完全相同的每个依赖版本。此外，你还可以在部署应用程序时使用此功能，以便确保生产服务器使用与您正在开发的完全相同的软件包。 错误处理当然，所有这些都假设你的依赖图是完美无瑕的。即使使用版本范围和pub的约束求解和语义版本控制，你也永远无法完全避免版本可能存在的危险。 你可能会遇到以下问题之一： 不相交的约束让我们以应用程序使用 widgets 和 templates 为例子，这2个程序包都使用collection。但是widgets 要求它在1.0.0和2.0.0之间的版本，templates 需要3.0.0和4.0.0之间的版本。这些范围甚至都不重叠，因此没有可行的版本。 不包含已发布版本的范围让我们说在将所有约束放在一起共享依赖关系之后，你会留下&gt; = 1.2.4 &lt;1.2.6的窄范围。这不是空的范围。如果有1.2.4版本的依赖项，那你就幸运的。但也许他们从未发布过，而是直接从1.2.3发布到1.3.0。你有一个范围但内部没有任何东西。 有一个不稳定的引用图到目前为止，这是pub版本求解过程中最具挑战性的部分。该过程被描述为：构建依赖图，然后解决所有约束和选择版本。但实际上并没有这样做。在选择任何版本之前，如何构建整个依赖图？ pubspecs本身是特定于版本的。同一包的不同版本可能具有不同的依赖关系集。 选择包的版本时，它们正在改变 依赖图本身的形状。随着图表的变化，这可能会改变约束条件，这可能会导致您选择不同的版本， pub版本要点总结 代码重用很棒，但为了让开发人员 快速行动，软件包需要能够 独立开发。 版本控制是启用它的方式。但是，取决于单个具体精确版本，并且因为共享依赖性导致 版本锁定。 为了解决这个问题，需要依赖于 版本范围。 Pub然后遍历您的依赖图并为您挑选最佳版本。如果它不能，它告诉你。 一旦您的应用程序为其 依赖项 提供了一组 可靠的版本，那么它将 被锁定 在一个 锁定文件 中。这可以确保您的应用程序所在的每台计算机都使用 相同版本的所有依赖项。 5. 常用的包 常用的包分为3组： 通用包 Dart核心库的扩展包 专业包 通用包 包 描述 常用API archive 对各种存档和压缩格式进行编码和解码。 Archive，ArchiveFile，TarEncoder，TarDecoder，ZipEncoder，ZipDecoder http 一组高级函数和类，可以轻松使用HTTP资源。 delete（），get（），post（），read（） intl 国际化和本地化设施，支持复数和性别，日期和数字格式和解析，以及双向文本。 Bidi，DateFormat，MicroMoney，TextDirection json_serializable 易于使用的代码生成包。有关更多信息 @JsonSerializable logging 用于向应用程序添加消息日志记录的可配置机制。 LoggerHandler，Level，LogRecord mockito 在测试中模拟对象的流行框架。如果您正在编写依赖注入测试，则特别有用。与测试包一起使用。 path 操作不同类型路径的常用操作。有关更多信息 absolute（），basename（），extension（），join（），normalize（），relative（），split（） quiver 使用核心Dart库的实用程序更方便。Quiver提供额外支持的一些库包括异步，缓存，集合，核心，可迭代，模式和测试。 CountdownTimer（quiver.async）; MapCache（quiver.cache）; MultiMap，TreeSet（quiver.collection）; EnumerateIterable（quiver.iterables）; center（），compareIgnoreCase（），isWhiteSpace（）（quiver.strings） shelf Dart的Web服务器中间件。Shelf可以轻松创建和组合Web服务器以及Web服务器的一部分。 级联，管道，请求，响应，服务器 stack_trace 解析，检查和操作由底层Dart实现生成的堆栈跟踪的方法。还提供了以比原生StackTrace实现更可读的格式生成堆栈跟踪的字符串表示的函数。有关更多信息 Trace.current（）， Trace.format（），Trace.from（） stagehand Dart项目生成器。WebStorm和IntelliJ在创建新应用程序时使用Stagehand模板，但您也可以使用命令行中的模板。 通常通过IDE或stagehand命令使用。 yaml YAML的解析器。 loadYaml（），loadYamlStream（） Dart核心库的扩展包以下每个软件包都构建在核心库之上，添加了功能并填充了缺少的功能： 包 描述 常用API async 扩展dart：async，添加实用程序类以使用异步计算。 AsyncMemoizer，CancelableOperation，FutureGroup，LazyStream，Result，StreamCompleter，StreamGroup，StreamSplitter collection 扩展dart：集合，添加实用程序函数和类，以便更轻松地处理集合。 Equality，CanonicalizedMap，MapKeySet，MapValueSet，PriorityQueue，QueueList convert 扩展dart：转换，添加编码器和解码器，以便在不同的数据表示之间进行转换。其中一个数据表示是百分比编码，也称为URL编码。 HexDecoder，PercentDecoder io 包含两个库ansi和io，以简化文件，标准流和进程的处理。使用ansi库自定义终端输出。io库具有用于处理进程，标准输入和文件复制的API。 copyPath（），isExecutable（），ExitCode，ProcessManager，sharedStdIn 专业包Flutter包。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2理解]]></title>
    <url>%2FRxJava2%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于RxJava2 1 基础知识储备 - Reactive 规范Reactive规范是 JVM Reactive 扩展规范 中的 Reactive Streams JVM，而 Reactive 框架 最典型的实现是： Java 9 ：Flow API ReactiveX：RxJava Spring 5：Reactor 1.1 Reactive Streams（规范）1.1.1 是什么Reactive Streams 是 JVM 面向Stream库的标准和规范，包括： 处理潜在无限数量的元素； 按顺序； 在组件之间异步传递元素； 具有强制性非阻塞背压。 1.1.2 目的是：为 非阻塞 背压 的 异步 流处理 提供标准。包括针对运行时环境（JVM和JavaScript）以及网络协议的工作。 1.1.3 目标是：管理 跨异步边界 的 数据流交换 —— 将元素传递至另一个线程或者线程池。 1.1.4 API的组成 Publisher：发布者（生产者） Subscriber：订阅者（消费者） Subscription：订阅 Processor：处理器 代码为： 1234567891011121314public interface Publisher&lt;T&gt; &#123; public void subscribe(Subscriber&lt;? super T&gt; s);&#125;public interface Subscriber&lt;T&gt; &#123; public void onSubscribe(Subscription s); public void onNext(T t); public void onError(Throwable t); public void onComplete();&#125;public interface Subscription &#123; public void request(long n); public void cancel();&#125;public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; &#123;&#125; 1.1.5 术语 术语 解释 Signal 本意：信号。作为一个名词：指的是这些onSubscribe()，onNext()，onComplete()，onError()，request(n)或cancel()方法中的一个。作为一个动词，指的是调用这些方法中的一个方法 Demand 本意：需求。作为一个名词：指的是一个订阅者（向发布者）请求的一定数量的元素，它（元素）还没有被发布者分发。作为一个动词，指的是请求更多元素的行为动作。 Synchronous 本意：同步。指的是在当前调用线程上执行（没有新开线程）。 Return normally 本意：正常返回。指的是仅返回已声明过的类型的值给调用者。如果想发送一个失败给订阅者，唯一合法的方式是通过onError（回调）方法。 Responsivity 本意：响应度。指的是已准备就绪，且有能力来做出响应。在这个文档里用来指示不同的组件不应该互相削弱响应的能力。 Non-obstructing 本意：不堵塞。描述在调用线程上尽可能快地执行的方法。 这意味着，例如，避免繁重的计算和其他会阻碍调用者执行线程的事情。 Terminal state 本意：终止状态。对于一个 Publisher（发送者），指的是：当onComplete或者onError已经被调用。对于一个Subscriber（订阅者），指的是：当一个onComplete或onError（回调方法）已经收到。 NOP 指的是：执行对于调用线程来说没有可检测到的影响，能够像这样安全地被调用任意次。 Thread-safe 能够安全地被同步或异步调用，不需要外部的同步来确保程序的正确性 Serial 在信号的上下文中，不重叠。 在JVM的上下文中，当且仅当这些调用之间存在先发生关系时（意味着调用不重叠），对对象上的方法的调用才是串行的。 当异步执行调用时，使用诸如但不限于 atomics, monitors, 或者 locks的技术来实现用于建立先发生关系的协调。 1.1.6 规格 Publisher 123public interface Publisher&lt;T&gt; &#123; public void subscribe(Subscriber&lt;? super T&gt; s);&#125; 1、一个发布者对一个订阅者的onNext调用总次数必须总是小于或等于订阅者的Subscription请求的元素总数。 2、一个发布者可能调用的onNext次数比要求的少，然后通过调用onComplete或onError来终止Subscription。 3、对一个订阅者的onSubscribe，onNext，onError和onComplete调用必须以一个线程安全的方式进行，如果被多个线程执行，使用external synchronization。 4、如果一个发布者失败，它必须调用一个onError。 5、如果一个发布者成功地终止（对于有限流），它必须调用一个onComplete。 6、如果一个发布者调用一个订阅者上的onError或onComplete方法，那个订阅者的Subscription必须认为已被取消。 7、一旦一个terminal state已经被调用（onError，onComplete），它要求没有进一步的调用发生。 8、如果一个订阅被取消，它的订阅者必须最终停止被调用。 9、发布者的subscribe方法里必须在早于对订阅者上的任何方法调用之前先调用onSubscribe方法，且必须return normally。当订阅者是null的时候，此时必须向调用者抛出java.lang.NullPointerException异常。对于其它任何情况，通知失败（或拒绝订阅者）的唯一合法方式是调用onError。 10、发布者的subscribe方法可能被调用任意多次，但是每次必须使用一个不同的订阅者。 11、一个发布者可以支持多个订阅者，并决定每一个订阅是单播或多播。 Subscribe 12345678910public interface Subscriber&lt;T&gt; &#123; public void onSubscribe(Subscription s); public void onNext(T t); public void onError(Throwable t); public void onComplete();&#125; 1、一个订阅者必须通过订阅（Subscription）的request(long n)方法声明需求，然后接收onNext调用。 2、如果一个订阅者怀疑它的调用处理将消极地影响它的发布者的响应度，建议异步地分发它的调用。 3、订阅者的onComplete()和onError(Throwable t)这两个方法里禁止调用订阅或发布者上的任何方法。 4、订阅者的onComplete()和onError(Throwable t)这两个方法在接收到调用后必须认为订阅已经被取消。 5、一个订阅者必须在收到onSubscriber之后调用指定订阅上的cancel()方法取消该订阅，如果它已经有一个活动的订阅。 6、一个订阅者必须调用订阅的cancel()方法，如果这个订阅不再需要的话。 7、一个订阅者必须确保所有对订阅发生的调用都来自于同一个线程或为它们各自提供external synchronization。 8、一个订阅者必须准备好接收一到多个onNext调用，在已经调用过订阅的cancel()方法之后如果还有请求的元素即将发送。订阅的cancel()方法并不保证立即执行底层的清理操作。 9、一个订阅者必须准备好接收一个onComplete调用，不管之前有或没有调用过订阅的request(long n)方法。 10、一个订阅者必须准备好接收一个onError调用，不管之前有或没有调用过订阅的request(long n)方法。 11、一个订阅者必须确保它的所有的方法调用发生在它们各自的处理之前。该订阅者必须小心合适地发布调用到它的处理逻辑。 12、订阅者的onSubscribe方法必须最多被调用一次，对于一个给定的订阅者。 13、对onSubscribe，onNext，onError或onComplete的调用必须return normally，除了当提供的任何参数是null时，这种情况必须向调用者抛出一个java.lang.NullPointerException异常。对于其它情况，对于一个订阅者来说，去通知一个失败的唯一合法的方式是取消它的订阅。在这个规则被违反的情况下，任何与该订阅者关联的订阅必须被认为是取消的，调用者必须激发这个错误条件，以一种对于运行环境来说是足够的方式。 Subscription 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface Subscription &#123; public void request(long n); public void cancel();&#125; ``` **说明：** **一个 `Subscription` 被一个 `Publisher` 和一个`Subscriber` 共享，目的是：为了在它们之间 `调节数据交换`。 这也是为什么 `Publisher.subscribe()` 并没有返回创建的 `那个Subscription` 而是返回 `void` 的原因。 这个 `Subscription` 只能通过 `Subscriber.onSubscriber()` 回调方法传给 `Subscriber`。** 1、Subscription.request() 和 Subscription.cancel() 必须在 Subscriber 的上下文中调用。 2、Subscription 必须允许 Subscriber 在 onNext() 或 onComplete() 里同步地调用Subscription.request()。 3、Subscription.request() 必须放置一个关于 Publisher 和 Subscriber 间的同步递归调用的上界。 4、Subscription.request() 应该尊重它的 Subscriber 的响应度，通过以一个适时的方式返回。 5、Subscription.cancel方法必须尊重它的 Subscriber 的响应度，通过以一个适时的方式返回，必须是幂等的和线程安全的。 6、在 Subscription 取消之后，额外的 Subscription.request(long n) 调用必须是NOP。 7、在 Subscription 取消之后，额外的 Subscription.cancel()调用必须是NOP。 8、当 Subscription 没有被取消时，Subscription.request(long n)方法必须注册给定数目的额外元素，这些元素将被生产并分发给各自的 Subscriber。 9、当 Subscription 没有被取消时，Subscription.request(long n)必须使用一个 java.lang.IllegalArgumentException 异常来调用 Subscriber.onError()，如果参数小于等于0。引起的原因应该解释为不是正数的调用是非法的。 10、当 Subscription 没有被取消，Subscription.request(long n) 可以同步地调用这个（或其它）Subscriber.onNext()。 11、当 Subscription 没有被取消，Subscription.request(long n) 可以同步地调用这个（或其它）Subscriber.onComplete() 或 Subscriber.onError()。 12、当 Subscription 没有被取消，Subscription.cancel() 必须请求 Publisher 最终停止调用它的Subscriber 上的方法。这个操作不要求立即影响 Subscription。 13、当 Subscription 没有被取消，Subscription.cancel() 必须请求 Publisher 最终删除对相关 subscriber 的任何引用。 14、当 Subscription 没有被取消，调用 Subscriptioncancel() 可以引起 Publisher（如果是有状态的）进入关闭状态，如果在此刻没有其它的 Subscription 存在。 15、调用 Subscription.cancel() 必须是 return normally。 16、调用 Subscription.request() 必须是 return normally。 17、一个 Subscription 必须支持无数次地调用 Subscription.request()，必须支持到 2^63 - 1（Long.MAX_VALUE）次。如果一个需求等于或大于 2^63 - 1（Long.MAX_VALUE），或许被 Publisher 认为是真正的无界。 - **Processor** ```Javapublic interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; &#123;&#125; 1、一个 Processor 表示一个处理阶段，它既是一个 Subscriber 又是一个 Publisher，必须遵守它们两者的契约。 2、一个处理器可以选择恢复一个onError调用。如果它选择这样做，必须认为订阅被取消，否则必须立即传播onError调用到它的订阅者。 在不被强制时，当最后一个订阅者取消它的订阅时，取消一个处理器的上游订阅是一个好主意，可以让这个取消调用往上游传播。 1.2 Reactive Programming 1Reactive Programming：一种技术，各自表达。 1.2.1 概念解释 维基百科： 是一种声明式的编程规范，其核心要素是数据流（data streams ）与其传播变化（ propagation of change），前者是关于数据结构的描述，包括静态的数组（arrays）和动态的事件发射器（event emitters）。像是Java中的： 数据流：Java 8 Stream 传播变化：Java Observable/Observer 事件/监听：Java EventObject/EventListener ReactiveX、Reactor 对观察者模式进行了扩展：通过 操作符（Operators） 对 数据/事件序列（Sequence of data or events） 进行操作，并且 屏蔽了并发细节，如线程 API（Exectuor 、Future、Runnable）、同步、线程安全、并发数据结构以及非阻塞 I/O。 Java API Java8中的 Stream API 也包含操作符，也屏蔽了并发细节，在数据结构方面Stream基本上就是数据流。与 ReactiveX 不同的是在 设计模式 上。 Stream 使用的是 迭代器模式（Iterator）； ReactiveX 使用的是 观察者模式（Observer） 两者的差异为： 迭代器模式（Iterator）属于：拉（pull）模式 观察者模式（Observer）属于：推（push）模式 来自 André Staltz In a way, this isn&#39;t anything new. Event buses or your typical click events are really an asynchronous event stream, on which you can observe and do some side effects. Reactive is that idea on steroids. You are able to create data streams of anything, not just from click and hover events. Streams are cheap and ubiquitous, anything can be a stream: variables, user inputs, properties, caches, data structures, etc. 1.2.2 Reactive Programming 使用场景 Reactive Streams JVM Reactive Streams 用于在 异步边界（asynchronous boundary） 管理 流式数据交换（ govern the exchange of stream data）。异步说明其并发模型，流式数据则体现数据结构，管理则强调它们的它们之间的协调。 Spring 5 Spring 认为 Reactive 和 非阻塞 通常并非让应用运行更快速（generally do not make applications run faster），甚至会增加少量的处理时间，因此，它的使用场景则是 性能：利用较少的资源，提升应用的伸缩性（scale with a small, fixed number of threads and less memory）。 ReactiveX ReactiveX 所描述的使用场景与 Spring 的不同，它没有从性能入手，而是 代码可读性 + 减少Bugs 的角度出发，解释了 Reactive Programming 的价值。 同时，强调其框架的核心特性：异步（asynchronous）、同顺序（same sort）和 组合操作（composable operations）。它也间接地说明了：Java 8 Stream 在 组合操作 的限制，以及操作符 的不足。 Reactor 同样强调 结构性 、可读性（Composability and readability）和 高层次并发抽象（High level abstraction），并明确地表示它提供 丰富的数据操作符（ rich vocabulary of operators）弥补 Stream API 的短板，还支持背压（Backpressure）操作，提供数据生产者和消费者的消息机制，协调它们之间的产销失衡的情况。同时，Reactor 采用订阅式数据消费（Nothing happens until you subscribe）的机制，实现 Stream 所不具备的数据推送机制。 1.2.3 总结 Reactive Programming 作为 观察者模式（Observer）的延伸，不同于传统的命令编程方式（ Imperative programming）同步拉取数据的方式，如迭代器模式（Iterator） 。而是采用数据发布者同步或异步地推送到数据流（Data Streams）的方案。当该数据流（Data Steams）订阅者监听到传播变化时，立即作出响应动作。 在实现层面上：Reactive Programming 可结合 函数式编程 简化面向对象语言语法的臃肿性，屏蔽并发实现的复杂细节，提供数据流的有序操作，从而达到提升代码的可读性，以及减少 Bugs 出现的目的。 同时，Reactive Programming 结合 背压（Backpressure）的技术解决发布端生成数据的速率高于订阅端消费的问题。 简单归纳为： 设计模式 - 观察者模式 数据/事件序列 -数据结构 或者 数据流 操作符 - 数据操作 并发模型 - 线程 支持背压 - 解决数据的生产与消费速度问题 2 RxJava2基础概念2.1 与 RxJava2.x 相关的参考网站：1.ReactiveX2.RxJava Github3.reactive-streams-jvm4.Reactive Stream5.RxJava 2.x javadoc 2.2 RxJava2是什么？或者说“ReactiveX”是什么？ Reactive框架的实现：通过使用 设计模式、数据结构（数据/事件序列）、数据操作（操作符）、并发模型 来实现这个框架。 Reactive Extensions for the JVM（Java VM implementation of Reactive Extensions） a library for composing asynchronous and event-based programs using observable sequences for the Java VM. It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures. 关键点： Reactive Extensions for the JVM observer pattern sequences of data/events operators to compose sequences asynchronous 2.3 RxJava Version 2.X 特点 single dependency: Reactive-Streams Java 8 lambda-friendly API async or synchronous execution non-opinionated about source of concurrency (threads, pools, event loops, fibers, actors, etc) virtual time and schedulers for parameterized concurrency 2.4 一个最基本的 观察者模式（Observer） Observable接口 12345678public interface Observable &#123; void register(Observer observer); void unRegister(Observer observer); void notifyObserver();&#125; Observable接口实现类：ObservableImp 123456789101112131415161718192021222324252627282930313233public class ObservableImp implements Observable &#123; private ArrayList&lt;Observer&gt; mObserverArrayList = null; public ObservableImp() &#123; mObserverArrayList = new ArrayList&lt;&gt;(); &#125; @Override public void register(Observer observer) &#123; mObserverArrayList.add(observer); &#125; @Override public void unRegister(Observer observer) &#123; if (mObserverArrayList.contains(observer)) &#123; mObserverArrayList.remove(observer); &#125; &#125; @Override public void notifyObserver() &#123; String newData = getNewData(); for (Observer observer : mObserverArrayList) &#123; observer.update(newData); &#125; &#125; private String getNewData() &#123; return "this is new msg"; &#125;&#125; Observer接口 123public interface Observer &#123; void update(Object object);&#125; Observer接口实现类：ObserverImp 1234567public class ObserverImp implements Observer &#123; @Override public void update(Object object) &#123; System.out.println("current data is : " + (String) object); &#125;&#125; 测试类：MainTest 123456789101112public class MainTest &#123; public static void main(String[] args) &#123; ObservableImp observableImp = new ObservableImp(); ObserverImp observerImp1 = new ObserverImp(); ObserverImp observerImp2 = new ObserverImp(); observableImp.register(observerImp1); observableImp.register(observerImp2); observableImp.notifyObserver(); &#125;&#125; 结果为： 12current data is : this is new msgcurrent data is : this is new msg 3 RxJava2.x 分析3.1 RxJava2.x Package 分析 io.reactivex：基础 reactive类，Flowable、Observable、Single、Maybe和Completable； 基础reactive消费者; 其他常见的基本接口。 io.reactivex.annotations：用于指示实验和beta运算符，类，方法，类型或字段的注释。 io.reactivex.disposables：基于Disposable的资源管理（一次性容器类型）和实用程序类的默认实现，用于从回调和其他类型构造Disposable。 io.reactivex.exceptions：异常处理实用程序，安全订阅者异常类，生命周期异常类。 io.reactivex.flowables：支持Flowable基础反应类的类：ConnectableFlowable和GroupedFlowable。 io.reactivex.functions：arity 0到9的函数和动作的功能接口以及相关的实用程序类。 io.reactivex.observables：支持Observable基础反应类的类：ConnectableObservable和GroupedObservable。 io.reactivex.observers：基于Observer的使用者类和接口的默认包装器和实现，包括一次性和资源跟踪变体，以及允许单元测试基于Observable，Single，Maybe和Completable的流的TestObserver。 io.reactivex.parallel：包含基本类型ParallelFlowable，一个用于并行处理Flowable序列的子DSL。 io.reactivex.plugins：包含中央插件处理程序RxJavaPlugins类，以挂接到基本响应类型和调度程序的生命周期。 io.reactivex.processors：表示实现FlowableProcessor类的所谓热背压感知源（即处理器）的类，Reactive Streams Processor接口允许向一个或多个订户发送多播事件形式以及使用另一个Reactive Streams Publisher。 io.reactivex.schedulers：特别包含调度程序的工厂类，提供用于检索标准调度程序实例的方法，用于以受控方式调度流的TestScheduler以及可以保存与之关联的值和时间戳的类Timed。 io.reactivex.subjects：表示所谓的热源（即主题）的类，它们一次实现基本反应类和相应的消费者类型，以允许多个消费者的多播事件形式以及消费他们类型的另一个基本反应类型。 io.reactivex.subscribers：基于subscribers的使用者类和接口的默认包装器和实现，包括一次性和资源跟踪变体以及允许单元测试基于Flowable的流的TestSubscriber。 3.2 创建 概念解释 被观察者：Observable（不支持背压）/Flowable（支持 背压(Backpressure) ）观察者：Observer/Subscriber 创建步骤 1）创建：被观察者2）创建：观察者3）订阅 4 操作符4.1 Creating（创建） Observables4.1.1 Create最常用的操作符，用于创建一个具有发射事件能力的被观察者 4.1.2 just只是简单的原样发射,可将数组或Iterable当做单个数据。它接受1至9个参数： 12345678Disposable disposable2 = Observable.just(1, 23).subscribe(integer -&gt; System.out.println("integer is : " + integer));System.out.println("disposable2 is : " + disposable2.isDisposed());/* * integer is : 1 * integer is : 23 * disposable2 is : true */ 4.1.3 from系列将数组或Iterable的元素拿出来，做成多个事件进行发射。 注意：在使用fromArray()时，数组的声明类型如果是基本数据类型，则必须是基本数据类型的包装类型。如果使用int[]，则在声明观察者时，返回参数类型也是int[]数组，而不是单个的元素；如果使用Integer[]，则在声明观察者时，返回的参数类型是Integer元素，不是数组 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Integer[] nums = new Integer[]&#123;44,55,66&#125;;// fromArray()Disposable disposable3 = Observable.fromArray(nums).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println("integer is : " + integer); &#125;&#125;);System.out.println("disposable3 is : " + disposable3.isDisposed());/* * integer is : 44 * integer is : 55 * integer is : 66 * disposable3 is : true */ String[] strs = new String[]&#123;"a","b","c"&#125;; Disposable disposable = Observable.fromArray(strs).subscribe(new Consumer&lt;String&gt;()&#123; @Override public void accept(String s) throws Exception &#123; System.out.println("array s is : " + s); &#125;&#125;);System.out.println("disposable is : " + disposable.isDisposed());/* * array s is : a * array s is : b * array s is : c * disposable is : true */ArrayList&lt;String&gt; integers = new ArrayList&lt;&gt;();integers.add("A");integers.add("B");integers.add("C");// fromIterable()Disposable disposable1 = Observable.fromIterable(integers).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println("s is : " + s); &#125;&#125;);System.out.println("disposable1 is : " + disposable1.isDisposed());/* * s is : A * s is : B * s is : C * disposable1 is : true */ 4.1.4 Interval定时任务（心跳包） 4.2 Transforming（变换） Observables4.3 Filtering（过滤） Observables4.4 Combining（合并） Observables4.5 Error Handling（异常处理） Operators4.6 Observable Utility(公用) Operators4.7 Conditional and Boolean（条件与布尔） Operators4.8 Mathematical and Aggregate（数学与聚合） Operators4.9 Backpressure（背压） Operators4.10 Connectable Observable（可连接） Operators4.11 Operators to Convert Observables（转换被观察者）4.12 Implementing Your Own Operators（自定义）参考文章1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Reactive StreamsReactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.NEWS: JDK9 java.util.concurrent.FlowThe interfaces available in JDK9’s java.util.concurrent.Flow, are 1:1 semantically equivalent to their respective Reactive Streams counterparts. This means that there will be a migratory period, while libraries move to adopt the new types in the JDK, however this period is expected to be short - due to the full semantic equivalence of the libraries, as well as the Reactive Streams &lt;-&gt; Flow adapter library as well as a TCK compatible directly with the JDK Flow types.Read this if you are interested in learning more about Reactive Streams for the JVM.The ProblemHandling streams of data—especially “live” data whose volume is not predetermined—requires special care in an asynchronous system. The most prominent issue is that resource consumption needs to be controlled such that a fast data source does not overwhelm the stream destination. Asynchrony is needed in order to enable the parallel use of computing resources, on collaborating network hosts or multiple CPU cores within a single machine.The main goal of Reactive Streams is to govern the exchange of stream data across an asynchronous boundary—think passing elements on to another thread or thread-pool—while ensuring that the receiving side is not forced to buffer arbitrary amounts of data. In other words, back pressure is an integral part of this model in order to allow the queues which mediate between threads to be bounded. The benefits of asynchronous processing would be negated if the communication of back pressure were synchronous (see also the Reactive Manifesto), therefore care has to be taken to mandate fully non-blocking and asynchronous behavior of all aspects of a Reactive Streams implementation.It is the intention of this specification to allow the creation of many conforming implementations, which by virtue of abiding by the rules will be able to interoperate smoothly, preserving the aforementioned benefits and characteristics across the whole processing graph of a stream application.ScopeThe scope of Reactive Streams is to find a minimal set of interfaces, methods and protocols that will describe the necessary operations and entities to achieve the goal—asynchronous streams of data with non-blocking back pressure.End-user DSLs or protocol binding APIs have purposefully been left out of the scope to encourage and enable different implementations that potentially use different programming languages to stay as true as possible to the idioms of their platform.We anticipate that acceptance of this Reactive Streams specification and experience with its implementations will together lead to wide integration, for example including Java platform support in future JDK releases or network protocol support in future web browsers.Working GroupsBasic SemanticsThe basic semantics define how the transmission of stream elements is regulated through back-pressure. How elements are transmitted, their representation during transfer, or how back-pressure is signaled is not part of this specification.JVM Interfaces (Completed)This working group applies the basic semantics to a set of programming interfaces whose main purpose is to allow the interoperation of different conforming implementations and language bindings for passing streams between objects and threads within the JVM, using the shared memory heap.As of December 19th, 2017 we have released version 1.0.2 of Reactive Streams for the JVM, including Java API, a textual Specification, a TCK and implementation examples.New in 1.0.2 is the JDK9 adapter library and the JDK9 TCK for Flow.Corresponding code artifacts are available on Maven Central:&lt;dependency&gt; &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt; &lt;artifactId&gt;reactive-streams&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt; &lt;artifactId&gt;reactive-streams-tck&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt; &lt;artifactId&gt;reactive-streams-flow-adapters&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt; &lt;artifactId&gt;reactive-streams-tck-flow&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt; &lt;artifactId&gt;reactive-streams-examples&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;The source code for these is available on github. Please use github issues for providing feedback.All artifacts and specifications are released under Creative Commons Zero into the Public Domain.Read more about Reactive Streams 1.0.2 for the JVM here.A Note for ImplementorsTo get started implementing the final specification, it is recommended to start by reading the README and the Java API documentation, then taking a look at the Specification then taking a look at the TCK and the example implementations. If you have an issue with any of the above, please take a look at closed issues and then open a new issue if it has not already been answered.This work was performed in the reactive-streams-jvm repository.JavaScript InterfacesThis working group defines a minimal set of object properties for observing a stream of elements within a JavaScript runtime environment. The goal is to provide a testable specification that allows different implementations to interoperate within that same runtime environment.This work is performed in the reactive-streams-js repository.Network ProtocolsThis working group defines network protocols for passing reactive streams over various transport media that involve serialization and deserialization of the data elements. Examples of such transports are TCP, UDP, HTTP and WebSockets.This work is performed in the reactive-streams-io repository. 参考： https://yq.aliyun.com/articles/617466https://www.reactivemanifesto.org/?spm=a2c4e.11153940.blogcont617466.22.7baa5ab8WGQ0TgJVM平台上的响应式流（Reactive Streams）规范Reactive Programminghttp://reactivex.io/https://github.com/ReactiveX/RxJavaRxJava2.x javadochttps://gist.github.com/staltz/868e7e9bc2a7b8c1f754?spm=a2c4e.11153940.blogcont617466.36.7baa5ab8WGQ0Tg#reactive-programming-is-programming-with-asynchronous-data-streams]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专题]]></title>
    <url>%2F%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[专题总结 数据结构 专题温故知新-数据结构-C指针 温故知新-数据结构-数组、链表C 温故知新-数据结构-算法复杂度 温故知新-数据结构-hash 温故知新-数据结构-树 温故知新-数据结构-数组题解 温故知新-数据结构-链表题解 设计模式 专题 设计模式与设计原则 单例模式 观察者模式 建造者模式%E6%A8%A1%E5%BC%8F/) 责任链模式 抽象工厂模式 迭代模式 代理模式 装饰者模式 原型模式 JVM 专题 JVM理解-javac编译器 JVM理解-class文件 JVM理解-并发与JVM内存模型 JVM理解-内存管理 JVM理解-编译、加载 Java 专题Java-字符串 Java-容器 Java-反射 线程 专题线程-概述 线程池-相关类 线程池-ThreadPoolExecutor Android-AsyncTask Android 专题 消息机制 IPC Service Activity Window与Window相关类 View-点击事件分发机制 View-绘制原理 优化-全面 优化-关键字、内部类使用 优化-屏幕适配 优化-内存相关 动画-Canvas 动画-属性动画 Apk打包 Apk反编译 View-XML形状、颜色绘制 View-自定义-TypedArray View-自定义-Paint使用详解 View-自定义-绘制图表%20%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8/) View-自定义-Canvas+Paint+Path View-组合自定义 蓝牙-传统 蓝牙-BLE NFC 新特性-8.0/8.1 Notification的使用 新特性-Shortcuts WebView的使用 框架-MVP初探 aseets中的文件读取 FileProvider 文字处理 获取数字签名 aar压缩包 Android各个支持库 百度地图 macOS下Android源码编译 线程-AsyncTask 开源库-GreenDao 开源库-Retrofit2 开源库-RxJava 开源库-OkHttp3 开源库-OkHttp3-Interceptor 开源库-EventBus 开源库-SwipeToLoadLayout KitKit Dart-Flutter 专题Dart-Tour1 Dart-Tour2 Dart-Tour3 Dart/Flutter Kotlin 专题Kotlin基础 Kotlin递进 Groovy 专题Groovy基础 Gradle 专题Gradle基础 Gradle与Android Git 专题Git基础 Python3 专题Python3 基础-基本数据类型 Python3 函数-返回值 Python3 函数-参数类型 Python3 函数-生成器+切片 Python3 数据-序列 Python3 函数式编程-函数作为返回值 Python3 函数式编程-高阶函数 Python3 迭代器 Python3 闭包+匿名+装饰器+偏函数 Python3 模块 Python3 面向对象 Python3 面向对象+临时变量、方法+@property+多继承 Python3 面向对象+定制对象 Python3 错误+测试+调试 Python3 面向对象+元类 Python3 面向对象+枚举 Python3 调试 Python3 单元测试 Python3 I/O Python3 安装爬虫工具Scrapy Python3 Scrapy爬虫框架使用 Python3 Scrapy爬取练手-5级联动数据 心得 专题熟悉项目 阅读源码 记一次翻车-个人博客图床问题 系统配置 专题Linux Vim操作命令 Linux Ubuntu桌面使用命令 Linux Ubuntu16.04安装记录 Linux Alias的使用 Mac环境下MySQ安装与使用 Mac环境下Hexo-GitHub-MWeb搭建个人博客]]></content>
      <categories>
        <category>专题</category>
      </categories>
      <tags>
        <tag>专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App优化-小]]></title>
    <url>%2FApp%E4%BC%98%E5%8C%96-%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[App优化-小 故事引用： 12345假如饭点将至，需要打开订餐APP进行点餐：首先一定不希望，在浏览商家和菜品列表内容很丰富的时候遇到卡顿现象；然后千挑万选后在期待美食将至的心情下准备下单，突然遇到闪退崩溃，那简直想卸载APP的心都有了；其次就是配送员在配送过程中不希望耗电和耗流量太严重；最后就是用户和配送员都希望版本更新的时候安装包希望能小一点。 一张图表述 App 性能优化切入点： Android Studio 自带的 Lint3.2 在线图片压缩工具 TinyPNG。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App优化-省]]></title>
    <url>%2FApp%E4%BC%98%E5%8C%96-%E7%9C%81%2F</url>
    <content type="text"><![CDATA[App优化-省 故事引用： 12345假如饭点将至，需要打开订餐APP进行点餐：首先一定不希望，在浏览商家和菜品列表内容很丰富的时候遇到卡顿现象；然后千挑万选后在期待美食将至的心情下准备下单，突然遇到闪退崩溃，那简直想卸载APP的心都有了；其次就是配送员在配送过程中不希望耗电和耗流量太严重；最后就是用户和配送员都希望版本更新的时候安装包希望能小一点。 一张图表述 App 性能优化切入点： 省电Android中是从2个方面做耗电的统计： 软件 硬件 软件耗电统计所谓 软件耗电统计 是通过 代码估算 的。准确度取决于厂商 ROM 所提供的 power_profile.xml 文件。由于不同厂商 power_profile.xml 准确度及源码有差异，因此不同手机、不同版本的数据可能有较大差异。 硬件耗电统计参考 电量数据采集数据的采集是 机器单方面 的行为，不需要依赖第三方的辅助，因为这是 Android 系统级 的功能。 步骤： 打开 开发者模式，开启USB调试，USB连接计算机，开启电量记录，终端中执行： 1adb shell dumpsys batterystats --enable full-wake-history 出现：Enabled: full-wake-history 则表示成功。 然后执行 重置 操作： 1adb shell dumpsys batterystats --reset 出现：Battery stats reset. 表示运行成功。此时断开USB连接。 操作一段要测试的App后，连接USB，导出电量统计数据，在终端中执行： 1adb bugreport bugreport.zip 然后，关闭 全量记录唤醒，在终端中操作： 1adb shell dumpsys batterystats --disable full-wake-history 搭建 Battery Historian &amp; 上传Battery Historian，是谷歌出品的耗电分析器，是在运行Android 5.0 Lollipop（API级别21）及更高版本的Android设备上检查电池相关信息和事件的工具，。通过 Battery Historian，可将导出的 bugreport文件 可视化。 步骤： 安装 Docker 启动 Docker。点击上方状态栏 Docker 图标，如图所示 “Docker is running” 则表示启动成功。 在终端中通过 docker 搜索 battery historian，执行： 1docker search battery 搜索的结果为： 安装第一个数据源： 1docker run --name=battery2.0 -d -p 9999:9999 bhaavan/battery-historian 结果： 本地执行： 1]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App优化-快]]></title>
    <url>%2FApp%E4%BC%98%E5%8C%96-%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[App优化-快 故事引用： 12345假如饭点将至，需要打开订餐APP进行点餐：首先一定不希望，在浏览商家和菜品列表内容很丰富的时候遇到卡顿现象；然后千挑万选后在期待美食将至的心情下准备下单，突然遇到闪退崩溃，那简直想卸载APP的心都有了；其次就是配送员在配送过程中不希望耗电和耗流量太严重；最后就是用户和配送员都希望版本更新的时候安装包希望能小一点。 一张图表述 App 性能优化切入点： 1 关于 快 的总结关于 卡顿情景 的总结： 关于 卡顿因素 的总结 2 启动方式分为3种： 冷启动（Cold Start） 热启动（Hot Start） 温启动（Warm Start） 2.1 冷启动（Cold Start） 冷启动 的大致过程：当用户点击Launcher中App图标时，会通知 AMS 启动App的入口 Activity，若发现此这个App还未启动，则通知 Zygote 去孵化（fork）一个进程（process），AMS 保存一个进程的 代理对象。在这个进程中执行 ActivityThread类 的入口 main()，在这里名做 Loop 的准备、 消息队列，通过 ActivityThread类 的 attach() 将进程绑定到 AMS中，获取 Handler 对象，最后开始 loop 循环。 在冷启动开始时，系统有3个任务。这些任务是： 通过AMS调用ActivityStack，然后通过 WindowManagerService来创建Window； 然后 立即显示 应用程序的 空白启动窗口（可以通过设置Application的theme修改)； 创建Process、创建Application、创建Activity。 实际上 第2步 和 第3步 应该是 同时进行 的。如果 第3步 操作的时间足够快，那么 第2步 中的 白屏 可能就不会被用户感觉到。 一旦系统创建了应用程序流程，应用程序流程就会负责下一个阶段： 创建Application对象 启动主线程 创建主Activity 加载布局 屏幕布局 执行初始绘制 应用程序进程完成第一次绘制后，系统进程 会 交换 当前显示的 背景窗口，将其 替换 为主Activity。此时，用户可以开始使用该应用程序。至此启动完成。 根据这个流程分析，在进行 Application 与 Activity 创建时可能会出现 性能问题。 下图展示了系统和应用启动时相互之间的关系： 以上流程中的大部分由系统来控制，出现性能问题的地方往往在 Application 和 Activity 的创建 (onCreate) 过程中。 2.1.1 Application创建 当Application启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成应用程序绘制。 此时，系统进程会 交换 应用程序的启动窗口，允许用户开始与应用程序进行交互。这就是为什么我们的程序启动时会先出现一段时间的 黑屏(白屏)。 如果我们有自己的Application，系统会在我们的Application对象上调用onCreate()方法。 之后，应用程序会生成 主线程（也称为UI线程），并通过创建主Activity来执行任务。从这一点开始，App就按照他的 应用程序生命周期阶段进行。 总结来说就是：Application创建 -&gt; UI线程 -&gt; Activity创建 2.1.2 Activity创建 Application进程创建活动后，活动将执行以下操作： 初始化值。 调用构造函数。 调用回调方法，例如 Activity.onCreate()，对应Activity的当前生命周期状态。 通常，该 onCreate() 方法对加载时间 的影响最大，因为它以最高的开销执行工作：加载和填充视图，以及初始化活动运行所需的对象。 2.1.3常见问题Android开发者博客 2.1.4 闪屏页的启动逻辑优化 黑白屏问题 2.2 热启动（Hot start）热启动 就是：后台已有该进程，当再次启动App时，这种启动就会从已有的启动中启动应用。 热启动 因为会从 已有的进程中来启动，所以热启动就不会走 Application 这步了，而是直接走 MainActivity，所以热启动的过程不必 创建和初始化 Application，因为一个应用从新进程的创建到进程的销毁， Application 只初始化一次。 应用程序的热启动比冷启动要简单得多，开销也更低。在一个热启动中，系统都会把你的Activity带到前台。如果应用程序的Activity仍然驻留在内存中，那么应用程序可以避免重复对象初始化、布局加载和渲染。 注意：**热启动显示与冷启动方案相同的屏幕行为：系统进程显示空白屏幕，直到应用程序完成呈现活动**。 热启动包括冷启动期间发生的一些操作子集; 同时，它比热启动代表更少的开销。有许多潜在的状态可以被视为热启动。例如： 用户退出应用，但随后重新启动它。该过程可能已继续运行，但应用程序必须通过调用从头开始重新创建 Activity 的 onCreate()。 系统将应用程序从内存中逐出，然后用户重新启动它。需要重新启动进程和活动，但是任务可以从传入的已保存实例状态包中获益 onCreate()。 2.3 温启动（Warm start）温启动 严格来说也是 冷启动，之所以把首次启动单独列出来，一般来说，温启动 时间会比非首次启动要久，温启动 会做一些 系统初始化 工作，如： 缓存目录的生产； 数据库的建立； SharedPreference的初始化； 如果存在 多dex 和 插件 的情况下，首次启动会有一些特殊需要处理的逻辑，而且对启动速度有很大的影响。 所以首次启动的速度非常重要，毕竟影响用户对 App 的第一印象。 场景： 用户退出您的应用，但随后重新启动它。该过程可能已继续运行，但应用程序必须通过调用从头开始重新创建Activity 的onCreate()。 系统将您的应用程序从内存中逐出，然后用户重新启动它。需要重新启动进程和活动，但是在调用onCreate()的时候可以从Bundle（savedInstanceState）获取数据。 谷歌官方给的建议是：1、利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；2、避免在启动时做密集沉重的初始化（Heavy app initialization）；3、避免I/O操作、反序列化、网络操作、布局嵌套等。 这里是慢的定义： 冷启动需要5秒或更长时间。 温启动需要2秒或更长时间。 热启动需要1.5秒或更长时间。 无论何种启动，我们的优化点都是：Application、Activity创建以及回调等过程 参考 3 快-启动时间统计设计一个统计时间的工具类（来自网络） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /** * 计时统计工具类 */public class TimeUtils &#123; private static HashMap&lt;String, Long&gt; sCalTimeMap = new HashMap&lt;&gt;(); public static final String COLD_START = "cold_start"; public static final String HOT_START = "hot_start"; public static long sColdStartTime = 0; /** * 记录某个事件的开始时间 * @param key 事件名称 */ public static void beginTimeCalculate(String key) &#123; long currentTime = System.currentTimeMillis(); sCalTimeMap.put(key, currentTime); &#125; /** * 获取某个事件的运行时间 * * @param key 事件名称 * @return 返回某个事件的运行时间，调用这个方法之前没有调用 &#123;@link #beginTimeCalculate(String)&#125; 则返回-1 */ public static long getTimeCalculate(String key) &#123; long currentTime = System.currentTimeMillis(); Long beginTime = sCalTimeMap.get(key); if (beginTime == null) &#123; return -1; &#125; else &#123; sCalTimeMap.remove(key); return currentTime - beginTime; &#125; &#125; /** * 清除某个时间运行时间计时 * * @param key 事件名称 */ public static void clearTimeCalculate(String key) &#123; sCalTimeMap.remove(key); &#125; /** * 清除启动时间计时 */ public static void clearStartTimeCalculate() &#123; clearTimeCalculate(HOT_START); clearTimeCalculate(COLD_START); sColdStartTime = 0; &#125;&#125; 3.1 本地 局部方法 运行时间同步在 具体方法 中使用 TimeUtils 工具类。 3.2 本地 全局统计 — 使用adb 启动指定 Activity 1adb shell am start -n 包名/.指定Activity 关闭App 1adb shell am force-stop 包名 以下这个命令表示：通过 adb 的方式，循环启动指定Activity的，统计启动时间 -S 表示每次启动前先强制停止； -R 表示循环启动的次数为10次， -W表示具体的启动路径 1adb shell am start -S -R 10 -W com.yannis.myapplication/.MainActivity 注意：S/R/W 必须为大写。 得到的结果为： 12345678Stopping: com.yannis.myapplicationStarting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.yannis.myapplication/.MainActivity &#125;Status: okActivity: com.yannis.myapplication/.MainActivityThisTime: 1165TotalTime: 1165WaitTime: 1308Complete 返回值说明： ThisTime：表示 一连串Activity 启动中的 最后一个Activity 的启动耗时； TotalTime：表示 新应用启动 的耗时，包括 新进程 的启动和 Activity 的启动，但 不包括 前一个应用 Activity pause() 的耗时。 WaitTime： 从 startActivity() 到 应用第一帧 完全显示这段时间。就是 总耗时 = 前一个应用Activity的pause() 的时间 + 新应用启动 的时间； 我们一般只要关心 TotalTime 即可，这个时间才是 自己应用真正启动 的耗时。 缺点： 实际场景中，可能当前Activity的启动过程需要经历多个Activity，此时的启动时间因此 不准确。 此命令仅统计Activity启动以及初始化时间，并不能统计一些数据、动画初始化的时间。因此与用户感知时间不同。导致 有误差。 在AndroidManifest.xml对应的Activity声明中没有指定&lt;intent-filter&gt;或者属性没有android:exported=&quot;true&quot;的Activity不能使用这种命令行的形式计算启动时间。因此 有限制 3.3 线上统计 — Log将App发送到线上之后，就不能再通过 adb 的方式获取时间了，要做启动时间统计的工作可以通过 Log 的方式获取启动时间。 有了解决问题的方式，那么就要进行实施，实施的关键就在于：在哪里打Log，打 Log位置 的准确与否，将决定统计的时间是否准确。 既然知道是 位置 决定 统计时间 的 准确 性，那么就要具体分析位置了，实际上就是分析 App的启动流程 了，分析启动流程和各个生命周期函数的调用顺序。 3.3.1 生命周期函数执行流程12345678910-&gt; Application 构造函数-&gt; Application.attachBaseContext()-&gt; Application.onCreate()-&gt; Activity 构造函数-&gt; Activity.setTheme()-&gt; Activity.onCreate()-&gt; Activity.onStart-&gt; Activity.onResume-&gt; Activity.onAttachedToWindow-&gt; Activity.onWindowFocusChanged 要记录启动统计时间，就需要有2个时间点，对应着就需要2个方法： 1. 启动时间： 冷启动 一般可以在 Application.attachBaseContext() 开始的位置记录起始时间点，因为在这之前 Context 还没有初始化，一般也干不了什么事情，当然这个是要视具体情况来定，其实 只要保证在 App 的具体业务逻辑 开始执行之前记录起始时间点即可。 热启动 启动时间点可以在 Activity.onRestart() 中记录起始时间点。 2. 结束时间： 一般情况下认为在 Activity 的 onResume() 方法执行完成之后，Activity 就对用户可见了，实际上并不是。 一个 Activity 走完 onCreate() 、onStart() 、onResume() 这几个生命周期之后，只是完成了 应用自身 的一些配置，比如：Activity 主题设置、 window 属性的设置、 View树 的建立，但是其实后面还需要 各个View 执行 measure()、 layout()、 draw()等。 所以在 OnResume() 中记录结束时间点的 Log 并不准确，那么根据上面流程中我们可以看到最后一个函数 ：Activity.onWindowFocusChanged()。 onResume()方法的注释中专门提到这个问题 12345678/** * &lt;p&gt;Keep in mind that onResume is not the best indicator that your activity * is visible to the user; a system window such as the keyguard may be in * front. Use &#123;@link #onWindowFocusChanged&#125; to know for certain that your * activity is visible to the user (for example, to resume a game). */@CallSuperprotected void onResume() &#123;&#125; 大意为： 12请记住，onResume() 不是您的活动对用户可见的最佳指标; 诸如键盘锁之类的系统窗口可以在前面。使用&#123;@link #onWindowFocusChanged&#125;可以确定您的活动对用户可见（例如，恢复游戏）。 以及： 1234567/** * Called when the current &#123;@link Window&#125; of the activity gains or loses * focus. This is the best indicator of whether this activity is visible * to the user. The default implementation clears the key tracking * state, so should always be called. */public void onWindowFocusChanged(boolean hasFocus) &#123;&#125; 大意为： 1当活动的当前&#123;@link Window&#125;获得或失去焦点时调用。这是该活动对用户是否可见的最佳指标。 到此为止，我们已经找到了对应的启动时间统计方法，接下来就要进行统计了。 3.3.2 执行启动时间统计使用这个上文中提到的 TimeUtils 工具类 在 Application#attachBaseContext()方法中添加如下代码： 1234567@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); if (/**如果是主进程**/) &#123; TimeUtils.beginTimeCalculate(TimeUtils.COLD_START); &#125;&#125; 在 第一个Activity 的 onCreate() 方法中添加如下代码： 123456789101112@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); calculateStartTime(); ....&#125;private void calculateStartTime() &#123; long coldStartTime = TimeUtils.getTimeCalculate(TimeUtils.COLD_START); // 这里记录的TimeUtils.coldStartTime是指Application启动的时间，最终的冷启动时间等于Application启动时间+热启动时间 TimeUtils.sColdStartTime = coldStartTime &gt; 0 ? coldStartTime : 0; TimeUtils.beginTimeCalculate(DictTimeUtil.HOT_START);&#125; 在 真正的首页Activity 的 onWindowFocusChanged() 方法中添加如下代码： 12345678910111213141516171819 @Overridepublic void onWindowFocusChanged(boolean hasFocus) &#123; if (hasFocus &amp;&amp; /**没有经过广告或者引导页**/) &#123; long hotStartTime = TimeUtils.getTimeCalculate(TimeUtils.HOT_START); if (TimeUtils.sColdStartTime &gt; 0 &amp;&amp; hotStartTime &gt; 0) &#123; // 真正的冷启动时间 = Application启动时间 + 热启动时间 long coldStartTime = TimeUtils.sColdStartTime + hotStartTime; // 过滤掉异常启动时间 if (coldStartTime &lt; 50000) &#123; // 上传冷启动时间coldStartTime &#125; &#125; else if (hotStartTime &gt; 0) &#123; // 过滤掉异常启动时间 if (hotStartTime &lt; 30000) &#123; // 上传热启动时间hotStartTime &#125; &#125; &#125;&#125; 3.4 工具的使用3.4.1 Android Studio 自动工具3.4.2 第三方启动时间统计分析利器：nimbledroid 及其 使用参考特点： 分享：在这个阶段输入相应的开发人员邮箱，等分析结束后，结果会发送到相应人员的邮箱中。这对组内协作特别方便。 自动化：具体可以分为 gradle jekins 这2中集成方式。 3.4.3 在线图片压缩工具 TinyPNG。3.5 启动时间相关 的问题解决方法3.5.1 启动白屏问题思路：给应用设置一个与主界面类似的启动画面，这样做可以向用户隐藏这个启动过程，用户会感受到应用已经在运行了，显示的界面就是应用的一部分或者说是流程的一部分。 具体方法： 使用 Activity 的 windowBackground 属性，在启动时显示简单的自定义的画面： 创建一个要在启动时显示的画面 12345678910&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" android:opacity="opaque"&gt; &lt;!-- The background color, preferably the same as your normal theme --&gt; &lt;item android:drawable="@android:color/white"/&gt; &lt;!-- Your product logo - 144dp color version of your app icon --&gt; &lt;item&gt; &lt;bitmap android:src="@drawable/product_logo_144dp" android:gravity="center"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 自定义一个 style: 123&lt;style name="AppTheme.Launcher" parent="@style/PeopleTheme"&gt; &lt;item name="android:windowBackground"&gt;@drawable/start_activity_background&lt;/item&gt;&lt;/style&gt; 在 super.onCreate() 之前调用 setTheme(R.style.AppTheme)，如下所示： 123456789public class MyMainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; // Make sure this is before calling super.onCreate setTheme(R.style.Theme_MyApp); super.onCreate(savedInstanceState); // ... &#125;&#125; 3.5.2 视图显示问题：MessageQueue类的IdleHandler接口的使用使用参考 源码相关： MessageQueue#IdleHandler 1234567891011121314/** * Callback interface for discovering when a thread is going to block * waiting for more messages. */public static interface IdleHandler &#123; /** * Called when the message queue has run out of messages and will now * wait for more. Return true to keep your idle handler active, false * to have it removed. This may be called if there are still messages * pending in the queue, but they are all scheduled to be dispatched * after the current time. */ boolean queueIdle();&#125; 源码声明：MessageQueue# 12private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;();private IdleHandler[] mPendingIdleHandlers; 源码相关方法： MessageQueue# addIdleHandler(): 12345678public void addIdleHandler(@NonNull IdleHandler handler) &#123; if (handler == null) &#123; throw new NullPointerException("Can't add a null IdleHandler"); &#125; synchronized (this) &#123; mIdleHandlers.add(handler); &#125;&#125; MessageQueue# removeIdleHandler(): 12345public void removeIdleHandler(@NonNull IdleHandler handler) &#123; synchronized (this) &#123; mIdleHandlers.remove(handler); &#125;&#125; 源码调用：MessageQueue# Message next(): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// line:310Message next() &#123; // …… // -1 only during first iteration int pendingIdleHandlerCount = -1; for (;;) &#123; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0;&#125; 实际使用： 注意：pendingIdleHandlerCount = -1 已经说明只能在 第1次遍历 时才能处理 IdleHandler 12345678Looper.myQueue().addIdleHandler(new IdleHandler() &#123; @Override public boolean queueIdle() &#123; ... return false; &#125;&#125; 4 快-绘制过程分析从原理入手：CPU、GPU、屏幕（VYSYNC，16ms，60帧） 优化方法：先嵌套、后背景。 在 布局 这个解决方向中，最为重要的的一点就是 布局嵌套层级 的问题。如果一个 View树 的高度太高就会严重影响测量、布局和绘制的速度。 对比理解 RelativeLayout类 与 LinearLayout 2种布局方式： 在 RelativeLayout类 的 onMeasure() 中，执行 2次 遍历： 1234567891011protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; View[] views = mSortedHorizontalChildren; int count = views.length; for (int i = 0; i &lt; count; i++) &#123;&#125; views = mSortedVerticalChildren; count = views.length; final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion; for (int i = 0; i &lt; count; i++) &#123;&#125; &#125; 在 LinearLayout类 的 onMeasure() 中，执行 1次 遍历： 1234567protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; 虽然2者在 for循环 的操作数上存在差异，LinearLayout类 好于 RelativeLayout类，但是有一点可以明显确定的就是：RelativeLayout类 的嵌套层级一般情况下明显少于 LinearLayout类 。 4.1 检测方式 Android Studio 自带布局查看器：Layout Inspector 手机的 开发者选项：调试GPU过度绘制，查看布局层数 4.2 优化方法 &lt;include&gt;标签 作用：布局复用。 &lt;merge&gt;标签 作用：降低View树层级，减少视图结点。使用 &lt;merge/&gt; 注意： &lt;merge/&gt; 必须放在布局文件的根节点上。 &lt;merge/&gt; 不是一个ViewGroup，也不是一个View，它相当于声明了一些视图，等待被添加。 &lt;merge/&gt; 标签被添加到A容器下，那么 &lt;merge/&gt; 下的所有视图将被添加到A容器下。 因为 &lt;merge/&gt; 并不是View，所以在通过 LayoutInflate.inflate 方法渲染的时候， 第二个参数必须指定一个 父容器，且第三个参数必须为 true，也就是必须为 &lt;merge/&gt; 下的视图指定一个父亲节点。 如果Activity的布局文件根节点是FrameLayout，可以替换为 &lt;merge/&gt;，这样，执行setContentView之后，会减少一层FrameLayout节点。 自定义View如果继承LinearLayout，建议让自定义View的布局文件根节点设置成 &lt;merge/&gt;，这样能少一层结点。 因为 &lt;merge/&gt; 不是View，所以对 &lt;merge/&gt;标签设置的所有属性都是无效的。 &lt;ViewStub&gt;懒加载 作用：提前填充布局，延时真正布局的加载。inflate() 方法只能调用一次，不建议通过 setVisibility() 加载视图 使用 要实现的操作：在一个 Activity 上放置了一个按钮，点击后加载懒加载的视图。 1、 Activity布局文件定义 my_sub_activity.xml： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:onClick=&quot;onClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;加载视图&quot;/&gt; &lt;ViewStub android:id=&quot;@+id/stub&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/my_sub_tree&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt; android:inflatedId 指定了懒加载视图跟节点的 ID，android:layout 指定了懒加载的视图。android:layout_width、android:layout_height 分别指定了懒加载视图的宽和高。 2、 懒加载布局文件 my_sub_tree.xml： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffffff&quot; android:gravity=&quot;center&quot; android:padding=&quot;10dip&quot; android:text=&quot;懒加载视图&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;22sp&quot;&gt;&lt;/TextView&gt; 3、 在 Activity 中调用的代码，点击后查到ViewStub对象，并加载视图 1234567@Overridepublic void onClick(View v) &#123; // 这里调用的是inflate方法，当然，也可以调用setVisibility方法（但是不建议这么做） // 只能点击一次加载视图按钮，因为inflate只能被调用一次 // 如果再次点击按钮，会抛出异常&quot;ViewStub must have a non-null ViewGroup viewParent&quot; ((ViewStub) findViewById(R.id.stub)).inflate();&#125; 效果图： &lt;ViewStub/&gt; 在VIew树中加载的前后对比： 加载前： 加载后： 颜色 如果父控件有颜色，也是自己需要的颜色，那么就不必在子控件加背景颜色 如果每个子控件的颜色不太一样，而且可以完全覆盖父控件，那么就不需要再父控件上加背景颜色 onDraw() 处理方法： 不要做耗时的任务，也 不做过多的循环操作，特别是 嵌套循环，虽然每次循环耗时很小，但是大量的循环势必 霸占CPU的时间片，从而造成View的绘制过程不流畅。 不要创建新的局部对象，因为 onDraw() 方法一般都会 频繁大量调用，就意味着会 产生大量的临时对象，不仅 占用过的内存，而且会导致系统更加 频繁的GC，大大降低程序的执行速度和效率。 参考1参考2]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[责任链模式 释义多个对象处理一个请求，多个对象是由当前对象对下一个对象的引用而连接在一起的一条链，从而形成一条处理请求的链，当请求在这条链上进行传递，直到链上的某一个对象处理此请求。客户端发送请求后，不知道是责任链上的哪一个对象处理了请求。这样的好处是：可以对客户端过来的请求做动态的处理。 责任链模式的分类 纯责任链模式： 当请求到达一个处理者对象时，这个处理者对象只能在2个行为中选择其中一个，要么 “承担责任”，处理请求；要么将责任推给下家； 一个请求必须被某一个处理者对象所接收。 非纯责任链模式： 一个具体的处理对象在承担了一部分责任后，又把责任传给下一个处理者； 一个请求可以最终不被任何处理者对象所接收。 非纯责任链模式 适合 对一个结果做分步骤操作，动态的去完成一个结果，更加灵活。 一个实际生活中的例子-击鼓传花在击鼓传花这个游戏中，传花 就是一个请求事件，参与这个游戏的人就是待处理这个 事件 的多个对象，花 的传递是从一个人的手中传递到下一个人的手中，因此这些对象构成一条链。 角色组成责任链模式包括 抽象处理角色 与 具体处理者角色。 抽象处理角色：定义处理请求接口。规范子类处理请求的操作 或者可以按照需要定义一个引用下一个对象的接口方法。 具体处理者角色：事件的 具体处理者，当接收到请求后，可以选择将请求处理掉，或者将请求传递给下家。 一个简单的例子 抽象处理者角色 12345678910111213141516public abstract class Handler&#123; // 处理下一个责任的对象 private Handler successor; // 规范子类处理请求的方法 public abstract void handleRequest(); public Handler getSuccessor()&#123; return successor; &#125; public void setSuccessor(Handler successor)&#123; this.successor = successor; &#125;&#125; 具体处理着角色 12345678910111213public class ConcreteHandler extends Handler&#123; /** * 判断是否有后继的责任对象 * 如果有，就转发请求给后继的责任对象 * 如果没有，则处理请求 */ if (getSuccessor() != null) &#123; System.out.println("放过请求"); getSuccessor().handleRequest(); &#125; else &#123; System.out.println("处理请求"); &#125;&#125; 参考：http://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okHttp3框架-Interceptor]]></title>
    <url>%2FokHttp3%E6%A1%86%E6%9E%B6-Interceptor%2F</url>
    <content type="text"><![CDATA[okHttp3源码-Interceptor okHttp3框架-拦截器分类 RealCall类#execute()#getResponseWithInterceptorChain() 方法源码： 12345678910111213141516171819202122232425Response getResponseWithInterceptorChain() throws IOException &#123; // 拦截器的责任链。 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 开发者应用层自定义的Interceptor interceptors.addAll(client.interceptors()); // 失败重试以及重定向的 RetryAndFollowUpInterceptor interceptors.add(retryAndFollowUpInterceptor); // 把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor interceptors.add(new BridgeInterceptor(client.cookieJar())); // 负责读取缓存直接返回、更新缓存的 CacheInterceptor interceptors.add(new CacheInterceptor(client.internalCache())); // 负责和服务器建立连接的 ConnectInterceptor interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; // 加开发者自定义的网络层拦截器 interceptors.addAll(client.networkInterceptors()); &#125; // 负责向服务器发送请求数据、从服务器读取响应数据的 CallServerInterceptor interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); // 开启责任链的调用 return chain.proceed(originalRequest);&#125; 完整连接器链： 方法中的这行代码表示：请求执行 1chain.proceed(originalRequest); 1 责任链模式1.1 什么是 责任链模式释义： 多个对象处理请求，其中每一个当前对象都引用了下一个对象，从而形成一条处理请求的链。当客户端的请求到达时，并不知道责任链上的哪一个对象处理了请求。这样的好处是：可以对请求做动态的处理。 抽象类与具体实现类的需要 抽象类：定义一个处理请求的方法 实现类：在具体实现类中需要持有下一个处理责任的对象的引用 1.2 责任链模式的分类纯责任链模式：当请求到达一个类时要么处理完，要么扔给下一个对象 非纯责任链模式：当请求到达时，该类仅处理一部分（可以配置一些参数，适配一下请求），然后扔给下一个对象。 2 OkHttp3框架中 “拦截器-非纯责任链模式”的实现2.1 接口：Interceptor接口官方注释对于这个接口描述： 12观察、修改并可能使请求中断并返回相应的响应。通常拦截器会在请求或响应上添加，删除或转换 headers。 源码： 123456789101112131415161718192021222324public interface Interceptor &#123; /* * @param chain ：每一次传递的 chain，都是在生成一个 （index+1） 后的RealInterceptorChain * @return Response ：真正的负责请求处理，返回响应数据 */ Response intercept(Chain chain) throws IOException; interface Chain &#123; Request request(); /** * 负责调用连接器 */ Response proceed(Request request) throws IOException; /** * 返回将在其上执行请求的连接。 * 这仅适用于网络拦截器链; 对于应用程序拦截器，它始终为null。 */ @Nullable Connection connection(); &#125;&#125; 2.2 Interceptor.Chain接口 的实现类：RealInterceptorChain类这个类的出现是在 RealInterceptorChain类#getResponseWithInterceptorChain()中（注意方法中传递的具体参数。）： 123Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest); // 开启责任链的调用return chain.proceed(originalRequest); 注意： processd() 这个方法的调用才是拦截器中调用的关键。 官方源码注释： 1一个带有整个拦截器链的具体拦截器链：所有应用程序拦截器，OkHttp核心，所有网络拦截器，最后是网络调用者。 此类的源码结构： 12345678910111213141516171819202122232425262728293031323334353637383940public final class RealInterceptorChain implements Interceptor.Chain &#123;public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // 如果我们已经有一个stream。确定即将到来的request会使用它 if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must retain the same host and port"); &#125; // 如果我们已经有一个stream， 确定chain.proceed()唯一的call if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must call proceed() exactly once"); &#125; // 调用链的下一个拦截器 RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // 确认下一个拦截器对 chain.proceed() 进行了所需的调用。 if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException("network interceptor " + interceptor + " must call proceed() exactly once"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException("interceptor " + interceptor + " returned null"); &#125; return response; &#125;&#125; 在这个方法中主要功能分为3部分： 执行各种判定条件 下一个拦截器的调用 返回值判定 同时这个方法中最重要的操作，也是 责任链模式 中 接口具体实现类中要含有下一个处理责任的对象的引用 的具体实现代码： 1234567// 在链中回调下一个拦截器RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request);// 获取当前索引所对应的当前拦截器Interceptor interceptor = interceptors.get(index);// 当前拦截器调用下一个拦截器Response response = interceptor.intercept(next); 在代码中是通过 index索引 来获取集合中的 Interceptor接口 的 当前子类，通过 index+1 索引 来获取下一个责任承担者的子类，当前子类 通过 Intercept() 方法调用 下一个责任承担者的子类。这段代码描述的就是这样的一个 链式引用。 okHttp3框架-拦截器处理流程 OkHttp拦截器-责任链模式]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okHttp3框架]]></title>
    <url>%2FokHttp3%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[okHttp3 OKHttp3框架-执行流程 1 okHttp3框架介绍1.1 基本描述OKhttp3框架 作为Square公司（优秀的开源库：Retrofit、Okio、Picasso等）开发，旨于替换Java的HttpUrlConnection和Apache的HttpClient的轻量级网络框架，已经被运用到很多开源库以及Android的源码中(在6.0 之后移除了HttpClient，并且用 OKHttp代替了HttpUrlConnection)。 OKhttp3框架 是高性能的 http库，支持 同步、异步，而且实现了spdy、http2、websocket 协议，api很简洁易用，和volley一样实现了http协议的缓存。Picasso就是利用okHttp的缓存机制实现其文件缓存，实现的很优雅，很正确。 OKhttp3框架 使用了 okio I/O组件，okio 是对 Java io、nio 的简洁封装，有着：简单易用，高效，显著的节省CPU和Memory资源。 1.2 特点： 支持 HTTP2/SPDY； socket 自动选择最好的路线、支持自动重连； 拥有自动维护的socket连接池减少握手次数； 拥有线程池； 拥有 Interceptors 处理请求与响应； 支持同步、异步数据请求。 1.3 主要概念由以下 6个概念 一起运作: OkHttpClient类：HTTP请求的客户端类； Request类：封装了请求报文信息：请求的Url地址、请求的方法（如GET、POST等）、各种请求头（如Content-Type、Cookie）以及可选的请求体。 Response类：装了响应报文信息：状态吗（200、404等）、响应头（Content-Type、Server等）以及可选的响应体。 CallBack类：代表了一个实际的HTTP请求，它是连接Request和Response的桥梁，通过Request对象的newCall()方法可以得到一个Call对象。Call对象既支持同步获取数据，也可以异步获取数据。 执行Call对象的execute()方法，会阻塞当前线程去获取数据，该方法返回一个Response对象。执行Call对象的enqueue()方法，不会阻塞当前线程，该方法接收一个Callback对象，当异步获取到数据之后，会回调执行Callback对象的相应方法。如果请求成功，则执行Callback对象的onResponse方法，并将Response对象传入该方法中；如果请求失败，则执行Callback对象的onFailure方法。 Dispatcher类：线程池； Interceptor类：拦截器(OKhttp的精髓)； 说明： Request类 与 Response类 中，都包括 Headers类 与 XXXBody抽象类，而且2个 XXXBody抽象类 的结构非常相似，仅仅是方绘制和命名的不同，其余均相同（包括数量），都含有2个具体的实现类。 1.4 设计模式 建造者模式： 外观模式：OkHttpClient类 责任链模式： 在以下情况下可以考虑使用外观模式：(1)设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。(2) 开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。(3) 维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。 1.5 核心框架、技术 okio 线程池（okhttp3：Dispatcher类） Dispatcher Interceptor（精髓） 2 简单的使用 get请求方式 1234567891011121314151617String url = "http://wwww.baidu.com";OkHttpClient okHttpClient = new OkHttpClient();final Request request = new Request.Builder() .url(url) .build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(TAG, "onFailure: "); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(TAG, "onResponse: " + response.body().string()); &#125;&#125;); post请求方式 12345678910111213141516 public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8"); OkHttpClient client = new OkHttpClient(); RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); return response.body().string();&#125; 无论是 get 请求方式 还是 post 请求方式，整个处理流程可简单的分为3个部分：client、call、request 3 OkHttpClient类 - 参数初始化 外部采用外观模式，将很多的功能包裹在这个类中； 内部使用 构造器模式 初始化了一些 配置信息： 方法 newCall() + newWebSocket()，这是非常重要的一个方法。 注意： 此处的 newCall() 与 newWebSocket() 通过调用与参数的关系将上一节中讲到的3个流程连接在了一起。 123456789101112131415161718192021222324252627public static final class Builder &#123; final Dispatcher dispatcher; //分发器 final Proxy proxy; //代理 final List&lt;Protocol&gt; protocols; //协议 final List&lt;ConnectionSpec&gt; connectionSpecs; //传输层版本和连接协议 final List&lt;Interceptor&gt; interceptors; //拦截器 final List&lt;Interceptor&gt; networkInterceptors; //网络拦截器 final ProxySelector proxySelector; //代理选择 final CookieJar cookieJar; //cookie final Cache cache; //缓存 final InternalCache internalCache; //内部缓存 final SocketFactory socketFactory; //socket 工厂 final SSLSocketFactory sslSocketFactory; //安全套接层socket 工厂，用于HTTPS final CertificateChainCleaner certificateChainCleaner; // 验证确认响应证书 适用 HTTPS 请求连接的主机名。 final HostnameVerifier hostnameVerifier; // 主机名字确认 final CertificatePinner certificatePinner; // 证书链 final Authenticator proxyAuthenticator; //代理身份验证 final Authenticator authenticator; // 本地身份验证 final ConnectionPool connectionPool; //连接池,复用连接 final Dns dns; //域名 final boolean followSslRedirects; //安全套接层重定向 final boolean followRedirects; //本地重定向 final boolean retryOnConnectionFailure; //重试连接失败 final int connectTimeout; //连接超时 final int readTimeout; //read 超时 final int writeTimeout; //write 超时 &#125; 4 Request类 请求参数封装Request类 中的对象种类： 123456789101112public final class Request &#123; HttpUrl url; String method; Headers.Builder headers; RequestBody body; Object tag; public Builder() &#123; this.method = "GET"; this.headers = new Headers.Builder(); &#125;&#125; 4.1 RequestBody抽象类本身（只有方法）RequestBody是一个 抽象类， 在这个抽象类中只有4个方法。其中的2个抽象方法为： 1234567public abstract class RequestBody &#123; /** 返回此正文的Content-Type标头. */ public abstract @Nullable MediaType contentType(); /** 将此请求的内容写入&#123;@code out&#125;。. */ public abstract void writeTo(BufferedSink sink) throws IOException;&#125; 另个1方法为 contentLength() 123public long contentLength() throws IOException &#123; return -1;&#125; 最后1个方法是 static RequestBody create() 方法。这个方法是对 contentType() 、writeTo(BufferedSink sink) 与 contentLength() 3个方法的封装 这2个抽象方法的实现是在 RequestBody类 本身中就有具体应用的地方：static create() 方法 传输字节流 123456789101112131415161718public static RequestBody create(final @Nullable MediaType contentType, final byte[] content, final int offset, final int byteCount) &#123; if (content == null) throw new NullPointerException("content == null"); Util.checkOffsetAndCount(content.length, offset, byteCount); return new RequestBody() &#123; @Override public @Nullable MediaType contentType() &#123; return contentType; &#125; @Override public long contentLength() &#123; return byteCount; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.write(content, offset, byteCount); &#125; &#125;;&#125; 传输文件： 1234567891011121314151617181920212223public static RequestBody create(final @Nullable MediaType contentType, final File file) &#123; if (file == null) throw new NullPointerException("content == null"); return new RequestBody() &#123; @Override public @Nullable MediaType contentType() &#123; return contentType; &#125; @Override public long contentLength() &#123; return file.length(); &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; Source source = null; try &#123; source = Okio.source(file); sink.writeAll(source); &#125; finally &#123; Util.closeQuietly(source); &#125; &#125; &#125;;&#125; 4.2 RequestBody子类 - FormBody（表单提交）在这个实现类中是通过 2个 集合来存储 键-值对，键 是1个集合，值 是另1个集合。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public final class FormBody extends RequestBody &#123; // 指明媒体类型 private static final MediaType CONTENT_TYPE = MediaType.parse("application/x-www-form-urlencoded"); // 参数接收 private final List&lt;String&gt; encodedNames; private final List&lt;String&gt; encodedValues; // 初始化 FormBody(List&lt;String&gt; encodedNames, List&lt;String&gt; encodedValues) &#123; this.encodedNames = Util.immutableList(encodedNames); this.encodedValues = Util.immutableList(encodedValues); &#125; // 确定媒体类型 @Override public MediaType contentType() &#123; return CONTENT_TYPE; &#125; // 上传内容的长度 @Override public long contentLength() &#123; return writeOrCountBytes(null, true); &#125; // 对表单数据 进行判断 后通过 for循环 拼接上传 @Override public void writeTo(BufferedSink sink) throws IOException &#123; writeOrCountBytes(sink, false); &#125; /** * 执行具体的表单数据的拼接处理过程 */ private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) &#123; long byteCount = 0L; Buffer buffer; if (countBytes) &#123; buffer = new Buffer(); &#125; else &#123; buffer = sink.buffer(); &#125; for (int i = 0, size = encodedNames.size(); i &lt; size; i++) &#123; if (i &gt; 0) buffer.writeByte('&amp;'); buffer.writeUtf8(encodedNames.get(i)); buffer.writeByte('='); buffer.writeUtf8(encodedValues.get(i)); &#125; if (countBytes) &#123; byteCount = buffer.size(); buffer.clear(); &#125; return byteCount; &#125; &#125; 4.3 RequestBody子类 - MultipartBody（多请求块、文件上传）这个类的具体实现就是通过1个内部类 Part类 来封装 Headers类 与 RequestBody抽象类，通过 Part类 将这2个类进行统一管理，然后通过这个类自身的 addPart(Part part) 方法收集数据，最后通过 for循环 对每一个 part 对象中的 header 与 body 对象的数据做单独处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class MultipartBody extends RequestBody &#123; // 一个非常重要的变量，在对 “多part处理” 时会用到。 private final List&lt;Part&gt; parts; @Override public MediaType contentType() &#123; return contentType; &#125; @Override public long contentLength() throws IOException &#123; long result = contentLength; if (result != -1L) return result; return contentLength = writeOrCountBytes(null, true); &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; writeOrCountBytes(sink, false); &#125; private long writeOrCountBytes()&#123; // 此方法的主要代码 // parts变量的应用 for (int p = 0, partCount = parts.size(); p &lt; partCount; p++) &#123; Part part = parts.get(p); Headers headers = part.headers; RequestBody body = part.body; …… &#125; &#125; // 封装 `Headers类` 和 `RequestBody抽象类`的 类 public static final class Part &#123; final @Nullable Headers headers; final RequestBody body; private Part(@Nullable Headers headers, RequestBody body) &#123; this.headers = headers; this.body = body; &#125; public @Nullable Headers headers() &#123; return headers; &#125; public RequestBody body() &#123; return body; &#125; &#125;&#125; MultipartBody类 在实际功能中的使用： 123456789MultipartBody body = new MultipartBody.Builder("AaB03x") .setType(MultipartBody.FORM) .addPart( Headers.of("Content-Disposition", "form-data; name=\"title\""), RequestBody.create(null, "Square Logo")) .addPart( Headers.of("Content-Disposition", "form-data; name=\"image\""), RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png"))) .build(); 注意代码中的 addPart() 方法： 12345public Builder addPart(Part part) &#123; if (part == null) throw new NullPointerException("part == null"); parts.add(part); return this;&#125; 此处的 parts 就是用来接收实际功能中的数据。 5 Response类 响应结果封装这个类的作用通过源码就可以看出就是对 响应结果 的封装。 本类源码： 12345678910111213141516171819202122232425262728293031public final class Response implements Closeable &#123; final Request request; final Protocol protocol; final int code; final String message; final @Nullable Handshake handshake; final Headers headers; final @Nullable ResponseBody body; final @Nullable Response networkResponse; final @Nullable Response cacheResponse; final @Nullable Response priorResponse; final long sentRequestAtMillis; final long receivedResponseAtMillis; private volatile CacheControl cacheControl; // Lazily initialized. Response(Builder builder) &#123; this.request = builder.request; this.protocol = builder.protocol; this.code = builder.code; this.message = builder.message; this.handshake = builder.handshake; this.headers = builder.headers.build(); this.body = builder.body; this.networkResponse = builder.networkResponse; this.cacheResponse = builder.cacheResponse; this.priorResponse = builder.priorResponse; this.sentRequestAtMillis = builder.sentRequestAtMillis; this.receivedResponseAtMillis = builder.receivedResponseAtMillis; &#125;&#125; 其中用到较多的就是 Headers类 和 ResponseBody抽象类。在类关系实现这一点上，与 RequestBody抽象类 相似。 值得注意点是：所有的 Response 对象使用完毕后，必须要调用 close() 进行关闭: 1234567Response.close()Response.body().close()Response.body().source().close()Response.body().charStream().close()Response.body().byteString().close()Response.body().bytes()Response.body().string() 5.1 ResponseBody抽象类本身这个类的实现和 RequestBody抽象类 的结构大致是相似的： 相似点： 同样有2个抽象方法：contentType() 与 source() 、1个 contentLength() 和1个封装方法： create() 2个抽象类：RealResponseBody（真实响应）与 CacheResponseBody（缓存响应） 不同点： 在这个方法中对 source() 方法做了多种转化。 源码： 1234567891011121314151617181920212223242526public abstract class ResponseBody implements Closeable &#123; public abstract @Nullable MediaType contentType(); public abstract long contentLength(); public abstract BufferedSource source(); public static ResponseBody create(final @Nullable MediaType contentType, final long contentLength, final BufferedSource content) &#123; if (content == null) throw new NullPointerException("source == null"); return new ResponseBody() &#123; @Override public @Nullable MediaType contentType() &#123; return contentType; &#125; @Override public long contentLength() &#123; return contentLength; &#125; @Override public BufferedSource source() &#123; return content; &#125; &#125;; &#125;&#125; 5.2 ResponseBody子类 - RealResponseBody（真实响应）12345678910111213141516171819202122public final class RealResponseBody extends ResponseBody &#123; private final Headers headers; private final BufferedSource source; public RealResponseBody(Headers headers, BufferedSource source) &#123; this.headers = headers; this.source = source; &#125; @Override public MediaType contentType() &#123; String contentType = headers.get("Content-Type"); return contentType != null ? MediaType.parse(contentType) : null; &#125; @Override public long contentLength() &#123; return HttpHeaders.contentLength(headers); &#125; @Override public BufferedSource source() &#123; return source; &#125;&#125; 5.3 ResponseBody子类 - CacheResponseBody（缓存响应）12345678910111213141516171819202122232425262728293031323334353637private static class CacheResponseBody extends ResponseBody &#123; final DiskLruCache.Snapshot snapshot; private final BufferedSource bodySource; private final @Nullable String contentType; private final @Nullable String contentLength; CacheResponseBody(final DiskLruCache.Snapshot snapshot, String contentType, String contentLength) &#123; this.snapshot = snapshot; this.contentType = contentType; this.contentLength = contentLength; Source source = snapshot.getSource(ENTRY_BODY); bodySource = Okio.buffer(new ForwardingSource(source) &#123; @Override public void close() throws IOException &#123; snapshot.close(); super.close(); &#125; &#125;); &#125; @Override public MediaType contentType() &#123; return contentType != null ? MediaType.parse(contentType) : null; &#125; @Override public long contentLength() &#123; try &#123; return contentLength != null ? Long.parseLong(contentLength) : -1; &#125; catch (NumberFormatException e) &#123; return -1; &#125; &#125; @Override public BufferedSource source() &#123; return bodySource; &#125;&#125; 6 Call接口前面在介绍 OkHttpClient类 的时候，已经说到过方法 newCall() 这个方法，那么在这一节就开始梳理与 Call接口 相关的知识。 newCall() 方法源码： 123@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */);&#125; 源码中对于这个方式的注释是： 123/*** Prepares the &#123;@code request&#125; to be executed at some point in the future.*/ 在未来的某个点准备执行request。 在 newCall() 这个方法的返回值是 Call接口，那么在 okHttp3框架 中，Call 到底是怎么样的构建关系呢？下面就来梳理一下。 6.1 Call接口源码中对 Call 的注释说明是： 一个 Call 是已经准备执行的 request ，同时一个 Call 是可以取消的。 由于此对象表示的是一对单独的 请求/响应，因此无法执行2次。 Call接口 源码： 123456789101112131415161718192021222324252627public interface Call extends Cloneable &#123; // 返回发起此调用的原始请求。 Request request(); // 同步执行网络请求 Response execute() throws IOException; // 异步执行网络请求 void enqueue(Callback responseCallback); // 取消网络请求 void cancel(); // 是否执行网络请求 boolean isExecuted(); // 是否取消网络请求 boolean isCanceled(); Call clone(); // 工厂接口 interface Factory &#123; Call newCall(Request request); &#125;&#125; 根据 Call接口 的源码来看，其封装了 HTTP 的各种请求任务，能用到的操作在这个接口都已经定义了。同时在接口的内部，提供了 工厂模式（将对象的创建延迟到该工厂类的子类，从而实现动态配置）。在 OkHttpClient类 中已经实现了 Call.Factory接口，并且实现了 newCall()。在这个方法中返回了一个 RealCall对象。下面就来梳理一下这个 RealCall类，看看在这个类中都进行了什么样的操作。 6.2 RealCall类首先来看 RealCall类 的 构造方法 源码： 1234567891011RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; final EventListener.Factory eventListenerFactory = client.eventListenerFactory(); this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); // TODO(jwilson): this is unsafe publication and not threadsafe. this.eventListener = eventListenerFactory.create(this);&#125; 从构造方法的源码中可以发现，参数有3个： OkHttpClient client：HTTP请求的客户端对象 Request originalRequest：请求封装对象 boolean forWebSocket)：是否有socket对象 因此可以发现，这个 RealCall类 中包装了 Request类 对象与 OkHttpClient类 对象，可以很方便的使用这个2个对象。 在构造方法中还有一个 RetryAndFollowUpInterceptor类 的对象：retryAndFollowUpInterceptor，这也是一个非常重要的参数。这个类的作用是： 1此拦截器从故障中恢复，并在必要时遵循重定向。 如果取消call，它可能会抛出&#123;@link IOException&#125;。 6.3 两个重要的执行方法 execute()：同步网络请求 enqueue()：异步网络请求 在这2个方法中，都调用了 captureCallStackTrace() 方法，方法源码： 1234private void captureCallStackTrace() &#123; Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()"); retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);&#125; 这个方法的作用就是捕获这个请求的 StackTrace。 6.3.1 execute()123456789101112131415@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 在这个方法中，首先对 executed 做 boolean 判断。如果为 true 则抛出异常，即表示一个 call 只能执行1次。然后捕获 cllStackTrace 对象。 client.dispatcher().executed(this); 这行代码引出了另1个重要的类：Dispatcher类，这个类具体在第7节中进行梳理。同时这行代码也是整个网络请求过程中一个重要的节点。 12345678try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result;&#125; finally &#123; client.dispatcher().finished(this);&#125; 这段代码在功能上分3个步骤： 执行请求数据 1client.dispatcher().executed(this); 获取响应数据 1Response result = getResponseWithInterceptorChain(); 结束调度 1client.dispatcher().finished(this); 与 dispatcher() 相关的操作梳理放到第7节中。接下来看看 getResponseWithInterceptorChain() 方法中都进行了什么操作，源码如下： 1234567891011121314151617Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest);&#125; 通过方法中的代码，可以明显的看到这个方法的作用就是：构建一整套拦截器，同时这个方法的返回值是 Response类，所以实际上是这个方法 实际执行了具体的请求处理。因此这个方法十分的重要。具体梳理将在第 8 节中。 6.3.2 enqueue()在参考 execute() 方法的基础之上。通过比较的方式来看 enqueue() 方法就会更容易理解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 @Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125;``` `enqueue()` 方法与 `execute()` 方法相比： - **相同点**： - 都对 `executed` 变量做判定 - 都执行 `captureCallStackTrace()` - **不同点**： - 在 `enqueue()` 方法中执行的是 `client.dispatcher().enqueue(new AsyncCall(responseCallback));` - `enqueue()` 没有执行 `getResponseWithInterceptorChain();` - `enqueue()` 没有执行 `client.dispatcher().finished(this);` - `enqueue()` 没有返回值，`execute()` 有 `Response` 返回值。# 7 Dispatcher类 - 调度器```Javapublic final class Dispatcher &#123; private int maxRequests = 64; //最大请求数量 private int maxRequestsPerHost = 5; //每台主机最大的请求数量 private @Nullable Runnable idleCallback; /** Executes calls. Created lazily. */ private @Nullable ExecutorService executorService; //线程池 /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); /** 这个线程池没有核心线程，线程数量没有限制，空闲60s就会回收*/ public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125;&#125; 框架解析参考：https://yq.aliyun.com/articles/607975详细使用参考：https://www.jianshu.com/p/da4a806e599b详细使用参考：https://www.jianshu.com/p/2663ce3da0db基础API使用：https://blog.csdn.net/iispring/article/details/51661195Interceptor参考：https://blog.csdn.net/wenyiqingnianiii/article/details/65635678Interceptor参考：https://www.jianshu.com/p/27c1554b7fee]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>okHttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App优化-稳]]></title>
    <url>%2FApp%E4%BC%98%E5%8C%96-%E7%A8%B3%2F</url>
    <content type="text"><![CDATA[App优化-稳 故事引用： 12345假如饭点将至，需要打开订餐APP进行点餐：首先一定不希望，在浏览商家和菜品列表内容很丰富的时候遇到卡顿现象；然后千挑万选后在期待美食将至的心情下准备下单，突然遇到闪退崩溃，那简直想卸载APP的心都有了；其次就是配送员在配送过程中不希望耗电和耗流量太严重；最后就是用户和配送员都希望版本更新的时候安装包希望能小一点。 一张图表述 App 性能优化切入点： 概述因为是优化的开篇，在这一篇中将会总结一些在后面3篇中通用的检测工具 和 检测方法。同时，也会总结一下个人对于优化的理解。 个人理解： 优先级：个人认为将优化的按照 1、2、3、4 的程度来设置重要性，1最高，4最低，分别对应： 1 —— 稳 2 —— 快 3 —— 省 4 —— 小 1 稳在 App优化 这个专题中，将 稳 作为第一篇，也是个人认为最为重要的一篇，毕竟，一个App如果总是时不时的崩溃一下，那么这个App这么调皮还会有人用吗？ 稳 体现在2点： Crash（崩溃、闪退） ANR（无响应） 2 CrashCrash 即 崩溃、闪退，指的就是App在使用过程中突然停止，退出当前所在的进程，这是最为严重的。 造成Crash的原因却有很多，比如：运行时异常的空指针、数组越界、未实例化、强制类型等等，有些时候我们在开发测试阶段都没有出现异常崩溃现象，而发布上线后到了用户手机就会出现各种奇怪闪退。 2.1 工具 Cockroach工具的使用及原理 这个工具的作用是：可以保证不管怎样抛异常都不会闪退，App进程也不会重启。 LeakCanary 适用于Android和Java的 内存泄漏检测库。只在 debug版本 下检测，正式版 上线后 自动跳过检测，是Square公司在Github开源的。 3 ANR造成ANR程序无响应的原因主要是在四大组件的耗时操作； 4 内存泄漏内存泄漏 指的是 那些程序不再使用的对象无法被GC识别，这样就 导致这个对象一直留在内存当中，占用了没来就不多的内存空间。 内存泄漏是一个 缓慢积累 的过程，温水煮青蛙一般，往往很难直观的看到，只能最后内存不够用了，程序崩溃。 因为有 内存泄漏，所以 内存被占用越来越多，那么 GC会更容易被触发，GC会 越来越频发，但是当GC的时候 所有的线程都是暂停状态的，需要处理的 对象数量越多耗时越长，所以这也会造成 卡顿。 发生泄漏的4大类情况 集合类 单例/静态变量 匿名内部类/非静态内部类 资源未关闭 集合类泄漏集合类添加元素后，仍引用着集合元素对象，导致该集合中的元素对象无法被回收，从而导致内存泄露。合适的做法为： 123456789static List&lt;Object&gt; mList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 100; i++) &#123; Object obj = new Object(); mList.add(obj); obj = null;&#125;mList.clear();mList = null; 单例/静态变量单例模式具有其 静态 特性， 其生命周期 = 应用程序生命周期，正是因为这一点，往往很容易造成内存泄漏。 一个示例： 12345678910111213141516public class SingleInstance &#123; private static SingleInstance mInstance; private Context mContext; private SingleInstance(Context context)&#123; this.mContext = context; &#125; public static SingleInstance newInstance(Context context)&#123; if(mInstance == null)&#123; mInstance = new SingleInstance(context); &#125; return sInstance; &#125;&#125; 在此单例模式中，当我们将 Activity 作为 context 参数进行传递时，这个单例就拥有了 Activity 的引用。当此 Activity 没有用、要被销毁时，此单例仍然持有 此Activity的引用。所以 GC 无法回收，结果就是造成了内存泄漏。 修改之后，合理的使用方式为: 12345678910111213141516public class SingleInstance &#123; private static SingleInstance mInstance; private Context mContext; private SingleInstance(Context context)&#123; this.mContext = context.getApplicationContext(); &#125; public static SingleInstance newInstance(Context context)&#123; if(mInstance == null)&#123; mInstance = new SingleInstance(context); &#125; return sInstance; &#125;&#125; 匿名内部类/非静态内部类 两个关键点： 生命周期 对象引用 非静态内部类一个示例：123456789101112131415161718192021public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); new MyAscnyTask().execute(); &#125; class MyAscnyTask extends AsyncTask&lt;Void, Integer, String&gt;&#123; @Override protected String doInBackground(Void... params) &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125; &#125;&#125; 乍一看这一段程序在功能上是没有问题的。但是如果从对象持有、内存状态再来看待这段程序时，MyAscnyTask是一个非静态内部类，如果他处理数据的时间很长，极端点用sleep 100秒，在这期间Activity可能运行5s后就关闭了，原本理想的状态是Activity的内存应该被回收的。但是：我们知道非静态内部类会持有外部类的引用，所以Activity也需要陪着非静态内部类MyAscnyTask一起跑完 100s。好了，内存泄漏就形成了。 如何解决呢？ 这就要回到这一节主题所代表的问题本质：生命周期。 既然 MyAscnyTask 与 Activity 的 生命周期差距如此之大，那么就干脆把 MyAscnyTask 变成 静态内部类，和Application玩去吧，这样做得到的结果就是： 静态内部类与外部类两者之间的 引用、内存 关系也相互独立了。 于是，可以修改该为： 123456789101112131415161718192021public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); new MyAscnyTask().execute(); &#125; //改了这里 注意一下 static static class MyAscnyTask extends AsyncTask&lt;Void, Integer, String&gt;&#123; @Override protected String doInBackground(Void... params) &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125; &#125;&#125; 匿名态内部类一个示例：12345678910111213141516171819202122232425262728293031public class TestActivity extends Activity &#123;private TextView mText; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg);//do somethingmText.setText(&quot; do someThing&quot;); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); mText = findVIewById(R.id.mText); // 匿名线程持有 Activity 的引用，进行耗时操作 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); mHandler. sendEmptyMessageDelayed(0, 100000); &#125;&#125; 在本小结的一开始列出了2个关键点：生命周期 已经在第一种问题中得到了应用。 那么接下来通过 对象引用 这个出发点来解决这个问题。 引用分为：强、软、弱、虚引用，而且 引用强度依次递减。 强引用： 平时用的最多、不做处理的一般都是强引用，如果一个对象具有的是强引用，那么GC即使发生OOM也不会回收它。 软引用（SoftReference）： 如果内存空间足够，GC则不会回收它，如果内存空间不足，那么GC则回收它。 弱引用（WeakReference）： GC的时候无论内存是否够用，都要回收它。 虚引用： 不常用。 那么此 匿名态内部类示例 的内存问题解决方式就变成了： static化 - 对内外类之间的联系进行分离 引用强度下降，使用弱引用 - 保证生命周期短的类及时销毁 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestActivity extends Activity &#123; private TextView mText; private MyHandler myHandler = new MyHandler(TestActivity.this); private MyThread myThread = new MyThread(); private static class MyHandler extends Handler &#123; WeakReference&lt;TestActivity&gt; weakReference; MyHandler(TestActivity testActivity) &#123; this.weakReference = new WeakReference&lt;TestActivity&gt;(testActivity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); weakReference.get().mText.setText(&quot;do someThing&quot;); &#125; &#125; private static class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); mText = findViewById(R.id.mText); myHandler.sendEmptyMessageDelayed(0, 100000); myThread.start(); &#125; //最后清空这些回调 @Override protected void onDestroy() &#123; super.onDestroy(); myHandler.removeCallbacksAndMessages(null); &#125;&#125; 资源未关闭可能出现问题的方面有： 流 未关闭 注册后未进行解绑 start() 后没有 stop() 内存分析工具： leakcanary：适用于Android的 内存泄漏检测库。漏洞直接显示 Android Lint：帮助发现代码构成/质量问题。内存泄漏时会有发黄。 Android Profiler-Memory：展示应用内存使用情况的实时图像、抓取内存的dump信息、强制垃圾回收及追踪内存分配。 MAT（Memory Analyzer Tools）： 是一个快速且功能丰富的 Java堆分析器，可帮助您查找 内存泄漏并减少内存消耗。此工具是Eclipse IDE下的，如果想要在 Android Studio 下使用，可以从官网下载。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus理解]]></title>
    <url>%2FEventBus%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[EventBus理解 1. 概述1.1 官方介绍：EventBus 是一个使用“观察者模式”的、松耦合的开源框架。它使用少量的几句代码就可以实现核心类之间的通讯，帮助我们简化代码、松依赖、加速开发。 1.2 Android中的其他消息处理方式 BroadCast Handler 1.2.1 BroadCast 广播 是四大组件之一，许多 系统级的事件 都是通过广播来通知的，比如说：网络的变化、电量的变化，短信发送和接收的状态，所以，如果与 Android系统 进行相关的通知，还是要选择本地广播；在BroadcastReceiver的 onReceive方法中，可以获得Context 、intent参数，这两个参数可以调用许多的sdk中的方法，而eventbus获得这两个参数相对比较困难. 因此广播是 重量级 的、消耗资源较多的方式。它的优势体现在 与sdk连接紧密，如果需要同 Android 交互的时候，广播的 便捷性 会抵消掉它过多的资源消耗，但是如果不同Android交互，或者说，只做很少的交互，使用广播是一种浪费； 广播作为Android组件间的通信方式，可以使用的场景如下： 1. 同一app内部的同一组件内的消息通信（单个或多个线程之间）； 2. 同一app内部的不同组件之间的消息通信（单个进程）； 3. 同一app具有多个进程的不同组件之间的消息通信； 4. 不同app之间的组件之间消息通信； 5. Android系统在特定情况下与App之间的消息通信。 广播的 不可替代性 在于：它可以 跨进程进行通信，也就是不同App之间可以通过广播进行传递数据，并且在OnReceiver中更容易使用Context和Intent对象来执行必要的操作。单就同一app内部的消息通信而言，使用广播是较为消耗资源和笨重的。 1.2.2 Handlerhandler 一般用于 线程间通信，它可以分发：Message对象和 Runnable对象 到 主线程 中， 每个 Handler实例，都会绑定到：创建他的线程中(一般是位于主线程)，它有两个作用： 1. 安排消息或Runnable 在某个主线程中某个地方执行； 2. 安排一个动作在不同的线程中执行。 一般 Handler 的使用方法即在 调用线程内 创建 Handler内部类，并重写handlerMessage(Message msg)方法，而在发布消息时使用 sendMessage() 方法进行发布，在处理时通过 switch(msg.what) 进行消息分发并进行相应的处理。 这里，Hander内部类 和其定义类是绑定的，这就造成了事件发布者和接受者之间的高耦合。而Handler的最大好处是发生问题时，可以：非常明确、快速的进行定位，通过msg.what很容易就可以理清每一条消息流的逻辑。 2. 基本使用方式2.1 准备工作2.1.1 首先，在模块的 build.gradle 构建脚本中添加 EventBus 依赖：1234dependencies &#123; ... compile 'org.greenrobot:eventbus:3.1.1'&#125; 2.1.2 混淆订阅者的事件处理方法没有被直接调用，如果开启了ProGuard工具 的压缩功能，那么你必须告诉ProGuard工具 保留这些订阅者方法。在 模块 下的 proguard-rules.pro 混淆规则文件 中添加如下规则： 123456# EventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125; 2.2 使用EventBus 的使用非常简单，主要分为3个步骤： 定义事件。 订阅事件。 发布事件。 粘性事件。 事件优先级。 订阅者索引。 官方使用步骤描述： 12345EventBus是Android的中央发布/订阅事件系统。 事件被发布（&#123;@link #post（Object）&#125;）到总线，总线将事件传递给具有事件类型的匹配处理程序方法的订阅者。 要接收事件，订户必须使用&#123;@link #register（Object）&#125;将自己注册到总线。一旦注册，订阅者就会收到事件，直到调用&#123;@link #unregister（Object）&#125;。 事件处理方法必须由&#123;@link Subscribe&#125;注释，必须是public，return nothing（void），并且只有一个参数（事件）。 2.2.1 定义事件1234567891011121314151617public class AppEvent&lt;T&gt; &#123; public int type; private T data; public AppEvent(int type) &#123; this.type = type; &#125; public AppEvent(int type, T data) &#123; this.type = type; this.data = data; &#125; public AppEvent() &#123; &#125;&#125; 2.2.2 订阅事件注册 和 注销 订阅者 需要在 总线上注册，并在不需要时在总线上 注销。只有订阅者注册了，它们才会收到事件。 在Android中，可以根据 Activity 或者 Fragment 的 生命周期 来注册和注销。例如 1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initContentView(); // 注册订阅者 EventBus.getDefault().register(this);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); // 注销订阅者 EventBus.getDefault().unregister(this);&#125; 2.2.3 订阅事件处理方法默认情况下：EventBus在查找订阅者方法时采用的是 反射。 订阅者 需要定义 事件处理方法（也称为订阅者方法）。 当发布对应类型的事件时，该方法将被调用。EventBus 3使用 @Subscribe 注解来定义订阅者方法。 方法名可以是任意合法的方法名；参数类型为订阅事件的类型。例如： 1234@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(AppEvent event) &#123; ...&#125; 重点：@Subscribe 所对应的 线程模式 源码： 1234567891011121314// EventBus独立于发布线程处理线程。public enum ThreadMode &#123; POSTING, MAIN, BACKGROUND, ASYNC; private ThreadMode() &#123; &#125;&#125; POSTING: 订阅者将直接在发布该事件的 同一个 thread 中调用。这是默认值。 事件传递意味着 开销最小，因为它 完全避免了线程切换 。因此，这是已知在很短的时间内完成而不需要主线程的简单任务的推荐模式。使用此模式的事件处理程序必须快速返回以避免阻止发布线程，这可能是主线程。 MAIN: 订阅者方法将在 主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。如果发布事件的线程是主线程，那么该模式的订阅者方法将被直接调用 BACKGROUND: 在Android上，将在后台线程中调用订阅者。 如果发布线程 不是主线程，则将 在发布线程中直接调用订阅者方法。如果发布线程是主线程，则EventBus使用单个后台线程，该线程将按顺序传递其所有事件。使用此模式的订阅者应尝试快速返回以避免阻止后台线程。 ASYNC: 订阅者将在 单独的线程 中调用，始终独立于发布线程和主线程。发布事件永远不会等待使用此模式的订阅者方法。 订阅者方法如果执行可能需要一些时间，则应使用此模式，例如 用于网络访问。避免同时触发大量长时间运行的异步订阅者方法以限制并发线程数。EventBus使用 线程池 从已完成的异步订阅者通知中有效地重用线程。 2.2.4 发布事件在需要的地方发布事件，所有订阅了该类型事件并已注册的订阅者将收到该事件。例如： 1EventBus.getDefault().post(new MessageEvent("Hello EventBus!")); 2.2.5 粘性事件一般事件订阅、处理规则：先发布了事件，然后有订阅者订阅了该事件，那么除非再次发布该事件，否则订阅者将永远接收不到该事件。 此时，可以使用 粘性事件。 发布一个 粘性事件 之后，EventBus 将在 内存中缓存 该粘性事件，当有订阅者订阅了该粘性事件，订阅者将接收到该事件。 订阅 与 发布 粘性事件： 12345678// 订阅粘性事件@Subscribe(sticky = true)public void onMessageEvent(MessageEvent event) &#123; ...&#125;// 发布粘性事件EventBus.getDefault().postSticky(new MessageEvent("Hello EventBus!")); 发布一个粘性事件之后，EventBus将一直缓存该粘性事件。如果想要移除粘性事件，那么可以使用如下方法： 12345678// 移除指定的粘性事件removeStickyEvent(Object event);// 移除指定类型的粘性事件removeStickyEvent(Class&lt;T&gt; eventType);// 移除所有的粘性事件removeAllStickyEvents(); 2.2.6 事件优先级EventBus 支持在 定义订阅者方法 时指定 事件传递的优先级。默认情况下，订阅者方法的事件传递优先级为0。数值越大，优先级越高。在相同的线程模式下，更高优先级的订阅者方法将优先接收到事件。 注意：优先级只有在相同的线程模式 下才有效。 指定事件传递优先级的示例代码如下所示： 1234@Subscribe(priority = 1)public void onMessageEvent(MessageEvent event) &#123; ...&#125; 同时，可以在 高优先级 的订阅者方法接收到事件之后 取消 事件的传递。此时，低优先级 的订阅者方法将 不会接收到该事件。 注意： 订阅者方法 只有 在线程模式为 ThreadMode.POSTING 时，才可以 取消1个事件的传递。 取消事件传递的示例代码如下所示： 123456@Subscribe(threadMode = ThreadMode.POSTING, priority = 1)public void onMessageEvent(MessageEvent event) &#123; ... // 取消事件传递 EventBus.getDefault().cancelEventDelivery(event);&#125; 2.2.7 订阅者索引订阅者索引 是 EventBus 3 的一个新特性。它可以 加速 订阅者的 注册，是一个 可选优化。 订阅者索引的原理是：使用 EventBus的注解处理器 在应用构建期间 创建 订阅者索引类，该类包含了 订阅者 和 订阅者方法 的相关信息。 EventBus官方推荐在Android中使用订阅者索引以获得最佳的性能。 使用步骤： 修改 模块 下的 build.gradle 构建脚本： 使用 annotationProcessor 属性将 EventBus的注解处理器 添加到 构建中，还要设置一个 eventBusIndex 参数来指定要生成的 订阅者索引 的 完全限定类名。简而言之就是： 添加 EventBus的注解处理器，并指定 订阅者索引 的 完全限定类名 12345678910111213141516android &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [eventBusIndex: 'com.yannis.myapplication.MyEventBusIndex'] &#125; &#125; &#125; ...&#125;dependencies &#123; ... api 'org.greenrobot:eventbus:3.1.1' annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.1.1'&#125; 在应用 自定义Application类 的 onCreate() 方法中将 订阅者索引类 添加到 EventBus 中，并将该EventBus设置成默认的EventBus。示例代码如下所示： 123456789public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 配置EventBus EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池-相关类]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E7%9B%B8%E5%85%B3%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[线程池-相关类 对列Queue接口源码： 1234567891011121314151617public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; // 插入一个元素，如果队列已满，则抛出一个IIIegaISlabEepeplian异常 boolean add(E e); // 添加一个元素并返回true，如果队列已满，则返回false boolean offer(E e); // 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 E remove(); // 移除并返问队列头部的元素 如果队列为空，则返回null E poll(); // 检查 E element(); E peek();&#125; 实现阻塞队列方法的接口：BlockingQueue接口源码声明：1public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123;&#125; 说明： 其是一种 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。 阻塞队列的方法说明： add()、remove()、element() ：在试图为一个已满的队列增加元素或从空队列取得元素时：抛出异常。 offer()、poll()、peek()：在多线程程序中，队列在任何时间都可能变成满的或空的，这些方法在无法完成任务时：只是给出一个出错示而不会抛出异常。 方法变化： put：添加一个元素，如果队列满，则阻塞 take：移除并返回队列头部的元素，如果队列为空，则阻塞 实现类：LinkedBlockingQueue其容量是没有上限的（实际上不指定时容量为Integer.MAX_VALUE，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。 实现类：ArrayBlockingQueue其在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序。 实现类：PriorityBlockingQueue其是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。 ThreadFactory接口源码： 123public interface ThreadFactory &#123; Thread newThread(Runnable r);&#125; Future接口12345678910111213public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Future 就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get() 获取执行结果，该方法会阻塞直到任务返回结果。 方法说明： cancel(boolean mayInterruptIfRunning)： cancel() 方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。 isCancelled(): 表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。 isDone(): 表示任务是否已经完成，若任务完成，则返回true； get() 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回； get(long timeout, TimeUnit unit)： 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null FutureTask 因为Future只是一个接口，所以是无法直接用来创建对象使用的，具体实现类是FutureTask。 参考：https://www.cnblogs.com/upcwanghaibo/p/6591379.html Worker类 Worker类主要负责运行线程状态的控制。 Worker继承了AQS实现了简单的获取锁和释放所的操作。来避免中断等待执行任务的线程时，中断正在运行中的线程（线程刚启动，还没开始执行任务）。 自己实现不可重入锁，是为了避免在实现线程池控状态控制的方法，例如 setCorePoolSize的时候中断正在开始运行的线程。etCorePoolSize可能会调用interruptIdleWorkers()，该方法中会调用worker的tryLock()方法中断线程，自己实现锁可以确保工作线程启动之前不会被中断 此类是 ThreadPoolExecutor类 的私有内部静态类。 源码 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667line:612private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker. */ public void run() &#123; runWorker(this); &#125; // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池-ThreadPoolExecutor]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[线程池 1. Executor 接口123public interface Executor &#123; void execute(Runnable command);&#125; 线程池的顶级接口。定义了方法 execute(Runnable)，该方法接收一个Runnable实例，用来执行一个任务，该任务即是一个实现Runnable接口的类。 此服务方法无返回值，原因是因为实现Runnable接口的类的run方法是无返回（void）的。 常用方法 ： void execute（execute） 作用 ： 启动并执行线程任务 2. ExecutorService 接口123456789101112131415161718192021222324252627282930313233public interface ExecutorService extends Executor &#123; void shutdown(); List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 继承自 Executor接口，提供了更多的方法调用，例如关闭方法shutdown()，有返回值的submit()。 3. Executors 使用 Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE Executors.newSingleThreadExecutor(); //创建容量为1的缓冲池 Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池 三个方法的具体实现： 12345678910111213141516public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 4. 线程池 参考：https://www.cnblogs.com/dolphin0520/p/3932921.html 使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 线程池使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务。 4.1 ThreadPoolExecutor类继承关系流程图描述： 文字描述： 首先线程池判断 核心线程池 是否已满（&lt; corePoolSize）？没满：创建一个工作线程来执行任务；满了: 则进入下个流程。 其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。 最后线程池判断整个线程池是否已满（&lt; maximumPoolSize ？）？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。 4.2 构造函数中的各个参数含义： 1. int corePoolSize： 2. int maximumPoolSize： 3. long keepAliveTime： 4. TimeUnit unit： 5. BlockingQueue workQueue： 6. ThreadFactory threadFactory： 7. RejectedExecutionHandler handler： 1. int corePoolSize： 核心池的大小（例如：正式工人。就是线程池大小），这个参数跟后面讲述的线程池的实现原理有非常大的关系。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到 缓存队列 当中； 2. int maximumPoolSize： 线程池最大线程数（例如：正式工人 + 临时工人。任务量突然过大时的一种补救措施），它表示在线程池中最多能创建多少个线程。 3. long keepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； 4. TimeUnit unit： 参数keepAliveTime的时间单位，有7种取值： 1234567TimeUnit.DAYS; //天TimeUnit.HOURS; //小时TimeUnit.MINUTES; //分钟TimeUnit.SECONDS; //秒TimeUnit.MILLISECONDS; //毫秒TimeUnit.MICROSECONDS; //微妙TimeUnit.NANOSECONDS; //纳秒 5. BlockingQueue workQueue： 一个阻塞队列，用来存储等待执行的任务。阻塞队列有以下几种选择，一般使用LinkedBlockingQueue： 123ArrayBlockingQueue;LinkedBlockingQueue;SynchronousQueue; 6. ThreadFactory threadFactory：线程工厂，主要用来创建线程。 7. RejectedExecutionHandler handler：表示当拒绝处理任务时的策略，有以下四种取值： 1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 allowCoreThreadTimeOut(boolean value)参数设置源代码: 12345678910line : 1669public void allowCoreThreadTimeOut(boolean value) &#123; if (value &amp;&amp; keepAliveTime &lt;= 0) throw new IllegalArgumentException("Core threads must have nonzero keep alive times"); if (value != allowCoreThreadTimeOut) &#123; allowCoreThreadTimeOut = value; if (value) interruptIdleWorkers(); &#125;&#125; 该方法在 boolean == true 时，最终会调用: 12@FastNativeprivate native void nativeInterrupt(); 4.3 主要方法： execute() 方法实际上是 Executor 中声明的方法，在 ThreadPoolExecutor 进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。 submit() 这个方法也是用来向线程池提交任务的，但是它和execute() 方法不同，它能够返回任务执行的结果，去看 submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了 Future 来获取任务执行结果。 shutdown()和shutdownNow()是用来关闭线程池的。 4.4 ThreadPoolExecutor类实现原理4.4.1 线程池的处理流程流程图描述： 文字描述： 首先线程池判断 核心线程池 是否已满（&lt; corePoolSize）？没满：创建一个工作线程来执行任务；满了: 则进入下个流程。 其次线程池判断 工作队列 是否已满？没满：则将新提交的任务存储在工作队列里；满了：则进入下个流程。 最后线程池判断 整个线程池 是否已满（&lt; maximumPoolSize）？没满：则创建一个新的工作线程来执行任务；满了：则交给饱和策略来处理这个任务。 4.4.2 线程池状态在ThreadPoolExecutor中定义了一个volatile变量 :runState，另外定义了几个static final变量表示线程池的各个状态： 12345volatile int runState; // 保证线程之间的可见性static final int RUNNING = 0; // 当创建线程池后，初始时static final int SHUTDOWN = 1; // 调用了shutdown()方法，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；static final int STOP = 2; // 调用了shutdownNow()方法，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；static final int TERMINATED = 3; // 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后 4.4.3 线程池的任务提交方式： execute()：没有返回值，也就不能判断任务是否被线程池执行成功 submit()：会返回一个Future对象，通过future的get()方法来获取返回值，get()方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。 4.4.4 线程池的关闭 shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 4.4.5 添加任务处理流程当一个任务通过 execute(Runnable) 方法欲添加到线程池时： 如果当前线程池中的数量 小于corePoolSize，并线程池处于Running状态，创建并添加的任务。 如果当前线程池中的数量 等于corePoolSize，并线程池处于Running状态，缓冲队列 workQueue未满，那么任务被放入缓冲队列、等待任务调度执行。 如果当前线程池中的数量 大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量 小于maximumPoolSize，新提交任务会创建新线程执行任务。 如果当前线程池中的数量 大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量 等于maximumPoolSize，新提交任务由Handler处理。 当线程池中的线程 大于corePoolSize 时，多余线程空闲时间 超过keepAliveTime 时，会关闭这部分线程。 执行过程在 ThreadPoolExecutor类 中，最核心的任务提交方法是 execute() 方法。execute() 方法的实现原理： 123456789101112131415161718192021222324252627282930313233343536373839public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1.如果运行的线程数小于corePoolSize，尝试创建一个新线程（Worker），并执行它的第一个任务command * * 2. 如果task成功插入等待队列，我们仍需要进行双重校验是否可以成功添加一个线程 （因为有的线程可能在我们上次检查以后已经死掉了）或者在我们进入这个方法后线程池已经关闭了 * * 3. 如果等待队列已满，我们尝试新创建一个线程。如果创建失败，我们知道线程已关闭或者已饱和，因此我们拒绝改任务。 */ int c = ctl.get(); //工作线程小于核心线程数，创建新的线程 if (workerCountOf(c) &lt; corePoolSize) &#123; //创建新的worker立即执行command，并且轮训workQueue处理task if (addWorker(command, true)) return; c = ctl.get(); &#125; //线程池在运行状态且可以将task插入队列 //第一次校验线程池在运行状态 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //第二次校验，防止在第一次校验通过后线程池关闭。如果线程池关闭，在队列中删除task并拒绝task if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果线程数=0（线程都死掉了，比如：corePoolSize=0），新建线程且未指定firstTask，仅仅去轮训workQueue else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //线程队列已满，尝试创建新线程执行task，创建失败后拒绝task //创建失败原因：1.线程池关闭；2.线程数已经达到maxPoolSize else if (!addWorker(command, false)) reject(command);&#125; 以上方法主要是通过 线程数 和 addWorker() 来执行的判断操作，其中addWorker() 方法源码: 参数： firstTask： worker线程的初始任务，可以为空。 core： true：将corePoolSize作为上限 false：将maximumPoolSize作为上限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: // 外层循环判断线程池的状态 for (;;) &#123; int c = ctl.get(); // 线程池状态 int rs = runStateOf(c); // 线程池状态:RUNNING = -1、SHUTDOWN = 0、STOP = 1、TIDYING = 2、TERMINATED = 3 // 线程池至少是shutdown状态 if (rs &gt;= SHUTDOWN &amp;&amp; //除了线程池正在关闭（shutdown），队列里还有未处理的task的情况，其他都不能添加 ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; //内层循环判断是否到达容量上限，worker+1 for (;;) &#123; //worker数量 int wc = workerCountOf(c); //worker大于Integer最大上限或到达边界上限 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //CAS worker+1 if (compareAndIncrementWorkerCount(c)) //成功了跳出循环 break retry; c = ctl.get(); // Re-read ctl // 如果线程池状态发生变化，重试外层循环 if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //在获取住锁定时重新检查。 //退出ThreadFactory失败或者如果 //在获得锁定之前关闭。 int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // workers是HashSet&lt;Worker&gt; workers.add(w); int s = workers.size(); // 设置最大线程池大小 if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 方法中调用的 compareAndIncrementWorkerCount(int expect) 方法的源码： 123private boolean compareAndIncrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect + 1);&#125; 方法中 compareAndSet(expect, expect + 1); 方法的源码： 123public final boolean compareAndSet(int expect, int update) &#123; return U.compareAndSwapInt(this, VALUE, expect, update);&#125; 在 execute() 方法中，共用到了3次参数不同的 addWorker() : addWorker(command, true) addWorker(null, false) addWorker(command, false) 这个 addWorker()方法虽然行数多，但是实际上只做了2个操作： 在无限 for() 循环中，对 线程状态和 线程数量做判断是否要通过 AtomicInteger 的 compareAndSet(int expect, int update) 来更改线程数。 在加锁后，对线程的状态做检测，然后进行Worker的添加处理。 在看到 addWork() 方法中的如下代码： 12t.start();workerStarted = true; 我们就应该意识到，线程开始运行了，注意这里的 run()，这个方法时 Worker类 中的 run()： 123public void run() &#123; runWorker(this);&#125; 而 runWorker(this) 方法则是 ThreadPoolExecutor类 中的方法，源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; w.lock(); //如果线程池正在停止，请确保线程被中断; //如果线程池没有被停止，请确保线程不被中断。 //这需要在第二种情况下重新检查以在清除中断时处理shutdownNow竞争 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; //执行完毕后task重置，completedTasks计数器++，解锁。 task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 在 runWorker() 这个方法中，在 while(){} 循环中获取 task，当前 task 不为null或者从队列中取的任务不为null时，worker线程就一直去执行任务，处理完之后进行释放。其涉及到了如下几个方法： getTask()：不断的从阻塞队列中取任务交给线程执行。 runStateAtLeast(ctl.get(), STOP)： beforeExecute(wt, task) ： afterExecute(task, thrown)： processWorkerExit(w, completedAbruptly)： getTask 是 ThreadPoolExecutor类 中的方法，并不是Worker类中的方法，下面是getTask() 方法的实现： 12345678910111213141516171819202122232425262728293031323334353637private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //1：如果线程池处于shutdown状态，并且 队列为空 或者 线程池为空，则线程池数量-1，返回null，回收线程 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); //标识当前线程：是否设置允许超时 或者 线程数大于核心线程数 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 2：判断线程数 或者时间 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 参考：https://blog.csdn.net/u011637069/article/details/79593114 4.4.6 任务拒绝策略1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 ThreadPoolExecutor类 原生使用 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class MainThreadPool &#123; public static void main(String[] args) &#123; ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); for (int i = 0; i &lt; 15; i++) &#123; MyTask myTask = new MyTask(i); poolExecutor.execute(myTask); System.out.println("第 " + i + "个 —— 线程池中线程数目：" + poolExecutor.getPoolSize() + "，队列中等待执行的任务数目：" + poolExecutor.getQueue().size() + "，已执行玩别的任务数目：" + poolExecutor.getCompletedTaskCount()); &#125; poolExecutor.shutdown(); &#125; static class MyTask implements Runnable &#123; private int taskNum; public MyTask(int num) &#123; this.taskNum = num; &#125; @Override public void run() &#123; System.out.println("正在执行task " + taskNum); try &#123; Thread.currentThread().sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("task " + taskNum + "执行完毕"); &#125; &#125; /** * 当 i &lt; 5 时： 正在执行task 0 第 0个 —— 线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 第 1个 —— 线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 1 第 2个 —— 线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 2 第 3个 —— 线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 3 第 4个 —— 线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 4 task 1执行完毕 task 2执行完毕 task 3执行完毕 task 0执行完毕 - - - - - - - - - - - 当 i &lt; 10 时： 正在执行task 0 第 0个 —— 线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 第 1个 —— 线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 1 第 2个 —— 线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 2 第 3个 —— 线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 正在执行task 3 第 4个 —— 线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0 第 5个 —— 线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0 第 6个 —— 线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0 正在执行task 4 第 7个 —— 线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0 第 8个 —— 线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0 第 9个 —— 线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0 task 0执行完毕 task 1执行完毕 task 3执行完毕 正在执行task 7 task 2执行完毕 正在执行task 8 正在执行task 5 正在执行task 6 task 4执行完毕 正在执行task 9 task 7执行完毕 task 6执行完毕 task 9执行完毕 task 5执行完毕 task 8执行完毕 */&#125; 多线程对于 成员变量 与 局部变量 的影响 如果一个变量是 成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是 彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。 如果一个变量是 局部变量，那么 每个线程 都会有一个 该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本数据类型]]></title>
    <url>%2FJava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java基本数据类型 Number抽象类类声明： 123456789101112131415161718192021public abstract class Number implements java.io.Serializable &#123; public abstract int intValue(); public abstract long longValue(); public abstract float floatValue(); public abstract double doubleValue(); public byte byteValue() &#123; return (byte)intValue(); &#125; public short shortValue() &#123; return (short)intValue(); &#125; private static final long serialVersionUID = -8742448824652078965L;&#125; 官方文档描述： 123抽象类 Number 是表示可转换为基本类型：byte、short、int、float、double、long。从特定 Number 实现的数值到给定基元类型的转换的特定语义由所讨论的 Number 实现定义。对于平台类，转换通常类似于缩小基元转换或扩展基元转换，如在 Java＆trade中定义; 用于在基元类型之间进行转换的语言规范。 因此，转换可能会丢失有关数值总体大小的信息，可能会丢失精度，甚至可能返回与输入不同的符号结果。 特点：实现 java.io.Serializable 接口，已经实现序列化 。 AtomicInteger类类声明： 123456789101112131415public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value;&#125; 描述： 官方文档描述 ： 123可以原子更新的 int 值。 有关原子变量属性的描述，请参阅：java.util.concurrent.atomic 的包规范。AtomicInteger 用于诸如原子递增计数器的应用程序中，不能用作 Integer 的替代。 但是，此类确实扩展了 Number，以允许通过处理基于数字的类的工具和实用程序进行统一访问。 AtomicInteger 是一个：提供原子操作 的 Integer 类，通过 线程安全 的方式操作 加减，因此十分适合 高并发 情况下的使用。。 关键词：原子，volatile 这里value 使用了volatile 关键字，volatile 在这里可以做到的作用是 : 使得多个线程可以共享变量，但是问题在于使用 volatile 将使得VM优化失去作用，导致效率较低。 volatile 的作用是当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。 value 变量的处理 获取变量 123public final int get() &#123; return value;&#125; 变量自增处理（其他处理类似）： 12345678public final int incrementAndGet() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return next; &#125;&#125; 应用：1234567private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;; 在这段代码中，变量 mCount 的声明 ： 1private final AtomicInteger mCount = new AtomicInteger(1); 这个变量的应用： 123public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement());&#125; 此处应用的正是： 12345678public final int getAndIncrement() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return current; &#125;&#125; 实例比较： Integer类型变量： 12345678public class Sample1 &#123; private static Integer count = 0; synchronized public static void increment() &#123; count++; &#125;&#125; 对于这个 count++; 的分析： 1231. 获取变量当前值2. 给获取的当前变量值+13. 写回新的值到变量 假设count的初始值为10，当进行并发操作的时候，可能出现：线程A和线程B都进行到了1操作，之后又同时进行2操作。A先进行到3操作+1，现在值为11；注意刚才AB获取到的当前值都是10，所以B执行3操作后，count的值依然是11。这个结果显然不符合我们的要求。 AtomicInteger 类型变量： 123456789public class Sample2 &#123; private static AtomicInteger count = new AtomicInteger(0); public static void increment() &#123; count.getAndIncrement(); &#125;&#125;]]></content>
      <categories>
        <category>Java,基本数据类型</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window与WindowManager]]></title>
    <url>%2FWindow%E4%B8%8EWindowManager%2F</url>
    <content type="text"><![CDATA[Window与WindowManager 1. 概述View 是Android中视图的呈现方式，但是 View 不能单独存在，必须依靠 Window 这个抽象类的概念上，有视图的地方就有Window，所以 Window抽象类 实际是 View类 管理者。。 Window 是一个 抽象类（public abstract class Window{}），其表示一个窗口的概念，其具体的实现类是 PhoneWindow类。 WindowManager 是一个 接口（public interface WindowManager extends ViewManager{}），WindowManager接口 是 外界访问 Window抽象类 的窗口，Window抽象类 的具体实现是在 WindowManagerService 中 ， WindowManager 与 WindowManagerService 的交互是一个 IPC 过程。 在 WIndow这个类中有2种参数： flags：表示 Window 的 属性，控制 Window的显示特性 type ：表示 Window 的 类型，有3种类型： 系统类型：Toast； 应用类：Activity： 子Window类型：Dialog 分层概念： 层级大的会覆盖在层级小的上面。 系统类型：Toast：层级范围：2000~2999 应用类：Activity：层级范围：1000~1999 子Window类型：Dialog：1~99 WindowManager接口 其实现了 ViewManage接口r，接口源码为： 12345public interface ViewManager&#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 由此可见，WindowManager接口 提供了 添加View、更改View、刷新View 的功能。实例参见书籍P297。 2. Window 抽象类每一个 Window抽象类 都对应着一个 View 和 ViewRootImpl。文档中对 ViewRootImpl （public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks）的描述： 1The top of a view hierarchy, implementing the needed protocol between View and the WindowManager. 由此可见是 ViewRootImpl 将 Window 与 View 建立起联系。 WIndow类 中有一个抽象方法 getDecorView()（ public abstract View getDecorView();），此方法具体在 PhoneWindow类 中实现： 12345678// line : 2068@Overridepublic final View getDecorView() &#123; if (mDecor == null || mForceDecorInstall) &#123; installDecor(); &#125; return mDecor;&#125; 3. WindowManager 接口对 Window 的访问操作必须通过 WindowManager ，而 WindowManager 类的具体是现实通过 WindowManagerImpl类实现的：public final class WindowManagerImpl implements WindowManager。 WindowManager 提供了 添加View、更改View、刷新View 的功能，但是这3个功能在 WindowMangerImpl类 中并没有进行彻底的实现： 12345678910111213141516171819private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125;@Overridepublic void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params);&#125;@Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; 要完成 Window 的：添加、删除、更新 除了以上提到的类，还需要 WindowManagerService类 的配合。 在源代码中出现了 mGlobal 这个变量，而这个变量则是 WindowManagerGlobal.getInstance() 的实例。所以具体的方法实现转移到了 WindowManagerGlobal类 中（public final class WindowManagerGlobal）。 在 WindowManagerGlobal类 中重要的4个集合，这4个集合在之后的 addView() ,removeVIew(), updateViewLayout() 方法中都会用到： 12345private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;();private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); 3.1 Window 添加View 的过程这个添加View过程 对应的源码方法为： 1public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow) &#123;&#125; 这个过程可以分为 3个 步骤： 参数检查 123456789101112131415161718192021if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (display == null) &#123; throw new IllegalArgumentException("display must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; 列表添加数据 123456789101112131415int index = findViewLocked(view, false);if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException("View " + view + " has already been added to the window manager."); &#125;&#125; root = new ViewRootImpl(view.getContext(), display);view.setLayoutParams(wparams);mViews.add(view);mRoots.add(root);mParams.add(wparams); 更新界面 1root.setView(view, wparams, panelParentView); 最终的添加实现还是通过 ViewRootImpl 的 setView() 来实现的。在 setView() 方法中通过调用 ViewRootImpl 中的 requestLayout() 来刷新请求。requestLayout() 源码： 12345678@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 这个方法中有2步： checkThread() 这一步的作用是检查当前线程是否为UI主线程 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; scheduleTraversals() 12345678910111213void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 3.2 Window 删除View 的过程removeView(View view, boolean immediate) 源码： 1234567891011121314151617public void removeView(View view, boolean immediate) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException("Calling with view " + view + " but the ViewAncestor is attached to " + curView); &#125;&#125; removeViewLocked(int index, boolean immediate) 源码： 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125;&#125; 执行具体的删除过程的是 ViewRootImpl类 的 die(boolean immediate) {} 源码。 123456789101112131415boolean die(boolean immediate) &#123; if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(mTag, "Attempting to destroy the window while drawing!\n" + " window=" + this + ", title=" + mWindowAttributes.getTitle()); &#125; mHandler.sendEmptyMessage(MSG_DIE); return true;&#125; 在 die() 这个方法中，并没有直接就删除了 View，而是分了情况： 异步删除，调用 mHandler.sendEmptyMessage(MSG_DIE);； 同步删除，调用 doDie(); ViewRootImpl类 的 doDie() 源码： 123456789101112131415161718192021222324252627282930313233343536void doDie() &#123; checkThread(); synchronized (this) &#123; if (mRemoved) &#123; return; &#125; mRemoved = true; if (mAdded) &#123; dispatchDetachedFromWindow(); &#125; if (mAdded &amp;&amp; !mFirst) &#123; destroyHardwareRenderer(); if (mView != null) &#123; int viewVisibility = mView.getVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility; if (mWindowAttributesChanged || viewVisibilityChanged) &#123; try &#123; if ((relayoutWindow(mWindowAttributes, viewVisibility, false) &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123; mWindowSession.finishDrawing(mWindow); &#125; &#125; catch (RemoteException e) &#123; &#125; &#125; mSurface.release(); &#125; &#125; mAdded = false; &#125; WindowManagerGlobal.getInstance().doRemoveView(this);&#125; 在这个 doDie() 以及 die() 方法中做的是对 此View 在Window中的一些 判断、解除、停止性 的操作。最后的操作还是在 WindowManagerGlobal类 中完成的。实际上就是 从自己家出门，绕了一个弯（到”装备厂“ 卸下 ”装备“）又回到了自己家。 WindowManagerGlobal类 中的 doRemoveView(ViewRootImpl root) 源码： 1234567891011121314void doRemoveView(ViewRootImpl root) &#123; synchronized (mLock) &#123; final int index = mRoots.indexOf(root); if (index &gt;= 0) &#123; mRoots.remove(index); mParams.remove(index); final View view = mViews.remove(index); mDyingViews.remove(view); &#125; &#125; if (ThreadedRenderer.sTrimForeground &amp;&amp; ThreadedRenderer.isAvailable()) &#123; doTrimForeground(); &#125;&#125; 最终 待删除View 的删除还是体现在了 private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;(); private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); 集合中。 3.3 Window 更新View 的过程WindowManagerGlobal类 中的 updateViewLayout(View view, ViewGroup.LayoutParams params)源码： 1234567891011121314151617181920public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if (view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized (mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); root.setLayoutParams(wparams, false); &#125;&#125; 4. 各种类型 Window 的创建4.1 Activity 中 Window 内容的创建4.1.1 Activity 与 Window 关联Activity类（public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, WindowControllerCallback, AutofillManager.AutofillClient {}） 将Activity的视图附属在Window上： Activity类 中的方法 setContentView(@LayoutRes int layoutResID){} 源码： 12345// line ：2770public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; 在 Activity 类中有3个 setContentView() 方法，但是调用的都是 getWindow().setContentView()。而这个方法来自：Window抽象类 中的 setContentView(@LayoutRes int layoutResID) 源码： 12// line : 1384public abstract void setContentView(@LayoutRes int layoutResID); 由于 PhoneWindow类 是 Window抽象类 的具体实现，所以实际方法 setContentView(int layoutResID) 的源码： 1234567891011121314151617181920212223// line : 404@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 到这个方法为止，Activity类 与 Window抽象类 的结合过程就到了 PhoneWindow类 的 setContentView()。下面具体分析结合的过程。 4.1.2 PhoneWindow 中 Activity 视图的具体设定PhoneWindow类 中 setContentView()`` 的源码： 1234567 ViewGroup mContentParent; if (mContentParent == null) &#123; installDecor();&#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews();&#125; 在这个方法中调用到了一个 installDecor();，而在这个 installDecor(); 中主要有2个方法： mDecor = generateDecor(-1);：生成空DecorView。 mContentParent = generateLayout(mDecor);：为 android.R.id.content 设置 layout。 4.1.2.1 生成空白 DecorVIew为 Activity 设置视图的第1步就是判空：判断 ViewGroup 是否为空，调用 installDecor() 。PhoneWindow类 中 installDecor() 的源码： 123456789101112131415// line : 2659private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; ……&#125; 如果 DecorView 对象为空，那么先创建此对象。PhoneWindow类 中 generateDecor(int featureId) 的源码： 123456protected DecorView generateDecor(int featureId) &#123; …… return new DecorView(context, featureId, this, getAttributes());&#125; 4.1.2.2 加载 id为content的 layout到此步骤，仅仅是生成了一个 空白的DecorView壳。 DecorView 是一个 FrameLayout，是Activity 中的顶级 View，包含标题栏 和 内容栏，但是这两个内容的存在是会随着主题的改变而改变的，无论怎么变 内容栏 是一定会存在的。而且 内容栏 的 id值 是固定的：android.R.id.content 。当 DecorView 通过 installDecor() 调用 generateDecor(-1) 时，仅仅是生成了一个 空白的FrameLayout，没有任何内容。 接下来 PhoneWindow类 中 installDecor(int featureId) 的源码： 12345678910// line : 2659protected DecorView installDecor(int featureId) &#123; …… if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); &#125;&#125; PhoneWindow类 中 generateLayout(DecorView decor) 的源码： 123456// line : 2313protected ViewGroup generateLayout(DecorView decor) &#123; mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);&#125; 其中 ID_ANDROID_CONTENT 就是： 1234/** * The ID that the main layout in the XML layout file should have. */public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 而此时Activity 中的 setContentView() 名字的由来也是明了了。因为：Activity 的布局文件仅仅是被添加到 DecorView 中的 mContentParent 中。 PhoneWindow类 中 onResourcesLoaded(LayoutInflater inflater, int layoutResource) 的源码： 123456789101112131415161718// line : 1875void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; mDecorCaptionView = createDecorCaptionView(inflater); final View root = inflater.inflate(layoutResource, null); if (mDecorCaptionView != null) &#123; if (mDecorCaptionView.getParent() == null) &#123; addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; else &#123; // Put it below the color views. addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mContentRoot = (ViewGroup) root;&#125; 4.1.2.3 回调 Activity 中的 onContentChanged() 通知 Activity的视图 发生改变123456789// line : 404@Overridepublic void setContentView(int layoutResID) &#123; final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 4.2 Dialog 的 Window 创建Dialog 的 Window 创建的过程与 Activity 的创建过程相似： setContentView() 中添加布局 show() 中通过 WindowManager 的 addView() 添加 DecorView 1234567// line : 288public void show() &#123; …… mWindowManager.addView(mDecor, l); mShowing = true;&#125; 当 Dialog 关闭时： 123456789101112 // line : 355@Overridepublic void dismiss() &#123; if (Looper.myLooper() == mHandler.getLooper()) &#123; dismissDialog(); &#125; else &#123; mHandler.post(mDismissAction); &#125;&#125;void dismissDialog() &#123; mWindowManager.removeViewImmediate(mDecor);&#125; 将 DecorView 移除。 4.3 Toast 的 Window 创建 Toast类 的实现涉及到 IPC，涉及到 INotificationManager以及 Toast 中的私有静态内部类 TN（private static class TN extends ITransientNotification.Stub）。 因为 Toast 属于系统Window，其内部视图是由2种方式确立的； 系统默认样式； 通过 setView() 来指定一个自定义View。 这2种方式最终都对应到 Toast类 中的 mNextView 参数。 Toast视图 与 Window 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// line : 348private static class TN extends ITransientNotification.Stub &#123; // line : 373 TN(String packageName, @Nullable Looper looper) &#123; final WindowManager.LayoutParams params = mParams; params.height = WindowManager.LayoutParams.WRAP_CONTENT; params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.format = PixelFormat.TRANSLUCENT; params.windowAnimations = com.android.internal.R.style.Animation_Toast; params.type = WindowManager.LayoutParams.TYPE_TOAST; params.setTitle("Toast"); params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; mPackageName = packageName; if (looper == null) &#123; // Use Looper.myLooper() if looper is not specified. looper = Looper.myLooper(); if (looper == null) &#123; throw new RuntimeException( "Can't toast on a thread that has not called Looper.prepare()"); &#125; &#125; mHandler = new Handler(looper, null) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SHOW: &#123; IBinder token = (IBinder) msg.obj; handleShow(token); break; &#125; case HIDE: &#123; handleHide(); // Don't do this in handleHide() because it is also invoked by // handleShow() mNextView = null; break; &#125; case CANCEL: &#123; handleHide(); // Don't do this in handleHide() because it is also invoked by // handleShow() mNextView = null; try &#123; getService().cancelToast(mPackageName, TN.this); &#125; catch (RemoteException e) &#123; &#125; break; &#125; &#125; &#125; &#125;; &#125; // line : 452 // 将Toast视图添加至 Window public void handleShow(IBinder windowToken) &#123; if (mView != mNextView) &#123; // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) &#123; context = mView.getContext(); &#125; mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; try &#123; mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125; catch (WindowManager.BadTokenException e) &#123; /* ignore */ &#125; &#125; &#125; // line : 523 // 将Toast视图从 Window 移除 public void handleHide() &#123; if (mView != null) &#123; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeViewImmediate(mView); &#125; try &#123; getService().finishToken(mPackageName, this); &#125; catch (RemoteException e) &#123; &#125; mView = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>Window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-绘制原理]]></title>
    <url>%2FView-%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[View绘制原理 View 的绘制过程分为 measure、layout、draw 三个流程。 measure：确定View的测量宽高； layout：确定View最终的宽高、4个顶点的位置； draw：绘制内容到屏幕。 1. MeasureSpec类1.1 概述MeasureSpec类 起的是 测量规格的作用。在测量过程中，系统会将 View 的 LayoutParams 根据父容器所施加的规则转换成对应的 MeasureSpace ，然后再根据这个 measureSpace 来测量出 View 的宽高。 MeasureSpace 代表一个32位的int值，高2位代表 SpaceMode（测量模式），低30位代表 SpaceSize（某种测量模式下的测量值）， 主要源码为： 12345678910111213141516171819202122232425262728293031323334public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; @MeasureSpecMode public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125;&#125; 1.2 SpaceMode（3类） UNSPECIFIED 父容器对 View 是 无任何限制的。 EXACTLY 父容器已经检测出 View 所需的精确大小。此时 View 的最终大小就是 SpaceSize所指定的值，对应于 LayoutParams 中的 match_parent 和 具体数值。 AT_MOST 父容器已经指定了一个 最大的使用范围，View 的大小值不能大于这个数值。对应于 LayoutParams 中的 wrap_parent 和 具体数值。 1.3 View 的宽高View的 MeasureSpace（宽高）是由 自身的LayoutParams 和 父容器的MeasureSpace 一起决定的。MeasureSpace确定后，在 onMeasure() 中就可以确定 View的宽高。 ViewGroup -&gt; getChildMeasureSpace() （普通View的MeasureSpace的创建规则）方法表格化。 2. ViewRootImpl类 中的绘制执行2.1 宏观调用ViewRootImpl类 中的 scheduleTraversals() 1234567891011121314// line : 1428void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; ViewRootImpl类 中的 TraversalRunnable内部类 1234567// line : 7181final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125; ViewRootImpl类 中的 doTraversal() 123456789// line : 1451void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); performTraversals(); &#125;&#125; 2.2 步骤调用ViewRootImpl类 中的 performTraversals() 123456// line : 1676private void performTraversals() &#123; performLayout(); performMeasure(); performDraw();&#125; 2.2.1 performLayout()ViewRootImpl类 中的 performLayout(): 12345// line : 2776private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());&#125; 2.2.2 performMeasure()ViewRootImpl类 中的 performMeasure(): 123456789101112// line : 2713private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 2.2.3 performDraw()ViewRootImpl类 中的 performDraw(): 1234// line ：3092private void performDraw() &#123; boolean canUseAsync = draw(fullRedrawNeeded);&#125; ViewRootImpl类 中的 draw(): 1234567// line : 3171private boolean draw(boolean fullRedrawNeeded) &#123; if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) &#123; return false; &#125;&#125; ViewRootImpl类 中的 drawSoftware(): 12345// line : 3357private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets) &#123; mView.draw(canvas);&#125; 2.3 DecorView类DecorView类 在绘制流程中属于 顶级View 3. measure过程3.1 View 的 measure()重要方法： measure() ：测量自身 onMeasure() ：测量子元素 getDefaultSize() 方法调用： View在绘制自身的时候，调用的是 final 修饰的： measure(int widthMeasureSpec, int heightMeasureSpec) 源代码： 123456789101112131415161718192021public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; …… if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; …… mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec;&#125; 由于这个方法是 final 修饰的，表示在子类中是不能被重写的。但是在这个方法中调用了 onMeasure()，在这个方法中做了进一步的处理： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; setMeasuredDimension() 源码： 123456789101112protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; setMeasuredDimensionRaw(measuredWidth, measuredHeight);&#125; setMeasuredDimensionRaw(int, int) 源码： 123456private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;&#125; 可见这两个方法是对 mMeasuredWidth 与 mMeasuredHeight 进行赋值。真正对测量数据进行处理的是方法 getDefaultSize() ，源码: 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 3.2 ViewGroup 的 measureChildren()ViewGroup 与 View 的不同是，ViewGroup 是一个组合，除了要完成 自己本身 的 measure 以身以外，还会遍历去调用所有 子元素 的 measure，然后各个子元素在去遍历本身包含的子元素，依次递归完成测量工作。 与 View 不同的是，ViewGroup 是一个抽象类，并没有重写 View 中的 onMeasure() ，但是提供了一个 measureChildren()，源码： 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; 通过此方法也可以看出测量过程时通过 自身LayoutParams 与 父容器的MeasureSpace 共同组合成 子元素的MeasureSpace，然后将结果作为参数传递给 measureChild() : 1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 到了这个方法 子元素 就开始调用测量自己的 measure() 方法。 3.3 ViewGroup 子类的 onMeasure() 方法 LinearLayout 的 onMeasure() 方法 因为 ViewGroup 是一个抽象类，而且自身没有测量的具体过程，所以具体的 onMeasure() 就留了子类去实现。 LinearLayout 的 onMeasure() 方法源码： 12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; 由此可见，其测量过程是根据 布局方式 进行测量的。在测量内部子元素时采用的方法依然是通过遍历child的方式。 RelativeLayout 的 onMeasure() 方法 首先对 子元素排序： 1234if (mDirtyHierarchy) &#123; mDirtyHierarchy = false; sortChildren(); &#125; 具体的子元素排序代码： 1234567891011121314151617181920private void sortChildren() &#123; final int count = getChildCount(); if (mSortedVerticalChildren == null || mSortedVerticalChildren.length != count) &#123; mSortedVerticalChildren = new View[count]; &#125; if (mSortedHorizontalChildren == null || mSortedHorizontalChildren.length != count) &#123; mSortedHorizontalChildren = new View[count]; &#125; final DependencyGraph graph = mGraph; graph.clear(); for (int i = 0; i &lt; count; i++) &#123; graph.add(getChildAt(i)); &#125; graph.getSortedViews(mSortedVerticalChildren, RULES_VERTICAL); graph.getSortedViews(mSortedHorizontalChildren, RULES_HORIZONTAL);&#125; 由以下这两行代码，可以非常明显的看出来是分 水平 和 垂直 方向的： 12graph.getSortedViews(mSortedVerticalChildren, RULES_VERTICAL);graph.getSortedViews(mSortedHorizontalChildren, RULES_HORIZONTAL); 具体的测量过程是分方向、宽高的： 2.1 水平方向 1234567891011121314151617View[] views = mSortedHorizontalChildren;int count = views.length;for (int i = 0; i &lt; count; i++) &#123; View child = views[i]; if (child.getVisibility() != GONE) &#123; LayoutParams params = (LayoutParams) child.getLayoutParams(); int[] rules = params.getRules(layoutDirection); applyHorizontalSizeRules(params, myWidth, rules); measureChildHorizontal(child, params, myWidth, myHeight); if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123; offsetHorizontalAxis = true; &#125; &#125;&#125; 2.2 垂直方向 123456789101112131415views = mSortedVerticalChildren;count = views.length;final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;for (int i = 0; i &lt; count; i++) &#123; final View child = views[i]; if (child.getVisibility() != GONE) &#123; final LayoutParams params = (LayoutParams) child.getLayoutParams(); applyVerticalSizeRules(params, myHeight, child.getBaseline()); measureChild(child, params, myWidth, myHeight); …… &#125;&#125; 2.3 WrapContentWidth 1234567891011121314151617181920212223242526272829if (isWrapContentWidth) &#123; // Width already has left padding in it since it was calculated by looking at // the right of each child view width += mPaddingRight; if (mLayoutParams != null &amp;&amp; mLayoutParams.width &gt;= 0) &#123; width = Math.max(width, mLayoutParams.width); &#125; width = Math.max(width, getSuggestedMinimumWidth()); width = resolveSize(width, widthMeasureSpec); if (offsetHorizontalAxis) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = views[i]; if (child.getVisibility() != GONE) &#123; final LayoutParams params = (LayoutParams) child.getLayoutParams(); final int[] rules = params.getRules(layoutDirection); if (rules[CENTER_IN_PARENT] != 0 || rules[CENTER_HORIZONTAL] != 0) &#123; centerHorizontal(child, params, width); &#125; else if (rules[ALIGN_PARENT_RIGHT] != 0) &#123; final int childWidth = child.getMeasuredWidth(); params.mLeft = width - mPaddingRight - childWidth; params.mRight = params.mLeft + childWidth; &#125; &#125; &#125; &#125;&#125; 2.4 isWrapContentHeight 2.5 (horizontalGravity || verticalGravity) 3.4 Activity启动时获取View宽高数据的方式3.4.1 在 Activity中调用 onWindowFocusChanged()123456public void onWindowFocusChanged(boolean hasFocus) &#123; if (hasFocus) &#123; int width = view().getMeasuredWidth(); int height = view().getMeasuredHeight(); &#125;&#125; 3.4.2 在 Activity中调用 view.post(runnable)1234567891011@Overrideprotected void onStart() &#123; super.onStart(); view().post(new Runnable() &#123; @Override public void run() &#123; int width = view().getMeasuredWidth(); int height = view().getMeasuredHeight(); &#125; &#125;);&#125; 4. layout过程4.1 View的layout()12345678910111213141516171819202122@SuppressWarnings(&#123;"unchecked"&#125;) public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); …… &#125; &#125; 通过 setFrame(l, t, r, b) 设置4个定点的位置。在 layout() 中调用了 onLayout()。但是在 View类 中， 这个方法是一个空实现，其具体实现是在具体的子类中实现的。 4.2 ViewGroup 子类中的 onLayout()以 LinearLayout 为例: 源代码为： 12345678@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; 其中 layoutVertical(l, t, r, b) 的源码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122void layoutHorizontal(int left, int top, int right, int bottom) &#123; final boolean isLayoutRtl = isLayoutRtl(); final int paddingTop = mPaddingTop; int childTop; int childLeft; // Where bottom of child should go final int height = bottom - top; int childBottom = height - mPaddingBottom; // Space available for child int childSpace = height - paddingTop - mPaddingBottom; final int count = getVirtualChildCount(); final int majorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK; final int minorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK; final boolean baselineAligned = mBaselineAligned; final int[] maxAscent = mMaxAscent; final int[] maxDescent = mMaxDescent; final int layoutDirection = getLayoutDirection(); switch (Gravity.getAbsoluteGravity(majorGravity, layoutDirection)) &#123; case Gravity.RIGHT: // mTotalLength contains the padding already childLeft = mPaddingLeft + right - left - mTotalLength; break; case Gravity.CENTER_HORIZONTAL: // mTotalLength contains the padding already childLeft = mPaddingLeft + (right - left - mTotalLength) / 2; break; case Gravity.LEFT: default: childLeft = mPaddingLeft; break; &#125; int start = 0; int dir = 1; //In case of RTL, start drawing from the last child. if (isLayoutRtl) &#123; start = count - 1; dir = -1; &#125; for (int i = 0; i &lt; count; i++) &#123; final int childIndex = start + dir * i; final View child = getVirtualChildAt(childIndex); if (child == null) &#123; childLeft += measureNullChild(childIndex); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); int childBaseline = -1; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); if (baselineAligned &amp;&amp; lp.height != LayoutParams.MATCH_PARENT) &#123; childBaseline = child.getBaseline(); &#125; int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; switch (gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) &#123; case Gravity.TOP: childTop = paddingTop + lp.topMargin; if (childBaseline != -1) &#123; childTop += maxAscent[INDEX_TOP] - childBaseline; &#125; break; case Gravity.CENTER_VERTICAL: // Removed support for baseline alignment when layout_gravity or // gravity == center_vertical. See bug #1038483. // Keep the code around if we need to re-enable this feature // if (childBaseline != -1) &#123; // // Align baselines vertically only if the child is smaller than us // if (childSpace - childHeight &gt; 0) &#123; // childTop = paddingTop + (childSpace / 2) - childBaseline; // &#125; else &#123; // childTop = paddingTop + (childSpace - childHeight) / 2; // &#125; // &#125; else &#123; childTop = paddingTop + ((childSpace - childHeight) / 2) + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = childBottom - childHeight - lp.bottomMargin; if (childBaseline != -1) &#123; int descent = child.getMeasuredHeight() - childBaseline; childTop -= (maxDescent[INDEX_BOTTOM] - descent); &#125; break; default: childTop = paddingTop; break; &#125; if (hasDividerBeforeChildAt(childIndex)) &#123; childLeft += mDividerWidth; &#125; childLeft += lp.leftMargin; setChildFrame(child, childLeft + getLocationOffset(child), childTop, childWidth, childHeight); childLeft += childWidth + lp.rightMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, childIndex); &#125; &#125;&#125; 在这个方法中是在 遍历子元素 的过程中通过 setChildFrame(child, childLeft + getLocationOffset(child), childTop,childWidth, childHeight); 来设置子元素的位置。 setChildFrame(View child, int left, int top, int width, int height) 方法源码 123private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; 5. draw过程5.1 View 的 draw() 绘制背景 - drawBackground(canvas) 如有必要，保存画布的图层以准备褪色 绘制视图的内容 - onDraw(canvas) 绘制子元素 - dispatchDraw(canvas) 如有必要，绘制淡化边缘并恢复图层 绘制装饰（例如滚动条） - onDrawForeground(canvas) 一个重要的参数 Canvas类。 主要源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) &#123; debugDrawFocus(canvas); &#125; // we're done... return; &#125; …… &#125; 5.2 ViewGroup 的 dispatchDraw()源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132protected void dispatchDraw(Canvas canvas) &#123; boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode); final int childrenCount = mChildrenCount; final View[] children = mChildren; int flags = mGroupFlags; if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123; final boolean buildCache = !isHardwareAccelerated(); for (int i = 0; i &lt; childrenCount; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123; final LayoutParams params = child.getLayoutParams(); attachLayoutAnimationParameters(child, params, i, childrenCount); bindLayoutAnimation(child); &#125; &#125; final LayoutAnimationController controller = mLayoutAnimationController; if (controller.willOverlap()) &#123; mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE; &#125; controller.start(); mGroupFlags &amp;= ~FLAG_RUN_ANIMATION; mGroupFlags &amp;= ~FLAG_ANIMATION_DONE; if (mAnimationListener != null) &#123; mAnimationListener.onAnimationStart(controller.getAnimation()); &#125; &#125; int clipSaveCount = 0; final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK; if (clipToPadding) &#123; clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG); canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom); &#125; // We will draw our child's animation, let's reset the flag mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION; mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED; boolean more = false; final long drawingTime = getDrawingTime(); if (usingRenderNodeProperties) canvas.insertReorderBarrier(); final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size(); int transientIndex = transientCount != 0 ? 0 : -1; // Only use the preordered list if not HW accelerated, since the HW pipeline will do the // draw reordering internally final ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties ? null : buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); for (int i = 0; i &lt; childrenCount; i++) &#123; while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123; final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; transientIndex = -1; &#125; &#125; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; while (transientIndex &gt;= 0) &#123; // there may be additional transient views after the normal views final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; break; &#125; &#125; if (preorderedList != null) preorderedList.clear(); // Draw any disappearing views that have animations if (mDisappearingChildren != null) &#123; final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren; final int disappearingCount = disappearingChildren.size() - 1; // Go backwards -- we may delete as animations finish for (int i = disappearingCount; i &gt;= 0; i--) &#123; final View child = disappearingChildren.get(i); more |= drawChild(canvas, child, drawingTime); &#125; &#125; if (usingRenderNodeProperties) canvas.insertInorderBarrier(); if (debugDraw()) &#123; onDebugDraw(canvas); &#125; if (clipToPadding) &#123; canvas.restoreToCount(clipSaveCount); &#125; // mGroupFlags might have been updated by drawChild() flags = mGroupFlags; if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123; invalidate(true); &#125; if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp; mLayoutAnimationController.isDone() &amp;&amp; !more) &#123; // We want to erase the drawing cache and notify the listener after the // next frame is drawn because one extra invalidate() is caused by // drawChild() after the animation is over mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER; final Runnable end = new Runnable() &#123; @Override public void run() &#123; notifyAnimationListener(); &#125; &#125;; post(end); &#125;&#125; 以上这段代码中执行了 遍历子元素 与 动画的绘制 过程，其中 遍历子元素后的绘制 是通过方法 drawChild()。 drawChild() 的源码: 123protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 5.3 ViewGroup 子类的 onDraw()LinearLayout 的绘制 Divider过程，以 Vertical布局为例： onDraw() 源码 123456789101112 @Overrideprotected void onDraw(Canvas canvas) &#123; if (mDivider == null) &#123; return; &#125; if (mOrientation == VERTICAL) &#123; drawDividersVertical(canvas); &#125; else &#123; drawDividersHorizontal(canvas); &#125;&#125; drawDividersVertical(Canvas canvas) 源码 12345678910111213141516171819202122232425void drawDividersVertical(Canvas canvas) &#123; final int count = getVirtualChildCount(); for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child != null &amp;&amp; child.getVisibility() != GONE) &#123; if (hasDividerBeforeChildAt(i)) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int top = child.getTop() - lp.topMargin - mDividerHeight; drawHorizontalDivider(canvas, top); &#125; &#125; &#125; if (hasDividerBeforeChildAt(count)) &#123; final View child = getLastNonGoneChild(); int bottom = 0; if (child == null) &#123; bottom = getHeight() - getPaddingBottom() - mDividerHeight; &#125; else &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); bottom = child.getBottom() + lp.bottomMargin; &#125; drawHorizontalDivider(canvas, bottom); &#125;&#125; drawHorizontalDivider(Canvas canvas, int top) 源码： 12345void drawHorizontalDivider(Canvas canvas, int top) &#123; mDivider.setBounds(getPaddingLeft() + mDividerPadding, top, getWidth() - getPaddingRight() - mDividerPadding, top + mDividerHeight); mDivider.draw(canvas);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-链表题解]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[链表题解 一个链表节点 1234567891011121314151617public class Node &#123; int data; Node next; public Node(int data) &#123; this.data = data; &#125; @Override public String toString() &#123; return &quot;Node&#123;&quot; + &quot;data=&quot; + data + &quot;, next=&quot; + next + &apos;&#125;&apos;; &#125;&#125; 链表节点操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261import java.util.Hashtable;public class LinkedOperator &#123; /** * 链表的首结点 */ private Node head = null; /** * 添加 链表节点 * * @param data 节点的数据 */ public void addNode(int data) &#123; Node newNode = new Node(data); // 判断头节点下是否有元素 if (head == null) &#123; // 如果没有：为头节点添加 首元素 head = newNode; return; &#125; // 链表的遍历总是从链表头开始遍历 Node tempNode = head; // 判断链表中是否有元素 while (tempNode.next != null) &#123; // 如果有：遍历至最后一个元素 tempNode = tempNode.next; &#125; // 如果没有：将新添加的元素添加至 链表的尾部 tempNode.next = newNode; &#125; /** * 链表排序：选择排序 * * @return 返回排序结束之后的链表头 */ public Node distLink() &#123; Node curNode = head; while (curNode != null) &#123; Node nextNode = curNode.next; while (nextNode != null) &#123; if (curNode.data &gt; nextNode.data) &#123; int tempData = curNode.data; curNode.data = nextNode.data; nextNode.data = tempData; &#125; nextNode = nextNode.next; &#125; curNode = curNode.next; &#125; return head; &#125; /** * 删除指定索引节点 * * @param index 指定索引 */ public boolean delNode(int index) &#123; // 判断删除索引是否合理 if (index &lt; 1 || index &gt; getLength()) &#123; return false; &#125; // 判断删除所以是否为特殊索引 if (index == 1) &#123; // 如果删除的首节点，则直接将指针指向第二个节点，使其成为首节点 head = head.next; return true; &#125; // 非特殊位置的索引，正常删除链表节点 int i = 1; Node preNode = head; Node curNode = preNode.next; while (curNode != null) &#123; if (i == index) &#123; // 如果 是要删除索引 // 执行节点删除操作：跳过当前节点，直接将当前节点的指向指向上一个结点的指向。 preNode.next = curNode.next; return true; &#125; else &#123; // 如果不是 要删除索引 // 将当前节点后移 preNode = curNode; curNode = curNode.next; i++; &#125; &#125; return true; &#125; /** * 获取链表长度 * * @return 长度 */ public int getLength() &#123; int length = 0; Node node = head; while (node.next != null) &#123; length++; node = node.next; System.out.println(&quot;getLength() node is : &quot; + node.toString()); &#125; return length; &#125; /** * 打印当前链表 */ public void printLink() &#123; Node curNode = head; while (curNode != null) &#123; System.out.println(curNode.toString()); curNode = curNode.next; &#125; &#125; public void clearLink() &#123; &#125; /** * 元素去重 */ public Node distinctLink() &#123; Node temp = head; Node pre = null; Hashtable&lt;Integer, Integer&gt; hashtable = new Hashtable&lt;&gt;(); while (temp != null) &#123; if (hashtable.containsKey(temp.data)) &#123; // 如果hashtable中已存在该结点，则跳过该结点 pre.next = temp.next; &#125; else &#123; //如果hashtable中不存在该结点，将结点存到hashtable中 hashtable.put(temp.data, 1); pre = temp.next; &#125; temp = temp.next; &#125; return head; &#125; /** * 查找指定的元素 * * @param index 指定索引 * @return 返回指定 Node */ public Node getNNode(int index) &#123; if (index &lt; 1 || index &gt; getLength()) &#123; return null; &#125; Node node = head; for (int i = 0; i &lt; index - 1; i++) &#123; node = node.next; &#125; return node; &#125; /** * 反转链表 * 反转本质：当前节点指向前一个节点 * * @return 翻转之后的列表 */ public Node reserverLink() &#123; Node curNode = head; Node preNode = null; while (curNode != null) &#123; // 将当前节点的指向暂存 Node nextNode = curNode.next; // 1 - 先确定 反转后当前节点要指向的位置 curNode.next = preNode; // 2 - 位置确定后，再对指向的位置进行数据填充 preNode = curNode; // 3 - 从暂存变量中重新获取当前节点 curNode = nextNode; &#125; return preNode; /** * 原始： * Node&#123;data=12, next=Node&#123;data=56, next=Node&#123;data=23, next=Node&#123;data=6, next=null&#125;&#125;&#125;&#125; * * 结果： * Node&#123;data=6, next=Node&#123;data=23, next=Node&#123;data=56, next=Node&#123;data=12, next=null&#125;&#125;&#125;&#125; */ &#125; /** * 获取链表最后一个元素 * @return 最后一个元素 */ public Node getLastNode()&#123; Node temp = head; while (temp.next != null) &#123; temp = temp.next; &#125; return temp; &#125; /** * 判断 当前链表是否为一个圆 * 设置 快指针 和 慢指针 * @return 返回判定值 */ public boolean isRing()&#123; if (head == null) &#123; return false; &#125; if (head.next == null) &#123; return false; &#125; Node s = head.next; Node f = head.next.next; while (f != null) &#123; if (s == f) &#123; return true; &#125; s = s.next; f = f.next.next; &#125; return true; &#125; /** * 判断 2个链表是否相交 * @param head1 链表1 * @param head2 链表2 * @return 返回判定值 */ /*public boolean isCross(Node head1, Node head2)&#123; &#125;*/&#125; 运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainTest &#123; public static void main(String[] srgs)&#123; LinkedOperator linkedList = new LinkedOperator(); linkedList.addNode(12); linkedList.addNode(56); linkedList.addNode(23); linkedList.addNode(12); /*linkedList.addNode(23); linkedList.addNode(44); linkedList.addNode(6);*/ //linkedList.printLink(); // Node&#123;data=12, next=Node&#123;data=56, next=Node&#123;data=2, next=Node&#123;data=23, next=null&#125;&#125;&#125;&#125; //System.out.println(linkedList.getLength()); /* * node is : Node&#123;data=12, next=Node&#123;data=24, next=Node&#123;data=36, next=Node&#123;data=48, next=null&#125;&#125;&#125;&#125; * node is : Node&#123;data=24, next=Node&#123;data=36, next=Node&#123;data=48, next=null&#125;&#125;&#125; * node is : Node&#123;data=36, next=Node&#123;data=48, next=null&#125;&#125; * node is : Node&#123;data=48, next=null&#125; * 4 */ //linkedList.delNode(2); //System.out.println(linkedList.getLength()); /* * getLength() node is : Node&#123;data=12, next=Node&#123;data=36, next=Node&#123;data=48, next=null&#125;&#125;&#125; * getLength() node is : Node&#123;data=36, next=Node&#123;data=48, next=null&#125;&#125; * getLength() node is : Node&#123;data=48, next=null&#125; * 3 */ // 执行排序操作 //linkedList.distLink(); //linkedList.printLink(); // Node&#123;data=2, next=Node&#123;data=12, next=Node&#123;data=23, next=Node&#123;data=56, next=null&#125;&#125;&#125;&#125; //linkedList.clearLink(); //System.out.println(linkedList.distinctLink()); //System.out.println(linkedList.getNNode(3)); //System.out.println(linkedList.reserverLink()); //System.out.println(linkedList.getLastNode()); System.out.println(linkedList.isRing()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-数组题解]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[数组题解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300package just_do;public class TestMainClass &#123; public static void main(String args[]) &#123; int a[] = &#123; 5, 2, 7, 2, 4, 23, 7, 2, 3, 0, 43, 3, 8, 31 &#125;; // 1-排序冒泡 maoPao(a); System.out.println(); // 2-选择排序 xunZe(a); System.out.println(); // 3-插入排序 chaRu(a); System.out.println(); // 4-二分法排序 erFenFa(a); System.out.println(); // 5-希尔排序 xiEr(a); System.out.println(); // 6-快速排序 kuaiPai(a,0,a.length-1); // 查找 //有序排列数组（大到小，小到大无所谓） int[] array = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; //打印二分法的返回值 System.out.println(searchRecursive(array, 0, array.length - 1, 9)); &#125; /** * 快速排序(一种划分交换排序。它采用了一种分治的策略，通常称其为分治法) * * 选择一个关键值作为基准值(一般选择序列的第一个元素)。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。 * * 基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 */ private static void kuaiPai(int[] a, int low, int high) &#123; // 划分后的基准记录的位置 int pivot; // 仅当区间长度大于1时才须排序 if (low &lt; high) &#123; // 对 a[low..high] 做划分 pivot = partitoin(a,low,high); // 对左区间递归排序 kuaiPai(a,low,pivot-1); // 对右区间递归排序 kuaiPai(a,pivot+1,high); &#125; for(int i = 0; i &lt; a.length; i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125; private static int partitoin(int[] a, int low, int high) &#123; // 用区间的第1个记录作为基准 int pivot = a[low]; while (low &lt; high) &#123; //从区间两端交替向中间扫描，直至i=j为止 while (low &lt; high &amp;&amp; a[high] &gt;= pivot) &#123; high--; &#125; // 表示找到的a[high]的关键字&lt;key if (low &lt; high) &#123; a[low++] = a[high]; &#125; while (low &lt; high &amp;&amp; a[low] &lt;= pivot) &#123; low++; &#125; if (low &lt; high) &#123; a[high--] = a[low]; &#125; &#125; a[low] = pivot; return low; &#125; /** * 希尔排序 * * 类似于插入排序，只是每次所取的步长为（数组的长度/2/i）。 * * 时间复杂度为（n*logn）。 */ private static void xiEr(int[] a) &#123; for (int gap = a.length/2; gap &gt; 0 ; gap /= 2) &#123; for (int j = gap; j &lt; a.length; j++) &#123; int key = a[j]; int g = j - gap; while (g &gt;= 0 &amp;&amp; a[g] &gt; key) &#123; a[g+gap] = a[g]; g -= gap; &#125; a[g+gap] = key; &#125; &#125; for(int i = 0; i &lt; a.length; i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125; /** * 二分法排序 * * 先用二分法查找插入位置，然后再所有插入位置（二分法查出来的）后面的元素全部后移，最后插入元素 */ private static void erFenFa(int[] a) &#123; int left,right,mid,get; for (int i = 1; i &lt; a.length; i++) &#123; // 初始化参数 left = 0; right = i-1; get = a[i]; // 通过 二分法 查找插入位置 while (left &lt;= right) &#123; mid = (left + right)/2; if (a[mid] &lt; a[i]) &#123; right = mid - 1; &#125; else &#123; left = mid +1; &#125; &#125; // 后移排序码大于a[i]的记录 for (int j = i-1; j &gt;= left; j--) &#123; a[j+1] = a[j]; &#125; // 插入 a[left] = get; &#125; for(int i = 0; i &lt; a.length; i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125; /** * 插入排序 * * 从第二个元素开始，和之前的已排好序的字数组的元素比较，找到合适的位置，然后后面的元素向后移动一位，再将该元素插入到前面合适的位置。 * * 时间复杂度为（O（n^2）） */ private static void chaRu(int[] a) &#123; for (int i = 1; i &lt; a.length; i++) &#123; int font = i - 1; int get = a[i]; for (;font &gt;=0 &amp;&amp; a[font] &gt; get;font--) &#123; a[font+1] = a[font]; &#125; a[font+1] = get; &#125; for(int i = 0; i &lt; a.length; i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125; /** * 选择 排序 * * 外层循环选取1个元素，与内层循环的每1个元素做大小比较 * * 时间复杂度为（（O（n^2））） */ private static void xunZe(int[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = i+1; j &lt; a.length; j++) &#123; if (a[i] &gt; a[j]) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125; for(int i = 0; i &lt; a.length; i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125; /** * 冒泡 排序 * * 相邻2个元素之间的比较 * * 时间复杂度为（O（n^2）） */ private static void maoPao(int a[]) &#123; for (int i = 0; i &lt; a.length-1; i++) &#123; for (int j = 0; j &lt; a.length-i-1; j++) &#123; if (a[j+1] &lt; a[j]) &#123; int temp = a[j+1]; a[j+1] = a[j]; a[j] = temp; &#125; &#125; &#125; for(int i = 0; i &lt; a.length; i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125; /** * 二分法 查找 * */ public static int searchRecursive(int[] array, int start, int end, int findValue) &#123; if (array == null) &#123; return -1; &#125; if (start &lt;= end) &#123; //中间位置 int middle = (start + end) / 2; //中值 int middleValue = array[middle]; if (findValue == middleValue) &#123; //与中值相等就直接返回 return middle; &#125; else if (findValue &lt; middleValue) &#123; //目标值小于中值，在中值前面找（这里调用了二分法的方法） return searchRecursive(array, start, middle - 1, findValue); &#125; else &#123; //目标值大于中值，在中值后面找（这里调用了二分法的方法） return searchRecursive(array, middle + 1, end, findValue); &#125; &#125; else &#123; //返回-1，查找失败 return -1; &#125; &#125;&#125;// 汉诺塔public class Hannuo &#123; static int m = 0; public static void main(String[] args) &#123; int disks = 3; char A = &apos;A&apos;; char B = &apos;B&apos;; char C = &apos;C&apos;; Hannuo.hannuo(disks, A, B, C); &#125; private static void move(int disks, char M, char N) &#123; System.out.println(&quot;第&quot; + (++m) + &quot; 次移动 : &quot; + &quot; 把 &quot; + disks + &quot; 号圆盘从 &quot; + M + &quot; -&gt;移到-&gt; &quot; + N); &#125; public static void hannuo(int n, char A, char B, char C) &#123; if (n == 1) &#123; Hannuo.move(n, A, C); &#125; else &#123; hannuo(n - 1, A, C, B); Hannuo.move(n, A, C); hannuo(n - 1, B, A, C); &#125; &#125;&#125;/* 第1 次移动 : 把 1 号圆盘从 A -&gt;移到-&gt; C 第2 次移动 : 把 2 号圆盘从 A -&gt;移到-&gt; B 第3 次移动 : 把 1 号圆盘从 C -&gt;移到-&gt; B 第4 次移动 : 把 3 号圆盘从 A -&gt;移到-&gt; C 第5 次移动 : 把 1 号圆盘从 B -&gt;移到-&gt; A 第6 次移动 : 把 2 号圆盘从 B -&gt;移到-&gt; C 第7 次移动 : 把 1 号圆盘从 A -&gt;移到-&gt; C */]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart-Tour3]]></title>
    <url>%2FDart-Tour3%2F</url>
    <content type="text"><![CDATA[Dart-Tour3 Dart语法样式： https://www.dartlang.org/guides/language/effective-dart/style语法：https://www.dartlang.org/guides/language/language-tour 概览 重要概念 关键词 注释 变量 内置类型 函数 操作符 流程 异常 类 泛型 库 异步 发电机 可调用的类 分离 类型定义 元数据 泛型为什么要使用泛型？类型安全通常需要泛型，但它们比仅允许代码运行有更多好处： 正确指定泛型类型可以生成更好的代码。 您可以使用泛型来减少代码重复。 使用collection字面量1234var names = &lt;String&gt;['A','B','C'];var pages = &lt;int, String&gt;&#123;1:'pageOne',2:'pageTwo',3:'pageThree'&#125;;assert(names is List);assert(pages is Map); 使用带有构造函数的参数化类型12345var names2 = List&lt;String&gt;();names2.addAll(names);print(names2); var maps = Map&lt;int, String&gt;(); 泛型集合及其包含的类型Dart的泛型类型是具体化的，这意味着他们在运行时随身携带类型信息 1234var names2 = List&lt;String&gt;();names2.addAll(names);assert(names2 is List&lt;String&gt;);print(names2 is List&lt;String&gt;); 结果为： 1[A, B, C] 注意：在Java中，您可以测试对象是否为List，但您无法测试它是否为List&lt;String&gt;。Java中的泛型使用擦除，这意味着在运行时删除泛型类型参数。 限制参数化类型通过extends限制其参数的类型。 例如： 1234var pintT = PointT&lt;Point&gt;();var pintInner = PointT&lt;PointInner&gt;();print(pintT);print(pintInner); 结果为： 12Instance of &apos;PointT&lt;Point&gt;&apos;Instance of &apos;PointT&lt;PointInner&gt;&apos; 错误的使用方式： 1var pintInner2 = PointT&lt;num&gt;(); 结果： 错误提示num 没有继承 Point 使用泛型方法最初，Dart的泛型支持仅限于class。一种称为泛型方法的新语法允许在方法和函数上使用类型参数。例如： 12345678var names = &lt;String&gt;['A','B','C'];T fun&lt;T&gt;(List&lt;T&gt; lists)&#123; T temp = lists[0]; return temp;&#125;print(fun&lt;String&gt;(names)); 结果： 1A first（&lt;T&gt;）的泛型类型参数允许你在一下几个地方使用类型参数T： 在函数的返回类型（T）中。 在参数类型（List）中。 在局部变量的类型（T tmp）。 Libraries - 具有很大的灵活性import和library指令可以帮助创建一个模块化的、可共享的代码库。库不仅提供API，还是隐私单元：以下划线 _ 开头的标识符仅在库内可见。每个Dart应用程序都是一个库。 Dart中使用 pub 来管理包 使用库使用import指定如何从一个库中的命名空间在另一个库的范围内使用。 注意： URI代表统一资源标识符。 URL（统一资源定位符）是一种常见的URI。 指定库前缀如果导入两个具有冲突标识符的库，则可以为一个或两个库指定前缀。例如，如果library1和library2都有一个Element类，那么可以这样导入： 12345678import 'package:lib1/lib1.dart';import 'package:lib2/lib2.dart' as lib2;// Uses Element from lib1.Element element1 = Element();// Uses Element from lib2.lib2.Element element2 = lib2.Element(); 仅导入库的一部分如果只想使用库的一部分，则可以有选择地导入库。例如： 12345// Import only foo.import 'package:lib1/lib1.dart' show foo;// Import all names EXCEPT foo.import 'package:lib2/lib2.dart' hide foo; 延迟加载一个库延迟加载允许应用程序根据需要加载库，如果需要的话。以下是可能使用延迟加载的一些情况： 减少应用程序的初始启动时间。 加载很少使用的功能，例如可选的屏幕和对话框。 要延迟加载库，必须先使用 deferred as导入这个库。 1import 'package:greetings/hello.dart' deferred as hello; 当需要库时，调用loadLibrary()使用库的标识符 。 1234Future greet() async &#123; await hello.loadLibrary(); hello.printGreeting();&#125; 在上面的代码中，await关键字暂停执行，直到加载库以后。此处涉及到异步的知识。可以多次使用loadLibrary()而不会出现问题，因为该库只加载一次。 异步支持Dart库中包含许多返回Future或Stream对象的函数。这些函数是异步的。async和await关键字支持异步编程，使得写异步代码看起来类似于同步代码。 处理Future处理Future结果时，有2种选择： 使用async和await关键字。 使用Future API 使用async和await异步的代码看起来很像同步代码。例如：使用await关键字来等待一个异步函数的结果 1await lookUpVersion(); 要使用await，要确保代码必须包含在一个被async标记的异步函数中： 1234Future checkVersion() async &#123; var version = await lookUpVersion(); // Do something with version&#125; 注意： 虽然异步函数可能执行耗时的操作，但它不会等待这些操作。相反，异步函数只在遇到第一个await表达式（详细信息）时执行。然后它返回一个Future对象，仅在await表达式完成后才恢复执行。 使用try、catch和finally 来处理await代码中的错误 12345try &#123; version = await lookUpVersion();&#125; catch (e) &#123; // React to inability to look up the version&#125; 可以在异步功能中多次使用await。例如，以下代码等待三次函数结果： 123var entrypoint = await findEntrypoint();var exitCode = await runExecutable(entrypoint, args);await flushThenExit(exitCode); 异步函数的声明一个异步函数是由一个async修饰的函数体，将async关键字添加到函数使其返回Future。 未异步，函数返回的值是：String 1String lookUpVersion() =&gt; '1.0.0'; 变为异步，函数返回的值是：Future&lt;String&gt; 1Future&lt;String&gt; lookUpVersion() async =&gt; '1.0.0'; 如果函数没有返回有用的值，则设置其返回类型Future&lt;void&gt;。 流处理当您需要从Stream获取值时，您有2个选择： 使用async和异步for循环（await for）。 使用Stream API 异步for循环具有以下形式： 123await for (varOrType identifier in expression) &#123; // Executes each time the stream emits a value.&#125; 值expression必须具有Stream类型。执行过程如下： 等到流发出一个值。 执行for循环的主体，将变量设置为该发出的值。 重复1和2，直到关闭流。 要停止侦听流，可以使用 break 或者 return。 如果在实现异步for循环时遇到编译时错误，请确保await for它处于异步函数中。 例如，要在应用程序的main()函数中使用异步for循环，main()必须将正文标记为async： 1234567Future main() async &#123; // ... await for (var request in requestServer) &#123; handleRequest(request); &#125; // ...&#125; 生成器当需要懒惰地生成一系列值时，可以考虑使用生成器函数。Dart内置支持2种生成器函数： 同步生成器：返回Iterable对象。 异步生成器：返回Stream对象。 要实现同步生成器函数，请将函数体标记为sync*，并使用yield语句来传递值： 123456Iterable&lt;int&gt; naturalsTo(int n) sync* &#123; int k = 0; while (k &lt; n) yield k++;&#125;print(naturalsTo(5)); 结果为： 1(0, 1, 2, 3, 4) 要实现异步生成器函数，请将函数体标记为async*，并使用yield语句来传递值： 1234Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* &#123; int k = 0; while (k &lt; n) yield k++;&#125; 如果生成器是递归的，可以使用yield*来提高其性能： 12345678Iterable&lt;int&gt; naturalsDownFrom(int n) sync* &#123; if (n &gt; 0) &#123; yield n; yield* naturalsDownFrom(n - 1); &#125;&#125;print(naturalsDownFrom(5)); 结果为： 1(5, 4, 3, 2, 1) 可回调的类实现call()方法可以允许你的Dart类像函数一样被调用。 123456789// 实现 call()class WF&#123; call(String one, String two) =&gt; '$one, $two';&#125;// 未实现 call()class WF2&#123; String (var one, var two) =&gt; '$one, $two';&#125; 调用： 12345678var wf = WF();var out = wf('A','B');print(out);var wf2 = WF2();// 提示错误：wf2('A','B') 不是函数// var out2 = wf2('A','B');// print(out2); 结果为： 1A, B 隔离（线程） Isolate所有Dart代码都在隔离区内运行，而不是线程。每个隔离区都有自己的内存堆，确保不会从任何其他隔离区访问隔离区的状态。 使用隔离的并发编程：与线程类似但不共享内存的独立工作者，仅通过消息进行通信。 类型定义（Typedef）在Dart中，函数时对象，就像String、number都是对象。一个typedef或者函数别名，声明字段和返回类型时你可以使用给函数类型定义的一个名称。当函数类型分配给变量时，typedef会保留类型信息。 不使用typedef的情况下： 123456789101112131415class SC&#123; Function compare; SC(int f(Object a, Object b))&#123; compare = f; &#125;&#125;void main()&#123; int sort(Object a, Object b) =&gt; 0; SC sc = SC(sort); // 仅仅能够得出：sc.compare 是 Function // 不能够得出 sc.compare的类型 assert(sc.compare is Function);&#125; 使用 typedef： 123456789101112131415typedef Compare = int Function(Object a, Object b);class SC2&#123; Compare compare; SC2(this.compare);&#125;void main() &#123; int sort(Object a, Object b) =&gt; 0; SC2 sc2 = SC2(sort); assert(sc2.compare is Function); assert(sc2.compare is Compare);&#125; 注意： 目前，typedef仅限于函数类型。 因为typedef只是别名，所以提供了一种检查任何函数类型的方法。例如： 123456typedef Compare2&lt;T&gt; = int Function(T a, T b);void main() &#123; int sort(int a, int b) =&gt; a + b; assert(sort is Compare2&lt;int&gt;);&#125; 元数据元数据就是描述数据的数据，一个元数据注释由@字符开始。后跟对编译时常量（如deprecated）的引用或对常量构造函数的调用。所有Dart代码都有两个注释：@deprecated和 @override。 例子： 12345678910class Television &#123; /// _Deprecated: Use [turnOn] instead._ @deprecated void activate() &#123; turnOn(); &#125; /// Turns the TV's power on. void turnOn() &#123;...&#125;&#125; 您可以自定义元数据注释。这是一个定义带有两个参数的@todo注释的示例： 1234567class Todo &#123; final String who; final String what; // 常量构造函数 const Todo(this.who, this.what);&#125; 调用： 1234void main()&#123; @Todo('Bob', 'ouput a thing') void doSOmething() =&gt; print('dod something');&#125; 结果: 1dod something 元数据可以出现在库、类、typedef、类型参数、构造函数、工厂、函数、字段、参数或变量声明之前以及导入或导出指令之前。可以使用反射在运行时检索元数据。]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart-Tour2-类]]></title>
    <url>%2FDart-Tour2-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类 Dart语法样式： https://www.dartlang.org/guides/language/effective-dart/style语法：https://www.dartlang.org/guides/language/language-tour 概览 重要概念 关键词 注释 变量 内置类型 函数 操作符 流程 异常 类 泛型 库 异步 发电机 可调用的类 分离 类型定义 元数据 类Dart是一种具有类和基于mixin的继承的面向对象语言。每个对象都是一个类的实例，所有类都来自Object。基于Mixin的继承意味着虽然每个类（除了Object）只有一个超类，但是类体可以在多个类层次结构中重用。 特点：当最左边的操作数为null时，使用?.而不是.避免异常： 构造函数12345678910111213141516class Point&#123; num x,y; /* // 原始写法 Point(num x, num y)&#123; // 该this关键字是指当前实例。 this.x = x; this.y = y; &#125;*/ // 使用Dart语法糖 // 在构造体运行之前，为x，y设置语法糖。 Point(this.x, this.y); &#125; 默认构造函数如果未声明构造函数，则会为您提供默认构造函数。默认构造函数没有参数，并在超类中调用无参数构造函数。 构造函数不是继承的子类不从其超类继承构造函数。没有声明构造函数的子类只有默认（无参数，无名称）构造函数。 命名构造函数（多构造函数）12345678// 命名构造函数:originPoint.origin()&#123;x = 8;y = 9;&#125;// 命名构造函数:withValPoint.withVal(this.x, this.y); 注意：构造函数不是继承的，这意味着超类的命名构造函数不会被子类继承。如果希望使用超类中定义的命名构造函数创建子类，则必须在子类中实现该构造函数。 一个完整的多构造函数写法： 123456789101112131415161718192021222324252627class Point&#123; num x,y; /* // 原始写法 Point(num x, num y)&#123; // 该this关键字是指当前实例。 this.x = x; this.y = y; &#125;*/ // 使用Dart语法糖 // 在构造体运行之前，为x，y设置语法糖。 Point(this.x, this.y); // 命名构造函数:origin Point.origin()&#123; x = 8; y = 9; &#125; // 命名构造函数:withVal Point.withVal(this.x, this.y);&#125; 调用 1234567891011121314void classAboutMethod()&#123; var pointOrigin = Point(34,67); print(pointOrigin.x); print(pointOrigin.y); var pointAbout = Point.origin(); print(pointAbout.x); print(pointAbout.y); var pointAboutVal = Point.withVal(11, 21); print(pointAboutVal.x); print(pointAboutVal.y);&#125; 结果为： 1234563467891121 调用非默认的超类构造函数执行顺序如下： 初始化列表 超类的无参数构造函数 主类的无参数构造函数 初始化列表重定向构造函数有时构造函数的唯一目的是重定向到同一个类中的另一个构造函数。重定向构造函数的主体是空的，构造函数调用出现在冒号（:)之后。 123456789class Point&#123; num x,y; Point(this.x, this.y); Point.alongX(num x) : this(x,0);&#125; 调用： 123var pointAlongX = Point.alongX(11);print(pointAlongX.x);print(pointAlongX.y); 结果为： 12110 常量构造函数如果你想使你的类生成永远不会更改的对象，则可以使这些对象成为编译时常量。为此，请 定义 const构造函数并 确保 所有实例变量都是final。 1234567class ImmutablePoint &#123; static final ImmutablePoint origin = const ImmutablePoint(0, 0); final num x, y; const ImmutablePoint(this.x, this.y);&#125; 工厂建设者在不需要总是创建新的实例的情况下可以使用 factory 关键字，例如下面这个例子表示：从缓存中返回对象的构造函数： 注意：工厂构造函数无权访问this。 123456789101112131415161718class Point&#123; num x,y; Point.alongX(num x) : this(x,0); static final Map&lt;String, Point&gt; _cache = Map&lt;String, Point&gt;&#123;&#125;; factory Point.name(String name)&#123; if (_cache.containsKey(name)) &#123; return _cache[name]; &#125;else &#123; final point = Point.alongX(9); _cache[name] = point; return point; &#125; &#125;&#125; 调用: 1234567var pointName = Point.name('Alice');var pointName2 = Point.name('Alice');var pointName3 = Point.name('Bob');print(pointName.hashCode);print(pointName2.hashCode);print(pointName3.hashCode);assert(pointName == pointName2); 结果： 123477440163477440163461006651 使用class成员 使用 . 来引用实例变量或方法 123var pointOrigin = Point(34,67);print(pointOrigin.x);print(pointOrigin.y); 当最左边的操作数为null时，使用 ?. 而不是 . 避免异常： 123456789// 如果pointAbout不为空，那么设置x = 4；pointAbout?.x = 4;print('pointAbout.x is $&#123;pointAbout.x&#125;');// 结果：pointAbout.x is 4pointAbout = null;pointAbout?.x = 4;//print('pointAbout.x is $&#123;pointAbout.x&#125;');// 结果：抛出异常 使用构造函数一般情况1234567var pointOrigin = Point(34,67);print(pointOrigin.x);print(pointOrigin.y);var pointAbout = Point.origin();print(pointAbout.x);print(pointAbout.y); 注意：在Dart2中，new是可选关键字。 常量构造函数有些类提供常量构造函数。要使用常量构造函数创建编译时常量，请将const关键字放在构造函数名称之前： 1var p = const ImmutablePoint(2, 2); 如果构造2个相同的编译时常量，那么结果是：产生同一个规范的实例： 1234var a = const ImmutablePoint(1, 1);var b = const ImmutablePoint(1, 1);assert(identical(a, b)); // They are the same instance! 在常量上下文中，您可以省略const构造函数或文字之前的内容。例如，查看此代码，该代码创建一个const映射： 1234const pointAndLine = const &#123; 'point': const [const ImmutablePoint(0, 0)], 'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],&#125;; 那么，除了第一次出现的const外其他所有的const关键字都可以省略。简写为： 12345// Only one const, which establishes the constant context.const pointAndLine = &#123; 'point': [ImmutablePoint(0, 0)], 'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],&#125;; 如果常量构造函数在常量上下文之外并且在没有const的情况下调用，则会创建一个非常量对象： 1234var a = const ImmutablePoint(1, 1); // Creates a constantvar b = ImmutablePoint(1, 1); // Does NOT create a constantassert(!identical(a, b)); // NOT the same instance! 获取对象的类型要在运行时获取对象的类型，可以使用Object的runtimeType属性，该属性返回一个Type对象。 12var pointAboutVal = Point.withVal(11, 21);print('the type of pointAboutVal is $&#123;pointAboutVal.runtimeType&#125;'); 结果为： 1the type of pointAboutVal is Point 实例变量以下是 声明 实例变量的方法： 12345class Point &#123; num x; // Declare instance variable x, initially null. num y; // Declare y, initially null. num z = 0; // Declare z, initially 0.&#125; 所有未初始化的实例变量都具有该值null。 所有实例变量都生成一个隐式getter方法。非final实例变量也会生成隐式setter方法。有关详细信息，请参阅Getters和setter。 1234567891011class Point &#123; num x; num y;&#125;void main() &#123; var point = Point(); point.x = 4; // Use the setter method for x. assert(point.x == 4); // Use the getter method for x. assert(point.y == null); // Values default to null.&#125; 如果初始化声明它的实例变量（而不是构造函数或方法），则在创建实例时设置该值，该实例在构造函数及其初始化列表执行之前。 方法方法是为对象提供行为的函数。 实例方法对象的实例方法可以访问实例变量和this。 getters and setters抽象方法实例、getter和setter方法可以是抽象的，定义一个接口，但将其实现留给其他类。抽象方法只能存在于抽象类中。 1234567891011abstract class Doer &#123; // Define instance variables and methods... void doSomething(); // Define an abstract method.&#125;class EffectiveDoer extends Doer &#123; void doSomething() &#123; // Provide an implementation, so the method is not abstract here... &#125;&#125; 抽象类（abstract）使用abstract修饰符定义抽象类 - 无法实例化的类。抽象类对于定义接口非常有用，通常还有一些实现。如果希望抽象类看起来是可实例化的，请定义工厂构造函数。 12345abstract class Doer &#123; // Define instance variables and methods... void doSomething(); // Define an abstract method.&#125; Dart 与 Java 关于 抽象类 的区别： Dart：由abstract关键字修饰的类就是抽象类，由关键字决定。 Java：只要一个类中有未实现的方法，这个方法就是抽象类，由方法决定。 隐式接口（interfaces） 每个类隐式的定义了一个接口，含有类的所有实例和它实现的所有接口。如果你想创建一个支持类 B 的 API 的类 A，但又不想继承类 B ，那么，类 A 应该实现类 B 的接口。 一个类实现一个或更多接口通过用 implements 子句声明，然后提供 API 接口要求。例如 12345678910111213141516171819202122232425// A person. The implicit interface contains greet().class Person &#123; // In the interface, but visible only in this library. final _name; // Not in the interface, since this is a constructor. Person(this._name); // In the interface. String greet(String who) =&gt; 'Hello, $who. I am $_name.';&#125;// An implementation of the Person interface.class Impostor implements Person &#123; get _name =&gt; ''; String greet(String who) =&gt; 'Hi $who. Do you know who I am?';&#125;String greetBob(Person person) =&gt; person.greet('Bob');void main() &#123; print(greetBob(Person('Kathy'))); print(greetBob(Impostor()));&#125; 这里是具体说明一个类实现多个接口的例子： 123class Point implements Comparable, Location &#123; // ... &#125; 特点：这里的interface接口和java不同在于：不需要定义interface，任何class都可以被implements 继承类（extends）同Java 重写成员（@override）同Java 注意：要在类型安全的代码中缩小 方法参数 或 实例变量 的 类型，可以使用covariant关键字。 例子： 123456789class Animal &#123; void chase(Animal x) &#123; ... &#125;&#125;class Mouse extends Animal &#123; ... &#125;class Cat extends Animal &#123; void chase(covariant Mouse x) &#123; ... &#125;&#125; 虽然此示例显示covariant在子类型中使用，但covariant关键字可以放在超类或子类方法中。通常，超类方法是放置它的最佳位置。该covariant关键字适用于单个参数，并且在setter和字段上也受支持。 重写操作符您可以覆盖下表中显示的运算符。 说明：表达e1 != e2是!(e1 == e2)的语法糖。 一个覆盖+和-运算符的类的示例： 123456789101112131415161718class Vector&#123; final x,y; Vector(this.x, this.y); Vector operator +(Vector v) =&gt; Vector(x + v.x,y + v.y); Vector operator -(Vector v) =&gt; Vector(x - v.x,y - v.y); &#125;final v = Vector(2,2);print('x is $&#123;v.x&#125;, y is $&#123;v.y&#125;');final w = Vector(4,5);print('x is $&#123;w.x&#125;, y is $&#123;w.y&#125;');var vw = v + w;print('x is $&#123;vw.x&#125;, y is $&#123;vw.y&#125;'); 结果为： 123x is 2, y is 2x is 4, y is 5x is 6, y is 7 noSuchMethod()可以通过重写noSuchMethod()可以发现或者对在代码中尝试使用不存在的方法或者实例变量作出反应。 123456789class A &#123; // Unless you override noSuchMethod, using a // non-existent member results in a NoSuchMethodError. @override void noSuchMethod(Invocation invocation) &#123; print('You tried to use a non-existent member: ' + '$&#123;invocation.memberName&#125;'); &#125;&#125; 你不能调用未实现的方法，除非以下一个是真实的： 接收器具有静态类型dynamic。 接收器有一个静态类型，它定义了未实现的方法（抽象是OK），接收器的动态类型的实现与类noSuchMethod() 中的实现不同Object。 枚举类型枚举类型（通常称为枚举或枚举）是一种特殊类，用于表示固定数量的常量值。 使用enum关键字声明枚举类型： 1enum Color &#123; red, green, black &#125; 枚举中的每个值都有一个index，从0开始。如: 1assert(Color.black.index == 2); 要获取枚举中所有值的列表，请使用枚举values常量。如： 1234List&lt;Color&gt; colors = Color.values;for (var x in colors) &#123; print('当前的索引为： $&#123;x.index&#125; ,对应着的值为：$&#123;x&#125;');&#125; 结果为： 123当前的索引为： 0 ,对应着的值为：Color.red当前的索引为： 1 ,对应着的值为：Color.blue当前的索引为： 2 ,对应着的值为：Color.black switch用法 12345678910111213void doSwitch() &#123; var colorSingel = Color.black; switch (colorSingel) &#123; case Color.black: break; case Color.blue: break; case Color.red: break; default: print(''); &#125;&#125; 向类添加功能：mixinmixins是一种在多个类层次结构中重用类代码的方法。可以简单的理解为： mixin修饰的类中定义了多个类中公用的变量和方法。 mix是混合的意思；in是在……里面。那么mixin可以理解为：可以混合在指定类里面的公用代码块。用mixin关键字代替class关键字来实现一个可扩展的Object类，且无需声明构造函数 ： mixin本身可以是抽象的，可以定义各种方法属性，也可以是抽象的，等后续类去实现。 mixin使用要使用 mixin，请使用with关键字后跟一个或多个 mixin关键字修饰的类。以下示例显示了使用有mixins修饰的类： 1234567891011121314151617181920mixin TestMixin &#123; void test() &#123; print('test'); &#125; int testInt = 1; void test2();&#125;class Test with TestMixin &#123; @override test2() &#123; print('test2'); &#125;&#125;void main() &#123; Test().test(); // test print(Test().testInt); // 1 Test().test2(); // test2&#125; 注意：mixin 是 Dart 2.1中引入的对关键字的支持。 mixin与on关键字：要指定只有某些类型可以使用mixin——使用on来指定所需的超类，这样你的mixin可以调用一个它自身没有定义的方法： 1234567891011121314151617181920212223class BaseObject &#123; void method() &#123; print(&apos;call method&apos;); &#125;&#125;mixin TestMixin on BaseObject&#123; void test() &#123; print(&apos;test&apos;); &#125; int testInt = 1; void test2() &#123; method(); &#125;&#125;class Test extends BaseObject with TestMixin &#123;&#125;void main() &#123; Test().test(); // test print(Test().testInt); // 1 Test().test2(); // call method&#125; 当使用on关键字后，则表示该mixin修饰的类只能在那个类的子类使用了。 多个mixin123456789101112131415161718192021222324252627282930313233343536373839404142mixin TestMixin1 on BaseContext&#123; var intValue = 1; void mix1() =&gt; print(&apos;this is from textMixin1&apos;); void printAnother() =&gt; sayHello();&#125;mixin TestMixin2 on BaseContext&#123; var intValue = 2; void mix2() =&gt; print(&apos;this is from testMixin2&apos;); void printBye() =&gt; sayGoodbye();&#125;class BaseContext&#123; void sayHello() =&gt; print(&quot;BaseContext say hello&quot;); void sayGoodbye() =&gt; print(&apos;BaseContext say byebye&apos;);&#125;class TestClass extends BaseContext with TestMixin1,TestMixin2&#123; @override void mix2() &#123; // TODO: implement mix2 super.mix2(); print(&apos;this msg is from TestClass!&apos;); &#125;&#125;void main()&#123; TestClass().mix2(); // this is from testMixin2 this msg is from TestClass! TestClass().mix1(); // this is from textMixin1 TestClass().sayGoodbye(); // BaseContext say byebye TestClass().printAnother(); // BaseContext say hello TestClass().printBye(); // BaseContext say byebye print(TestClass().intValue); // 2&#125; 在TestMixin1与TestMixin2中都声明了一个intValue变量，但是值不同。在class TestClass extends BaseContext with TestMixin1,TestMixin2的顺序中，得到的结果是： 12 即：TestMixin2 中初始化的值。 那么改变一下with的顺序呢？class TestClass extends BaseContext with TestMixin2,TestMixin1，结果是： 11 由此可见：取值的是最后一个with的类中的值。 类变量和方法使用static关键字实现类范围的变量和方法。 静态变量静态变量（类变量）对于类范围的状态和常量很有用： 12345678class Queue &#123; static const initialCapacity = 16; // ···&#125;void main() &#123; assert(Queue.initialCapacity == 16);&#125; 注意： 静态变量在使用之前不会初始化。 遵循样式指南建议，优先使用lowerCamelCase作为常量名称。 静态方法12345678910class Point &#123; num x, y; Point(this.x, this.y); static num distanceBetween(Point a, Point b) &#123; var dx = a.x - b.x; var dy = a.y - b.y; return sqrt(dx * dx + dy * dy); &#125;&#125; 注意： 对于常用或广泛使用的实用程序和功能，请考虑使用顶级函数而不是静态方法。 您可以使用静态方法作为编译时常量。例如，您可以将静态方法作为参数传递给常量构造函数。]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart-Tour]]></title>
    <url>%2FDart-Tour%2F</url>
    <content type="text"><![CDATA[Dart-Tour Dart语法样式： https://www.dartlang.org/guides/language/effective-dart/style语法：https://www.dartlang.org/guides/language/language-tour 概览 重要概念 关键词 注释 变量 内置类型 函数 操作符 流程 异常 类 泛型 库 异步 发电机 可调用的类 分离 类型定义 元数据 一个基本程序12345678910// Define a function.printInteger(int aNumber) &#123; print('The number is $aNumber.'); // Print to console.&#125;// This is where the app starts executing.main() &#123; var number = 42; // Declare and initialize a variable. printInteger(number); // Call a function.&#125; main() 函数每个应用程序都必须具有 顶级main() 功能，该功能用作 应用程序 的 入口 点。 Dart重要概念 Dart是一门 面向对象 的语言，Object 是所有类的父类。Dart中每个变量都引用一个对象（一个类的实例），每个内置类型都有自己的构造函数。 尽管Dart是强类型语言 ，但 类型说明 是可选的，因为Dart可以推断类型。 Dart 支持 泛型类型 Dart 支持 顶级函数 Dart 支持 顶级变量，以及绑定到类或对象的变量（静态和实例变量）。实例变量有时称为字段或属性。 与 Java 相比 Dart 不具备关键字 public，protected 和 private。如果标识符以下划线 _ 开头，则它对其库是私有的。 标识符可以以 字母 或 下划线 _开头，后跟这些字符加数字的任意组合。 Dart 关键词 注释 https://www.dartlang.org/guides/language/language-tour#comments Dart 代码注释 和文档注释。 代码注释： 单行注释： // 多行注释： /* */ 文档注释： 单行注释： /// 多行注释： /** 变量声明并初始化 隐式声明并初始化 1var name = 'Bob'; 变量存储引用。调用的变量name包含对String值为“Bob” 的对象的引用。此种方式声明的变量可以通过推断类型来推断name是String类型。 显示声明 显式声明可以推断出的类型： 1String name = 'Bob'; 非单一类型声明方式 如果对象不限于单一类型，dynamic类型 。 1dynamic name = 'Bob'; 默认值 null未初始化的变量的初始值为null。Dart是面向对象语言。 12345String na;int naCount;assert(na == null);assert(naCount == null); final 和 常量（const）如果从不打算更改变量，使用 final 或者 const 代替 var 或者 显示类型。最终变量只能设置一次。 注意：实例变量可以是final但不能是const； final变量的创建 1234final name = 'Bob';final String name = 'Bob';// name 再次被赋值时提示异常name = 'Alice'; const 使用const关键字可以将一个变量声明为编译时常量(基本数据类型及其简单操作)。声明常数变量： 1234const bar = 1000;// bar 再次被赋值时提示异常bar = 2000;const atm = bar * 2; 创建常量值： 1234567// 1var foo = const[];// 2final bar1 = const[];// 3// const bar2 = [] 相当于 const bar2 = const[]const bar2 = []; 注意： 可以忽略声明const初始化表达式，就像：const bar2 = [] 可以更改非final 与 非const 变量的值（非const初始化表达式）。如： 123456// 正常foo = [1,2,3];// 异常，无法赋值bar1 = [1,2,3];// 异常，无法赋值bar2 = [1,2,3]; Dart 内置类型 数字（Numbers） 字符串（Strings） 布尔（Booleans） List（也称为数组）Lists (also known as arrays) Map集合（Maps） 符文（用于表示字符串中的Unicode字符）Runes (for expressing Unicode characters in a string) 符号（Symbols） 可以使用文字初始化这些特殊类型的对象，因为Dart中的每一个变量都引用一个对象（一个类的实例），而每一个类都有自己的构造函数，所以可以通过构造函数来初始化变量。 数字（Numbers）Dart中有2中形式的Number int double int和double是num的子类，包括基本的运算符以及几个常用方法。 int整数值不大于64位，具体取决于平台：在Dart VM上，值可以是-2 63到2 63 - 1.编译为JavaScript的Dart使用 JavaScript编号， 允许从-2 53到2 53 - 1的值。 12var x2 = 1;var xx = 0XAC; 结果为 121172 double64位（双精度）浮点数，由IEEE 754标准规定。 1234var y = 1.1;double yy = 1.2;// Dart 2.1之后，相当于：double z = 1.0。 double yy2 = 1; 结果为 1231.11.21.0 String与Number之间的转换123456789101112131415161718// String -&gt; intvar one = int.parse('2');assert(one == 2);// Stirng -&gt; doublevar two = double.parse('2.2');assert(two == 2.2);// int -&gt; Stringvar one2 = 2.toString();assert(one2 == '2');// double -&gt; Stringvar two2 = 2.2.toString();assert(two2 == '2.2');var two3 = 2.2123.toStringAsFixed(3);assert(two3 == '2.212'); 字符串（Strings）Dart字符串是一系列UTF-16代码单元（code units）。您可以使用单引号或双引号来创建字符串： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ''var str1 = 'Single Str';print(str1);// ""var strInclude = "Double Str 'Single Str' ";print(strInclude);// ''' '''var strThreeLines = '''Amultilinestring''';print(strThreeLines);// """ """var strThreeLinesDouble = """Doublemultilinestring""";print(strThreeLinesDouble);//'==' 表示的是测试两个对象是否相等。如果这两个对象包含相等的代码单元序列，则表示他们是相等的。assert(strThreeLines == strThreeLinesDouble);// 截取print(str1.hashCode);var strSub = str1.substring(0,5);print(str1.hashCode);print(str1);print(strSub.hashCode);print(strSub);// 拼接var strAdd = strSub + " + " + strInclude;print(strAdd);// $&#123;&#125;var strWith = '$&#123;str1 + strSub&#125; has $&#123;str1.length + strSub.length&#125; letters';print(strWith);var strWith2 = " '$str1' has $&#123;str1.length&#125; letters";print(strWith2);// 字符串由可通过codeUnitAt或codeUnits成员访问的Unicode UTF-16代码单元序列表示var strCode = 'Dart';print(strCode.codeUnitAt(0));print(strCode.codeUnits);print(strCode[0] + " + " + strCode[1] + " + " + strCode[2] + " + " + strCode[3]);// 字符串的字符以UTF-16编码,'rune'表示Unicode代码点的整数。使用runes属性获取字符串的符文// StringBuffer 用于有效连接字符串的类StringBuffer strBuffer = new StringBuffer("temp buffer");strBuffer.write(" " + str1);print(strBuffer);// 使用 r 创建原始Stringvar rRaw = r'In a raw string, not even \n gets special treatment.';print(rRaw);// 可以作为一个常量字符串使用const aConstNum = 0;const aConstBool = true;const aConstString = 'a constant string';const validConstString = '$aConstNum $aConstBool $aConstString';print(validConstString);// 不能作为一个常量字符串使用var aNum = 0;var aBool = true;var aString = 'a string';const aConstList = [1, 2, 3]; //const validConstString2 = '$aNum $aBool $aString';//print(validConstString2); 结果为： 12345678910111213141516171819202122Single StrDouble Str &apos;Single Str&apos; AmultilinestringAmultilinestring378132249378132249Single Str576223980SinglSingl + Double Str &apos;Single Str&apos; Single StrSingl has 15 letters &apos;Single Str&apos; has 10 letters68[68, 97, 114, 116]D + a + r + ttemp buffer Single StrIn a raw string, not even \n gets special treatment.0 true a constant string 布尔（Booleans）Dart通过bool类型表示布尔值，只有2种布尔类型：字面量true和false，2者均是编译时常量。 Dart语言的类型安全意味着你不需要使用像是if (nonbooleanValue) 或者assert (nonbooleanValue)这样的代码，相反的，而是可以通过以下方式明确的检查数值 12345678910111213var fullName = "";assert(fullName.isEmpty);var zeroVal = 0;assert(zeroVal &lt;= 0);var nullVal;assert(nullVal == null);var nanVal = 0/0;// 结果为 ：NaNprint(nanVal);assert(nanVal.isNaN); Lists（也称为数组）Dart中，数组式List对象。注意： 1分析推断list的类型 List&lt;int&gt; ,如果尝试将非整数对象添加到此列表，则分析器或运行时会引发错误。 示例： 123456List listVal = [1,2,3];print(listVal.length);listVal.add(4);for (var i = 0; i &lt; listVal.length; i++ ) &#123; print(listVal[i]);&#125; 结果： 1234531234 可以通过一下const方式创建编译时List： 123var listConst = const['A','B','C','D'];// Cannot add to an unmodifiable list//listConst.add('E'); Map集合（Maps）示例 12345// Mapvar maps = &#123;'first': 1, 'second':2, 'third':3&#125;;// 添加元素maps['fourth'] = 4;print(maps.length); 可以通过以下const方式创建编译时map: 123var mapsConst = const&#123;1:'one',2:'two',3:'three'&#125;;//Cannot set value in unmodifiable Map//mapsConst[1] = 'first'; 符文（Runes）在Dart中，符文是字符串的UTF-32代码点。Unicode为世界上所有书写系统中使用的每个字母，数字和符号定义唯一的数值。由于Dart字符串是一系列UTF-16代码单元，因此在字符串中表示32位Unicode值需要特殊语法。 符号（Symbols）符号的字面量是编译时常量 函数 （Function）Dart是一种真正面向对象的语言，即使是函数也是有类型的对象， 这就意味着函数本身可以赋值给变量或者作为其他函数的参数。您也可以像调用函数一样调用Dart类的实例。 写法 示例1：带有函数类型 123bool isTwo(atomicNum)&#123;return atomicNum == 2;&#125; 调用： 1print(isTwo(2)); 结果为： 1true 示例2：无函数类型 123isThree(atomicNum)&#123; return atomicNum == 3;&#125; 示例3：对函数体只有一行表达式的情况下，写法简化为： 1isFour(atomicNum) =&gt; atomicNum == 4; 参数Dart中的函数可以有2种类型的参数： 必需参数（required parameters） 可选参数（Optional parameters） 声明时：首先列出所需参数，然后列出任何可选参数。 命名可选参数可以通过@required进行标记。 可选参数 （Optional parameters）可选参数可以是命名也可以是位置参数，但是两者不能同时存在。 可选命名参数 -（{}）调用函数时，可以使用指定命名参数，例如：paramName : value 12345678910enableFlagsSecond(String one, &#123;bold, hidden&#125;)&#123; print('one param val is $one'); if (bold == true) &#123; print('bold is true'); &#125; if (hidden == true) &#123; print('hidden is true'); &#125; &#125; 或者声明为： 12345678910enableFlagsSecond(String one, &#123;bool bold, bool hidden&#125;)&#123; print('one param val is $one'); if (bold == true) &#123; print('bold is true'); &#125; if (hidden == true) &#123; print('hidden is true'); &#125; &#125; 调用函数： 123enableFlags('ONE',bold: true, hidden: false);enableFlags('ONE',hidden: true);enableFlagsSecond('ONE'); 结果为： 12345one param val is ONEbold is trueone param val is ONEhidden is trueone param val is ONE 注意： Flutter实例创建表达式可能变得复杂，因此窗口小部件构造函数仅使用命名参数。这使得实例创建表达式更易于阅读。 此外，可以使用@required在任何Dart代码（不仅仅是Flutter）中注释命名参数， 以指示它是必需参数。例如： 可选位置参数 -（[]）函数声明： 1234567String say(String from, String msg, [String device]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; return result;&#125; 调用 12assert(say('Bob', 'Howdy') == 'Bob says Howdy');assert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal'); 默认参数值（{=}）/（[=]）注意：默认参数的值，仅能是编译时常量。 可以通过 = 来为可选命名参数和可选位置参数两者来设置参数默认值，例如： 12345678910enableFlagsFourth(String one, &#123;bool bold = false, bool hidden = true&#125;)&#123; print('one param val is $one'); if (bold == true) &#123; print('bold is true'); &#125; if (hidden == true) &#123; print('hidden is true'); &#125; &#125; 调用: 1enableFlagsFourth('ONE'); 结果为： 12one param val is ONEhidden is true 同时，可以在 List 和 Map 的初始化的值的前面添加 const 关键字来设置默认值： 12345678void doStuff(&#123; List&lt;int&gt; list = const [1,2,3], Map&lt;String, String&gt; maps = const&#123;'first':'A', 'second':'B', 'Thread':'C' &#125;&#125;)&#123; print('list is $list'); print('maps is $maps');&#125; 调用： 1doStuff(); 结果为： 12list is [1, 2, 3]maps is &#123;first: A, second: B, Thread: C&#125; 弃用注意： 在Dart 的早期版本中，曾使用过 : 来为参数设置默认值 ，但是在新版的Dart中已经通过=来替代:为参数设置默认值。 main()每个应用程序都必须具有顶级main()功能，该功能用作应用程序的入口点。main()函数返回void并具有List参数的可选参数。 将函数作为第一类对象您可以将函数作为参数传递给另一个函数。例如： 1234567void printElement(String element)&#123; print(element);&#125;var listVal2 = ['One','Two','Three'];listVal2.forEach(printElement); 匿名函数（Anonymous functions）没有函数名称的函数。例如： 123456789101112131415161718var loudify = (msg) =&gt; '$&#123;msg.toUpperCase()&#125;';print(loudify('hhhh'));// 结果：HHHHvar listVal2 = ['One1','Two2','Three3'];listVal2.forEach((item)&#123; print('$&#123;listVal2.indexOf(item)&#125;: $item');&#125;);listVal2.forEach((item) =&gt; print("$&#123;listVal2.indexOf(item)&#125;: $item"));// 结果为：0: One11: Two22: Three30: One11: Two22: Three3 词汇范围（作用域）123456789101112131415161718bool topLevel = true;void main() &#123; var insideMain = true; void myFunction() &#123; var insideFunction = true; void nestedFunction() &#123; var insideNestedFunction = true; assert(topLevel); assert(insideMain); assert(insideFunction); assert(insideNestedFunction); &#125; &#125;&#125; 词汇闭包 闭包：https://www.cnblogs.com/jingwhale/p/4574792.html 简单的说，闭包（closure）就是能够读取其他函数内部变量的函数。同时，可以理解为：“定义在一个函数内部的函数”。所以在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的好处： 希望一个变量长期驻扎在内存当中； 避免全局变量的污染； 私有成员的存在 例子： 123Function makeAdder(num addBy)&#123; return (num i) =&gt; addBy + i;&#125; 调用 123456789101112var add1 = makeAdder(0);// 1print(add1(1));var add2 = makeAdder(2);print(add2);assert(add2(3) == 5);var add4 = makeAdder(4);print(add4);// 5print(add2(3)); 结果： 12341Closure: (num) =&gt; numClosure: (num) =&gt; num5 测试方法是否相等12345678910111213141516171819202122232425262728293031void foo()&#123;&#125;class A&#123; static bar()&#123;&#125; void baz()&#123;&#125;&#125;void main(List&lt;String&gt; args) &#123; var x; print('x hashCode is $&#123;x.hashCode&#125;'); print('foo hashCode is $&#123;foo.hashCode&#125;'); x = foo; print('x hashCode is $&#123;x.hashCode&#125;'); print('foo hashCode is $&#123;foo.hashCode&#125;'); assert(x == foo); x = A.bar(); print('A.bar() hashcode is $&#123;A.bar().hashCode&#125;'); print('x hashCode is $&#123;x.hashCode&#125;'); assert(x == A.bar()); var v = A(); // Instance #1 of A var w = A(); // Instance #2 of A print('v hashCode is $&#123;v.hashCode&#125;'); print('w hashCode is $&#123;w.hashCode&#125;');&#125; 结果为: 12345678x hashCode is 2011foo hashCode is 223675968x hashCode is 223675968foo hashCode is 223675968A.bar() hashcode is 2011x hashCode is 2011v hashCode is 261340588w hashCode is 87310029 返回值每个函数均有返回值，如果未指定返回值，则将会返回null。 12foo() &#123;&#125;assert(foo() == null); 操作符 在以上这张运算符表中，每个运算符的优先级是高于其后一行中的运算符的，即：前一行中的运算符高于后一的运算符。 算术运算符 常用算术运算符 操作示例 12345print(5/2);print(5~/2);print(4/2);print(4~/2);print(5%2); 结果为： 123452.522.021 前缀与后缀的增加与减量运算符 示例： 12345678var a,b;a = 10;b = ++a;print(b);b = a--;print(b);print(a); 结果为: 123111110 相等和关系运算符 要测试两个对象x和y是否表示相同的事物，使用 == 运算符。在极少数情况下，你需要知道是否两个对象是否是完全相同的，那么使用 identical()。 类型检查运算符12345678910111213class AA&#123; var name;&#125;var aaVal = new AA();if (aaVal is AA) &#123; aaVal.name = 'Alice';&#125;print(aaVal);print(aaVal.name);print((aaVal as AA).name = 'Alice'); 结果为: 123Instance of &apos;AA&apos;AliceAlice 注意：如果aaVal为null或者aaVal 不是 AA 则is：不会产生任何异常。 则as：抛出异常。 分配（复合赋值）操作符??=操作符： 如果当前变量assignValB是null，那么 assignValB ??= &#39;assignValB new value DDDD&#39;就相当于是assignValB == &#39;assignValB new value DDDD&#39;； 如果当前变量assignValB不是null，那么 assignValB = &#39;BBBB&#39;； 示例: 1234567891011var assignValA = 'AAA';var assignValB = 'BBBB';assignValA = 'assignValA new value CCCC ';assignValB ??= 'assignValB new value DDDD';print(assignValA);print(assignValB);print('now assignValB is null');assignValB = null;assignValB ??= 'assignValB new value DDDD';print(assignValB); 结果为: 1234assignValA new value CCCC BBBBnow assignValB is nullassignValB new value DDDD 复合赋值运算符 复合赋值工作原理 逻辑运算符 按位和移位运算符 条件表达式通过2个运算符，可以简明地计算可能需要if-else语句的表达式： 1condition ? expr1 : expr2 即：如果condition为true，则计算expr1（并返回其值）; 否则，计算并返回expr2的值。 1expr1 ?? expr2 即：如果expr1为非null，则返回其值; 否则，计算并返回expr2的值。例如： 1234567891011121314151617String newName(String name) =&gt; name ?? 'Alice';String newName1(String name1) =&gt; name1 == null ? 'Alice' : name1;String newName2(String name2)&#123; if (name2 == null) &#123; return 'Alice'; &#125;else &#123; return name2; &#125;&#125;print(newName(null));print(newName1(null));print(newName2(null)); print(newName('BobBob'));print(newName1('BobBob'));print(newName2('BobBob')); 结果为： 123456AliceAliceAliceBobBobBobBobBobBob 级联符号（..）允许您对同一对象进行一系列操作。除了函数调用，您还可以访问同一对象上的字段。这通常可以为您节省创建临时变量的步骤，并允许您编写更流畅的代码。 示例： 1234querySelector('#confirm') // Get an object. ..text = 'Confirm' // Use its members. ..classes.add('important') ..onClick.listen((e) =&gt; window.alert('Confirmed!')); 第一个方法调用后，querySelector()返回一个选择器对象。级联表示法后面的代码对此选择器对象进行操作，忽略可能返回的任何后续值。 上面的实例相当于： 1234var button = querySelector('#confirm');button.text = 'Confirm';button.classes.add('important');button.onClick.listen((e) =&gt; window.alert('Confirmed!')); 级联之间的嵌套： 12345678final addressBook = (AddressBookBuilder() ..name = 'jenny' ..email = 'jenny@example.com' ..phone = (PhoneNumberBuilder() ..number = '415-555-0100' ..label = 'home') .build()) .build(); 小心在返回实际对象的函数上构造级联。例如，以下代码失败： 123var sb = StringBuffer();sb.write('foo') ..write('bar'); // Error: method 'write' isn't defined for 'void'. 该sb.write()调用后返回void，因此你不能在void之上构造上级联。 注意： 严格来说，级联的“双点”符号不是运算符。它只是Dart语法的一部分。 其他操作符 控制流程可以使用以下任一方法控制Dart代码的流程： if 和 else for 循环 while和do- while循环 break 和 continue switch 和 case assert if elsefor 循环123456789101112131415161718var msg = StringBuffer('Dart is fun');for (var i = 0; i &lt; 5; i++) &#123; msg.write('!');&#125;print(msg);var listVal = [];for (var i = 0; i &lt; 5; i++) &#123; listVal.add(() =&gt; print(i));&#125;listVal.forEach((item) =&gt; item());var listVal2 = [11,22,33];for (var x in listVal2) &#123; print(x); &#125; 结果为： 123456789Dart is fun!!!!!01234112233 while、do-whilebreak、continue 使用break停止循环： 使用continue跳到下一个循环迭代： switchDart中的switch语句通过使用==来比较整数，字符串或编译时常量。比较对象必须都是同一个类的实例（而不是其任何子类型的实例），并且该类不能覆盖==。 示例1： 1234567891011121314151617181920var command = 'OPEN';switch (command) &#123; case 'CLOSED': executeClosed(); break; case 'PENDING': executePending(); break; case 'APPROVED': executeApproved(); break; case 'DENIED': executeDenied(); break; case 'OPEN': executeOpen(); break; default: executeUnknown();&#125; 示例2： 12345678var command = 'CLOSED';switch (command) &#123; case 'CLOSED': // Empty case falls through. case 'NOW_CLOSED': // Runs for both CLOSED and NOW_CLOSED. executeNowClosed(); break;&#125; assert如果一个布尔值是false那么可以通过使用assert声明来中断一个正常的语句执行。 异常（Exceptions）throw直接抛出异常 catch12345try &#123;&#125; catch &#123; &#125; finally无论是否抛出异常，要确保某些代码运行，使用finally子句。 123456try &#123; breedMoreLlamas();&#125; finally &#123; // Always clean up, even if an exception is thrown. cleanLlamaStalls();&#125; 或者 1234567try &#123; breedMoreLlamas();&#125; catch (e) &#123; print('Error: $e'); // Handle the exception first.&#125; finally &#123; cleanLlamaStalls(); // Then clean up.&#125;]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM理解-javac源码文件]]></title>
    <url>%2FJVM%E7%90%86%E8%A7%A3-javac%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JVM理解-javac源码文件 1. 准备既然是“JVM理解-Java源文件编译”，那怎么能少得了编译工具javac呢~可是我们用的javac仅仅是jdk提供的一个工具，直接供我们使用，而我这篇文章是希望通过源码来大致了解在javac源码的具体实现。所以我们的首要任务时获取javac源码。 1.1 获取javac源码地址： http://hg.openjdk.java.net/jdk8/jdk8/langtools/ 进入这个地址后，点击下图所示的链接，即可进行下载： 或者通过此链接（JDK8）： http://hg.openjdk.java.net/jdk8u/jdk8u-dev/langtools/archive/tip.tar.bz2 下载之后解压压缩包。 通过此图就已经非常明显的看到了javac的源码文件目录了。 至此，我们成功的拿到了javac的源码，接下来就是将源码导入到一个项目进行愉快的阅读和调试了！ 1.2 导入javac源码我用的是IntelIiJ IDEA，就以此为基础进行说明。 在IDEA中新建一个Project，然后建一个Module，在Module的src导入com目录下除了javadoc文件夹外的文件。 javac编译器程序入口：com.sun.tools.javac.Main类中的main()方法。 1.3 配置修改如果不进行此步骤的配置修改，将会出现 1无论你怎么在自己添加的 javac 源码中加断点，当进行断点调试时，总是不走自己的文件，而是走反编译的当前jdk版本的源码。 点击如下图标： 做出如下修改，即可解决此问题： 如果不出意外的话，找到javac目录下的Main.java文件，右键Run Main.main()得到如下结果就表示成功了，而且走断点时走的也是自己的源码文件。 出现这样的结果是因为没有为javac添加参数导致的。 javac选项用法请参考： http://docs.oracle.com/javase/8/docs/technotes/tools/unix/javac.html 1.4 配置待编译的源码文件点击此按钮 然后在此界面的Program directory下配置具体要编译的Java源码文件 至此，前期准备工作已经完成！ 2. 编译原理 参考：https://blog.csdn.net/tangl_99/article/details/5600 2.1 概述编译器是一种翻译程序，将源语言翻译为目标语言。编译的过程分为5个阶段（运行时环境）： 词法分析 语法分析 语义分析与中间代码生成 优化 最终代码生成 词法分析：由词法分析器实现此功能，目的是分析源程序中的单词是否有错误。词法分析器是语法分析程序的一个子程序。这一阶段产生的错误被称为词法错误。 延伸： 1其实词法分析并非一开始就被列入编译器的必备部分，只是我们为了简化语法分析的过程，就把词法分析这种繁琐的工作单独提取出来，就成了现在的词法分析部分。 语法分析：由语法分析器实现此功能，目的是识别出源程序的语法结构（语句或句子）是否错误。这一阶段产生的错误被称为语法错误。语法分析阶段中处理的输入数据：是来自词法分析阶段的单词、符号。它们是词法分析阶段的终结符。语法分析器的类型有： 自下而上：算符优先分析法，是一个不断归约的过程，适合分析各种程序设计语中的表达式。 自上而下：递归下降分析法 静态语义检查一般包括以下四个部分： 类型检查 控制流检查 名字匹配检查 一致性检查 2.2 词法与语法序语言的基本功能是描述数据和对数据的运算。程序语言主要由语法和语义两个方面来定义。任何语言的程序都可看成是某字符集上的一个长字符串。语言的语法：是指可以生成和产生一个良定程序的一组规则（即产生式）。这些规则的一部分称为词法规则，另一部分称为语法规则。 词法规则：单词符号的形成规则；语法规则：语法单位（句子）的形成规则；语义规则：定义程序句子的意义。 3. javac编译过程3.1 项目结构在com.sun.tools.javac下有如下几个包: api -&gt; 实现了JavaCompiler 和javax.tools中其他的api code -&gt; 定义了Java程序的语义元素的表示，如符号、作用域和类型，在javax.lang.model.*.中实现. comp –&gt; 编译器的主要处理阶段，如标记、流分析、“解语法糖”和擦除 file –&gt; 使用java.nio.file 的api来访问本地的文件系统. jvm –&gt; 读取和写class文件,生成字节码 main –&gt; 编译的主要驱动代码,提供了多样的编译步骤选项 model –&gt; javax.lang.model.*. 的额外实现类 parser –&gt; 读取java源文件生成语法树 processing –&gt; 实现了在javax.annotation.processing.*定义的api resources –&gt; 信息本地化和版本信息的资源文件 tree –&gt; 编译器的语法树的表示和实用类，实现了com.sun.source.*.中定义的api util –&gt; 工具类 javac编译动作入口： com.sun.tools.javac.main.JavaCompiler类。 3个步骤 解析与填充符号表 注解处理 分析与字节码生成 3.2 编译流程 参考：http://www.cnblogs.com/wade-luffy/p/5925728.html参考：https://blog.csdn.net/Oeljeklaus/article/details/81000939 词法分析器 语法分析器 语义分析器 代码生成器 编译过程的方法(这张图太经典了，高频出现) 对应到实际源码中的 完整方法 就是： 位置：com.sun.tools.javac.main.JavaCompiler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * Main method: compile a list of files, return all compiled classes * * @param sourceFileObjects file objects to be compiled * @param classnames class names to process for annotations * @param processors user provided annotation processors to bypass * discovery, &#123;@code null&#125; means that no processors were provided */public void compile(List&lt;JavaFileObject&gt; sourceFileObjects, List&lt;String&gt; classnames, Iterable&lt;? extends Processor&gt; processors) &#123; if (processors != null &amp;&amp; processors.iterator().hasNext()) explicitAnnotationProcessingRequested = true; // as a JavaCompiler can only be used once, throw an exception if // it has been used before. if (hasBeenUsed) throw new AssertionError("attempt to reuse JavaCompiler"); hasBeenUsed = true; // forcibly set the equivalent of -Xlint:-options, so that no further // warnings about command line options are generated from this point on options.put(XLINT_CUSTOM.text + "-" + LintCategory.OPTIONS.option, "true"); options.remove(XLINT_CUSTOM.text + LintCategory.OPTIONS.option); start_msec = now(); try &#123; initProcessAnnotations(processors); // These method calls must be chained to avoid memory leaks delegateCompiler = processAnnotations( enterTrees(stopIfError(CompileState.PARSE, parseFiles(sourceFileObjects))), classnames); delegateCompiler.compile2(); delegateCompiler.close(); elapsed_msec = delegateCompiler.elapsed_msec; &#125; catch (Abort ex) &#123; if (devVerbose) ex.printStackTrace(System.err); &#125; finally &#123; if (procEnvImpl != null) procEnvImpl.close(); &#125;&#125;/** * The phases following annotation processing: attribution, * desugar, and finally code generation. */private void compile2() &#123; try &#123; switch (compilePolicy) &#123; case ATTR_ONLY: attribute(todo); break; case CHECK_ONLY: flow(attribute(todo)); break; case SIMPLE: generate(desugar(flow(attribute(todo)))); break; case BY_FILE: &#123; Queue&lt;Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; q = todo.groupByFile(); while (!q.isEmpty() &amp;&amp; !shouldStop(CompileState.ATTR)) &#123; generate(desugar(flow(attribute(q.remove())))); &#125; &#125; break; case BY_TODO: while (!todo.isEmpty()) generate(desugar(flow(attribute(todo.remove())))); break; default: Assert.error("unknown compile policy"); &#125; &#125; catch (Abort ex) &#123; if (devVerbose) ex.printStackTrace(System.err); &#125; if (verbose) &#123; elapsed_msec = elapsed(start_msec); log.printVerbose("total", Long.toString(elapsed_msec)); &#125; reportDeferredDiagnostics(); if (!log.hasDiagnosticListener()) &#123; printCount("error", errorCount()); printCount("warn", warningCount()); &#125;&#125; 3.2.1 词法分析器源码： com.sun.tools.javac.parser.JavacParser ：具体解析类，规定哪些词符合Java语言规范。 com.sun.tools.javac.parser.JavacParser.parseCompilationUnit() ：词法分析 com.sun.tools.javac.parser.Scanner ：读取源码的单个字符，解析符合Java语言规范的Token序列 com.sun.tools.javac.parser.Tokens：包含各种Token类型 com.sun.tools.javac.util.Names：用来存储和表示解析后的词法，每个字符集合都会是一个Name对象，所有的对象都存储在Name.Table这个内部类中。 作用：将源码转换为Token流。 流程：一个字节一个字节的读取源代码，形成规范化的Token流。规范化的Token包含： java关键词：package、import、public、class、int等 自定义单词：包名、类名、变量名、方法名 符号：=、;、+、-、*、/、%、{、}等 3.2.2 语法分析器源码： com.sun.tools.javac.tree.TreeMaker：由它生成语法节点，根据Name对象构建一个语法节点。 com.sun.tools.javac.tree.JCTree的三个属性： Tree tag:每个语法节点都会以整数的形式表示，下一个节点在上一个节点上加1； pos：也是一个整数，它存储的是这个语法节点在源代码中的起始位置，一个文件的位置是0，而－1表示不存在 type：它代表的是这个节点是什么java类型，如int，float，还是string等 作用：将进行词法分析后形成的Token流中的一个个Token组成一句句话（语法树），检查这一句句话是不是符合Java语言规范。 延伸：为什么要把分析的结果转换成“树”这种数据结构呢？ 1是Tree这种结构有很强的递归性，也就是说我们可以把Tree的任何结点Node提取出来后，它依旧是一颗完整的Tree。这一点符合我们现在编译原理分析的形式语言，比如我们在函数里面使用函数，循环中使用循环，条件中使用条件等等，那么就可以很直观地表示在Tree这种数据结构上。同样，我们在执行形式语言的程序的时候也是如此的递归性。 流程：语法分析三部分： package import 类（包含class、interface、enum），一下提到的类泛指这三类，并不单单是指class 3.2.3 语义分析器源码： com.sun.tools.javac.comp.Enter：将java类中的符号输入到符号表中，主要是两个步骤： 将所有类中出现的符号输入到类自身的符号表中，所有类符号、类的参数类型符号（泛型参数类型）、超类符号和继承的接口类型符号等都存储到一个未处理的列表中。 将这个未处理的列表中``所有的类都解析到各自的类符号列表中，这个操作是在MemberEnter.complete()中完成(默认构造器也是在这里完成的)。 com.sun.tools.javac.processing.JavacProcessingEnvironment：处理注解 com.sun.tools.javac.comp.Attr：检查语义的合理性并进行逻辑判断，类型是否匹配，是否初始化，泛型是否可推导，字符串常量合并 com.sun.tools.javac.comp.Check：协助attr，变量类型是否正确 com.sun.tools.javac.comp.Resolve：协助attr，变量方法类的访问是否合法，是否是静态变量 com.sun.tools.javac.comp.ConstFold：协助attr，常量折叠 com.sun.tools.javac.comp.Infer：协助attr，推导泛型 com.sun.tools.javac.comp.Flow：数据流分析和替换等价源代码的分析（即上面的进一步语义分析） 作用：将语法树转化为注解语法树。 流程： 添加默认无参构造器（在没有指定任何有参构造器的情况下） 处理注解 标注：检查语义合法性、进行逻辑判断 检查语法树中的变量类型是否匹配（eg.String s = 1 + 2;//这样”=”两端的类型就不匹配） 检查变量、方法或者类的访问是否合法（eg.一个类无法访问另一个类的private方法） 变量在使用前是否已经声明、是否初始化 常量折叠（eg.代码中：String s = “hello” + “world”，语义分析后String s = “helloworld”） 推导泛型方法的参数类型 数据流分析 变量的确定性赋值（eg.有返回值的方法必须确定有返回值） final变量只能赋一次值，在编译的时候再赋值的话会报错 所有的检查型异常是否抛出或捕获 所有的语句都要被执行到（return后边的语句就不会被执行到，除了finally块儿） 进一步分析 去掉永假代码（eg.if(false)） 变量自动转换（eg.int和Integer） 去掉语法糖（eg.foreach转化为for循环，assert转化为if，内部类解析成一个与外部类相关联的外部类） 3.2.4 代码生成器源码： com.sun.tools.javac.jvm.Gen：遍历语法树生成最终的java字节码 com.sun.tools.javac.jvm.Items：辅助gen，这个类表示任何可寻址的操作项，这些操作项都可以作为一个单位出现在操作栈上 com.sun.tools.javac.jvm.Code：辅助gen，存储生成的字节码，并提供一些能够映射操作码的方法 作用：将注解语法树转化成字节码，并将字节码写入*.class文件。 流程：将java的代码块转化为符合JVM语法的命令形式，这就是字节码按照JVM的文件组织格式将字节码输出到*.class文件中 内容：*.class文件中不只包含字节码信息，具体包含： 结构信息 class文件格式版本号 各部分的数量与大小 元数据 类、父类、实现接口的声明信息 属性声明信息 方法声明信息 常量池 方法信息 字节码 异常处理器表 局部变量区的大小 操作数栈的大小 操作数栈的类型记录 调试用符号信息]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM理解-class文件]]></title>
    <url>%2FJVM%E7%90%86%E8%A7%A3-class%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JVM理解-class文件 参考：https://blog.csdn.net/brave2211/column/info/zhangjg-java-blog 前言1. JVM是什么VM是一种抽象化的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件体系架构，如：处理器、堆栈、寄存器等，还具有相应的指令系统。JVM``屏蔽了具体操作系统平台的相关信息，使得Java程序只需要在JVM上运行目标代码（字节码），就可以实现跨平台。 以上这些描述仅仅是从JVM外部来对其进行解释，而JVM理解这一系列文章则是针对JVM内部来进行解释。 2. 进程与JVM进程是操作系统中的执行单位，而JVM又是运行在操作系统中，由此关系可以看出：JVM是操作系统中的一个进程实例，当JVM没有运行时，是一个 安静的程序 一个Java程序的运行 当我们运行一个Java程序Hello.java的时候，并没有运行经过javac编译产生的Hello.class文件，而是通过 java 来运行了 Hello，由此可见.class文件并不是能够直接被系统直接识别的二进制文件，而是在终端中通过调用java来运行一个编译后的文件的。 这是为什么呢 ？当我们运行java这个命令的时候，首先启动的是一个java程序，而这个java程序启动之后就是一个文章前面所提到的一个JVM进程实例。由此显而易见：真正处理java程序的是虚拟机。 当我们找到 java 这个命令所对应的文件夹时，可以看到他所存在路径： 1. class文件结构我自己学习JVM是通过《深入理解Java虚拟机 JVM高级特性与最佳实践》这本书。当我写这篇文章时，是我读这本书的第3遍。前2此都是读到关于class文件结构时，阅读就越乱，索性就直接跳过了，结果就是对于JVM大致有了 一个了解，但是具体到类加载的详细细节以及其中的某一个变量的加载、初始化时，还是一头雾水。 对于我这样的结果书中的一句话就已经说明了这个问题： 1对数据结构方面的讲解不可避免的会比较枯燥，而这部分内容又是了解JVM重要的基础之一。如果想要深入的了解虚拟机，那么这部分是不可能不接触的。 以下内容来自《深入理解Java虚拟机 JVM高级特性与最佳实践》： “ 文件内容class文件是一种8位字节的二进制流文件， 各个数据项按顺序**紧密的**从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间。 我们的Java源文件， 在被编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。 class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。 文件格式class文件格式采用一种类似于C语言结构体的伪结构体来存储数据，这种伪结构体只有两种数据类型：无符号数 + 表。 无符号数：属于基本数据类型。 以u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节的无符号数。无符号数用来描述：数字、索引引用、数量值或按照UTF-8编码构成的字符串值。 表：由多个无符号数或其他表作为数据项构成的复合数据类型。 所有的表都习惯性用_info结尾。表用于描述有层次关系的复合数据类型。 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置容量计数器+若干个连续的数据项形式。此时称这一连续的某一类型的数据为某一类型的数据集合。 class文件格式: 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attribute_count 1 attribute_info attributes attributes_count ” 一个class文件的实际格式（部分）： 探究开始 一个简单的java程序 1234567891011121314151617public class Hello &#123; public static String str = &quot;Java Code&quot;; public static final int currentCode = 18; static &#123; Person person = new Person(); &#125; public static void main(String[] args)&#123; String mainStr = &quot;this is main method&quot;; (&quot;Hello Word!&quot;); System.out.println(str); System.out.println(mainStr); System.out.println(currentCode); &#125;&#125; 调用 javac 1javac Hello.java 调用 javap 命令 javap是 class文件分解器，可以反编译（即对javac编译的文件进行反编译），也可以查看java编译器生成的字节码。 1javap -v Hello 得到的结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123Classfile /Users/yannischeng/Projects_IDEA_Java/InnerClass/src/Hello.class Last modified 2018-11-21; size 703 bytes MD5 checksum af24e8fdae56427e615d521bf93b4b6d Compiled from "Hello.java"public class Hello minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #12.#28 // java/lang/Object."&lt;init&gt;":()V #2 = String #29 // this is main method #3 = Fieldref #30.#31 // java/lang/System.out:Ljava/io/PrintStream; #4 = String #32 // Hello Word! #5 = Methodref #33.#34 // java/io/PrintStream.println:(Ljava/lang/String;)V #6 = Fieldref #7.#35 // Hello.str:Ljava/lang/String; #7 = Class #36 // Hello #8 = Methodref #33.#37 // java/io/PrintStream.println:(I)V #9 = String #38 // Java Code #10 = Class #39 // Person #11 = Methodref #10.#28 // Person."&lt;init&gt;":()V #12 = Class #40 // java/lang/Object #13 = Utf8 str #14 = Utf8 Ljava/lang/String; #15 = Utf8 currentCode #16 = Utf8 I #17 = Utf8 ConstantValue #18 = Integer 18 #19 = Utf8 &lt;init&gt; #20 = Utf8 ()V #21 = Utf8 Code #22 = Utf8 LineNumberTable #23 = Utf8 main #24 = Utf8 ([Ljava/lang/String;)V #25 = Utf8 &lt;clinit&gt; #26 = Utf8 SourceFile #27 = Utf8 Hello.java #28 = NameAndType #19:#20 // "&lt;init&gt;":()V #29 = Utf8 this is main method #30 = Class #41 // java/lang/System #31 = NameAndType #42:#43 // out:Ljava/io/PrintStream; #32 = Utf8 Hello Word! #33 = Class #44 // java/io/PrintStream #34 = NameAndType #45:#46 // println:(Ljava/lang/String;)V #35 = NameAndType #13:#14 // str:Ljava/lang/String; #36 = Utf8 Hello #37 = NameAndType #45:#47 // println:(I)V #38 = Utf8 Java Code #39 = Utf8 Person #40 = Utf8 java/lang/Object #41 = Utf8 java/lang/System #42 = Utf8 out #43 = Utf8 Ljava/io/PrintStream; #44 = Utf8 java/io/PrintStream #45 = Utf8 println #46 = Utf8 (Ljava/lang/String;)V #47 = Utf8 (I)V&#123; public static java.lang.String str; descriptor: Ljava/lang/String; flags: ACC_PUBLIC, ACC_STATIC public static final int currentCode; descriptor: I flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL ConstantValue: int 18 public Hello(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: ldc #2 // String this is main method 2: astore_1 3: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 6: ldc #4 // String Hello Word! 8: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 11: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 14: getstatic #6 // Field str:Ljava/lang/String; 17: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 20: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 23: aload_1 24: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 27: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 30: bipush 18 32: invokevirtual #8 // Method java/io/PrintStream.println:(I)V 35: return LineNumberTable: line 10: 0 line 12: 3 line 13: 11 line 14: 20 line 15: 27 line 16: 35 static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack=2, locals=1, args_size=0 0: ldc #9 // String Java Code 2: putstatic #6 // Field str:Ljava/lang/String; 5: new #10 // class Person 8: dup 9: invokespecial #11 // Method Person."&lt;init&gt;":()V 12: astore_0 13: return LineNumberTable: line 3: 0 line 6: 5 line 7: 13&#125;SourceFile: "Hello.java" 通过十六进制编辑器打开 Hello.class 文件 3.1 magicu4 magic = 0xCAFEBABE 作用：确定此文件是否是一个能够被虚拟机接受的class文件。除此外，很多文件也通过magic来进行身份的标识。 3.2 版本u2 minor_version：此版本号u2 major_version：主版本号 3.3 常量池常量池可理解为是class文件中的资源仓库，是class文件中与其他文件关联最多的数据类型 ，也是class文件中占用空间最大的数据项目之一，同时也是class文件中第一个出现表数据类型的数据项目。 常量池容量计数器u2 常量池容量计数器 ：因为常量池的数量是不固定的，同时此计数器的索引是从 1 开始的而不是0。 存放内容： 字面量（Literal）：类似于Java中的常量 符号引用（Symbolic References）： 类和接口的全限定名（Full Qualified Name） 字段名称与描述（Descriptor） 方法的名称与描述 关于符号引用 因为JVM在加载class文件的时候进行的动态连接，也就是说在class文件中并没有保存各个方法、字段的的最终内存地址。因此，如果这些字段、方法的符号引用若是不经过运行期转换的话是无法得到真正的内存地址入口的，无法被虚拟机直接使用。 于是当虚拟机运行时，需要从常量池中获得对应的符号引用，然后在类的创建或其他过程中将其对应到具体的内存地址之中 。 常量池内容 常量池中的每一项内容都是一个表，共有14种常量类型，每一种类型都有着自己的类型（具体参考《深入理解JVM》P172）。 3.4 访问标志访问标志 在 常量池接收之后出现，用于表示这个class文件是一个 接口 还是一个 类，是public 还是 private。如图： 3.5 类索引、父类索引、接口索引集合此处：父类索引只有1个，接口索引 确是一个集合，可见Java的单继承、多实现的特点。 3.6 字段表集合字段表（field_info）是用来描述：接口或者类中声明变量。字段（field）包括：类级别以及实例级别中的变量，不包括在方法内部中声明的局部变量。 注：字段以及方法中的描述符： 符号含义： 常见类型： |表示字符|含义| |:–|:–| |Z|基本类型 boolean| |B|基本类型 byte| |C|基本类型 char| |S|基本类型 short| |I|基本类型 int| |J|基本类型 long| |F|基本类型 float| |D|基本类型 double| |V|特殊类型 void| |L|对象类型 ，如：Ljava/lang/Object| 数组类型： 每一个纬度将使用一个[字符来表示。如果是一维java.lang.String[]则为：[Ljava/lang/String;，二维int[][] 表示为[[I 描述符来描述方法： 按照：先参数列表，后返回值的顺序来描述。如：void (java.lang.String[])表示为：([Ljava/lang/String;)V；void(int a)表示为:(I)V 字段表结构 类型 名称 数量 u2 access_flags 1 u2 name_index 1 u2 descriptor_index 1 u2 attribute_count 1 attribute_info attributes attributes_count 3.7 方法表集合 方法表结构 类型 名称 数量 u2 access_flags 1 u2 name_index 1 u2 descriptor_index 1 u2 attribute_count 1 attribute_info attributes attributes_count 不同点：访问标志（access_flags）与属性表集合(attribute_info)不同 特殊-方法体：Code在方法表结构中我们仅仅是看到了关于方法的描述，但是却未看到具体方法体，那么去哪了呢？ 答案是： 1Java文件中的方法体，在经过编译器编译成字节码文件后，存放在方法体中一个名为“Code”的属性里面。 在字节码中如下图所示： 经过javap处理后，如下图所示： Code 是class文件中一个重要的属性，如果把一个Java程序中的信息分为代码（Code，方法体中的代码）和元数据（类、字段、方法定义及其他描述信息）2个部分，那么在class文件中：Code用于描述代码，其他所有数据项目描述元数据。 Code 属性是学习关于字节码执行引擎内容的必要基础。 符号含义 名称 样式 类构造器 &lt;clinit&gt; 实例构造器 &lt;init&gt; 3.8 属性表集合由于属性太多，具体参考《深入理解JVM》P180 LineNumberTable属性：描述Java源码行号与字节码行号之间的对应关系。 属于非运行时必需属性，默认生成。所以在运行javac命令时，可以通过 1-g:none 或者 1-g:lines 来选择是否要生成此项信息。如果不生成LineNumberTable属性不会影响程序运行，但是存在的问题是： 抛出异常时，堆栈中将不会显示 出错的行号 调试程序时：无法按照源码设置断点 LocalVariableTable属性：描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。 属于非运行时必需属性，默认生成。如果不生成不会影响程序运行，会导致： 他人在调用其所在的方法参数名丢失，但不影响程序运行 在进行断点调试时无法根据参数名从上下文获取参数值。 SourceFile属性：记录生成这个class文件所对应的源码的文件名称。 属于非运行时必需属性，默认生成。如果不生成不会影响程序运行，会导致： 程序出现异常，在堆栈中将不会显示出错代码所属的文件名称。 ConstantValue属性：通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才能使用这项属性。 赋值差异： 非static类型变量（实例变量）的赋值是在实例构造器&lt;init&gt; 方法中进行的 static类型变量（类变量）的赋值方式有2种（由javac编译器限制）： 在类构造器&lt;clinit&gt;方法中：一个变量未被final关键字修饰，或者数据类型非基本数据类型或者String 使用ConstantValue属性：一个变量由final和static2个关键字同时修饰，且数据类型为基本数据类型或者String innerClasses属性：记录内部类与宿主类之间的关联。 2. JVM字节码指令字节码指令是一个字节长度的，分为：操作码+操作数。由于JVM是面向操作数栈而不是寄存器的架构，所以大多数指令只有操作码而没有操作数。 具体指令查看：《深入理解JVM》P199-P206]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次翻车-个人博客图床问题]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BF%BB%E8%BD%A6-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记一次翻车-个人博客图床问题 参考：http://robotkang.cc/2018/11/pic/ 问题起因 因为 七牛 关闭 临时域名 导致 个人博客中的图片 不能显示。 解决方案 添加自己的 个人真实域名，遇到的问题：按照七牛官网提示需要进行公安网络备份。但是由于备份需要填写的信息太多，且我仅仅是通过这个域名作为我的个人博客地址，并没有其他用途，导致有些字段信息根本就无法填写，因此：放弃。 在 七牛 官网在创建一个临时的 bucket ，将原有的 bucket 中的图片 copy 到新 bucket 中。因为：原 bucket 中的图片由于 临时域名 禁止访问问题，导致不能对其中的图片进行一些列操作，所以通过此方式在30天内（新创建的 bucket 30内有效），在对数据做进一步处理。 走上正道 本来想着直接将原 bucket 中的图片数据直接保存至本地，但是并不知道 临时域名 被撤销，导致无法执行任何操作，所以没有成功。 于是打电话咨询了 七牛 的 技术支持，经过指导，问题得以解决。 解决过程工具 - qshell 下载 qshell ，然后解压。 如果是Mac用户，将 qshell_darwin_x64 重命名为： qshell ，这是一个命令行工具。 配置 关于 qshell 全局路径的配置，在 当前用户名 的配置文件 中（bash：.bash_profile 文件，zsh：.zshrc 文件）： 1export PATH=$&#123;PATH&#125;:/Users/当前用户名/qshell存放路径 添加账号：ak 与 sk 可以在 控制台 右上角的 个人面板 -&gt; 密钥管理 里找到 1qshell account ak参数 sk参数 bucket名称 名词解释 - bucketbucket 就是你自己创建的存储空间的名字 copy 文件 需要 -i 指定携带需要同步的 文件列表，列表可以通过 listbucket 得到，自定义一个存储输出的文件 list.txt： 1qshell listbucket 原bucket名 -o list.txt 用 awk 获取 文件列表 list.txt 结果的第一列，结果存储到自定义文件 list_final.txt 中： 1cat list.txt | awk &apos;&#123;print $1&#125;&apos; &gt;list_final.txt 通过 batchcopy 进行文件复制，复制到新bucket的文件和原bucket文件名一致 123456789101112qshell batchcopy 原bucket名 新bucket名 -i list_final.txt``` ## 批量文件下载**注意：**此操作是在 **可用的bucket** 中进行的操作，如果你当前的 `bucket的测试域名` **已经过期**，那么你需要先执行 `copy 文件` 步骤- 创建 `自定义 batch_download.conf` 文件，因为： `qshell` 虽然提供了 [qdownload](https://github.com/qiniu/qshell/blob/master/docs/qdownload.md) 可以批量下载文件，不过官网给出的 `api 文档`特别标注了，这个接口默认是要收费的：配置【该功能默认需要计费，如果希望享受10G的免费流量，请自行设置 `cdn_domain` 参数，如不设置，需支付源站流量费用，无法减免！！！】 {“dest_dir” : “本地数据备份路径，为全路径”,“bucket” : “空间名称”,“prefix” : “”,“suffixes” : “”,“cdn_domain” : “设置下载的CDN域名，默认为空表示从存储源站下载”,“referer” : “”,“log_file” : “download.log”,“log_level” : “info”,“log_rotate” : 1,“log_stdout” : false}12- 通过 [qdownload](https://github.com/qiniu/qshell/blob/master/docs/qdownload.md) 执行 `批量下载` ： qshell qdownload batch_download.conf -c 1012345678910111213141516171819202122## 转存 腾讯cos在 `腾讯云` 官网创建 `bucket` ，注意两个关键设置： - 存储桶（bucket）**访问权限** 访问权限应设置为 **`公有读私有写`**。很好理解，我们是要用COS来做图床的，必然是需要获取文件的直接链接才行，所以不能在读取图片的时候设置权限。- **防盗链设置** 如果被盗链会导致你的免费额度可能会快用尽，因此防盗链也是需要考虑的（注意白名单的设置）。 **注意：**因为开启了防盗链这设置，因此当你在本地写博客的时候会出现图片无法预览的情况。因为防盗链机制只允许白名单中指定域名或IP访问。也就是说只能在博客中看## 批量替换 链接域名这一步是为了处理 `七牛` 原有图片域名转换为 `cos` 域名如果你用的是 `hexo` 搭建的博客，那么进入 `source/_post` 文件，然后执行： sed -i ‘’ ‘s#http://oy991qm3u.bkt.clouddn.com#https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com#g‘ *.md123为什么要在命令行 `-i` 与 `&apos;s` 之间添加 `&apos;&apos;`，因为如果你使用的是 `macOS` 那么在 `sed` 命令采用 `-i` 选项时需要设置 你在替换时设定一个备份文件以避免数据丢失——这个选项在 `Linux` 中是可选的，但在 `macOS` 中是必选的，如果没有 `&apos;&apos;` 一般会提示错误： sed: 1: “ “: ……``` 参考：https://stackoverflow.com/questions/29081799/sed-1-invalid-command-code-f参考：https://www.logcg.com/archives/3142.html]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何熟悉一个项目]]></title>
    <url>%2F%E5%BF%83%E5%BE%97-%E5%A6%82%E4%BD%95%E7%86%9F%E6%82%89%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[如何熟悉一个项目 总结： https://blog.csdn.net/mengdonghui123456/article/details/50703991https://blog.csdn.net/bigestt/article/details/80278452 拿到别人的程序第一反应：修改代码，导致的后果为：1.任务工期问题，时间成本大，2.不便于能力的提升 接手方法：不变应万变。 项目维护有三宝：沟通 、文档 、代码跑。 目标：了解业务逻辑流。 重点攻击 工具： 目的：提高接手的效率，节省时间。 核心原则： 不要试图先搞懂整个项目； 注重 有效提交，即：及时完成交给你的任务，以任务为第一，而不是自己的研究学习能力。 项目出活四部曲：跟、改、理、测要一起。 跟：抓住一个功能点，深入的调试跟踪流程，分析代码直到弄明白为止。 改：修改源代码，编译运行，看修改前后有什么变化，这是感知代码用途的最佳途径。 理：尝试弄清整个项目的业务逻辑。 测：熟悉业务逻辑后，清库测试，测验是否符合自己所想。 精进一个项目一般有 前端 与 后端 构成，其核心功能无非是由： 增、删、该、查 组成，然后通过 通信、运算、人机交互 将整个流程串联。 与此同时要注意项目的：规模、性能、稳定性、流程等方面上的问题。 对于老系统 老系统有许多宝藏，里面有很多你可以借鉴和学习的东西。 注意老系统潜在的坑，一个看起来毫无关联的代码改了之后可能引发地震。 有些看着不爽的代码其实都有道理。 看不懂的代码不要动。 在力所能及的范围内让老系统变得更美好。 一般运行项目 知道当前程序是什么、有何存在意义、功能有哪些、功能正确性、功能的完整性。 通过断点、日志调试。 掌握结构 先文档（需求文档、原型图、UI图、接口文档） 再 read code。 先整体（宏观、流程） 再 细节。 通过工具辅助 熟悉项目如何分层、分模块，每一层、每个模块的实现 细节集中且投入大量时间遇到问题：多问，与周边同是交流修改、bug 注意项目 难点、遗留问题、存在的坑 Android http://www.androidchina.net/7656.html 理论完整的项目一般会有比较严谨的 分包，每个包一个 功能，包下又会分子包，将视图、实体、控制等等部分分开。如此可以从： 实体类 和 工具类 看起：实体类没有逻辑比较好懂，工具类看不懂自己调用试试也差不多知道了。 然后看 控制层，控制层方法功能一般比较单纯，方法逻辑先放着不管，搞懂功能 再说。 然后看 界面，基本上就通了。 比较重要的是边看要边加注释，越详细越好。细到每个变量是做什么的，每个 if else 分支是在什么情况下触发的，看懂的都要注释，以后看也方便。 实践1.AndroidManifest.xml 文件AndroidManifest.xml 文件，App入口，包含了权限、Activity、Service、广播、第三方继承配置、Application配置。 2.定位当前 Activity运行App时，定位当前 Activity，通过工具 Top Activity。 3.定位资源id所在文件使用工具 uiautomatorviewer，通过此工具可以查看到所需的 布局的id值，然后通过 全局搜索 查找到在具体布局中的位置： 1/Users/当期用户名/Library/Android/sdk/tools/bin 运行以下语句进行工具调用： 1/Users/当期用户名/Library/Android/sdk/tools/bin/uiautomatorviewer; exit 4.build.gradle 文件打包、发版、部署流程 5.变量修改 查看一个 变量 在 整个项目 中的使用。 1com + b == opt + F7 == com + shift + F]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin与Java-递进篇]]></title>
    <url>%2FKotlin%E4%B8%8EJava-%E9%80%92%E8%BF%9B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Kotlin与Java-递进篇 Kotlin源码：https://github.com/JetBrains/kotlinKotlin官网：http://kotlinlang.org/Kotlin官方文档：http://kotlinlang.org/docs/reference/Kotlin标准库（Kotlin除了能调用Java自有库，还可以在此库上进行一系列的扩展（Extension）和必要的封装）：http://kotlinlang.org/api/latest/jvm/stdlib/index.html 面向对象 面向对象 继承与多态 抽象与接口 类声明1234567891011class Animal &#123; var nameAnimal = &quot;猴急&quot; private var sex = false /** * 成员函数 */ fun run()&#123; println(&quot;老快了&quot;) &#125;&#125; 调用： 12345fun main(args:Array&lt;Stringn&gt;)&#123; var animal = Animal() println(animal.nameAnimal) animal.run()&#125; 结果： 12猴急老快了 属性 顶层属性：类之外声明，类似顶层函数 成员属性：在类中声明 属性本身并不保存数据，数据是被保存到支持字段（blacking field）中的，支持字段一般不可见。 说明Kotlin中的一个属性（如Animal中的nameAnimal是属性而非字段）对应：一个字段 + 一个setter访问器 + 一个getter访问器。 即一个属性的完整格式为： 123var|val 属性名 [：属性类型] [ =属性初始化] [getter访问器] [setter访问器] 属性声明12345678910111213141516171819202122232425262728293031class Animal &#123; var no = 1 var job: String? = null var firstName: String = &quot;Jack&quot; var lastNmae: String = &quot;Tom&quot; var fullName: String get() &#123; return firstName + &quot;.&quot; + lastNmae &#125; set(value) &#123; val name = value.split(&quot;.&quot;) firstName = name[0] lastNmae = name[1] &#125; var fullName2: String get() = firstName + &quot;.&quot; + lastNmae set(value) &#123; val name = value.split(&quot;.&quot;) firstName = name[0] lastNmae = name[1] &#125; var salary: Double = 0.0 set(value) &#123; if (value &gt; 0.0) field = value &#125;&#125; 注意： fullName 这个属性时 firstName与lastName的组合体，由另外的属性计算而来。而这样的字段是没有支持字段（blacking field）的。 salary字段是在经过执行判断操作后，将值赋给了field支持字段，也就是salary。 调用 12345678910111213fun main(args:Array&lt;String&gt;)&#123; var animal = Animal() println(animal.fullName) animal.fullName = &quot;Flank.Bluce&quot; println(animal.fullName) println(animal.firstName) println(animal.lastNmae) animal.salary = -10.0 println(animal.salary) animal.salary = 10.0 println(animal.salary)&#125; 结果 123456Jack.TomFlank.BluceFlankBluce0.010.0 属性延迟初始化 - lateinit 关键字声明一个类 123class Zoo &#123; var nameZoo = &quot;美好时光&quot;&#125; 在另一个类中调用，注意此处的关键字：lateinit注意：限制条件 不能是可空类型 只能是 var 声明 lateinit 关键字只能放在 var 之前 123class Animal &#123; lateinit var getZooName: Zoo&#125; 调用 1234567// 初始化时不需要调用 Zoo类var animal = Animal()...// 需要的时候在调用 Zoo类animal.getZooName = Zoo() 委托属性 - by 关键字惰性加载属性 - lazy 函数作用与 属性延迟初始化 相似，但是不同点是： 属性延迟初始化 使用 lateinit关键字；其属性必须是var 惰性加载属性 使用 lazy函数 声明委托属性；其属性必须是val 123val fullName3: String by lazy &#123; firstName + &quot;.&quot; + lastNmae&#125; 可观察属性声明，其中：p表示属性；oldValue 表示旧值；newValue表示新值 12345class Animal &#123; var nameTch: String by Delegates.observable(&quot;&lt;无&gt;&quot;)&#123; p,oldValue,newVlaue -&gt; println(&quot;$oldValue -&gt; $newVlaue&quot;) &#125;&#125; 调用 12345fun main(args: Array&lt;String&gt;)&#123; var animal = Animal() animal.nameTch = &quot;前端&quot; animal.nameTch = &quot;后端&quot;&#125; 结果为 12&lt;无&gt; -&gt; 前端前端 -&gt; 后端 可扩展 Kotlin允许：在原始类的基础上添加新功能 ，所以扩展是一种轻量级的继承机制 Kotlin中称原始类为接收类型，扩展是必须针对某种接收类型的，所以不能扩展顶层函数和顶层属性 Kotlin中接收类型可以是 任何 数据类型，包括 基本数据类型 和 引用数据类型 Kotlin允许：扩展原始类的属性+函数 在使用Kotlin时，如果遇到Java的继承问题时，应优先考虑扩展机制 扩展函数语法如下： 1234fun 接收类型.函数名(参数列表)：返回值类型&#123; 函数体 return 返回值&#125; 例子： 123456fun Double.interestBy(inter: Double): Double&#123; return this * inter&#125;var getDouble = 1000_000.0.interestBy(0.6666)println(getDouble) 结果： 1666600.0 扩展属性Kotlin中的扩展属性没有 支持字段，不支持：初始化、不能使用field变量 123var|val 接受类型.属性名 [：属性类型] [ =属性初始化] [getter访问器] [setter访问器] ”成员优先“ 原则无论是扩展属性还是函数，如果接收类型中已经有了相同的属性和参数，那么优先使用接收类型中的属性和函数 定义中缀运算符 - infix关键字中缀运算符 本质是 函数，可以自己定义，该函数只有一个参数，且该函数只能是成员函数或扩展函数。 语法： 123infix fun 函数名（参数：数据类型）&#123; return this 运算符 参数&#125; 构造函数Kotlin中的构造函数分为：主构造函数（只能有一个） 与 次构造函数（多个） 主构造函数关键字 constructor init 主构造函数的演变过程 1、原始写法 123456789101112class Rectangle constructor(width: Int, height: Int) &#123; var w: Int = 0 var h: Int = 0 var area: Int = 0 init &#123; w = width h = height area = w * h println(&quot;area is $area&quot;) &#125;&#125; 2、改进后 将类中的成员变量的声明（var）提取到主构造函数中，这样一来主构造函数会根据 var关键字生成相应的属性。 12345678class ChangeRect constructor(var width: Int, var height: Int) &#123; var area: Int = 0 init &#123; area = width * height println(&quot;area is $area&quot;) &#125;&#125; 调用 1234fun main(args: Array&lt;String&gt;)&#123; Rectangle(10,9) ChangeRect(9,80)&#125; 结果 12area is 90area is 720 3、如果所有的属性都要在主构造函数中初始化，那么可以省略掉init函数，如： 1class User constructor(var name: String, var password: String) 4、若主构造函数中没有注解和可见性修饰符，那么constructor关键字可以省略。 即：以上代码精简为 1class User (var name: String, var password: String) 以下情况需要添加 constructor 关键字 1class User private constructor(var name: String, var password: String) 5、主构造函数参数有默认值，同函数一样 User类声明 1class User (var name: String = &quot;张三&quot;, var password: String = &quot;123456&quot;) 调用 123456789fun main(args:Array&lt;String&gt;)&#123; var user = User() println(user.name) println(user.password) var user2 = User(&quot;王五&quot;) println(user2.name) var user3 = User(password = &quot;999999&quot;) println(user3.password)&#125; 结果为 1234张三123456王五999999 次构造函数关键字：constructor 次构造关键字声明 123456789101112131415class Rect constructor(var width: Int, var height: Int) &#123; var area: Int = 0 init &#123; area = width * height &#125; constructor(width: Int,height: Int,area: Int) : this(width,height)&#123; this.area = area &#125; constructor(area: Int) : this(200,100)&#123; this.area = area &#125;&#125; 调用 12345678fun main(args: Array&lt;String&gt;)&#123; var rect2 = Rect(10,20) println(rect2.area) var rect3 = Rect(1000,100,10000) println(rect3.area) var rect4 = Rect(400) println(rect4.area)&#125; 运行结果 12320010000400 可见性修饰符 可见性 修饰符 类成员可见 顶层声明 共有 public 所有地方可见 所有地方可见 内部 internal 模块中可见 模块中可见 保护 protected 子类中可见 私有 private 类中可见 文件中可见 Kotlin中通过模块可见性 替代 Java中的包可见性 Kotlin中的属性和函数既可以顶层声明也可以类成员声明 数据类将一个自定义类声明为数据类，作为 数据容器在各个组件之间传递，一般情况下是重写 Kotlin中所有类的基类Any类中的3个函数 equals hashCode toString 除此之外，Kotlin还提供了一种数据类 （Data Class） 声明语法：在 class关键字前添加 data关键字 1data class User (var name: String = &quot;张三&quot;, var password: String = &quot;123456&quot;) 添加 data关键字后，不仅仅是重写了 Any类中的 3个方法，而且还增加了一个copy函数。通过重写equals()比较所有属性是否相等。 注意： data 关键字修饰的类的主构造函数中的参数的声明不能省略var或者val。 调用 123456789fun main(args: Array&lt;String&gt;)&#123; var userN = User(&quot;Tom&quot;,&quot;1234&quot;) var userN2 = User(&quot;Tom&quot;,&quot;1234&quot;) println(userN == userN2) println(userN.hashCode()) println(userN2.hashCode()) var userN3 = User(&quot;Jack&quot;,&quot;1234&quot;) println(userN3.hashCode())&#125; 结果 1234true4121936412193672838179 数据类中 copy函数的使用12345678fun main(args: Array&lt;String&gt;)&#123; var userN = User(&quot;Tom&quot;,&quot;1234&quot;) println(userN.hashCode()) var userN4 = userN.copy() var userN5 = userN.copy(name = &quot;Tony&quot;) println(userN4.hashCode()) println(userN5.hashCode())&#125; 结果 1234121936412193682501468 解构数据类数据对象是一个数据容器，将多个相关数据打包到一个对象中。解构是进行逆操作。 如 123456fun main(args: Array&lt;String&gt;)&#123; var userN = User(&quot;Tom&quot;,&quot;1234&quot;) var(name,password) = userN println(name) println(password)&#125; 结果为 12Tom1234 枚举嵌套类Object关键字函数Functions 内联扩展函数-let 场景一: 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。 场景二: 然后就是需要去明确一个变量所处特定的作用域范围内可以使用 1234model.let &#123; // 将model对象赋值给it Log.e("TAG--let",it.curName.value?:"")&#125; with调用 同一个类的多个方法时，可以省去类名重复，直接调用类的方法。 使用方式： 123456789// 对同一个对象的多个属性的访问with(model)&#123; // 直接操作model对象中的变量 if (curName.value == "new Mike") &#123; curName.value = "new new Mike" &#125;&#125;.let &#123; Log.e("TAG--with",model.curName.value?:"")&#125; 内联扩展函数-run是let、with两个函数结合体。 一方面弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样可以省略对象，直接访问实例的公有属性和方法； 另一方面它弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理。 内联扩展函数-applyapply一般用于一个 对象实例初始化 的时候，需要对对象中的属性进行赋值、判空等一系列对于属性的操作（1个对象中含有多个属性）。 apply函数和run函数很像，唯一不同点就是它们 各自返回的值不一样： run函数是以闭包形式返回 最后一行代码的值； apply函数的返回的是 传入对象的本身。 apply函数与with函数相似，不同的是： apply函数主要功能在于 传入对象 的 赋值； with函数主要功能在于传入对象 的 调用 赋值示例：未使用apply函数前： 1234567mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null)mSheetDialogView.course_comment_tv_label.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_score.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_cancel.paint.isFakeBoldText = truemSheetDialogView.course_comment_tv_confirm.paint.isFakeBoldText = truemSheetDialogView.course_comment_seek_bar.max = 10mSheetDialogView.course_comment_seek_bar.progress = 0 使用apply函数后，直接针对对象的属性进行操作： 12345678mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123; course_comment_tv_label.paint.isFakeBoldText = true course_comment_tv_score.paint.isFakeBoldText = true course_comment_tv_cancel.paint.isFakeBoldText = true course_comment_tv_confirm.paint.isFakeBoldText = true course_comment_seek_bar.max = 10 course_comment_seek_bar.progress = 0&#125; 多层级判空示例未使用apply之前 1234567891011if (mSectionMetaData == null || mSectionMetaData.questionnaire == null || mSectionMetaData.section == null) &#123; return;&#125;if (mSectionMetaData.questionnaire.userProject != null) &#123; renderAnalysis(); return;&#125;if (mSectionMetaData.section != null &amp;&amp; !mSectionMetaData.section.sectionArticles.isEmpty()) &#123; fetchQuestionData(); return;&#125; 使用apply之后 123456789mSectionMetaData?.apply&#123;//mSectionMetaData不为空的时候操作mSectionMetaData&#125;?.questionnaire?.apply&#123;//questionnaire不为空的时候操作questionnaire&#125;?.section?.apply&#123;//section不为空的时候操作section&#125;?.sectionArticle?.apply&#123;//sectionArticle不为空的时候操作sectionArticle&#125; 内联扩展函数-alsoalso函数和let很像，唯一的不同点就是： let函数最后的返回值是：最后一行的返回值； also函数的返回值是：返回当前对象。 also函数一般可用于：多个扩展函数链式调用 总结 泛型]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin与Java-基础篇]]></title>
    <url>%2FKotlin%E4%B8%8EJava-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Kotlin与Java-基础篇 Kotlin源码：https://github.com/JetBrains/kotlinKotlin官网：http://kotlinlang.org/Kotlin官方文档：http://kotlinlang.org/docs/reference/Kotlin标准库（Kotlin除了能调用Java自有库，还可以在此库上进行一系列的扩展（Extension）和必要的封装）：http://kotlinlang.org/api/latest/jvm/stdlib/index.html 历史趣闻Kotlin基础JVM，由JetBrains公司开发的静态类型语言（在编译器检查变量或者表达式的数据类型），目标是取代Java语言。该公司开发了 Java开发集成工具：IntelliJ IDEA，因此对于Java语言相当深入了解。 于是：2010年构思；2011年推出；2012开源；2016稳定版：Kotlin 1.0；2017年 Google I/O 宣布 Kotlin 为 Android 开发一级语言。 命名缘由：Kotlin语言是由俄罗斯圣彼得堡罗斯团队设计与开发的，名字源自圣彼得堡以西30千米芬兰湾中的 科特林岛。 编译过程 通过以上两张对比图，可以看出两种语言在运行过程的相似与不同之处。 编译： Java：javac 文件名+后缀 Kotlin：kotlinc 文件名+后缀 或者：kotlinc 文件名+后缀 -include-runtime -d 文件名.jar 运行： Java：java 编译后的文件名（无后缀） Kotlin：kotlin 编译后的文件名（无后缀） 或者 java -jar 编译后的文件名.jar 特点 简洁 数据类 类型推导 Lambda表达式 函数式编程 安全 避免空指针异常（默认情况下Kotlin的数据类型声明的变量都不能接受空值） 类型推导：Kotlin编译器根据变量所在的上下文环境推导出它的数据类型，这样可以无需对变量指定数据类型。 函数式编程 代码简洁、增强线程安全、便于测试 函数式编程是面向对象编程的补充 支持面向对象 面向对象便于系统分析和设计 与Java具有良好的互操作性 Kotlin基础Any类是Kotlin中所有类的基类，类似于Java中的Object。 语法基础 标识符 关键字 常量、变量 表达式 标识符 区分大小写 首字符：字母、_，不能是 数字。 除首字符外，其他字符可以是 字母、_、数字 硬关键字 不能作为标识符，软关键字、修饰符关键字在非特定场景可以使用。 注意： it 标识符用于 Lambda 表达式中，在省略了参数列表的情况下作为隐式参数（不需要声明即可使用）。 关键字要作为标识符，需要前后加 （`） Kotlin中字母采用的双字节 Unicode 编码。 关键字 硬关键字：在任何情况下都不能作为关键字， 软关键字；在其适用的场景中不能作为标识符，但是在其他环境中可以使用。 修饰符关键字：特殊的软关键字。 变量与常量 变量：在标识符前添加： var， 即可标示此 标识符 是一个 变量 常量 与 只读变量：一旦初始化后 就不能再修改了，在 标识符 前 添加 val 或者 const val 关键字 ，其区别是： val 表示：运行期常量，相当于Java 中的 final。该常量是在运行时初始化的； const val 表示 ：编译期常量，相当于Java 中的 public final static。该常量是在编译期初始化的。 并且只能是：顶层常量、或对象中的常量，而且只能是 String 或 基本数据类型 例如： 12val num = 10num = 2 在编译 num = 20 时，会报错： 1val cannot be reassigned 意思是：val无法重新分配 注释同Java 表达式语句：同行一条语句可以不写;，同行多条语句要写 ;表达式：可以直接使用：1var num = 10 也可以使用 1var num: int = 10 if语句 12345val num1 = 10;val num2 = 20;var result = if(num2 &gt; num1) &quot;大&quot; else &quot;小&quot;println(result) 结果： 1大 表达式函数体 123fun sum(a: Int, b: Int): Int = a + bval getSum = sum(4,9)println(getSum) 结果： 113 省略 表达式末尾的 ; 无返回值的函数 Unit 非嵌套 Lambda表达式中 隐式参数 it。 数据类型 Kotlin难点：数值类型相互转换 Kotlin特色：可空类型 基本数据类型：4类8种 整数型：Byte（1字节）、Short（2字节）、Int（4字节）、Long（8字节）。默认 Int 浮点型：Float（4字节）、Double（8字节）。默认 Double 字符型：Char（采用Unicode编码，2字节） 布尔型：Boolean 注意： 在Kotlin中，一个整数变量为Long类型时，表示为：16L。 较大数字常量可用 _ 进行分割。如：160_000_000L. 36.66 表示是 Double类型，在Kotlin中不能加D或者d。 36.66f 表示是Float类型 在Kotlin中，Char类型必须用 &#39;&#39;引起来。 数值类型间的转换赋值 - 显示转换在Kotlin中，6种数据类型（Byte、Short、Int、Long、Float、Double）与Char类型通过如下方式进行 任意转换： 1234567toByte()：BytetoShort()：ShorttoInt()：InttoLong()：LongtoFloat()：FloattoDouble()：DoubletoChar()：Char 数学计算 - 隐式 转换计算规则如下： 类型1 类型2 结果类型 Byte Byte Int Byte Short Int Byte、Short Int Int Byte、Short、Int Long Long Byte、Short、Int、Long Float Float Byte、Short、Int、Long、Float Double Double 非空类型Kotlin默认情况下所有的数据类型都是非空类型（Non-Null），声明的变量都是不能接受空值（null）的，这种设计能有效的防止空指针的产生。 如： 12var test: Int = 19test = null 运行结果为： 123HelloKotlin.kt:28:9: error: null can not be a value of a non-null type Int test = null ^ 可空类型描述一种情景：当执行数据库查询操作时，如果没有查询到结果，那么在给变量赋值时，就会 赋一个空值给 变量。而且这种情况是无法避免的。所以，在Kotlin中有了 可空类型 这一概念。 所以Kotlin为每一种非空类型的提供了对应的可空类型（Nullable），具体表现是：在每一种数据类型后面添加 ?，由此即可表示：可空类型。 如： 123var test: Int? = 19test = nullprintln(test) 结果为： 1null 注意：可空类型在使用时的一些限制 不能直接调用可空类型对象的函数或者属性 不能把可空类型数据赋值给非空类型变量 不能把可空类型数据传递给非空类型参数的函数 可空类型的运算符安全调用：?.可空类型变量 使用 ?. 可以调用非空类型的函数和属性。?. 会判断可空类型变量 是否为空：为空-不会调用函数或属性，直接返回空值；不为空-调用函数或属性 如： 1234567891011fun sum(a1:Int, a2:Int): Double?&#123; if (a2 == 0)&#123; return null &#125; return a1.toDouble()/a2&#125;var getNum = sum(20,20)println(getNum)var getNum2 = getNum?.plus(100)println(getNum2) 结果为： 121.0101.0 修改后 ： 1234567891011fun sum(a1:Int, a2:Int): Double?&#123; if (a2 == 0)&#123; return null &#125; return a1.toDouble()/a2&#125;var getNum = sum(20,0)println(getNum)var getNum2 = getNum?.plus(100)println(getNum2) 结果为： 12nullnull 安全转换：as?非空断言：!!可空类型变量 可以使用 !! 来调用 非空类型的函数或属性。非空断言 == 断言非空 断言 可空类型变量不会为空 ，如果可空类型变量为空，则报异常。 如： 1234567891011fun sum(a1:Int, a2:Int): Double?&#123; if (a2 == 0)&#123; return null &#125; return a1.toDouble()/a2&#125;var getNum3 = sum(20,0)println(getNum3)var getNum4 = getNum3!!.plus(100)println(getNum4) 结果为： 123nullException in thread &quot;main&quot; kotlin.KotlinNullPointerException at HelloKotlinKt.main(HelloKotlin.kt:56) 修改后： 1234567891011fun sum(a1:Int, a2:Int): Double?&#123; if (a2 == 0)&#123; return null &#125; return a1.toDouble()/a2&#125;var getNum3 = sum(20,40)println(getNum3)var getNum4 = getNum3!!.plus(100)println(getNum4) 结果为： 120.5100.5 Elvis （空值合并）: ?:当 可空类型 的值真的为空时，但是有不能返回一个 默认值，想要返回一个 自定义的默认值，此时就可以使用 合并空值运算符，将 自定义的默认值 作为默认值返回。 如： 1234567891011fun sum(a1:Int, a2:Int): Double?&#123; if (a2 == 0)&#123; return null &#125; return a1.toDouble()/a2&#125;var getNum5 = sum(20,0)println(getNum5)var getNum6 = getNum5?.plus(100) ?: 90println(getNum6) 结果为： 12null90 字符串 字符串字面量 不可变字符串 可变字符串 正则表达式 字符串字面量注意： 普通字符串：&quot;&quot; 1如果遇到 &quot;&quot;，这种情况即：空字符串。空字符串不是 null，因为空字符串会分配地址，而 null 是 不会分配内存地址的。 原始字符串 ：&quot;&quot;&quot; 字符串在代码中是如何编写的，在输出的时候就会按照原样输出。 例如： 1234 println(&quot;Hello \nworld&quot;) println(&quot;&quot;&quot;Helloworld&quot;&quot;&quot;) 结果为： 1234Hello worldHelloworld 如果修改为： 1234println(&quot;Hello \nworld&quot;)println(&quot;&quot;&quot;Hello world&quot;&quot;&quot;) 结果为： 1234Hello worldHello world 不可变字符串String类型字符串不可变；StringBuilder类型 字符串可变。 字符串模板语法： 12$变量或常量$&#123;表达式或单个变量、常量&#125; 控制流程 分支：if、when 循环：while、do-while、for 跳转：break、continue、return whenC语言风格的 switch 只能比较离散的单个的整数类型；而 Kotlin 的 when 则可以比较 整数、浮点、字符、字符串甚至任何可以比较的 类型表达式，比较的数据可以是离散的也可以是连续的。 例子： 1234567891011var gradle = when (testSource / 10) &#123; 9 -&gt; println(&quot;优秀&quot;) 8 -&gt; println(&quot;良&quot;) 7 -&gt; println(&quot;中&quot;) else -&gt; println(&quot;差&quot;)&#125;var gradle2 = when &#123; 100 &gt; 90 -&gt; &quot;对了&quot; else -&gt; &quot;错了&quot;&#125; forKotlin中的for语句与Java的for语句不同，仅相当于Java的增强for循环，仅适用于对：范围、数组或集合遍历。 如： 范围： 123for (num in 1..9) &#123; println(&quot;$num * $num = $&#123;num * num&#125;&quot;)&#125; 结果为 1234567891 * 1 = 12 * 2 = 43 * 3 = 94 * 4 = 165 * 5 = 256 * 6 = 367 * 7 = 498 * 8 = 649 * 9 = 81 遍历 1234var intArr = intArrayOf(34, 12, 23, 45, 67, 78, 89)for (item in intArr) &#123; println(&quot;item is $item&quot;)&#125; 结果为 1234567item is 34item is 12item is 23item is 45item is 67item is 78item is 89 或者 123for (i in intArr.indices) &#123; println(&quot;intArr[$i]index is $&#123;intArr[i]&#125;&quot;)&#125; 结果为 1234567intArr[0]index is 34intArr[1]index is 12intArr[2]index is 23intArr[3]index is 45intArr[4]index is 67intArr[5]index is 78intArr[6]index is 89 break语句：强制退出循环体语法： break：仅仅跳出当前循环 break@labe1：跳出labe1指定的整个循环 例如： 12345678910111213141516171819for (i in intArr.indices) &#123; if (i == 2) &#123; break &#125; println(&quot;intArr[$i]index is $&#123;intArr[i]&#125;&quot;)&#125;labe1@ for (i in intArr.indices) &#123; for (n in 6 downTo 1 step 2) &#123; println(&quot;n is $n&quot;) if (i == 2) &#123; break@labe1 &#125; println(&quot;intArr[$i] -- index is $&#123;intArr[i]&#125;&quot;) &#125;&#125; 结果为： 123456789101112131415intArr[0]index is 34intArr[1]index is 12n is 6intArr[0] -- index is 34n is 4intArr[0] -- index is 34n is 2intArr[0] -- index is 34n is 6intArr[1] -- index is 12n is 4intArr[1] -- index is 12n is 2intArr[1] -- index is 12n is 6 continue使用同 break 123456for (i in intArr.indices) &#123; if (i == 2) &#123; continue &#125; println(&quot;intArr[$i]index is $&#123;intArr[i]&#125;&quot;)&#125; 结果为： 123456intArr[0]index is 34intArr[1]index is 12intArr[3]index is 45intArr[4]index is 67intArr[5]index is 78intArr[6]index is 89 添加labe标签 123456789labe1@ for (i in intArr.indices) &#123; for (n in 6 downTo 1 step 2) &#123; println(&quot;n is $n&quot;) if (i == 2) &#123; continue@labe1 &#125; println(&quot;intArr[$i] -- index is $&#123;intArr[i]&#125;&quot;) &#125;&#125; 结果为： 12345678910111213141516171819202122232425262728293031323334353637n is 6intArr[0] -- index is 34n is 4intArr[0] -- index is 34n is 2intArr[0] -- index is 34n is 6intArr[1] -- index is 12n is 4intArr[1] -- index is 12n is 2intArr[1] -- index is 12n is 6n is 6intArr[3] -- index is 45n is 4intArr[3] -- index is 45n is 2intArr[3] -- index is 45n is 6intArr[4] -- index is 67n is 4intArr[4] -- index is 67n is 2intArr[4] -- index is 67n is 6intArr[5] -- index is 78n is 4intArr[5] -- index is 78n is 2intArr[5] -- index is 78n is 6intArr[6] -- index is 89n is 4intArr[6] -- index is 89n is 2intArr[6] -- index is 89 区间（Range） 闭区间：下临界值 &lt;= 范围 &lt;= 上临界值，采用(..)表示 半开区间： 下临界值 &lt;= 范围 &lt; 上临界值，采用(until) 其中：范围 在Kotlin中只有3种类型的数据： IntRange LongRange CharRange 例子： 1234567for (num in 1..4) &#123; println(&quot;$num * $num = $&#123;num * num&#125;&quot;)&#125;for (num in 1 until 4) &#123; println(&quot;$num * $num = $&#123;num * num&#125;&quot;)&#125; 结果为： 12345671 * 1 = 12 * 2 = 43 * 3 = 94 * 4 = 161 * 1 = 12 * 2 = 43 * 3 = 9 函数分类： 顶层函数：在一个类外部声明的函数 成员函数：在一个类内部声明的函数 局部函数：在一个函数内部声明的函数 匿名函数：不需要函数名 声明格式1234fun 函数名（参数 1，参数2，..）：返回值类型&#123; 函数体 return 返回值&#125; 无返回值时，函数返回值类型为 Unit（表示数据无实际意义）（类似于Java中的void），可以不写，同时return语句也可以忽略不写。 Nothing类型：只能用在函数返回值类型中，表示：永远不会有正常返回值，只会抛出异常。 函数参数- 不可变传参数时使用：参数名在传参数时使用参数名可以打乱函数定义时：参数的顺序 ，如 例子中的 第3行。有一点需要注意：当第一个参数使用了参数名时，后续的参数都要使用参数名。可以最后一个参数 使用参数名，前面的其他参数不使用参数名。 例子： 12345getArea(10.0,7.0)getArea(width = 10.0,height = 7.0)getArea(height = 10.0,width = 7.0)getArea(10.0,height = 7.0)//getArea(width = 10.0,7.0) 结果为： 123410.0 * 7.0 = 70.010.0 * 7.0 = 70.07.0 * 10.0 = 70.010.0 * 7.0 = 70.0 函数声明时：设置默认值 例如： 1234567fun makeTea(tyep: String = &quot;绿茶&quot;)&#123; println(&quot;您要的是$tyep&quot;)&#125;makeTea()makeTea(&quot;花茶&quot;) 结果： 12您要的是绿茶您要的是花茶 函数参数-可变对比Java中的可变参数 Java中的可变参数Java中可变参数规则： 可变参数前面可以有其他参数，但是可变参数只能出现在参数列表的最后 用...代表可变参数，...位于变量类型和变量名之间 调用含有可变参数的方法时，编译器为该可变参数隐式创建一个数组，在方法体中以数组的形式访问可变参数 如： 123456789101112131415public class TestVariableParemeters &#123; public static void main(String[] args) &#123; new TestVariableParemeters().addNumbers(&quot;liuliqianxiao&quot;, 1, 2, 3, 4, 5); &#125; public int addNumbers(String name, int... args) &#123; int result = 0; for (int i = 0; i &lt; args.length; i++) &#123; result += args[i]; &#125; return result; &#125;&#125; Kotlin中的可变参数Kotlin中可变参数规则： 可变参数 不必 是函数的参数列表中的 最后一个 用vararg paramName: paramType格式声明一个可变参数 和Java一样，在函数体内部，可以以数组的形式使用这个可变参数的形参变量 1、一个简单的示例： 123456789fun sumMult(vararg numbers: Int) &#123; var total = 0; for (item in numbers) &#123; total += item &#125; println(&quot;total is $total&quot;)&#125;sumMult(1, 2, 4, 5, 7, 9) 结果： 1total is 28 2、当 可变参数 不是第一个参数时 123456789fun sumMult2(vararg numbers: Int, idName: String) &#123; var total = 0; for (item in numbers) &#123; total += item &#125; println(&quot;$idName is $total&quot;)&#125;sumMult2(3, 2, 5, 6, 7, 8, idName = &quot;求和&quot;) 结果： 1求和 is 31 3、 可变、多种类型的参数 例如： 1234567fun sumMult3(vararg args:Any)&#123; for (it in args) &#123; print(&quot;$it &quot;) &#125;&#125;sumMult3(&quot;A&quot;,&apos;B&apos;,10,20f,40.0,true) 结果： 1A B 10 20.0 40.0 true 4、 函数参数是 可变参数 的情况下，直接传入数组 1234567891011fun sumMult2(vararg numbers: Int, idName: String) &#123; var total = 0; for (item in numbers) &#123; total += item &#125; println(&quot;$idName is $total&quot;)&#125;var intArrVal = intArrayOf(1,2,5,7,8)sumMult2(*intArrVal,idName = &quot;通过数组参数直接传入，需要添加*&quot;) 结果： 1通过数组参数直接传入，需要添加* is 23 5、 表达式函数体 例如 12fun getArea2(width:Int, height:Int) = width * heightprintln(getArea2(10,8)) 结果： 180]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart/Flutter]]></title>
    <url>%2FDart-Flutter%2F</url>
    <content type="text"><![CDATA[Dart/Flutter 相关链接： Google工程师 Xiao Yu 在 6 月成功举办的 2018 全球大前端技术大会（GMTC）中进行的演讲视频 ，视屏中的 演讲内容链接 2018 Google 开发者大会现场纪要 - Flutter Flutter中文社区 Flutter github地址 移动端跨平台开发演变WebView AppCan 优势：跨平台、两端一致的视觉体验，几乎可以完全继承现代Web开发的所有成果。对于Web开发人员，不需要太多的学习和迁移成本就可以开发一个App缺点：对于性能、体验。WebView的性能与JS的执行效率问题。 Android多版本、多厂商使得这一点更难以保证。 类似:React NativeFacebook的React Native，阿里巴巴的Weex都采用了前端系的DSL方案使用类HTML+JS的UI构建，将渲染工作通过JavaScript Engine交还给系统生成的原生控件。将框架与开发者都锁定了在系统原生的控件上，需要随着版本和API的变化，开发者要关注两端之间的差异。 RN简单原理图： （图片来自网络） Flutter1. 安装1.1 Flutter 集成SDK下载 安装Flutter过程中已经集成了Dart的SDK，因此不需要单独下载。 方式1：命令行 Flutter git源码下载 下载 Flutter SDK 之前先要拉取 Flutter 的 git 源码，执行命令（官方提示：） 1git clone -b beta https://github.com/flutter/flutter.git 更改配置文件 下载结束后，在当前用户目录下的 配置文件 添加： export PATH=$PATH:/Users/yannischeng/FLutter/flutter/bin 添加完毕后：保存、刷新。 方式2：通过官网链接下载 https://flutter.io/docs/get-started/install 1.2 单独下载 Dart SDK如果是要熟悉 Dart的语法，那么也可以单独安装Dart SDK。 12$ brew tap dart-lang/dart$ brew install dart 查看相关信息： 1$ brew info dart 2. 执行 flutter doctor 进行安装检测终端中执行命令： 1flutter doctor 下载完所有的数据后，会提示：Doctor summary (to see all details, run flutter doctor -v) 即：运行此命令查看当前的配置 详细 信息，如果去掉 -v 仅显示 简略 信息 1flutter doctor -v 所需文件下载结束后的目录 插件安装 Flutter插件 支持Flutter开发人员 工作流程（运行，调试，热重新加载等）。 Dart插件 提供 代码分析（键入时的代码验证，代码完成等）。 在 Android Studio 中 在 VS Code 中 项目创建在日常开发的基础上，一般不需要做太多其他的工作。 创建方式1：Android Studio新建 最新的创建类型：4种 较早的创建类型：3种 创建类型 select an Application when building for end usrs.(为最终用户构建时选择“应用程序”。) Select a Plugin when exposing an Android or iOS API for developers.(为开发人员公开Android或iOS API时选择“插件”) Select a Package when creating a pure Dart component, like a new Widget.(创建纯Dart组件时选择“包”，如新的Widget) Select a Module when creating a Flutter component to add to an Android app.(在创建要添加到Android应用程序的Flutter组件时选择“模块”) 如果未安装SDK，在创建时会提示： 安装SDK后 finish 创建方式2：VS Code 执行 shift + com + p 调出 命令面板 在 命令面板输入框 输入 flutter，选择 Flutter: New Project 按照提示，输入 项目名称，然后按下 Enter 即创建成功 命令 通过指定开发语言来创建项目 1flutter create -i iOS开发语言 -a Android开发语言 文件名 查看当前已有的模拟器 1flutter emulators 启动模拟器 1flutter emulators --launch &lt;emulator id&gt; 运行项目至设备-所有设备 1flutter run -d all 运行项目至设备-单个设备 1flutter run -d &lt;deviceId&gt; 若是在终端中通过命令运行的程序，那么修改代码后，通过在终端中按下 1r 作用是 To hot reload changes while running ，若是执行 1R 作用是：To hot restart (and rebuild state) Flutter是什么一句话总结：跨平台、UI框架 Flutter 是谷歌的移动端 UI 框架，可在极短的时间内构建 Android 和 iOS 上高质量的原生级应用。项目代码开源，Dart是其官方编程语言，是 Google 未来新操作系统Fuchsia的默认开发套件（Fuchsia 是 Google 继 Android 与 Chrome OS后的第3个操作系统）。 Flutter的主要设计人之一Ian Hickson，之前是HTML规范编写者，因此Flutter的设计理念也与HTML的实现方法有很多相似之处。 Flutter的跨平台方案更为彻底，它既没有采用WebView也没有采用JavaScript，而是自己实现了自己的一种UI框架，直接在系统更底层渲染，使用另一种开发语言Dart。 Flutter所使用的Dart语言同时支持JIT和AOT运行方式： JIT(Just-In-Time：实时编译，即时编译)，适用于开发调试： 该模式下还有一个备受欢迎的开发利器 热加载（Hot Reload），即在Android Studio中编辑Dart代码后，只需要 com +s 或者 点击Hot Reload 按钮，就可以立即更新到正在运行的设备上，不需要重新编译App，甚至不需要重启App，立即就可以看到更新后的样式。 (Ahead-Of-Time：预先编译，静态编译)，适用于部署发布： 支持AOT的Dart语言，执行效率也比JavaScript高得多。 Flutter学习了RN的UI编程方式，引入了状态机，更新UI时只更新最小改变区域 Flutter简单原理图： （图片来自网络） Flutter同时支持Windows、Linux和macOS作为开发环境，并且在Android Studio和VS Code两个IDE上都提供了全功能的支持 Flutter目标 有什么特点 一切皆为widget，所有功能都可以通过组合多个Widget来实现。 统一的应用开发体验 ：同一份代码，开发 iOS 和 Android 内置的 Material Design 和 Cupertino widget（iOS风格） 热重载 - Hot Reload 响应式框架 支持混合开发，可访问本地功能和SDK Flutter允许复用现有的Java、Swift或OC代码，访问iOS和Android上的 原生系统功能 和 系统SDK。 有什么问题 包变大 动态性 生态 发展 问题处理 没有反射 Dart并不是没有反射，dart:mirrors就具有Mirror概念的反射。在安全、分发、部署方面，Mirror-Base具有很大优势。但是反射生成的代码冗长，会使Flutter编译过后的包很大。Flutter通过将Dart编译成原生代码本身就会增加包大小，再加上反射的话包大小更会进一步扩大。所以Flutter团队在现阶段并没有开放dart:mirrors的使用。没有反射也就意味着Json String to Model 也没有办法完成，对于这一点，官方也比较无奈。 架构框架分为两个部分：Framework和Engine部分，其中Framework提供了各种基础的组件库，Engine部分渲染各种widget，两者共同作用，使得运行性能高效稳定。 （图片来自网络） Flutter跨平台最核心的部分，是它的高性能渲染引擎（Flutter Engine）。Flutter不使用浏览器技术，也不使用Native的原生控件，它使用自己的渲染引擎来绘制widget。 Framework Foundation：其中定义的大多是非常基础的、提供给其他所有层使用的工具类和方法。 Painting ：封装了Flutter Engine提供的绘制接口，主要是为了在绘制控件等固定样式的图形时提供更直观、更方便的接口 Animation：是动画相关的类，提供了类似Android系统的ValueAnimator的功能，并且提供了丰富的内置插值器。 Gesture：提供了手势识别相关的功能，包括触摸事件类定义和多种内置的手势识别器。 两套设计语言的控件实现Material 、 Cupertino，可以帮助App更好地在不同平台上提供原生的用户体验。 项目结构在 Android Studio 中创建的一个包含两个平台的宿主工程目录： Android项目目录展开： Flutter在本地运行时默认采用Debug模式，Debug模式下Flutter使用JIT方式来执行Dart代码 报错样式 Widget在 Flutter 中，一切皆 Widget ，Widget分类： 无状态 有状态 无状态 - StatelessWidget只能用来展示信息，不能有动作（用户交互），像是：用来展示静态的文本或者图片。 1234567class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build &#125;&#125; 有状态 - StatefulWidget可以通过改变状态使得 UI 发生变化，它可以包含用户交互。 123456789101112131415class FulWidget extends StatefulWidget&#123; @override State createState() &#123; // TODO: implement createState return FulWidgetState(); &#125;&#125;class FulWidgetState extends State&lt;FulWidget&gt;&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build &#125;&#125; Hot ReloadState的概念也是来源于Facebook的流行Web框架React，React风格的框架中使用控件树和各自的状态来构建界面，当某个控件的状态发生变化时，由框架负责对比前后状态差异并且采取最小代价来更新渲染结果。 混合开发Flutter插件Dart语言无法直接调用Android系统提供的Java接口，通过Flutter官方提供了丰富的原生接口封装，作为插件来实现中转： android_alarm_manager，访问Android系统的AlertManager。android_intent，构造Android的Intent对象。battery，获取和监听系统电量变化。connectivity，获取和监听系统网络连接状态。device info，获取设备型号等信息。image_picker，从设备中选取或者拍摄照片。package_info，获取App安装包的版本等信息。path_provider，获取常用文件路径。quick_actions，App图标添加快捷方式，iOS的eponymous concept和Android的App Shortcuts。sensors，访问设备的加速度和陀螺仪传感器。shared_preferences，App KV存储功能。url_launcher，启动URL，包括打电话、发短信和浏览网页等功能。video_player，播放视频文件或者网络流的控件。 依赖配置DartDart是谷歌开发的计算机编程语言，由ChromeV8引擎团队的领导者Lars Bak主持开发的Dart。于2011年10月份启动，可以被用于web、服务器、移动端和物联网等领域的开发，2017年9月发布第一个2.0-dev版本。Dart语言为了更好的适应 Flutter UI 框架，在内存分配和垃圾回收做了很多优化。 Dart本身提供了 三种 运行方式： 使用Dart2js编译成JavaScript代码，运行在常规浏览器中（Dart Web）。 使用DartVM直接在命令行中运行Dart代码（DartVM）。 AOT方式编译成机器码，例如Flutter App框架（Flutter）。 特点： 代码体积优化（Tree Shaking），编译时只保留运行时需要调用的代码 跨平台，iOS和Android共用一套代码。 JIT &amp; AOT运行模式，支持开发时的快速迭代和正式发布后最大程度发挥硬件性能。 垃圾回收与线程 垃圾回收： DartVM的内存分配策略非常简单，创建对象时只需要在现有堆上移动指针，内存增长始终是线形的，省去了查找可用内存段的过程。 垃圾回收也是采用了多生代算法垃圾回收器，新生代在回收内存时采用了“半空间”算法，触发垃圾回收时Dart会将当前半空间中的“活跃”对象拷贝到备用空间，然后整体释放当前空间的所有内存。整个过程中Dart只需要操作少量的“活跃”对象，大量的没有引用的“死亡”对象则被忽略，专门为UI框架中常见的大量Widgets对象创建和销毁优化。 （图片来自网络） 基本概念： 所有变量的值都是对象：类的实例、甚至数字、函数和null也都是对象，都继承自Object类。 虽然Dart是强类型语言，但是显式变量类型声明是可选的，Dart支持类型推断。如果不想使用类型推断，可以用dynamic类型。 Dart没有public、protected和private这些关键字，使用下划线 _ 开头的变量或者函数，表示只在库内可见。 Flutter 使用感受以下截图是开发者使用后的比较典型的感受： 1： 2： 最终总结引用：]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Dart/Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle描述]]></title>
    <url>%2FGradle%E6%8F%8F%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Gradle概览描述 参考：《Android Gradle 权威指南》参考：Gradle完整指南官网参考：https://docs.gradle.org/current/dsl/ 一句话总结：Gradle 是基于 Groovy 的 DSL GradleGradle 脚本类型 脚本类型 委托对象 实例与对应 设置脚本 Settings Settings实例 对应 settings.gradle文件 构建脚本 Project Project实例 对应 build.gradle文件 初始化脚本 Gradle 通过Project.getGradle()调用获取实例 每种类型均实现了 Script 接口。此接口定义了许多可在脚本中使用的属性和方法。 Settings作用：多项目构建。允许声明要包含在构建中的 项目（Android中的Module）。在构建中始终包含在 Settings 创建对象时自动添加的 根项目。 Project此接口时从构建文件与Gradle交互的主要API。 一个 Project 和 build.gradle 文件之间存在 一对一 的关系。在构建初始化期间，Gradle Project为 每个 参与构建的项目组装一个对象。 Gradle脚本块 之间的关系 Gradle中2个重要的概念 project task projectGradle任务 - taskTaskContainer task创建自定义一个简单的 task ： 123task hello&#123; println'Hello Gradle'&#125; 在自定义的过程中，我们可能认为 task 是一个 关键字，但是实际上 task 是一个方法。在 public interface Project 中是如下声明的： 1234567891011//在Project 中的声明1：Task task(String name) throws InvalidUserDataException;//在Project 中的声明2：Task task(Map&lt;String, ?&gt; args, String name) throws InvalidUserDataException;//在Project 中的声明3：Task task(Map&lt;String, ?&gt; args, String name, Closure configureClosure);//在Project 中的声明4：Task task(String name, Closure configureClosure); 由此，我们看到有4种task创建方式。在Android Studio的配置文件中，实际使用最多的就是： 12//在Project 中的声明4：Task task(String name, Closure configureClosure); 这个声明中有两个参数 String name, Closure configureClosure。其中，name 就是task的名字，而 configureClosure 就是一个闭包（代码块）。 所以 我们对于 .gradle 文件的配置实际上的操作就是：task(task名称, 闭包) 但是： 我们发现，我们具体自定义的 task 似乎和 声明的样式不同，按照声明方式，我们自定义的task的写法应该为： 123task(hello,&#123; println 'Hello Gradle'&#125;) 这一点，在 Groovy语法-5闭包-5.1迭代 中已经有了说明：当闭包作为一个方法的最后一个参数时，是可以写到 () 外面的，而且 Groovy 语法允许一个方法去掉 ()，于是就有了本小节一开头看到的一个 自定义task的写法。常见、实际书写样式都是根据 Groovy的特殊语法 而写的。 了解这样的一个 书写样式变化过程 ，既有助于加深我们对于 Groovy语法的了解，同时也能与Java语法作出对比。 task访问task描述task依赖任务和任务之间是由依赖的，通过依赖关系决定任务之间彼此的先后顺序。 单依赖： 1234567891011task helloSecond&#123; doLast&#123; println "this is helloSecond" &#125;&#125;task helloMain(dependsOn:helloSecond)&#123; doLast&#123; println "main: " &#125;&#125; 结果: 12345&gt; Task :helloSecondthis is helloSecond&gt; Task :helloMainmain: 多依赖： 12345678910111213141516171819task helloSecond&#123; doLast&#123; println "this is helloSecond" &#125;&#125;task helloMain(dependsOn:helloSecond)&#123; doLast&#123; println "main: " &#125;&#125;task helloMain2&#123; dependsOn helloSecond,helloThird doLast&#123; println "main: " &#125;&#125; 结果： 12345678&gt; Task :helloSecondthis is helloSecond&gt; Task :helloThirdthis is helloThird&gt; Task :helloMain2main: 其中，dependsOn 是 Task 类中的一个方法： 1Task dependsOn(Object... paths); 任务间的API调用提前亮出结论：我们创建的每一个 任务 都会作为 Project 的一个 属性。任务名 就是 属性名。 123456789101112131415161718192021task helloSecond&#123; doLast&#123; println "this is helloSecond" &#125;&#125;helloSecond.doLast&#123; println "helloSecond API doLast"&#125;helloSecond.doFirst&#123; println "helloSecond API doFirst"&#125;task helloMain2&#123; println project.hasProperty('helloSecond') dependsOn helloSecond,helloThird doLast&#123; println "main do" &#125;&#125; 结果： 1234&gt; Task :helloSecondhelloSecond API doFirstthis is helloSecondhelloSecond API doLast 以上这段代码的表达的是：通过调用 helloSecond 任务的 API，在该任务 执行前doLast 和 执行后doLast 做一些操作。 代码 project.hasProperty(&#39;helloSecond&#39;) 的意思是 ：检测属性 helloSecond 是否存在，若为 true 就是 存在。 通过查看 Task 的源码，发现在此接口中，是存在多个 1Task doLast(); 的。调用 一个 任务名 的API，就像是 Java 中调用一个 类的实例对象 的方法。所以： 12在 Gradle 中声明一个任务，“不严谨但是形象” 的可以说是：声明了某一类的一个具体实例对象；一个任务名调用API，“不严谨但是形象” 的可以说是：实例对象调用自身的属性或方法。 自定义属性在 Project 和 Task 中均可以添加 自定义属性。 在 Project 中声明 自定义属性： 1234567891011121314// 声明一个属性ext.age = 18// 声明多个属性ext &#123; phone = 6666666 address = "bj"&#125;task showExt&#123; println "age is $&#123;age&#125;" println "phone is $&#123;phone&#125;" println "address is $&#123;address&#125;"&#125; 结果为： 123age is 18phone is 6666666address is bj 为某一个 Task 声明 自定义属性： 12345678910111213141516171819sourceSets.all&#123; ext.sourceDir = ""&#125;sourceSets&#123; main&#123; sourceDir = 'main/src' &#125; test&#123; sourceDir = 'test/src' &#125;&#125;task showExt&#123; sourceSets.each&#123; println "name is $&#123;it.name&#125;, sourceDir is : $&#123;it.sourceDir&#125;" &#125;&#125; 结果为： 12name is main, sourceDir is : main/srcname is test, sourceDir is : test/src 如果在 一个task方法中调用 sourceDir 属性: 123task showDir&#123; println "sourceDir is $&#123;sourceDir&#125;"&#125; 结果为： 1&gt; Could not get unknown property &apos;sourceDir&apos; for task &apos;:showDir&apos; of type org.gradle.api.DefaultTask. 这就表示，这个 自定义属性 是声明在 sourceSets 这个 task 中的，不是 Project 的。 &lt;&lt; 操作符先展示结论 1234567891011121314151617181920212223242526272829task helloThird&#123; doLast&#123; println "this is helloThird" &#125;&#125;task helloThird2 &lt;&lt; &#123; println "this is helloThird"&#125;task helloSecond&#123; doLast&#123; println "this is helloSecond" &#125;&#125;task helloSecond2 &lt;&lt; &#123; println "this is helloSecond"&#125;task helloMain2&#123; println project.hasProperty('helloSecond') dependsOn helloSecond,helloThird&#125;task helloMain3 &#123; println project.hasProperty('helloSecond') dependsOn helloSecond2, helloThird2&#125; 运行 1./gradlew helloMain3 结果为： 12345&gt; Task :helloSecond2this is helloSecond&gt; Task :helloThird2this is helloThird 运行 1./gradlew helloMain2 结果为： 12345&gt; Task :helloSecondthis is helloSecond&gt; Task :helloThirdthis is helloThird 由结论可以得出 &gt;&gt; 与 doLast 得到的结果是相同的，在作用上是可以替代的。&gt;&gt; 操作符在 Gradle 的 Task上是 doLast方法 的 短标记形式。 task的执行task 代码块中的本质是 actions 为什么 doFirst 、 doLast 能够在当前task 之前和 之后 处理添加的操作？ 源码： doFist()源码 12345678910111213@Overridepublic Task doFirst(final String actionName, final Action&lt;? super Task&gt; action) &#123; hasCustomActions = true; if (action == null) &#123; throw new InvalidUserDataException("Action must not be null!"); &#125; taskMutator.mutate("Task.doFirst(Action)", new Runnable() &#123; public void run() &#123; getTaskActions().add(0, wrap(action, actionName)); &#125; &#125;); return this;&#125; doLast()源码 12345678910111213@Overridepublic Task doLast(final String actionName, final Action&lt;? super Task&gt; action) &#123; hasCustomActions = true; if (action == null) &#123; throw new InvalidUserDataException("Action must not be null!"); &#125; taskMutator.mutate("Task.doLast(Action)", new Runnable() &#123; public void run() &#123; getTaskActions().add(wrap(action, actionName)); &#125; &#125;); return this;&#125; 共同点：在这两个方法的源码中，都存在一行代码： 1getTaskActions().add( …); 而这个 getTaskActions() 实际对应的就是： 1234567@Overridepublic List&lt;ContextAwareTaskAction&gt; getTaskActions() &#123; if (actions == null) &#123; actions = new ArrayList&lt;ContextAwareTaskAction&gt;(); &#125; return actions;&#125; 即：getTaskActions() 的返回值是 List&lt;ContextAwareTaskAction&gt;。这就解释了 doFirst，在执行本任务之前: 添加操作 1getTaskActions().add(0, wrap(action, actionName)); doLast， 在执行本任务之后: 添加操作 1getTaskActions().add(wrap(action, actionName)); task的排序task 的任务排序是通过 taskB.shouldRunAfter(taskA) 应该而非必须，不强制 taskB.mustRunAfter(taskA) 强制 任务的禁用1任务名.enabled = false 任务的 onlyIf 断言具体参考：《Android Gradle 权威指南》 P45 1任务名.onlyIf&#123; &#125; task的任务规则1addRuler() 闭包 - 代码块1. 简单的实现、调用123456789101112131415161718task getList &lt;&lt; &#123; customEach&#123; // 接收一个闭包 println it &#125;&#125;// getList 任务的第二种写法：task getList2 &lt;&lt; &#123; customEach(&#123;println it&#125;)&#125;def customEach(tempList)&#123; for(i in 1..10)&#123; tempList(i) &#125;&#125; 执行 1./gradlew getList 结果为： 1234567891011&gt; Task :getList12345678910 重点理解：tempList 与 tempList() 当执行多个参数时： 123456789101112task getMap &lt;&lt; &#123; customMap&#123;key, value -&gt; println "$&#123;key&#125;, $&#123;value&#125;" &#125;&#125;def customMap(tempMap)&#123; def maps = [name:"ZhangSan", age:24] maps.each&#123; tempMap(it.key, it.value) &#125;&#125; 执行 1./gradlew getMap 结果为： 123&gt; Task :getMapname, ZhangSanage, 24 2. 闭包委托 闭包的强大之处在于：支持闭包方法的委托。 Groovy 的闭包有 thisObject, owner, delegate 三个属性。当在闭包内调用方法时，由他们来决定调用那个对象进行处理。 默认情况下： owner 与 delegate 是相等的，但是 delegate 是可以被修改的，Gradle中的闭包的很多功能都是通过修改 delegate 实现的。 方法处理顺序：thisObject &gt; owner &gt; delegate Gradle插件应用方式应用方式在源代码中有 3种 声明方式： 12345678// Map形式void apply(Map&lt;String, ?&gt; options);// 闭包形式void apply(Closure closure);// Action形式void apply(Action&lt;? super ObjectConfigurationAction&gt; action); 二进制方式二进制插件一般是被打包在jar中独立发布的，发布的时候可以为其指定 plugin id。 实现了 org.gradle.api.Plugin 接口的插件，他们会有 plugin id(Gradle自带的核心插件都有一个容易记的短名)。例如：方式1（用的最多） 1apply plugin:'java' 其中，java 就是 插件的 plugin id。 除了直接可以应用 plugin id外，也可以应用其对应的类型，例如：方式2（适用于自定义插件） 1apply plugin:org.gradle.api.plugins.JavaPlugin 因为包名是默认导入的，可以直接去掉包名。所以简写为：方式3 1apply plugin:JavaPlugin 脚本方式1234567891011apply from:'version.gradle'task showVersion&#123; println "versionName is $&#123;versionName&#125;, versionCode is $&#123;versionCode&#125;"&#125;// version.gradleext&#123; versionName = 'first' versionCode = '0.1'&#125; 执行 1./gradlew showVersion 结果为： 1versionName is first, versionCode is 0.1 第三方插件应用方式如果开一个插件已经被配置在 https://plugins.gradle.org/ 的网站上，则可以通过 plugins 执行 123plugins&#123; id 'base'&#125; 如果在 https://plugins.gradle.org/ 上不存在，则是通过 buildscript 中的 classpath引用。步骤为： 第1步：添加 插件路径 ：classpath &#39;com.android.tools.build:gradle:3.1.3&#39; 在 123456789buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.3' &#125;&#125; 第2步：应用 1apply plugin: &apos;com.android.application&apos; 自定义插件方式方式： 本地脚本方式共享jar包方式依赖添加依赖语句结构1'io.reactivex.rxjava2:rxjava:2.1.9' 以上语句以 : 最为分割，各个部分分别为： 1group:name:version 依赖的添加； 在 buildscript 中添加路径： 12345678910111213141516171819202122232425262728buildscript &#123; // 路径仓库设置 repositories &#123; // 方式1：各个中心库 google() mavenCentral() // 方式2：私服 maven &#123; url "http://XXX" &#125; &#125; // 依赖 dependencies &#123; // 仓库中的具体依赖项目 classpath 'xxx:xxx:xxx' // 依赖一个Gradle中配置过的项目 compile project(':app1') //依赖指定的文件包 compile files('libs/xxx.jar', …) // 添加一类（全部）文件包 (指定路径下的，指定类文件) compile fileTree(dir: 'libs', include: '*.jar') &#125;&#125; SourceSet 源代码集合这是用来描述和管理 源代码 以及 资源文件 的一个抽象概念，是源代码和资源文件的集合。通过 sourceSets属性 和 sourceSets{}闭包 来访问配置集。 多项目构建构建发布gradle生成的产物——构建 Android Gradle 插件从Gradle的角度来看：Android Gradle 是由Android团队，基于Gradle开发的一个第三方插件。 提一句： Android 开发IDE：以 Intellij 为基础 Android 管理、构建：以 Gradle 为基础 Android 开发语言： Java 。 Android插件分类具体参考书中 第7章 apk 插件id : com.android.application lib包 插件id : com.android.library test测试 插件id : com.android.test Android Gradle 渠道配置：Zipalign优化混淆配置签名配置：SigningConfig默认配置：defaultConfig多渠道配置：productFlavors高级设置共享库批量修改Apk名称动态生成版本信息版本号构成（一般：3部分）：major:minor:patch，对应为：主版本号：副版本号:补丁号。 方式1：单独文件获取各个参数 要点1： 类比Java：把共有的信息抽出为一个单独的类，在需要使用这些单独抽出的数据时，引用这个类。在此处就是类比这种实现方式，在 Gradle 中，通过使用 apply from 引用 自定义的 .build 文件。 要点2： 从git的tag中获取 版本名称 要点3： 从git的tag中获取 版本号 方式2：建立属性文件动态获取隐藏签名文件信息—–动态配置 AndroidManifest 文件自定义 BuildConfig添加自定义资源Java编译选项adb选项清理未使用资源所谓的资源清理，其实不是从项目里删除无用的资源，而是根据我们的配置，将无用的资源不打包到Apk中。 shrink - BuildTypes 构建类型 使用步骤： 先开启 code shrink（开启代码混淆-收缩） 再开启 resource shrink （再开启资源收缩） 存在问题：误删 当使用反射时，会存在资源文件误删的情况，解决方式就是：通过Android Gradle 提供的 keep 方法来配置不能被清理掉的资源。 resConfig - ProductFlavor 渠道资源处理通过使用此项配置，可以根据当前的渠道设置相应的资源，可以有效的减少Apk体积。 使用方式： resConfigs：可以设置多个参数 resConfig：设置单个参数 Android Gradle 多项目构建Android 项目构建分为 lib、application、test。这3种。 在Gradle中，一个工程包含多个项目，而且项目的结构是表随意的。可以在 settings.gradle 文件中对各个项目的路径进行具体配置。 在 Gradle 中能够最终体现一个工程中有多少个项目是通过 settings.gradle 文件来声明的。 库项目的配置更改 库项目 的发布版本：123android&#123; defaultPublishConfig &quot;debug&quot;&#125; 通过添加此项配置后，发布的版本就是 debug 版本了。 需求：如何处理同时发布多个版本的 库 或者 aar包 以供不同的项目引用 123android&#123; publishNonDefault true&#125; 发布到 Maven 库 第一步：配置自己的Maven私有库 进行 Nexus Repository OSS 的下载，地址 https://www.sonatype.com/download-oss-sonatype 。 解压 执行命令 1234# 开启/Users/XXX/nexus-3.14.0-04/bin/nexus run# 关闭/Users/XXX/nexus-3.14.0-04/bin/nexus stop 开启成功后，在浏览器输入：http://localhost:8081/ 在不显示 404 的情况下点击右上角 Login 登录，用户名 admin，密码 admin123 。 第二步：配置 gradle 文件 添加 maven 插件 1apply plugin: 'maven' 配置 maven 构建 Maven构建3要素：group:artifact:version 12version '1.0.0'group 'ori.XXX.XX' 各个属性的解释（参考：https://blog.csdn.net/lovesomnus/article/details/40981063）： groupId 团体，公司，小组，组织，项目，或者其它团体。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。 artifactId 在groupId下的表示一个单独项目的唯一标识符。比如我们的tomcat, commons等。不要在artifactId中包含点号(.)。 version 一个项目的特定版本。发布的项目有一个固定的版本标识来指向该项目的某一个特定的版本。而正在开发中的项目可以用一个特殊的标识： SNAPSHOT（快照版本） 。 虽然项目的打包格式也是Maven坐标的重要组成部分，但是它不是项目唯一标识符的一个部分。一个项目的 groupId:artifactId:version 使之成为一个独一无二的项目；你不能同时有一个拥有同样的groupId, artifactId和version标识的项目。 Android Gradle Flavor 多渠道 构建要素多渠道构建的原理Android Gradle 构建的产物 Build Variant = Build Type（构建类型） + Product Flavor（渠道）。有了多个 渠道 之后，就会产生多个task，像是 assemble、compile、install等；配置多个渠道后，除了生成多个 task 外，还会根据渠道的配置拥有自己的 SourceSet（代码、资源文件）、自己的Dependencies 多渠道构建定制ProductFlavor 构建所需元素： applicationId 指定生成的App的包名 minSdkVersion最低支持的Android操作系统的版本 targetSdkVersion配置开发所基于的Android版本 maxSdkVersionversionCode配置Android APP 的内置版本号，是一个整数值，通常用于版本升级。 versionName配置Android APP 的版本名称。外部使用。 consumerProguardFilesmanifestPlaceHoldersmultiDexEnabledproguardFiles配置 APP ProGuard 混淆所使用的 ProGuard 配置文件，接受一个配置文件作为参数。 proguardFiles配置 APP ProGuard 混淆所使用的 ProGuard 配置文件，可同时接受多个配置文件作为参数。 signingConfig配置默认的签名信息，对生成的App签名。 testApplicationId配置测试APP的包名，默认情况下 是 applicationId + .test，一般情况下是默认的 。 testInstrumentationRunner配置单元测试时使用的Runner。 useJackdimensionresConfig、resValue、ndkAndroid Gradle BuildType 的构建类型要素applicationIdSuffix配置基于默认applicationId的后缀 debuggable配置是否生成一个可供调试的 apk jniDebuggable配置是否生成一个可供调试的Jni代码 apk minifyEnabled配置该 BuildType 是否启用 Proguard 混淆 multiDexEnabled配置该 BuildType 是否启动自动拆分多个 Dex 的功能 proguardFile同 defaultConfig中的 proguardFile proguardFiles同 defaultConfig中的 proguardFiles shrinkResources配置是否自动清理未使用的资源，默认false signingConfig配置签名 zipalign优化是Android提供一个整理优化apk文件的工具，提高系统和应用的运行效率，更快的读写apk中的资源，降低内存使用。 高速多渠道构建美团 http://tech/meituan.com/mt-apk-packaging.htmlhttps://github.com/GavinCT/AndroidMultiChannelBuildTool. 命令 - 直接、常用 查看各任务间的依赖关系 查看某个任务由哪些子任务组成，各个子任务之间存在着什么样的依赖关系，该命令只会按正确的顺序列出所有的子任务而不会去真正执行。 1./ 任务名 –dry-run（或 -m） 在命令行中为task设置参数 具体使用参考：《Android Gradle 权威指南》 P45 1./gradlew -P键名=值 其他参数 -P 含义是为 Project 指定 “K-V” 格式的属性键值对，使用格式为“-PK=V” 刷新gradle依赖缓存 1gradle build --refresh-dependencies 输出项目中定义的目录： 1./gradlew sourceSets 运行任务时，添加参数：查看具体细节 当我们执行 所有task 的时候我们都可以通过添加 --profile 参数生成一份执行报告，在reports/profile 中。这份报告是一个html文件。]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Groovy基础语法]]></title>
    <url>%2FGroovy%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Groovy基础语法 参考：精通 Groovy GroovyGroovy 是一门 动态语言 。Groovy 并没有取代 Java，而是作为 Java 的补充，它提供了更简单、更灵活的语法，它能够像 Java 语言本身一样很好地应用于 Java 平台。在编写新应用程序时，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。 Groovy 和 Java 语言的主要区别是：完成同样的任务所需的 Groovy 代码比 Java 代码更少。 Groovy概览Groovy与Java语法上的的不同 允许省略 分号 和 修改符。 除非另行指定，Groovy 的所有内容都为 public。 允许 定义简单脚本，同时无需定义正规的class 对象。 允许省略 变量类型。 类型松散的 动态语言。 Groovy特性 本地集合：在 Groovy 中，列表 和 映射 都内置在语法中 — 无需导入任何内容 内置的正则表达式：不需要额外的导入或对象 闭包：了解闭包 用 Groovy 编写的任何内容都可以编译成标准的 Java 类文件并在 Java 代码中重用。（groovyc编译，jvm） Groovy实际上就是JavaGroovy写法1： 1println "Hello, Word" 运行结果： 1Hello Word Groovy写法2： 12345public class Test1 &#123; public static void main(String[] aegs)&#123; System.out.println("Hello Word"); &#125;&#125; 运行结果： 1Hello Word 截图为证： Groovy基础语法 使用 def 关键字 0. 字符串特点 无论是 单引号 还是 双引号 都是 String 类型； 单引号不能对字符串里的表达式做运算，没有运算能力。双引号 可以。 例子： 12345def name = "zhangsan"println "name is : $&#123;name&#125;"println "name is : $name"println 'name is : $&#123;name&#125;' 结果为： 123name is : zhangsanname is : zhangsanname is : $&#123;name&#125; 一个表达式： 123&quot;$&#123;name&#125;&quot;#只有一个变量时，可以省略&#123;&#125;&quot;$name&quot; 1. 变量 - 无类型 Groovy 会根据对象的值来判断它的类型。 Groovy实现： 1234567def value = "Tt's show time!"println valueprintln value.classdef value2 = 12println value2println value2.class 结果： 1234Tt&apos;s show time!class java.lang.String12class java.lang.Integer 2. 循环 - 更短、更好 Groovy一般实现 1234567def show(value)&#123; for (int i = 0; i &lt;5; i++) &#123; println value &#125;&#125;show 'good apple' 结果： 12345good applegood applegood applegood applegood apple 对 循环条件 进行变化 123456789101112131415161718192021222324def show2(value)&#123; for (i = 0; i &lt;5; i++) &#123; println value &#125; println "\n" for (i in 0..4) &#123; println "show2 : " + value &#125; println "\n" for (i in 0..&lt;5) &#123; println "show2 : " + value &#125; println "\n" for (i in 1..5) &#123; println "show2 : " + value &#125;&#125; 更加丰富的实现 123456789def show3(value, num = 5) &#123; println "\n" for (i in 0..&lt;num) &#123; println "show3 : " + value &#125;&#125;show3 'good juice', 3 结果： 123show3 : good juiceshow3 : good juiceshow3 : good juice 3. 集合Groovy 可以直接在语言内使用集合，不需要导入专门的类，也不需要初始化对象，集合是语言本身的本地成员。 List1234567891011121314def coll = ["Groovy", "Java", "Android"]println coll.getClass()println collassert coll instanceof Collectionprintln collassert coll instanceof ArrayListprintln collcoll.add("OC")println collcoll &lt;&lt; "Python"println collcoll[5] = "C"println coll 结果为 1234567class java.util.ArrayList[Groovy, Java, Android][Groovy, Java, Android][Groovy, Java, Android][Groovy, Java, Android, OC][Groovy, Java, Android, OC, Python][Groovy, Java, Android, OC, Python, C] 访问元素 123println coll[1]println coll[-1]println coll[1..2] 结果为： 123JavaAndroid[Java, Android] 集合常用 —— 范围索引:1..2 4. 映射生成写法： 1def hash = [name:'Andy', "Age":13] 获取写法： 12345println "name is $&#123;hash.name&#125;"hash.each &#123;key, value -&gt; println "$&#123;key&#125; : $&#123;value&#125;"&#125; 结果为： 123name is Andyname : AndyAge : 13 5. 闭包 闭包 其实就是一段代码 闭包 在 Groovy 中也是一类 对象 — 既可以作为 参数传递，也可以 放在以后执行。 闭包 类似于 Java 中的 内部类 5.1 迭代 集合-迭代 1234567891011def coll = ["Groovy", "Java", "Android"]for(Iterator iterator = coll.iterator();iterator.hasNext();)&#123; println iterator.next()&#125;println "\n"coll.each&#123; println it&#125; 结果: 1234567GroovyJavaAndroidGroovyJavaAndroid 闭包中的 it 变量是一个 关键字，指向被调用的外部集合的每个值的 默认值，可以用传递给闭包的参数（自定义）覆盖它。 例如，用 value 代替了 Groovy 的默认 it： 123coll.each&#123; value -&gt; println value&#125; 映射-迭代 1234def hash = [name:'Andy', "Age":13]hash.each &#123;key, value -&gt; println "$&#123;key&#125; : $&#123;value&#125;"&#125; 结果 12name : AndyAge : 13 字符串-迭代 123"ABCDEFG".each &#123; println it.toLowerCase()&#125; 结果 1234567abcdefg 凡是集合或一系列的内容，都可以使用 each 进行迭代 注意：一个闭包写法的演变 12345678910111213141516171819202122// 1 - 按照定义的写法coll.each(&#123;println it&#125;)// 2 - 对格式进行美化coll.each(&#123; println it&#125;)// 3 - 根据Groovy规定，如果闭包为最后一个参数，则可以放到方法外面coll.each()&#123; println it&#125;// 4 - Groovy语法允许 方法的 "（）"省略，所以写为：coll.each&#123; println it&#125;// 5 - 自定义参数的闭包coll.each&#123; value -&gt; println value&#125; 5.2 闭包的其他使用闭包在调用的时候才会执行这一事实（不是在定义的时候 12345def excite = &#123; world -&gt; return "$&#123;world&#125;!!"&#125;println excite("Apple") 结果 1Apple!! 这段代码是名为excite 的闭包。这个闭包接受一个参数（名为 word），返回的 String 是 word 变量加两个感叹号。 注意： 1在 String 实例中替换 的用法。在 String 中使用 $&#123;value&#125;语法将告诉 Groovy 替换 String 中的某个变量的值。 5.3 闭包的调用 直接调用 1excite("Groovy") 通过call()调用 1excite.call("Java") 5.4 闭包委托参照：Gradle-闭包 6. 方法重点1：（） 可省 例如: 12345def add(num1, num2)&#123; println num1 + num2&#125;add(1,2)add 1,2 结果为： 1233 重点2：代码块可以传递参数 代码块：一段被 {} 包裹的代码，其实就是 闭包。 例子：参考 闭包 Groovy 中的类一个例子： bean类 1234567package temp1.beanclass SongBean &#123; def name def artist def genre&#125; 调用类 12345678910111213141516171819package temp1.exampleimport temp1.bean.SongBeanclass SongExample &#123; static void main(args)&#123; # 类的初始化 方式1 def song = new SongBean(name:"Andy",artist:"Lip Inc",genre: "Disco") # 类的初始化 方式2 def song2 = new SongBean() # 通过 . 语法访问属性 song2.name = "Jack" song2.artist = "Chic" song2.genre = "pop" &#125;&#125; Groovy类特点1： 自动提供一个构造函数。构造函数接受一个 名称-值对 的映射，此映射类的 属性 相对应。这是 Groovy 的一项开箱即用的功能：用于类中定义的任何属性，Groovy 允许将存储了大量值的映射传给构造函数。 Groovy类特点2: 通过 . 语法访问属性 Groovy 还生成了标准的 setter 和 getter 方法。 在进行属性操纵时，非常有 Groovy 特色的是：总是会调用 setter 和 getter 方法 ： 即使直接通过 . 语法访问属性也是如此。 方法去掉 () ，例如： 1song.setName "Wang" Groovy类特点3：对于接受参数的方法，可以省略 ()重写 SongBean 类的 toString() 123String toString()&#123; "$&#123;name&#125;, $&#123;artist&#125;, $&#123;genre&#125;"&#125; 结果: 1Wang, Lip Inc, Disco Groovy类特点4：不需要 return因为：Groovy 默认返回 方法的 最后一行。 当修改代码为： 12345//song2.name = "Jack"song2.artist = "Chic"song2.genre = "pop"println song2.name.toUpperCase 时，结果为： 123456Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot get property &apos;toUpperCase&apos; on null object at org.codehaus.groovy.runtime.NullObject.getProperty(NullObject.java:60) at org.codehaus.groovy.runtime.InvokerHelper.getProperty(InvokerHelper.java:190) at org.codehaus.groovy.runtime.callsite.NullCallSite.getProperty(NullCallSite.java:46) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:298) at temp1.example.SongExample.main(SongExample.groovy:14) 那么在 Groovy 中如何修正呢？修改为： 1println song2.name?.toUpperCase 后，结果为： 1null Groovy类特点5：“？操作符” 确保 空指针安全性?操作符时刻都非常有用，可以极大地减少条件语句。]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Developer Days China 2018 总结]]></title>
    <url>%2FGoogle%20Developer%20Days%20China%202018%20%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[此文章仅仅关注个人认为重要的点。 参考链接 https://mp.weixin.qq.com/s/sjyd0eUPJyMinNoaVcNXaA 关注点1：TensorFlow 关于机器学习的7个步骤： 数据收集 准备数据 选择模型 训练 评估 超参数调节 预测 编程接口的新动态 新的TensorFlow编程语言 通过TensorFlowLite打造移动机器学习模型 闲鱼基于TensorFlowLite的端计算应用实践 TensorFlowLite在网易有道产品中的应用 以tf.data优化训练数据 关注点2：Android 关于Android 9 Pie的适配问题，提及了几个重点方向： 应用不兼容的常见原因 非sdk接口的限制名单 凹凸屏幕Display Cutout 屏幕旋转锁定 空闲应用无法访问麦克风、摄像头和传感器 前台服务权限 后台服务限制 Google Play targetSdkVersion政策 关注点3：Firebase关注点4：FlutterGitHub：https://github.com/flutter/flutter官网：flutter.io中文资源：flutter-io.cn Google软件工程师-于萧 ：“使用Flutter快速构建集美观与高性能于一体的移动应用”。 视屏地址 用户的需求 ？ 多平台 高性能 精美的定制设计 移动软件开发的困难？ 开发太贵 开发太慢 高质量太难 工程资源太难共享 目标 Fast Development Expressive and Flexible UI High Performance 媲美原生的速度 特点： 高工效 声明式 + 响应式 开发模式 API组合 多层次、组合性的API 性能优化 使用方式： 例子： Native + Flutter：咸鱼 - 商品详情界面（+商品发布界面），保证原生性能的前提下，保证两端的统一。]]></content>
      <categories>
        <category>GDD</category>
      </categories>
      <tags>
        <tag>GDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App性能优化概览]]></title>
    <url>%2FApp%E6%80%A7%E8%83%BD%E4%BC%98%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[App优化的本质 - 知识体系结构够丰富、知识点理解够透彻、代码够规范，则不存在优化。 引用： 12345假如饭点将至，需要打开订餐APP进行点餐：首先一定不希望，在浏览商家和菜品列表内容很丰富的时候遇到卡顿现象；然后千挑万选后在期待美食将至的心情下准备下单，突然遇到闪退崩溃，那简直想卸载APP的心都有了；其次就是配送员在配送过程中不希望耗电和耗流量太严重；最后就是用户和配送员都希望版本更新的时候安装包希望能小一点。 一张图表述 App 性能优化切入点： 本文内容将会根据此图进行说明，分为以下模块点： 布局 绘制 内存 启动速度 包体 耗电 RecyclerView自带优化、Bitmap 响应速度-线程 布局优化屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。 通过颜色我们可以知道应用是否有多余层次的绘制，如果一路飘红，那么我们就要相应的处理了。 优化 Version 1.0 ：颜色设置、include + merge、ViewStub颜色设置 如果父控件有颜色，也是自己需要的颜色，那么就不必在子控件加背景颜色 如果每个子控件的颜色不太一样，而且可以完全覆盖父控件，那么就不需要再父控件上加背景颜色 嵌套include + merge 参考：https://blog.csdn.net/a740169405/article/details/50473909 特点： 使用include标签可以增加布局的 复用性，提高效率。 使用merge标签可以 减少 视图树中的 节点个数，加快视图的绘制，提高UI性能。 &lt;merge/&gt; 标签的使用，看上去一次只减少一个节点，但是当一个布局嵌套很复杂的时候，节点的个数可能达到几百个，这个时候，如果每个地方都多一个节点，视图的绘制时间相应的也就变长了很多。 使用 &lt;merge/&gt; 注意： 1.&lt;merge/&gt; 必须放在布局文件的根节点上。 2.&lt;merge/&gt; 不是一个ViewGroup，也不是一个View，它相当于声明了一些视图，等待被添加。 3.&lt;merge/&gt; 标签被添加到A容器下，那么 &lt;merge/&gt; 下的所有视图将被添加到A容器下。 4.因为 &lt;merge/&gt; 并不是View，所以在通过 LayoutInflate.inflate 方法渲染的时候， 第二个参数必须指定一个 父容器，且第三个参数必须为 true，也就是必须为 &lt;merge/&gt; 下的视图指定一个父亲节点。 5.如果Activity的布局文件根节点是FrameLayout，可以替换为 &lt;merge/&gt;，这样，执行setContentView之后，会减少一层FrameLayout节点。 6.自定义View如果继承LinearLayout，建议让自定义View的布局文件根节点设置成 &lt;merge/&gt;，这样能少一层结点。 7.因为 &lt;merge/&gt; 不是View，所以对 &lt;merge/&gt;标签设置的所有属性都是无效的。 ViewStub 参考：https://blog.csdn.net/a740169405/article/details/50351013 &lt;ViewStub/&gt; 产生效果的本质是：==懒加载==、==弱引用==。通过一个在视图中已存在的 &lt;ViewStub/&gt; 来临时代替 正式布局，直到真正需要加载 正式布局 时，将 &lt;ViewStub/&gt; 替换掉。 inflate() 方法只能调用一次，不建议通过 setVisibility() 加载视图 使用 要实现的操作：在一个 Activity 上放置了一个按钮，点击后加载懒加载的视图。 1、 Activity布局文件定义 my_sub_activity.xml： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:onClick=&quot;onClick&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;加载视图&quot;/&gt; &lt;ViewStub android:id=&quot;@+id/stub&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/my_sub_tree&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt; android:inflatedId 指定了懒加载视图跟节点的 ID，android:layout 指定了懒加载的视图。android:layout_width、android:layout_height 分别指定了懒加载视图的宽和高。 2、 懒加载布局文件 my_sub_tree.xml： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffffff&quot; android:gravity=&quot;center&quot; android:padding=&quot;10dip&quot; android:text=&quot;懒加载视图&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;22sp&quot;&gt;&lt;/TextView&gt; 3、 在 Activity 中调用的代码，点击后查到ViewStub对象，并加载视图 1234567@Overridepublic void onClick(View v) &#123; // 这里调用的是inflate方法，当然，也可以调用setVisibility方法（但是不建议这么做） // 只能点击一次加载视图按钮，因为inflate只能被调用一次 // 如果再次点击按钮，会抛出异常&quot;ViewStub must have a non-null ViewGroup viewParent&quot; ((ViewStub) findViewById(R.id.stub)).inflate();&#125; 效果图： &lt;ViewStub/&gt; 在VIew树中加载的前后对比： 加载前： 加载后： 优化 Version 1.1 ：ConstraintLayout（约束布局）复杂界面可选择ConstraintLayout，可有效减少层级。 绘制优化 - 渲染性能：onDraw()Android渲染机制：Android系统 每隔16s 发出 VSYNC 信号，触发UI渲染： 渲染成功：界面流畅； 渲染失败：时间延误或者直接跳过，反应到手机屏幕就是：卡、跳帧。 Android渲染机制的最后一步是 onDraw()，在前面的介绍中已经处理了测量、布局过程，此时，解决办法，根本做法是 减轻onDraw()的负担。 onDraw() 处理方法： 不要做耗时的任务，也 不做过多的循环操作，特别是 嵌套循环，虽然每次循环耗时很小，但是大量的循环势必 霸占CPU的时间片，从而造成View的绘制过程不流畅。 不要创建新的局部对象，因为 onDraw() 方法一般都会 频繁大量调用，就意味着会 产生大量的临时对象，不仅 占用过的内存，而且会导致系统更加 频繁的GC，大大降低程序的执行速度和效率。 优化 Version 2.0 ：onDrow() onDraw中不要创建新的局部对象 onDraw方法中不要做耗时的任务 内存优化内存泄漏内存泄漏 指的是 那些程序不再使用的对象无法被GC识别，这样就 导致这个对象一直留在内存当中，占用了没来就不多的内存空间。 内存泄漏是一个 缓慢积累 的过程，温水煮青蛙一般，往往很难直观的看到，只能最后内存不够用了，程序崩溃。 因为有 内存泄漏，所以 内存被占用越来越多，那么 GC会更容易被触发，GC会 越来越频发，但是当GC的时候 所有的线程都是暂停状态的，需要处理的 对象数量越多耗时越长，所以这也会造成 卡顿。 发生泄漏的4大类情况 集合类 单例/静态变量 匿名内部类/非静态内部类 资源未关闭 集合类泄漏集合类添加元素后，仍引用着集合元素对象，导致该集合中的元素对象无法被回收，从而导致内存泄露。合适的做法为： 123456789static List&lt;Object&gt; mList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 100; i++) &#123; Object obj = new Object(); mList.add(obj); obj = null;&#125;mList.clear();mList = null; 单例/静态变量单例模式具有其 静态 特性， 其生命周期 = 应用程序生命周期，正是因为这一点，往往很容易造成内存泄漏。 一个示例： 12345678910111213141516public class SingleInstance &#123; private static SingleInstance mInstance; private Context mContext; private SingleInstance(Context context)&#123; this.mContext = context; &#125; public static SingleInstance newInstance(Context context)&#123; if(mInstance == null)&#123; mInstance = new SingleInstance(context); &#125; return sInstance; &#125;&#125; 在此单例模式中，当我们将 Activity 作为 context 参数进行传递时，这个单例就拥有了 Activity 的引用。当此 Activity 没有用、要被销毁时，此单例仍然持有 此Activity的引用。所以 GC 无法回收，结果就是造成了内存泄漏。 修改之后，合理的使用方式为: 12345678910111213141516public class SingleInstance &#123; private static SingleInstance mInstance; private Context mContext; private SingleInstance(Context context)&#123; this.mContext = context.getApplicationContext(); &#125; public static SingleInstance newInstance(Context context)&#123; if(mInstance == null)&#123; mInstance = new SingleInstance(context); &#125; return sInstance; &#125;&#125; 匿名内部类/非静态内部类 两个关键点： 生命周期 对象引用 非静态内部类一个示例：123456789101112131415161718192021public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); new MyAscnyTask().execute(); &#125; class MyAscnyTask extends AsyncTask&lt;Void, Integer, String&gt;&#123; @Override protected String doInBackground(Void... params) &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125; &#125;&#125; 乍一看这一段程序在功能上是没有问题的。但是如果从对象持有、内存状态再来看待这段程序时，MyAscnyTask是一个非静态内部类，如果他处理数据的时间很长，极端点用sleep 100秒，在这期间Activity可能运行5s后就关闭了，原本理想的状态是Activity的内存应该被回收的。但是：我们知道非静态内部类会持有外部类的引用，所以Activity也需要陪着非静态内部类MyAscnyTask一起跑完 100s。好了，内存泄漏就形成了。 如何解决呢？ 这就要回到这一节主题所代表的问题本质：生命周期。 既然 MyAscnyTask 与 Activity 的 生命周期差距如此之大，那么就干脆把 MyAscnyTask 变成 静态内部类，和Application玩去吧，这样做得到的结果就是： 静态内部类与外部类两者之间的 引用、内存 关系也相互独立了。 于是，可以修改该为： 123456789101112131415161718192021public class TestActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); new MyAscnyTask().execute(); &#125; //改了这里 注意一下 static static class MyAscnyTask extends AsyncTask&lt;Void, Integer, String&gt;&#123; @Override protected String doInBackground(Void... params) &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125; &#125;&#125; 匿名态内部类一个示例：12345678910111213141516171819202122232425262728293031public class TestActivity extends Activity &#123;private TextView mText; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg);//do somethingmText.setText(&quot; do someThing&quot;); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); mText = findVIewById(R.id.mText); // 匿名线程持有 Activity 的引用，进行耗时操作 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); mHandler. sendEmptyMessageDelayed(0, 100000); &#125;&#125; 在本小结的一开始列出了2个关键点：生命周期 已经在第一种问题中得到了应用。 那么接下来通过 对象引用 这个出发点来解决这个问题。 引用分为：强、软、弱、虚引用，而且 引用强度依次递减。 强引用： 平时用的最多、不做处理的一般都是强引用，如果一个对象具有的是强引用，那么GC即使发生OOM也不会回收它。 软引用（SoftReference）： 如果内存空间足够，GC则不会回收它，如果内存空间不足，那么GC则回收它。 弱引用（WeakReference）： GC的时候无论内存是否够用，都要回收它。 虚引用： 不常用。 那么此 匿名态内部类示例 的内存问题解决方式就变成了： static化 - 对内外类之间的联系进行分离 引用强度下降，使用弱引用 - 保证生命周期短的类及时销毁 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestActivity extends Activity &#123; private TextView mText; private MyHandler myHandler = new MyHandler(TestActivity.this); private MyThread myThread = new MyThread(); private static class MyHandler extends Handler &#123; WeakReference&lt;TestActivity&gt; weakReference; MyHandler(TestActivity testActivity) &#123; this.weakReference = new WeakReference&lt;TestActivity&gt;(testActivity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); weakReference.get().mText.setText(&quot;do someThing&quot;); &#125; &#125; private static class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; sleep(100000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); mText = findViewById(R.id.mText); myHandler.sendEmptyMessageDelayed(0, 100000); myThread.start(); &#125; //最后清空这些回调 @Override protected void onDestroy() &#123; super.onDestroy(); myHandler.removeCallbacksAndMessages(null); &#125;&#125; 资源未关闭可能出现问题的方面有： 流 未关闭 注册后未进行解绑 start() 后没有 stop() 分析工具： leakcanary，漏洞直接显示 Android Lint，帮助发现代码构成/质量问题。内存泄漏时会有发黄。 Android Profiler，自带，好好琢磨。 启动启动速度分为： 冷启动（Cold Start） 热启动（Hot Start） 温启动（Warm Start） 1 冷启动（Cold Start）冷启动是指应用程序从头开始：系统的进程在此开始之前没有创建应用程序的进程。 在冷启动开始时，系统有3个任务。这些任务是： 加载并启动应用程序； 启动后 立即显示 应用程序的 空白启动窗口； 创建应用程序进程。 一旦系统创建了应用程序流程，应用程序流程就会负责下一个阶段： 创建Application对象 启动主线程 创建主Activity 加载布局 屏幕布局 执行初始绘制 应用程序进程完成第一次绘制后，系统进程 会 交换 当前显示的 背景窗口，将其 替换 为主Activity。此时，用户可以开始使用该应用程序。至此启动完成。 根据这个流程分析，在进行 Application 与 Activity 创建时可能会出现 性能问题。 1.1 Application创建当Application启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成应用程序绘制。 此时，系统进程会 交换 应用程序的启动窗口，允许用户开始与应用程序进行交互。这就是为什么我们的程序启动时会先出现一段时间的 黑屏(白屏)。 如果我们有自己的Application，系统会在我们的Application对象上调用onCreate()方法。 之后，应用程序会生成主线程（也称为UI线程），并通过创建主Activity来执行任务。从这一点开始，App就按照他的 应用程序生命周期阶段进行。 总结来说就是：Application创建 -&gt; UI线程 -&gt; Activity创建 1.2 Activity创建Application进程创建活动后，活动将执行以下操作： 初始化值。 调用构造函数。 调用回调方法，例如 Activity.onCreate()，对应Activity的当前生命周期状态。 通常，该 onCreate() 方法对加载时间 的影响最大，因为它以最高的开销执行工作：加载和填充视图，以及初始化活动运行所需的对象。 2 热启动（Hot start）应用程序的热启动比冷启动要简单得多，开销也更低。在一个热启动中，系统都会把你的Activity带到前台。如果应用程序的Activity仍然驻留在内存中，那么应用程序可以避免重复对象初始化、布局加载和渲染。 注意：**热启动显示与冷启动方案相同的屏幕行为：系统进程显示空白屏幕，直到应用程序完成呈现活动**。 热启动包括冷启动期间发生的一些操作子集; 同时，它比热启动代表更少的开销。有许多潜在的状态可以被视为热启动。例如： 用户退出应用，但随后重新启动它。该过程可能已继续运行，但应用程序必须通过调用从头开始重新创建 Activity 的 onCreate()。 系统将应用程序从内存中逐出，然后用户重新启动它。需要重新启动进程和活动，但是任务可以从传入的已保存实例状态包中获益 onCreate()。 温启动（Warm start）温启动包含了冷启动时发生的一些操作，与此同时，它表示的开销比热启动少，有许多潜在的状态可以被认为是温暖的开始。 场景： 用户退出您的应用，但随后重新启动它。该过程可能已继续运行，但应用程序必须通过调用从头开始重新创建Activity 的onCreate()。 系统将您的应用程序从内存中逐出，然后用户重新启动它。需要重新启动进程和活动，但是在调用onCreate()的时候可以从Bundle（savedInstanceState）获取数据。 谷歌官方给的建议是：1、利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；2、避免在启动时做密集沉重的初始化（Heavy app initialization）；3、避免I/O操作、反序列化、网络操作、布局嵌套等。 这里是慢的定义： 冷启动需要5秒或更长时间。 温启动需要2秒或更长时间。 热启动需要1.5秒或更长时间。 无论何种启动，我们的优化点都是：Application、Activity创建以及回调等过程 包体优化APK的文件构成。 assets文件夹 存放一些配置文件、资源文件，assets不会自动生成对应的 ID，而是通过 AssetManager 类的接口获取。 res目录 res 是 resource 的缩写，这个目录存放资源文件，会自动生成对应的 ID 并映射到 .R 文件中，访问直接使用资源 ID。 META-INF 保存应用的签名信息，签名信息可以验证 APK 文件的完整性。 AndroidManifest.xml 这个文件用来描述 Android 应用的配置信息，一些组件的注册信息、可使用权限等。 classes.dex Dalvik 字节码程序，让 Dalvik 虚拟机可执行，一般情况下，Android 应用在打包时通过 Android SDK 中的 dx 工具将 Java 字节码转换为 Dalvik 字节码。 resources.arsc 记录着资源文件和资源 ID 之间的映射关系，用来根据资源 ID 寻找资源。 问题解决方案：减小 代码和资源 1、首先使用lint工具，同时开启资源压缩,自动删除无用的资源 1234567891011android &#123; ... buildTypes &#123; release &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125; 2、我们可以使用可绘制对象，某些图像不需要静态图像资源; 框架可以在运行时动态绘制图像。Drawable对象（以XML格式）可以占用APK中的少量空间。此外，XML Drawable对象产生符合材料设计准则的单色图像。 3、重用资源，比如一个三角按钮，点击前三角朝上代表收起的意思，点击后三角朝下，代表展开，我们会用两张图来切换，其实我们完全可以用旋转的形式去改变。一般比如同一图像的着色不同，我们可以用android:tint和tintMode属性 4、压缩PNG和JPEG文件您可以减少PNG文件的大小，而不会丢失使用工具如图像质量 pngcrush，pngquant，或zopflipng。所有这些工具都可以减少PNG文件的大小，同时保持感知的图像质量。 5、使用WebP文件格式可以使用图像的WebP文件格式，而不是使用PNG或JPEG文件。WebP格式提供有损压缩（如JPEG）以及透明度（如PNG），但可以提供比JPEG或PNG更好的压缩。 7、代码混淆使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能。这个大家太熟悉了。不多说了。 8、插件化。比如功能模块放在服务器上，按需下载，可以减少安装包大小。 耗电使用Battery Historian分析电源使用情况 过度唤醒 唤醒是AlarmManagerAPI 中的一种机制 ，允许开发人员设置警报以在指定时间唤醒设备。您的应用程序通过使用 或 标记调用其中一个set()方法来 设置唤醒警报。当触发唤醒警报时，设备退出低功耗模式并在执行警报 或 方法时 保持部分唤醒锁定。如果过度触发唤醒警报，则可以耗尽设备的电池电量。 不要 AlarmManager用于安排后台任务，尤其是重复或网络后台任务。使用 JobScheduler或 Firebase JobDispatcher 可以安排后台任务，因为它们具有以下优点： 批处理 - 将工作结合起来，以减少电池消耗持久性 - 即使在重新启动设备后，标记为持久的作业也将继续运行条件 - 作业可以根据条件运行，例如设备是否正在充电或WiFi是否可用 在后台进行过多的Wi-Fi扫描 当应用程序在后台执行Wi-Fi扫描时，它会唤醒CPU，从而导致电池耗尽率。当扫描次数过多时，设备的电池寿命可能会明显缩短。如果应用程序处于PROCESS_STATE_BACKGROUND或 PROCESS_STATE_CACHED处于状态，则认为该应用程序在后台运行。 后台网络使用量过高 耗电操作主要分为下面几种 高频通信 CPU密集型的计算 传感器 频繁唤醒系统 定位 解决方案 减少 推迟 合并 ①在需要网络连接的程序中，首先检查网络连接是否正常，如果没有网络连接，那么就不需要执行相应的程序;②判断网络类型,针对特定的数据在特定的网络下请求.例如:大量数据传输的时候在wifi下请求;wifi下下载数据耗电量只有2、3、4G的1/3.③使用效率高的数据格式和解析方法，推荐使用JSON和Protobuf;④在进行大数据量下载时，尽量使用GZIP方式下载;⑤使用推送，代替循环请求⑥其它：尽量不要使用浮点运算；回收java对象，特别是较大的java对像，使用reset方法；主动回收java对象，特别是较大的，例如bitmap。减少GC的工作频率；避免内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放；避免在for循环、onDraw方法中创建对象；无法避免的可以创建对象池，然后在不使用的时候释放；对定位要求不是太高的话尽量不要使用GPS定位，可以使用wifi和移动网络cell定位即可；获取屏幕尺寸等信息可以使用缓存技术，不需要进行多次请求；使用AlarmManager来定时启动服务替代使用sleep方式的定时任务 使用JobScheduler使用JobScheduler，来调整任务优先级等策略来达到降低损耗的目的。 具体功能：1、可以推迟的非面向用户的任务(如定期数据库数据更新)；2、当充电时才希望执行的工作(如备份数据)；3、需要访问网络或 Wi-Fi 连接的任务(如向服务器拉取配置数据)；4、零散任务合并到一个批次去定期运行；5、当设备空闲时启动某些任务；6、只有当条件得到满足, 系统才会启动计划中的任务（充电、WIFI…）。 懒惰第一的法则减少你的应用程序可以删除冗余操作吗？例如，它是否可以缓存下载的数据而不是重复唤醒无线电以重新下载数据？ 推迟应用是否需要立即执行操作？例如，它可以等到设备充电才能将数据备份到云端吗？ 合并可以批处理工作，而不是多次将设备置于活动状态吗？例如，几十个应用程序是否真的有必要在不同时间打开收音机发送邮件？在一次唤醒收音机期间，是否可以传输消息？ RecyclerView自带优化、BitmapBitmap的优化套路很简单、粗暴，就是：压缩。三种压缩方式：1.对图片质量进行压缩2.对图片尺寸进行压缩3.使用libjpeg.so库进行压缩 响应速度-线程优化影响响应速度的主要因素是主线程有耗时操作，影响了响应速度。所以响应速度优化的核心思想是避免在主线程中做耗时操作，把耗时操作异步处理。 线程优化的思想是采用线程池，避免在程序中存在大量的Thread。线程池可以重用内部的线程，从而避免了现场的创建和销毁所带来的性能开销，同时线程池还能有效地控制线程池的最大并发数，避免大量的线程因互相抢占系统资源从而导致阻塞现象发生。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存泄漏问题]]></title>
    <url>%2FAndroid%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[总结 Java static 关键字 参考：http://www.importnew.com/20579.html参考：https://www.cnblogs.com/dotgua/p/6354151.html?utm_source=itdadao&amp;utm_medium=referral 特点被static关键字修饰的变量、方法、代码块是独立于该类的、被该类的所有实例共享，任何一个实例对其修改后都会导致其他实例的变化。 修饰1、成员变量static 修饰的变量我们称之为 静态变量，没有用static修饰的变量称之为 实例变量，他们两者的区别是： 静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。 但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。 一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。static修饰的类成员，在程序运行过程中，只需要初始化一次即可，不会进行多次的初始化。 2、方法过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。 static修饰方法的最大的作用，就是可以使用”类名.方法名”的方式操作方法，避免了先要new出对象的繁琐和资源消耗。 3、代码块当我们new一个类的对象时，static修饰的成员变量首先被初始化（如果有多个static修饰的成员，那么会按照他们的先后位置进行初始化），随后是普通成员，最后调用类的构造方法完成初始化。 静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该类的任何地方。 Java final 关键字final 指的是：这是不可变的。 1、修饰数据final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。更重要的是，final会告诉编译器：这个数据是不会修改的。那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。 在针对 基本类型 和 引用类型 时，final关键字的效果存在细微差别： final修饰数据：在被赋值后是无法在对其进行值修改的； final修饰的数据的值是不可改变的，所以必须确保在使用前就已经对成员变量赋值了。我们有且只有两个地方可以给它赋值： 声明该成员时赋值 在构造方法中赋值 final修饰引用变量：只是限定了引用变量的引用不可改变，即不能将已经修饰过的引用再次去引用另一个对象（引用变量的值实际上是它所引用的对象的地址，也就是说该地址的值是不可改变的），但是引用的对象的值是可以改变的。 同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。 2、修饰方法参数 ？在参数前面添加final关键字，它表示在整个方法中：我们不会（实际上是不能）改变参数的值 123456public void finalFunc(final int i, final Value value) &#123; // i = 5; 不能改变i的值 // v = new Value(); 不能改变v的值 // 可以改变引用对象的值 value.v = 5; &#125; 疑问： java参数传递采用的是值传递，对于基本类型的变量，相当于直接将变量进行了拷贝。所以即使没有final修饰的情况下，在方法内部改变了变量i的值也不会影响方法外的i。 3、修饰方法用final关键字修饰方法，它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。 4、修饰类final修饰的类是无法被继承的。 上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。 Java 内部类 参考：http://www.cnblogs.com/dolphin0520/p/3811445.html 将一个类定义在另一个 类里面 或者一个 方法里面，这样的类称为内部类。 内部类分类 成员内部类 局部内部类 匿名内部类 静态内部类 成员内部类是最普通的内部类，它定义在另一个类的内部。成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法创建成员内部类的对象了。 12345678910111213141516171819202122public class InnerClassEg &#123; private int age = 12; public InnerClassEg(int age) &#123; this.age = age; &#125; public void innerInfo()&#123; System.out.println(&quot;InnerClassEg innerInfo()!age is : &quot; + age); &#125; class Apple&#123; public Apple() &#123; System.out.println(&quot;this is a apple !&quot;); &#125; public void printHelper()&#123; System.out.println(&quot;apple printHelper()!&quot;); &#125; &#125;&#125; 类 Apple 像是类 InnerClassEg 一个成员变量（可以像类的成员一样拥有多种权限修饰），所以被称为 成员内部类。成员内部类 Apple 可以访问 外部宿主类 InnerClassEg 中的各种成员变量。 12345678910111213141516171819202122public class InnerClassEg &#123; private int age = 12; private static String name = &quot;class&quot;; public InnerClassEg(int age) &#123; this.age = age; &#125; public void innerInfo()&#123; System.out.println(&quot;InnerClassEg innerInfo()!age is : &quot; + age); &#125; class Apple&#123; public Apple() &#123; &#125; public void printHelper()&#123; System.out.println(&quot;apple printHelper()!age is : &quot; + age + &quot;, name is : &quot; + name); &#125; &#125;&#125; 注意： 当成员内部类 Apple 的变量和宿主类 InnerClassEg 的成员变量名相同时，使用的是 成员内部类的变量（就近）。 12345678910111213141516171819public class InnerClassEg &#123; private int age = 12; private static String name = &quot;class - InnerClassEg&quot;; private String example = &quot;Example - InnerClassEg&quot;; // ... class Apple&#123; private String example = &quot;Example - Apple&quot;; public Apple() &#123;&#125; public void printHelper()&#123; System.out.println(&quot;apple printHelper()!age is : &quot; + age + &quot;, name is : &quot; + name + &quot;, example : &quot; + example); &#125; &#125;&#125; 运行结果： 12InnerClassEg innerInfo()!age is : 23apple printHelper()!age is : 23, name is : class - InnerClassEg, example : Example - Apple 当修改为一下形式时： 12345678910class Apple&#123; private String example = &quot;Example - Apple&quot;; public Apple() &#123;&#125; public void printHelper()&#123; System.out.println(&quot;apple printHelper()!age is : &quot; + age + &quot;, name is : &quot; + name + &quot;, example : &quot; + example); System.out.println(&quot;apple printHelper()! example is : &quot; + InnerClassEg.this.example ); &#125;&#125; 运行结果为： 123InnerClassEg innerInfo()!age is : 23apple printHelper()!age is : 23, name is : class - InnerClassEg, example : Example - Appleapple printHelper()! example is : Example - InnerClassEg 关于成员内部类的继承问题。 一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点： 1）成员内部类的引用方式必须为 Outter.Inner. 2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。 1234567891011121314class WithInner &#123; class Inner&#123;&#125;&#125;class InheritInner extends WithInner.Inner &#123; // InheritInner() 是不能通过编译的，一定要加上形参 InheritInner(WithInner wi) &#123; wi.super(); //必须有这句调用 &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner obj = new InheritInner(wi); &#125;&#125; 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 123456789101112131415class People&#123; public People() &#123;&#125;&#125; class Man&#123; public Man()&#123;&#125; public People getWoman()&#123; //局部内部类 class Woman extends People&#123; int age =0; &#125; return new Woman(); &#125;&#125; 注意：局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类 匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 在Android中编写事件监听的代码时，使用匿名内部类不但方便，而且使代码更加容易维护。 1234567history_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;); 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static（加有static关键字的成员内部类）。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，因为在没有外部类的对象的情况下，静态变量、静态内部类可以进行创建，普通成员变量则不能创建。 1234567class Outter &#123; public Outter() &#123;&#125; static class Inner &#123; public Inner() &#123;&#125; &#125;&#125; 内部类的初始化123456789101112131415161718192021222324252627282930public class Test&#123; public static void main(String[] args)&#123; // 初始化Bean1 Test test = new Test(); Test.Bean1 bean1 = test.new Bean1(); bean1.I++; // 初始化Bean2 Test.Bean2 bean2 = new Test.Bean2(); bean2.J++; //初始化Bean3 Bean bean = new Bean(); Bean.Bean3 = bean.new Bean3(); bean3.k++; &#125; class Bean1&#123; public int I = 0; &#125; static class Bean2&#123; public int J = 0; &#125;&#125; class Bean&#123; class Bean3&#123; public int k = 0; &#125;&#125; 内部类问题为什么成员内部类可以无条件访问外部类的成员？事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件。在内部类中会有一个指向外部类的对象的指针，也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用。 为什么局部内部类和匿名内部类只能访问局部final变量？匿名内部类的变量根本就不是外部类方法中的局部变量。 如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对 拷贝进行初始化赋值。 这样一来就解决了 变量生命周期不一致的问题。但是新的问题又来了，既然在匿名内部类的方法中访问的变量和外部类方法中的变量不是同一个变量，当在匿名内部类的方法中改变变量的值的话，会出现什么情况？ 对！会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将外部类方法中的变量限制为final变量，不允许对变量进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。 到这里，就清楚为何方法中的局部变量和形参都必须用final进行限定了。 静态内部类有特殊的地方吗？ 静态内部类是不依赖于外部类的：可以在不创建外部类对象的情况下创建内部类的对象。 静态内部类是不持有指向外部类对象的引用的。 内部类的使用场景和好处 内部类使得多继承的解决方案变得完整：每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。 方便编写事件驱动程序 方便编写线程代码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-字符串]]></title>
    <url>%2FJava-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[String、StringBuffer、StringBuilder String、StringBuffer、StringBuilder区别一张图描述3者之间的关系 String类象操作本质String类： 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence String类中的每一个方法在对 原有的 String对象 作出修改时，实际上都是 创建了一个全新的对象，已包含修改后的字符串内容，而最初的对象没有发生改变。 如：substring()： 12345678910public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125; 最终的在方法结束 return 时，返回的是：new String(value, beginIndex, subLen); 当一个String对象传递给另一个方法或者进行其他操作时，实际传递的是一个 引用的拷贝。被传入的 拷贝引用 其实只是在方法运行时存在，方法结束后拷贝引用消失，同时返回一个 新创建的对象。 如测试例子： 12345678String str1 = "Java is good !";System.out.println("str1 is : "+str1+", heshCode is: " + str1.hashCode());str1 = str1 + "Oh! Yes!";System.out.println("str1 is : "+str1+", heshCode is: " + str1.hashCode());str1 = str1.concat(" No! php is the best!");System.out.println("str1 is : "+str1+", heshCode is: " + str1.hashCode()); 运行结果为： 123str1 is : Java is good !, heshCode is: -158517034str1 is : Java is good !Oh! Yes!, heshCode is: -917780248str1 is : Java is good !Oh! Yes! No! php is the best!, heshCode is: -1986999688 String类的“+” 与 StringBuilder类的 append()StringBuilder类： 123public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 当 String对象 执行 + 操作时，实际执行的操作是：编译器自动引入 StringBuilder类，然后 自动创建StringBuilder对象，调用其 append()。 那么，我们直接使用 String类 的 + 操作和 StringBuilder类有什么区别呢？ 区别就是中间产生的 StringBuilder类对象。 假如要在 循环中 对 String类的对象 进行操作，则结果是每执行一次 循环操作就创建一个新的 StringBuilder类的对象，而内存是需要为这些对象分配空间的，同时还要在创建对象时消耗时间，即：费时费空间。 如果在执行循环之前，使用已经创建的 StringBuilder类对象，则在执行循环操作时不会再创建额外的对象。 那么，StringBuilder类的 append() 是如何实现的呢？1. StringBuilder类 中的 append() 12345@Overridepublic StringBuilder append(String str) &#123; super.append(str); return this;&#125; 2. AbstractStringBuilder类 中的 append() 1234567891011121314151617public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;&#125;private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125; 3. Arrays类 中的 copyOf() 123456public static char[] copyOf(char[] original, int newLength) &#123; char[] copy = new char[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 4. 最终调用的是System类的 arraycopy() 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 由此调用步骤可见，StringBuilder类 中的 append() 最终调用的是底层的方法。 这就是使用 String类对象 做 + 操作与 StringBuilder类 对象的 append() 操作的区别。 StringBuffer类又是什么呢？StringBuffer类： 123public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence 在 源码的注释文档中，有这么一段话： 12As of release JDK 5, this class has been supplemented with an equivalent class designed for use by a single thread, &#123;@link StringBuilder&#125;. The &#123;@code StringBuilder&#125; class should generally be used in preference to this one, as it supports all of the same operations but it is faster, as it performs no synchronization. 翻译成中文就是： 12从JDK 5发行版开始，这个类已经补充了一个设计用于单个线程StringBuilder的等效类。StringBuilder类通常应优先于此类使用，因为它支持所有相同的操作，但速度更快，因为它不执行同步。 注释中提到的 同步 指的是，在具体的执行方法中，有 synchronized 关键字。 如：同样是 append()， 在 StringBuffer类 中的源代码为： 123456@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 输出格式化默认情况下：数据都是右对齐的，但是使用 - flag 则可以实现左对齐。一般格式化语法的抽象语法描述为： 1%[argument_index$][flags][width][.precision]conversion 格式化输出像是 C语言 中的 printf() 的风格输出就是 格式化输出，在 Java SE5 引进了此种输出方式。 具体使用： 1234int age = 10;float length = 12.3f;System.out.printf("age is : %3d, length is %4.3f\n", age,length);System.out.format("age is : %d, length is %-4.2f\n", age,length); 输出结果为： 12age is : 10, length is 12.345age is : 10, length is 12.35 即：printf() 与 format() 在格式化输出上具有相同的功能。 格式化说明符Fromatter类 简单示例: 123Formatter formatter = new Formatter(System.out);String forStr = "%-15s %5d %3.3f";formatter.format(forStr,"total size is ", 123, 222.1234f); 运行结果： 1total size is 123 222.123]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS下Android源码编译]]></title>
    <url>%2FmacOS%E4%B8%8BAndroid%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[源码编译记录：一般为了阅读源码而进行的编译，是没有任何技术含量，仅仅就是耗时而已。 前言之前曾经编译过2次Android源码，最早是通过Ubuntu 16.04 LTS环境，但由于电脑实在太卡、太慢，除了感受了一次过程没有任何收获。第二次是在换了电脑后编译过一次，编译过程却是轻松了许多，但是由于没有找到适合自己的阅读源码的方法，所以也没有实质性作用。 今天早上一觉醒来，风和日丽，夏日里难得好天气。突然想起来，自己在前一段时间总结出了一套阅读源码的方法，正好拿来实践。 由于之前编写的记录文档不存在了，于是再写一篇补上。 注意：由于在同样一台电脑上已经编译过一次源码。有些工具、环境已经配置过了，本次博客中记录都是自己的实际操作的过程，并不代表具有通用性，仅供参考。 如果之前从未编译过源码，强烈建议先参阅以下文章： Mac OS X 下 Android6.0源码的下载与编译 以及： 1https://www.cnblogs.com/xyz123753/p/3322453.html 官方文档 参考以下链接及其相关链接： https://source.android.com/source/initializing 源码下载 编译环境：macOS 10.13.6 提高效率的关键：网速要快！网速要快！网速要快！ 下载过程时没有任何技术含量的，牢记我们的最终目的是 阅读源码，这个过程尽量高效即可。 下载方式1： Google官方源码下载地址 不推荐。 因为即时能进行科学上网，到了下载的时候仍然会连不上。 下载方式2： 清华大学开源软件镜像站 推荐。 原因有两点： 这是国内镜像，无需科学上网。 此网站中提供了一种更为简洁方便的 一键式 下载操作。 Step 1：创建一个大小写敏感的磁盘镜像macOS 会在一个 保留大小写但不区分大小写的文件系统 中运行。Git 并不支持此类文件系统，而且此类文件系统会导致某些 Git 命令（例如 git status）的行为出现异常。因此，建议在区分大小写的文件系统中对 AOSP 源文件进行操作。 注意：此步骤万不可省略，否则运行后期步骤时会出错。镜像大小分配： 1hdiutil create -type SPARSE -fs &apos;Case-sensitive Journaled HFS+&apos; -size 80g ~/android.dmg 注意： 镜像名称自定义； 镜像大小自定，不过最好是100G。因为： 下载的压缩文件大小：31G左右； 同步后的文件大小：68.57G； 还要为后期的编译流出足够空间，虽然说后期可以动态调节镜像大小。 重置分区带大小： 1hdiutil resize -size &lt;new-size-you-want&gt;g ~/android.dmg.sparseimage Step 2：设置一个文件描述符限制在 ~/.bash_profile 中添加以下内容： 12#set the number of open files to be 1024ulimit -S -n 1024 修改完配置文件后，一定要更新刚配置的环境变量，在终端中输入： 1source .bash_profile Step 3：加载镜像1hdiutil attach ~/android.dmg.sparseimage -mountpoint /Volumes/android Step 4：安装Repo这个没有什么好说的，按部就班就好： 1234mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo Step 5：下载源码最为快速、便捷、傻瓜式的下载方式就是这种，同样也是成功率最高的： 1https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar 压缩包大小约 30G。这种下载方式时间的快慢最终是要看网速的，网速比较快的话 1个小时 即可。 如果想要尝试其他的下载方法，参考 前言 中提到的 2种 下载方式。 Step 6：移动源码压缩文件到镜像中将同解压的 源码文件 复制到刚刚加载的 镜像 中。 Step 7：解压将下载得到的 aosp-latest.tar 文件，解压即可。 Step 8：同步进入刚刚解压得到的文件夹，然后在这个文件夹内进行同步操作。 在网速快的前提下，花了 30分钟左右 的时间就同步结束了。 12cd AOSP # 解压得到的 AOSP 工程目录# 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录 12repo sync # 正常同步一遍即可得到完整目录# 或 repo sync -l 仅checkout代码 以上就是本人在本次的实际下载过程中采用的顺序。 最终编译结果： 源码编译提示： 最好偶尔的看看你的终端中的编译，因为突发的一个意想不到的 error 就会 终止、结束 编译过程，而且是出现在编译过程的任何阶段，最好保持警惕。 那么，做好 时刻准备着心态，cd Android源码目录。 Step 1：清理为了确保新安装的二进制文件在解压后会被适当考虑在内，请使用以下命令 删除所有以前编译操作的已有输出 ： 1make clobber Step 2：设置环境使用 envsetup.sh 脚本 初始化环境。请注意，将 source 替换成 .（一个点）可以省去一些字符，这种简写形式在文档中更为常用。 1source build/envsetup.sh 或写为： 1. build/envsetup.sh Step 3：选择目标使用 lunch 选择要编译的目标。确切的配置可作为参数进行传递。例如以下命令： 1lunch aosp_arm-eng 该命令表示 针对模拟器进行完整编译，并且 所有调试功能均处于启用状态。 如果您没有提供任何参数就运行命令，lunch 将提示您从菜单中选择一个目标。 Step 4：编译使用 make 编译任何代码。GNU Make 可以借助 -jN 参数处理并行任务，通常使用的任务数 N 介于编译时所用计算机上硬件线程数的 1-2 倍之间。例如，在一台双核 E5520 计算机（2 个 CPU，每个 CPU 4 个内核，每个内核 2 个线程）上，要实现最快的编译速度，可以使用介于 make -j16 到 make -j32 之间的命令。 1make -j4 设置 make -jN 参数后，源码的编译就正式开始了~ 注意：如果在此编译过程中出现任何问题，先解决问题，然后依次重复执行本阶段的 步骤1~4 。 最终编译结束，花费的时间为： 1#### build completed successfully (07:52:17 (hh:mm:ss)) #### 真实够长的…… Step 5：为了阅读源码接着上一步，确认下 aosp/out/host/darwin-x86/framework 文件夹中没有idegen.jar， 第1步：生成 idegen.jar 包1mmm development/tools/idegen 如果是重新打开终端，需要输入 1source build/envsetup.sh 后，最终：文件夹中生成了这个idegen.jar包。那么命令中用到的 envsetup.sh 是做什么的呢？ idegen：一个角落里的法器 1要将Android系统源代码工程导入到Eclipse或者IntelliJ IDEA，关键是要有相应的工程配置文件。idegen就是用来生成针对Eclipse和IntelliJ IDEA的Android系统源代码工程配置文件的一个工具 第2步：生成3个文件1development/tools/idegen/idegen.sh 结果：生成3个文件 123android.iml：描述了modules，比如modules的路径,依赖关系等。android.ipr：工程相关的设置，比如编译器配置、入口，相关的libraries等。android.iws：包含了一些个人工作区的设置。 至此，为了能够在IDE中阅读源码，需要的文件已经生成。 第3步：导入IDE及配置修改参考： 自己动手调试Android源码(超简单) 把Android源码导入Android Studio进行调试 Android FrameWork学习（二）Android系统源码调试 Android Studio系列（二）使用AS开发/调试整个android系统源代码（不定时更新） 遇到问题Q1:1fatal error: &apos;linux/netfilter/xt_DSCP.h&apos; file not found 解决参考：https://blog.csdn.net/u013005791/article/details/52212584]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-树]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[内容持续更新中 树树是一种 非线性 数据结构，是n(n≥0)个节点的 有限集。 树的结构定义是一个递归的定义：在树的定义中又用到了树的概念。 树的其他表现形式： 术语： 结点： 包含一个元素及若干个指向其子树的分支。 度： 结点拥有的子树数量称为结点的度。 叶子/终端结点： 度为0。 分支结点/非终端结点：度不为0.。 树的度： 树内各个结点的度的最大值。 孩子： 结点的子树称为该结点的孩子，该结点称为该树的双亲。 兄弟：同一个双亲的孩子 层次：是从根开始的，根为第一层。 深度：树中结点的最大层次称为树的深度。 有序树/无序树： 如果将树中的结点的各个子树看成是从左向右（不能互换）的，则是有序，反之无序。 森林： m(m≥0)颗互不相交的树的集合，对树中每个结点而言，其子树的集合即为森林。 二叉树特点 每个结点 至多只有2棵子树（二叉树中不存在度大于 2 的结点） 二叉树的子树 有左右之分，次序不能任意颠倒 性质 在二叉树的 第 i 层 上至多有 $ 2^{i-1} $ 个结点。 深度为 k 的二叉树至多有 $ 2^{k} - 1$ 个结点。 对于任何一个二叉树T，如果其终端结点数为 n0，度为2的结点数为 n2，则 n0 = n2 + 1。 具有 n 个结点的 完全二叉树 的深度为 $ log2n + 1 $ . 分类 满二叉树：一棵深度为 k 且有 $ 2^{k} - 1$ 个结点的二叉树；每一层上的结点数都是最大结点数。 完全二叉树：一棵深度为 k ，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为k的 满二叉树 中编号从 1至n 的结点一一对应时，称为 完全二叉树； 叶子结点只可能在层次最大的两层上出现。 对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为 l 或者 l+1; 不完全二叉树 存储结构 数组式存储 用一组 地址连续的存储单元 依次的 自上而下、自左至右 的存储 完全二叉树 上的结点元素，即可将完全二叉树上编号为 i 的结点元素存储在如上定义的一维数组中下标为 i-1 的分量中。 一个深度为 k 且只有 k 个结点的单枝树（树中不存在度为2的结点）需要的长度为 $2^k - 1$ 的一维数组。 如：一个 完全二叉树 的树形表示为： 转换为 数组式 存储结构为： 如：一个一般的二叉树的树形表示为： 转换为 数组式存 储结构为： 链式存储 设计 不同的结点结构 可构成 不同形式的链式存储结构 。 二叉链表：由二叉树的定义得知，二叉树的结点由 一个数据元素 和 分别指向其左、右子树的 两个分支 构成，即：二叉树中的 结点 至少包含3个域：数据域 、 左指针域 、右指针域。 三叉链表：有时为了便于找到结点的双亲，还在二叉链表的结点结构中 增加一个指向双亲结点的指针域， 单支树的二叉链表 二叉链表 三叉链表 遍历二叉树按照某条搜索路劲访问树中的每个结点，使得 每个结点均被访问一次，而且仅被访问一次。 遍历二叉树是以 一定的规则 将二叉树的中的 结点排列成一个线性序列，这实质上是 对一个非线性结构进行线性化操作，使得每个结点（除了第一个和最后一个外）在 线性序列 中 有且仅有一个直接前驱和一个直接后继。 二叉树是由 3个 基本单元组成：根节点、左子树、右子树，只要依次遍历这三个部分，便是遍历了整个二叉树。 使用L、D、R分别表示遍历左子树、访问根、遍历右子树，将有 DLR、DRL、LDR、LRD、RLD、RDL6种。但是二叉树的其中一个特点是：左右有序，次序不能任意颠倒，于是只有 3 种： DLR - 先（根）序遍历 LDR - 中（根）序遍历 LRD - 后（根）序遍历 3种遍历算法的不同之处仅在于访问根节点和遍历左、右子树的 先后关系。 线索二叉树当以 二叉链表作为存储结构时 ，只能找到结点的左、右孩子信息，而 不能直接得到 结点在任一序列中的 前驱 和后继 信息，这种信息只能是在 遍历的动态过程中 才能得到。 通过在每个结点上 增加两个指针域 ，分别用来表示结点在任意一次遍历时得到的前驱和后继信息。如： 其中： LTag 0：lchild域指示结点的左孩子 1：lchild域指示结点的前驱 RTag 0：rchild域指示结点的右孩子 1：rchild域指示结点的后继 以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做：线索链表 。 其中，指向结点前驱和后继的指针，叫做 线索 。 加上线索 的 二叉树 称为 线索二叉树。 线索二叉树的表示： 对 二叉树 以某种次序遍历 使其变为线索二叉树的过程 叫做 线索化。 树和森林树的存储结构 双亲表示法 假设以一组连续空间存储树的结点，同时在 每个结点 中 附设一个指示器 指示其双亲结点在链表中的 位置。但是，在这种表示方法中，求结点的孩子时需要遍历整个树。 孩子表示法 描述：由于树中 每个结点 可能有 多棵子树，则可用 多重链表 ，即 每个结点有 多个指针域，每个指针域 指向一棵子树的根结点。 具体表示为：把 每个结点 的 孩子结点排列起来，看成是一个 线性表，且以 单链表作为存储结构，则 n 个结点就有 n 个孩子链表。而 n 个头指针组成一个线性表，为了方便查找，可采用顺序存储结构。 特点：此种实现方式适合于 涉及到孩子的操作，不适合于 原树： 孩子链表 双亲 + 孩子 表示法 孩子兄弟表示法 又称 二叉树表示法 或者 二叉链表表示法，以 二叉链表作为树的存储结构。 特点：通过此存储结构便于实现各种树的操作。 原树： 二叉树表示法： 森林与二叉树的转换树转换为二叉树 加线： 在所有的兄弟结点之间加一条连线. 去线,：对树中每个结点,只保留它与第一个孩子结点的连线,删除它与其它孩子结点之间的连线. 旋转：层次调整,以 树结点为轴心 ,将整个树 顺时针旋转 一定的角度,使之结构层次分明.第一个孩子是二叉树结点的左孩子,兄弟转化过来的孩子是结点的右孩子. 二叉树转换为树是树转二叉树的 逆过程 加线 去线 逆时针旋转，层次调整 森林转换为二叉树 把每个结点转化为二叉树 第一棵二叉树不动，从 第二棵开始 ，依次把 后一棵二叉树的根结点 作为 前一棵二叉树的根结点的 右孩子 ，用线连起来。当所有的二叉树链接起来后，就得到了有森林转换来的二叉树。 二叉树转换为森林 从根结点开始,若右孩子存在,则把 与右孩子的结点的连线删除 ,在查看分离后的二叉树,若右孩子存在,删除….直到所有的右孩子连线都删除为止,得到分离的二叉树 每棵分离后的二叉树转化为树即可. 树和森林的遍历 先序遍历先访问根结点，然后依次先序遍历完每棵子树：ABCDEFGIJHK 后序遍历先依次后序遍历完每棵子树，然后访问根结点:CDBFIJGHEKA 哈夫曼树定义哈夫曼树，又称最优二叉树，是一类带权路径长度最短的树。 路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。路径长度：路径上的分支数目。树的路径长度：从树根到每一个结点的路径长度之和。树的带权路径长度：树种所有叶子结点的带权路径长度之和。哈夫曼树（最优二叉树）：假设有 n 个权值，试构造一棵有 n 个叶子结点的二叉树，每个叶子结点带不同的权，则其中带权路径长度最小的二叉树被称为：哈夫曼树。 如： a的带全路径长度为：7x2+5x2+2x2+4x2=36b的带全路径长度为：7x3+5x3+4x2+2x1=46c的带全路径长度为：7x1+5x2+2x3+4x3=35 则：c树的带权路径长度最小，c树为哈夫曼树。 哈法曼树构造哈法曼树： 对给定的n个权值{W1,W2,W3,…,Wi,…,Wn}构成n棵二叉树的初始集合F={T1,T2,T3,…,Ti,…, Tn}，其中每棵二叉树Ti中 只有一个权值为Wi的根结点，它的左右子树均为空。 在F中选取 两棵 根结点 权值最小 的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值 为其左右子树的根结点的 权值之和。 从F中删除这两棵树，并把这棵 新的二叉树 同样以 升序排列 加入到集合F中。 重复2）和3），直到集合F中只有一棵二叉树为止。 实现图解 前缀编码：若要设计长短不等的编码，则必须是任一个字符的编码都不是另一个字符的编码的前缀。这种编码称为：前缀编码。 哈夫曼编码：由哈夫曼树对应的字符串转换的对应最短二进制码，就是哈夫曼编码。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络篇-基础]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[网络篇 - 基础总结 参考：http://www.cnblogs.com/maybe2030/p/4781555.html参考：https://blog.csdn.net/GitChat/article/details/78546898参考：https://blog.csdn.net/never_cxb/article/details/50420521参考：https://blog.csdn.net/zhangliangzi/article/details/51812415参考：https://blog.csdn.net/cxq2111504104/article/details/73480109参考：https://blog.csdn.net/guoguo527/article/details/52078962 计算机网络学习的 核心内容 就是 网络协议 的学习。网络协议是为计算机网络中进行 数据交换 而建立的 规则、标准或 约定 的集合（就像 普通话 之于全国人民之间的沟通、英语 之于全球人类之间的沟通），如：TCP/IP协议。 为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，于是提出了 网络模型、网络协议 网络模型层次划分 协议： 是控制 两个对等实体 进行通信的规则的集合，协议是 水平的。 服务： 任一层实体需要 使用下层服务，遵循本层协议，实现本层功能， 向上层提供服务，服务是 垂直 的 。 出现的先后顺序： OSI 7层 ：先有模型，后有协议，先有标准，后进行实践； TCP/IP 4层 ：先有协议和应用再提出了模型，且是参照的OSI模型。 实际应用： OSI 是一种理论下的模型 TCP/IP 已被广泛使用，成为网络互联事实上的标准。 7层 -&gt; 5层 -&gt; 4层 网络层次模型变化 7层 与 4层 网络层次模型表格对比 7层参考模型 - OSI/RM开放系统互联参考模型 —— OSI/RM（Open System Interconnection/Reference Model）。 数据在此网络模型中传递数据 物理层（Physical Layer） 该层为上层协议提供了一个 传输数据的可靠的物理媒体，激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。 传输的数据形式是比特流。 2个重要的设备名称：中继器 和 集线器。 数据链路层（Data Link Layer） 为网络层 提供可靠的数据传输；基本数据单位为帧； 主要的协议：以太网协议； 2个重要设备名称：网桥 和 交换机 网络层（Network Layer） 负责对子网间的数据包进行 路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；基本数据单位为IP数据报； 主要协议： IP协议（Internet Protocol，因特网互联协议）、 ICMP协议（Internet Control Message Protocol，因特网控制报文协议）、 ARP协议（Address Resolution Protocol，地址解析协议）、 RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 1个重要设备名称：路由器 传输层（Transport Layer） 负责将上层数据 分段 并提供 端到端的可靠、不可靠的传输 以及端到端的差错控制、流量控制问题； 主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）； 重要设备：网关 会话层（Session Layer） 管理主机之间的 会话进程，即负责建立、管理、终止进程之间的会话。 利用在数据中插入校验点来实现 数据同步。 主要协议：NetBIOS、SAP、SDP、NWLink 表示层（Presentation Layer） 对上层 数据或信息进行变换 以保证一个主机应用层信息可以被另一个主机的应用程序理解，数据转换包括数据的 加密、压缩、格式转换等。 主要协议：ASCII、MPEG、JPEG、MIDI 应用层（Application Layer） 为操作系统或网络应用程序 提供访问网络服务的接口。 主要协议：HTTP、SMTP、FTP、Telnet、DNS、DHCP、SSH TELNET 5层参考模型 物理层 比特传输 数据链路层 以太网（Ethernet）、 802.11 (WiFi)、PPP 网络层 IP协议、路由协议等 传输层 TCP, UDP 应用层 FTP, SMTP, HTTP 4层参考模型数据包传递过程。图片来自网络，十分贴切： HTTP 协议超文本传输协议 —— HTTP（HyperText Transfer Protocol），互联网上应用最为广泛的一种网络协议，是用于从万维网 WWW（:World Wide Web ）服务器 传输超文本到 本地浏览器 的传送协议。 HTTP协议工作于 客户端-服务端 架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 特点 无连接： 限制每次连接只处理 一个请求 。服务器处理完客户的请求，并收到客户的应答后，即断开连接。 无状态： 无状态是指协议 对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 灵活： 允许传输 任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。 简单快速： 客户向服务器请求服务时， 只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 URLURL组成 URI 与 URL2者都是 定位资源位置 的，就像 经纬度 一样可以表示你在世界的哪个角落。 定义： URI（Uniform Resource Identifier）：统一资源 标志符，是一种宽泛的含义、定义更广。 URL（Uniform Resource Locator）：统一资源 定位符，URL则是URI的一个子集。 操作： URI ：在 java.net.URI 只能看到一些属性，只是表示一个位置，但是无法通过 URI 获取到 这个对象的流 URL ：在 java.net.URL 该类提供方法 openConnection()，通过该方法我们可以 通过IO流进行操作。 HTTP - Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式，由4部分组成： 请求行（request line） 请求头部（header） 空行 请求数据 示例：以Post为例 HTTP - ResponseHTTP响应也由4个部分组成： 状态行 消息报头 空行 响应正文 HTTP - 状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 Http 请求方法 GET ： 请求指定的页面信息，并返回实体主体。 POST ： 向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中，可能会导致新的资源的建立和/或已有资源的修改。 HEAD ： 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 PUT ： 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE ： 请求服务器删除指定的页面。 CONNECT ： HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS ： 允许客户端查看服务器的性能。 TRACE ： 回显服务器收到的请求，主要用于测试或诊断。 GET 和 POST请求的区别 形式： GET 提交的数据会放在 URL之后 ，以?分割URL和传输数据，参数之间以&amp;相连。 POST 方法是把提交的数据放在HTTP包的 Body中。 大小： GET 提交的数据 大小有限制（因为浏览器对URL的长度有限制） POST 方法提交的数据 没有限制. 安全性： GET 方式提交数据时，参数 的键和值直接 出现在URL上。 获取值： GET 方式需要使用 Request.QueryString 来取得变量的值 POST 方式通过 Request.Form 来获取变量的值。 TCP 协议TCP 区别 UDP TCP：面向连接、可靠 TCP的三次握手机制很大程度上保证了连接的可靠性，其实网络的不安全不稳定特性，无论多少次握手都不能保证连接的可靠性 。 UDP：无连接、不可靠 UDP传送数据前并 不与对方建立连接，对接收到的数据也 不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发。但是正是因为没有三次握手机制，导致了其达到了TCP无法达到的传输效率。 TCP建立连接 - 3次握手3次握手描述 主机A 发起握手，目的端点是服务端的端点 post_server 生成一个随机数作为它的初始化发送序号 x 发出一个同步报文段，SYN = 1，发送序号 seq = x 发出后进入 SYN_SEND 状态，等待服务器确认 服务端 监听到端口 post_server 上有链接，则响应 生成一个随机数作为它的初始发送序号 seq = y 发出一个同步报文段，并对主机A端口的连接请求进行确认，发送ack = x+1 发送 SYC+ACK 包，此时服务器进入 SYN_RECV 状态 主机A 发出对 服务器端口 post_server 的确认，确认序号 ack = y+1，同时还有 ack = x+1 客户端和服务器端进入 ESTABLISHED 状态，完成三次握手 图形描述-简化 图形描述-详细 为什么是3次握手 第一次：客户端发送，服务端知道 客户端 可以发送数据 第二次：服务端接收、发送，客户端知道 服务端 能收、能发 第三次：客户端接收、发送，服务端知道 客户端 能收、能发 3 次是双向通信的最小值，也就是 SYN, SYN ACK, ACK。如果2次握手的话，客户端有可能因为网络阻塞等原因会发送多个请求报文，这时服务器就会建立连接，浪费掉许多服务器的资源。所以要增加第三次握手。 TCP关闭 - 4次握手4次握手描述 主机A的端口通知主机B的端口 应用程序通知 TCP数据 已经 发送完毕时，关闭连接。 TCP 向主机B 发送一个带 FIN 附加标记的报文段：FIN = 1，seq = x 主机B响应 收到 FIN 报文段后，并没有立刻用 FIN 报文段 回复主机A，而是先向主机A 发送一个确认信号（目的是为了防止这段时间内，主机A重复的发送 FIN 报文段）：ACK = 1，ack=x+1 。 同时，通知自己相应的应用程序：主机A传输已经结束，对方要求关闭连接。 主机B关闭向主机A发送数据的端口 自身的应用程序告诉 TCP：我也要彻底关闭连接。 TCP 收到对最后数据的确认后，向主机A发送一个 FIN 报文段：FIN = 1，seq = y, ACK:ack = x+1; 主机A响应 收到 FIN 这个报文段后，向主机B发送一个 ACK = 1， ack = y+1 表示连接彻底释放。 主机B收到主机A的ACK报文段后，关闭连接。此时，主机A等待2MSL （Maximum Segment Lifetime）后依然没有收到回复，则证明主机 B已正常关闭，那好，主机A也可以关闭连接了。 图形描述-简化 图形描述-详细 为什么是4次握手 参考：https://www.cnblogs.com/zengzy/p/5107516.html TCP是 全双工模式，关闭连接时，当 主机 B收到主机A的FIN报文时，仅仅表示主机 A不再发送数据，但是还能接收数据。 SocketUNIX BSD 发明了socket，其屏蔽了各个协议的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。 Socket 其实是提供了 tcp/ip协议的抽象，对外提供了一套接口，同过这个接口就可以统一、方便的使用tcp/ip协议的功能了。 Socket 在Java 中的实现需要通过 IP地址 + 端口号实现（TCP是两个进程之间的通信，一个客户端有多个进程同时进行通信，使用端口号加以区分）。 Socket 在网络模型中的位置 图片来自网络 套接字（Socket）编程接口是从顶上3层（应用层）进入传输层的接口，因为： 顶上3层处理的是具体的网络应用的所有细节，而对通信细节了解很少；低下4层对具体的网络应用了解不多，却处理所有的通信细节。 顶上3层通常构成所谓的用户进程，低下4层却通常作为操作系统的内核的一个部分提供。 Socket 与 TCP/IP 与 HTTP协议 3者之间的关系应用层的HTTP协议是基于 TCP协议的，传输层的 TCP协议 是基于 网络层的 IP协议的，Socket本身不算是协议，仅仅是提供了一个针对TCP或者UDP编程的接口。 HTTPSHTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）基于安全套接字层的超文本传输协议。HTTPS = HTTP + SSL HTTP与HTTPS的不同点 HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层 HTTP 无需加密，而 HTTPS 对传输的数据进行加密 HTTP 无需证书，而 HTTPS 需要认证证书 什么时候该使用 HTTPS?银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk反编译 - 构建、打包篇]]></title>
    <url>%2FApk%E5%8F%8D%E7%BC%96%E8%AF%91%20-%20%E6%9E%84%E5%BB%BA%E3%80%81%E6%89%93%E5%8C%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Apk反编译 - 构建、打包 之前总是根据用到的、学习到的知识点进行总结，写博客。但是写的多了，写的时间长了，在写到一个具体的知识点的实现过程时，会有意的意识到，这个知识点可以和之前的某个知识点串起来，而那个知识点又可以和另外知识点连接起来，这样我就在无形之中，将自己的知识点串联了起来，形成了属于我自己、适合我自己的知识体系、系统架构。 这一点是我在一开始写博客时，没有想到的。我一开始的想法仅仅是想记录下当前的这个点，方便自己以后日后使用。同样，正是由于这个意外的收获，是我更加坚定了自己写好博客、写有质量的博客、写知识系统性的博客。形成良性循环。 带着问题工作，思考工作中的每一个环节。 关注 各个大厂 的 微信技术公众号，从实际的产品中看热门知识点的应用。 Android构建过程Apk打包本文的分析方式为：反向分析。由结果向后倒推。 了解 Android 的打包流程，有助于我们做一些 针对编译期的优化，包括但不限于提高打包速度，提高 Android 应用的 hack 难度增加安全性，减少 Android 安装包的体积，完成一些自动化的编码，减少编码压力等。 Apk 文件构成 参考：https://mp.weixin.qq.com/s?__biz=MzI0NjIzNDkwOA==&amp;mid=2247483789&amp;idx=1&amp;sn=6aed8c7907d5bd9c8a5e7f2c2dcdac2e&amp;scene=1&amp;srcid=0831CCuRJsbJNuz1WxU6uUsI#wechat_redirect 概览apk 文件本质上其实是一个 zip包。 基本的 Apk包内容： 红色标注部分，这一些文件和文件夹是一个 Android 应用基本都具备的。而其他的一些文件和文件夹则是一些第三方库，或者是其他一些代码生成的。 不同项目的包的内容的差异： 1. AndroidManifest.xml是 Android 应用的全局配置文件 ，它包含了这个应用的很多配置信息，例如包名、版本号、所需权限、注册的服务等。 可以根据这个文件在相当程度上 了解这个应用的一些信息 。该文件在直接解压的状态下是被编译为二进制的 XML 文件，是 无法直接查看 的。 2. assets 文件夹assets 文件 夹用于保存 需要保持原始文件的资源文件夹，开发过程中拖了什么到里面，打包完之后里面还是什么。一般用于存放音频，网页（帮助页面之类的），字体等文件。 主要需要知道的点是它与 res 文件夹的区分 以及如何在应用中访问该文件夹的资源，如它可以有多级目录而 res 则只有两级。 assets 文件 与 res 文件夹 的 区分 子目录不同： res目录中的资源 只能存储在相应的子目录 (如res/layout、res/values等)中 ssets目录中的资源可以 任意存放，也可以建立任意层次的子目录 引用资源的方式 不同： res目录 中的 所有资源 都会在 R类 的相应子类中 生成对应的int类型变量，需要使用这些变量来引用资源。 assets目录中的资源需要 直接使用文件名 来引用，返回与资源文件对应的 InputStream对象，剩下的操作就是普通的Java代码 输入流 操作了。 例如： 12InputStream is1=getResources().getAssets().open(&quot;xyz.xml&quot;);InputStream is2=getResources().getAssets().open(&quot;abc/test.db&quot;); 编译时处理方式不同 res目录中 的资源子目录 除了raw 外，其他资源目录中的资源文件 都会被编译，这也是为什么将APK文件解压后无法直接查看XML格式资源文件内容的原因。 assets与res/raw目录 中的资源文件 不会做任何处理，在调用时通过 流 的方式，所以将APK解压后，这两个目录中的资源文件都会保持原样。 3. dex 文件classes.dex 文件是 Android 系统运行于 Dalvik Virtual Machine 上的 可执行文件，也是Android 应用程序的核心所在。 项目工程中的： Java 源码 通过 javac 生成 class 文件， 再通过 dx 工具 转换为 classes.dex， 注意： 这里有 classes2.dex和 classes3.dex。 1：这是 方法数超过一个 dex 的上限，分 dex 的结果。2：分 dex 在 Android 5.0 之前需要开发者自行完成，5.0 后 dx 自带支持。3：目前一些热补丁有关的技术，主要便是对 dex 做各种处理。 4. lib 文件夹该目录存放着应用需要的 native 库文件：如一些底层实现的图片处理、音视频处理、数据加密的库以 so 库的形式在该文件夹中。 而该文件夹下有时会 多一个层级，这是 根据不同 CPU型号 而划分 的，如 ARM，ARM-v7a，x86等。 5. META-INF 文件夹该目录的主要作用是用于保证 APK 的 完整性 以及 安全性。 主要有三个文件： MANIFEST.MF：保存了整个 apk 文件中 所有文件的文件名 + SHA-1后的 base64 编码值。这也就意味着 MANIFEST.MF 象征着 apk 包的完整性。 CERT.RSA：这个文件保存了 公钥 和 加密方式 的信息。 CERT.SF：这个文件与 MANIFEST.MF 的结构一样，只是其 编码被被私钥加密。 6. res 文件夹放的所有文件都会 被映射到 R 文件 中，生成对应的 资源 ID，便于代码中 通过 ID 直接访问。其中的资源文件包括了动画(anim)，图像(drwable)，布局(layout)，常量值(values)，颜色值(colors)，尺寸值(dimens)，字符串(strings)，自定义样式(styles)、菜单(menu)等。 7. resource.arsc 文件此文件是所有文件中 结构最复杂 的。 string 的信息最多 resource.arsc 是可以包含 多个 package 的资源的。 然后可以看到一个 Resource Types 的列表。这里看到的是 anim 的 type。 右边显示了有多少个 anim 以及多少项 configurations，以及表的具体内容为 ID - Name - 各个维度的值（在这里即是资源的路径），通过这个可以完成通过 id + 对应的 configuration 获取对应资源的操作。 资源混淆的原理，就是修改这里 各个维度的值，并修改 对应 res 里面的文件夹 以及 文件名实 现的。 Android 打包流程 参考：https://www.jianshu.com/p/8d691b6bf8b4参考：https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232113&amp;idx=1&amp;sn=02f413999ab0865e23d272e69b9e6196&amp;scene=1&amp;srcid=0831gT4p6M0NFG5HTTeRHTUC#wechat_redirect Android的是如何构建一个APK的？此图是谷歌官方发布的一张.apk打包流程图。 概述： 流程概述： 资源打包。应用程序的资源文件（res 文件下各个文件），通过AAPT打包成 R.java类（资源索引表）、.arsc文件。 AIDL处理。如果有AIDL，则通过 AIDL工具，打包成 Java接口类。 生成.class文件。R.java 和 aidl.java 通过 Java编译成为目标的 .class文件。 dx处理。第三方jar 或者 lib 通过 .dx工具 打包成 dex文件， .dx工具 的主要作用是将 Java的字节码 转换为 Dalvik的字节码，在此过程中会 压缩常量池，消除一些冗余信息。 apk打包。apkbuilder工具 会将所有 未编译的资源文件、.arsc资源、.DEX文件打包到一个完成的 apk文件 中。 签名。完成的apk将通过配置了签名文件（调试和释放都有）的 jarsigner工具 对其进行签名。得到一个签名后的APK：signed.apk 对齐处理。zipalign工具 对 signed.apk 进行对齐处理，所谓对齐，主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问APK文件时的速度会更快。对齐的作用主要是为了减少运行时内存的使用。 Android 打包后续加固快速多渠道包资源混淆热补丁]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Apk</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk反编译 - 工具篇]]></title>
    <url>%2FApk%E5%8F%8D%E7%BC%96%E8%AF%91%20-%20%E5%B7%A5%E5%85%B7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Apk反编译 - 工具 参考：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/1002/8570.html 工具工具套装-01 ApkTool： 作用：拆包，得到AndroidManifest和res等资源文件下载地址： http://ibotpeaches.github.io/Apktool/install/ dex2jar： 作用：classes.dex转化成jar文件下载地址： https://sourceforge.net/projects/dex2jar/files/ jd-gui： 作用：将jar文件转换成java代码下载地址： http://jd.benow.ca/ 工具套装-02jadx： 一步到位Apk反编译处理、强大的集合工具。 GitHub 项目地址：https://github.com/skylot/jadx zip包下载地址：https://bintray.com/skylot/jadx/releases/v0.7.1#files 工具套装-03 Android Studio 自带的 Apk 分析工具 将一个 Apk 拖进 Android Studio； 或者在执行 Build APK(s) 后，双击 build/output/apks/目录下的apk 即可显示： 通过此工具可以对 Apk 在宏观上有一个系统的认识，是 宏观 性的。 使用工具套装01 - ‘ApkTool + dex2jar + jd-gui’ApkTool拆解Apk文件，反编译 其中的资源文件，将它们反编译为 可阅读 的AndroidManifest.xml文件和res文件。 若是直接把Apk文件当做 zip解压，得到的xml资源文件都是 无法 直接用文本编辑器打开阅读的，因为它们在打包时经过了build-tools的处理。 在终端中执行以下命令： 1java -jar apktool_2.3.3.jar d police.apk 注意： 在执行命令时，一定要将 待处理的Apk文件 放置在 和 apktool_XXX.jar 文件同一文件目录下。 dex2jar在执行此步骤时，需要对 Apk文件进行解压，之后将解压文件夹中的 classes.dex文件 复制到 dex2jar_XX 文件夹中，如下： 然后在 当前目录 dex2jar_XX 下，运行命令： 1sh d2j-dex2jar.sh classes2.dex 若在原有文件的基础上，得到一个新文件 classes2-dex2jar.jar，这就表明处理成功： 注意： 若是在执行命令过程中，遇到了 权限问题，可作出如下修改即可： 1sudo chmod +x d2j_invoke.sh jd-gui到这一步就是 查看java代码 的环节了。点击 jd-gui-osx-1.4.0 目录下的 JD-GUI.app 文件， 会弹出一个UI窗口： 选择刚刚得到的 classes2-dex2jar.jar 文件： 打开后的界面为： 至此，就可以选择具体的包，查看具体的代码了： 工具套装02 - ‘jadx’jadx 的 官方使用参考：https://github.com/skylot/jadx博客参考：https://blog.csdn.net/Fisher_3/article/details/78654450 优点： 图形化的界面。 拖拽式的操作。 反编译输出 Java 代码。 导出 Gradle 工程。 根据自己的路径，进入到 jadx-0.7.1/bin 后，点击 jadx-gui 文件，即可开启UI窗口 然后选择要反编译的 Apk文件 即可： 其中的文件，除了 .java文件 是可读的之外，资源文件也是可直接读的： 区别jd-gui 与 jadx 对比jadx 可直接导出 gradle 项目但是貌似只有 .java文件 导出结果： 对 .java文件 的反编译能力不同，从对比可以看出，对于同一个 加固极好的CM.apk 文件而言，明显 jadx 反编译出的文件要多： 具体反编译的代码对比可以看出 jadx 反编译出的的文件的图标标识更符合 一般情况下对 Java 的认识，更熟悉。 变量：能够发编译出变量名的就显示变量名；对于不能编译出的变量名， jadx 是通过以下： 功能实现 自定义命名变量名 的如： f142g，但是这样的 变量名没有实际意义，仅仅就是一个变量的区分、标识而已。 而且同时不能实现通过 点击 进行变量间的跳转，仅仅是颜色上的区分，如： jd-gui 是通过以下： 功能实现 自定义命名变量名 的如： b，但是这样的 变量名没有实际意义，仅仅就是一个变量的区分、标识而已。 不同点： jd-gui 中的变量通过点击是 可以进行跳转 的，这一点真的是非常有用。 代码格式 jadx： 严格 符合代码格式的，且 代码颜色更为丰富。jd-gui： 不严格 符合代码格式，仅仅是有一个缩进的样子而已，代码颜色较为单一。 代码实现反编译结果 同一个方法内部的 代码实现是不同 的。左侧为： jadx ， 右侧为：jd-gui]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Apk</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器]]></title>
    <url>%2FJava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Java-容器 总结 优化是一个棘手的问题，但最好的策略就是置之不顾，直到你发现需要担心它了。 —— 《Java编程思想》 常用集合之间的继承、实现关系 常用容器类 Java容器类的用途是：保存对象 迭代器： 作用： 是 遍历 并 选择 序列总的对象，客户端程序员无需知道 该序列的底层结构 特点： 一般的只能单向移动（ListIterator 双向，只能适用于各种 List类 的访问） 使用 next() 获取序列中的下一个元素 使用 hasNext() 检查序列中是否还有元素 一个简单迭代器的实现 12345678910111213141516171819202122232425public class DinerMenuIterator implements Iterator &#123; MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if (position &gt;= items.length || items[position] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; MenuItem menuItem = items[position]; position++; return menuItem; &#125;&#125; 一个 display() 123456public static void display(Iterator&lt;String&gt; iterator)&#123; while (iterator.hasNext()) &#123; String item = iterator.next(); System.out.println(item); &#125;&#125; Collection 集合 参考: https://www.cnblogs.com/jing99/p/6947549.html Collection 继承了 Iterable 接口。 注意：Collections和Collection的区别 Collections包含有 各种有关集合操作 的 静态多态方法 Collection 是接口 子类特点对比 Set子接口：无序，不允许重复。增删快（不会引起元素位置改变）、查询慢 List子接口：有序，可以有重复元素。查询快、增删慢（会引起元素位置改变） List像数组一样，其建立了 数字索引 与 对象 的关联；支持添加重复的对象；有序（按照元素插入的顺序），一种可修改的序列。 LinkedList 与 ArrayList 特点对比 ArrayList：查询快（访问）、增删慢 LinkedList：增删快、查询慢 ArrayList数据底层结构 是 数组特点：查询快（随机访问元素）、增删慢 ArrayList 与 Arrays 与 ArrayArray类 ：提供静态方法来动态创建和访问Java数组，数组是大小固定的，并且同一个数组只能存放类型一样的数据。Arrays类 ：该类包含用于处理数组的各种方法（如排序和搜索）。 此类还包含一个静态工厂，允许将数组视为列表。使用相应的toArray()和Arrays.asList()方法可以相互转换。 ArrayList本质 - Object[]由源码的 成员变量声明 ： 1234private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData; 以及：构造函数： 12345678910111213141516171819202122232425262728public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;// - - - -public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;// - - - -public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 来看：ArrayList 本质是：是一个 容量可变 的 Object[] 。 ArrayList的扩容最终调用的扩容方法 123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 通过 Arrays.copyOf(elementData, newCapacity) 方法获取新的 数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 在 Arrays 类中 通过 copyOf() 方法 生成新的 数组。具体实现过程： 先创建新数组 再复制 1234567891011121314151617181920212223242526复制指定的数组，使用空值截断或填充（如有必要），以便副本具有指定的长度。对于在原始数组和副本中都有效的所有索引，这两个数组将包含相同的值。对于在副本中有效但不是原始副本的索引，副本将包含 `null`。当且仅当 **指定的长度大于原始数组的长度** 时，这些指数才会存在。返回的结果是 `newType` 类的数组参数说明： @param &lt;U&gt; 原始数组中对象的类 @param &lt;T&gt; 返回数组中对象的类 @param original 要复制的数组 @param newLength 要返回的副本的长度 @param newType 要返回的副本的类 -&gt; &lt;T&gt; @return 原始数组的副本，用空值截断或填充以获得指定的长度 public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") // 先创建新数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); // 再将源数据复制到新数组 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; Array 类的 newArray() 进行具体数组 类型 的创建，即：Arrays 类中 copyOf() 方法中的 T[] copy 实例 类型。 在具体的创建过程中，有一个方法： isPrimitive() ，其作用是：确定 对象类型 是否为 预定义的9个（ 8种基本类型 和 void） 类型。 123456789101112131415161718192021222324private static Object newArray(Class&lt;?&gt; componentType, int size) throws NegativeArraySizeException &#123; if (!componentType.isPrimitive()) &#123; return createObjectArray(componentType, size); &#125; else if (componentType == char.class) &#123; return new char[size]; &#125; else if (componentType == int.class) &#123; return new int[size]; &#125; else if (componentType == byte.class) &#123; return new byte[size]; &#125; else if (componentType == boolean.class) &#123; return new boolean[size]; &#125; else if (componentType == short.class) &#123; return new short[size]; &#125; else if (componentType == long.class) &#123; return new long[size]; &#125; else if (componentType == float.class) &#123; return new float[size]; &#125; else if (componentType == double.class) &#123; return new double[size]; &#125; else if (componentType == void.class) &#123; throw new IllegalArgumentException("Can't allocate an array of void"); &#125; throw new AssertionError();&#125; 当执行 123if (!componentType.isPrimitive()) &#123; return createObjectArray(componentType, size);&#125; 时，调用 Array 类的 private static native Object createObjectArray() 本地方法实现 创建数组副本。调用 System 类的 public static native void arraycopy() 本地方法实现 复制数组副本。 ArrayList 类中，clear() 方法的实现： 1234567public void clear() &#123; modCount++; for (int i = 0; i &lt; size; i++) // 为每一个元素置空，让其被 GC 回收 elementData[i] = null; size = 0;&#125; LinkedList数据底层结构 是 链表 特点：增删快、查询慢 源代码中，节点（Node） 的表示： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 各种 Queue 以及 栈 的行为，由 LinkedList 提供支持。 实现： Queue 接口 ：队列 队列 是一种典型的 先进先出 FIFO 的容器，即：从容器的一端放入，从容器的另一端取出，事物放入的顺序和取出的顺序是相同的。 队列 常被当做一种可靠的将对象从程序某的个区域 传输 到另一个区域的 途径，这一点在 并发编程 中特别重要。 实现：Deque接口 ：双端队列 Deque接口 中的每个操作都有 2种 方法，一种在 异常情况 下直接抛出异常奔溃，另一种则 不会抛异常，而是返回特殊的值，比如 false, null 既能作为 队列，实现 先进先出（FIFO）； 添加 元素是添加到 队尾，删除 时删除的是 头部 元素。 对应元素 添加、删除、获取元素 方法为： 也能作为 栈，实现 后进先出（LIFO） 这时 入栈、出栈 元素都是在双端队列的 头部 进行 对应的元素 压栈、出栈、获取元素 方法为： VectorVector是同步的，如果设计涉及到多线程，还是用Vector比较好一些。 SetSet 最常被使用的 测试归属性，可以很容易的查询某个对象是否在 Set 集合中。因此：查找 就成为了 Set 中最为重要的操作。 所有 Set子类 的 相同点： 不支持添加重复对象所有 Set子类 的 不同点： 顺序 HashSet：无序。是 最快的 获取元素方式，使用 散列函数 的存储方式。—— 快 TreeSet ：按照 比较结果的升序 保存元素，使用 红-黑树数据结构。—— 有序 LinkedHashSet：按照 被添加 的顺序保存元素。使用 散列函数 存储。—— 有序 HashSet对速度进行了优化。底层数据结构是 哈希表，覆盖 equals() 的同时 覆盖 hashCode()。 是 最快的 获取元素方式，使用 散列函数 的存储方式。 TreeSet底层数据结构是 二叉树。元素必须实现 Comparable接口。 有序存储： 按照比较结果的 升序 保存元素，使用 红-黑树数据结构。 LinkedHashSet底层数据结构是 链表（维护插入的次序） 和 哈希表，覆盖 equals() 的同时 覆盖 hashCode()。 按照 被添加 的顺序保存元素，使用 散列函数 存储。 Map将 对象 映射 到 其他对象 的能力是一种解决编程问题的杀手锏。 一组 成对 的 键值对 对象，允许使用键来查找值。因为映射中键的集合必须是唯一的，所以用Set。因为映射中值的集合可能不唯一，用Collection。 12345在Map中插入、删除和定位元素，HashMap是最好的选择。但如果您要按顺序遍历键，那么TreeMap会更好。根据集合大小，先把元素添加到HashMap，再把这种映射转换成一个用于有序键遍历的TreeMap可能更快。使用HashMap要求添加的键类明确定义了hashCode()实现。有了TreeMap实现，添加到映射的元素一定是可排序的。 各个实现类的特点： HashMap：最快 的查找技术，无明显顺序。—— 快 TreeMap：按照 比较结果的升序 保存键。—— 有序 LinkedHashMap：按照 插入顺序 保存键，同时保留了 HashMap 的查询速度。 —— 有序、快 HashMap 参考:https://www.cnblogs.com/chengxiao/p/6059914.html 最快 的查找技术，无明显顺序。 HashMap的工作原理 参考：http://www.importnew.com/7099.html 原理 HashMap 是基于 散列（hashing） 原理。 通过 put() 和 get() 存储和获取对象。当将 键值对 传递给 put() 方法时，它是调用 键对象 的 hashCode() 方法来计算 hasdCode，然后找到 bucket 位置来存储 键对象 和 值对象。当获取对象时，通过 键对象 的 equals() 找到正确的 键值对，然后返回 值对象。 碰撞问题 当 2个对象的hashCode 相同时，所以他们的 bucket 位置也相同，但是他们可能并不相同，此时碰撞 就会发生。 HashMap 通过使用 链表 来解决 碰撞问题。当发生 碰撞 时，对象会存储在 链表的下一个节点中，在每个 链表节点 中存放的是 键值对对象（包含有键值对的Map.Entry对象）。 如果 2个键对象的hashCode相同，如何获取值对象。（1）调用 get() 方法，HashMap 会使用 键对象 的 hashCode 找到 bucket 位置，然后获取对象；（2）如果有 2个值对象同时存储在1个bucket 中，通过 遍历链表 直到找到值对象：找到 bucket 位置后，回调用 keys.equals() 找到链表中正确的接节点，最终找到要找的值对象。 对象与 hashCode 的关系 如果 两个对象相等(equal)，那么他们 一定有相同的哈希值。 如果 两个对象的哈希值相同 ，但他们 未必相等(equal) —— 碰撞问题。 负载因子（load factor），容量 rehashing过程 ： 默认的负载因子大小为 0.75，当一个 map 填满了 75% 的 bucket 时，和其他集合类（如ArrayList）一样，将会创建原来 HashMap 容量 2倍 的 bucket数组，会重新调整 map大小，并将原对象放入新的 bucket数组 中。 为什么 类似 String、Integer这样的wrapper (final)类适合作为键 因为 String 以及其他的 wrapper 类，是 final 定义的，不可变的，是重写了 equals() 和 hasCode() 方法的。 不可变性 是必要的，因为为了要计算 hashCode() ，就要防止 键值 改变，如果 键值 在放入和获取时不同的话，就不能获取想要的 值对象。 因为 键值 不可变性 的必要，会减小 碰撞的几率 的发生，这样能提高 HashMap 的效率。 满足作为 键 的条件 可以使用任何遵守 equals() 和 hashCode() 的对象作为键。 源码中部分方法的实现 参考：https://blog.csdn.net/ymrfzr/article/details/51244052 具体放入键值对 的 put() 方法 123456/** * 将指定关键字和指定value关联在一起*/public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 计算key.hashCode（）并将散列（XOR）更高的散列位降低。 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; table 变量：表格首次使用时初始化，并根据需要调整大小。 分配时，长度始终是2的幂。 1transient Node&lt;K, V&gt;[] table; 具体执行 put 操作的 putVal() 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果table数组尚未创建（第一次调用put），则新建table数组 if ((tab = table) == null || (n = tab.length) == 0) // resize() 初始化或加倍表格大小。 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // table[i]中没有结点则创建新节点 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果p=table[i]的关键字与给定关键字key相同，则替换旧值 e = p; // 如果结点类型是TreeNode，则向红黑树中插入新节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 遍历链表，查找给定关键字 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 如果没有找到，则创建新节点 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 创建新节点后若超出树形化阈值，则转换为树形存储 treeifyBin(tab, hash); break; &#125; // 如果找到关键字相同的结点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e不为空，即map中存在要添加的关键字 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //修改map结构的操作数加1 ++modCount; if (++size &gt; threshold) //如果超出重构阈值，需要重新分配空间 resize(); afterNodeInsertion(evict); return null;&#125; put() 方法中使用到的 HashMap.Node&lt;K,V&gt;：基本哈希bin节点，用于大多数条目。 它是 Map.Entry&lt;K,V&gt; 接口的实现。Node&lt;K,V&gt; 的子类有：LinkedHashMap.LinkedHashMapEntry&lt;K,V&gt;，(红黑树形容器)TreeNode&lt;K,V&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 不可变的哈希值————由关键字key得来 final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; // 执行 异或运算，得到一个新的 hashCode return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 对象相同或同类型且key-value均相同，则返回true public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; TreeMap按照 比较结果的升序 保存键。 LinkedHashMap按照 插入顺序 保存键，同时保留了 HashMap 的查询速度。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM理解-并发与JVM内存模型]]></title>
    <url>%2FJVM%E7%90%86%E8%A7%A3-%E5%B9%B6%E5%8F%91%E4%B8%8EJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JVM理解 —— 并发与JVM内存模型之间的关系 Java程序多采用多线程的方式来支撑大量的并发请求处理，程序在多线程方式执行的情况下，复杂程度远高于单线程串行执行的程序。 多线程程序带来的最明显的问题就是 线程之间公共资源的竞争 与 线程之间的交互。 物理计算机的并发 高速缓存(Cache)释义： 由于计算机的存储设备与处理器的 运算速度 有着几个数量级的差距，所以需要加入一层 读写速度尽可能接近处理器运算速度的高速缓存，来作为 内存与操作系统之间的缓冲。 工作过程： 将运算需要的数据复制到缓存中，使得运算快速进行。当运算结束后再从缓存同步回内存中。 缓存一致性高速缓存虽然解决了处理器与内存之间的速度问题，但是也引入了 缓存一致性 的问题。 多处理器系统中，每一个处理器都有自己的高速缓存，但是它们又共享一块主内存，结果就是因为各自缓存的数据不一致，主内存不知该以谁的数据为准。 乱序执行优化除了 高速缓存 之外，为了使得处理器内部的运算单元能尽量被充分的使用，处理器可能会对 输入代码进行 乱序执行优化，。 在执行完计算之后将乱序执行的结果重组，保证 结果 与 代码顺序执行的结果 是 一致 的。但是 不能保证程序中各个语句计算的先后顺序 与 输入代码中的顺序是一致 的。 如果一个计算任务依赖另一个计算任务产生的中间结果，那么其顺序性将不能依靠代码的先后顺序来保证。 Java内存模型Java虚拟机规范中试图通过定义一种 Java内存模型 来 屏蔽 掉各种 硬件 和 操作系统 的 内存访问差异，以实现让 Java程序在各种平台下都能达到一致的运行内存访问结果。 Java内存模型的目标： 1定义程序中各个 变量 的 访问规则。即：在虚拟机中将变量 存储到内存 和 从内存中取出变量 这样的底层实现细节。 此处的 变量 与 Java程序中所指的变量有区别：它包括了 实力字段、静态字段、构成数组对象的元素，不包括局部变量与方法参数（属于线程私有，不会被共享）。 主内存 与 工作内存注意：在此部分中讲到的 主内存、工作内存 与 JVM中内存的划分不在一个层次上，两者基本没有关系。 各个内存中数据的处理主内存Java内存模型规定 所有变量 均存在于 主内存 Main Memory（可类比 物理计算机中的 主内存，但是此处仅是虚拟机内存的一部分） 中。 线程工作内存 每条线程还有自己的 工作内存 Work Memory（可类比物理计算机中的 高速缓存） 。 线程的工作内存中保存了 被该线程使用到的变量在主内存中的拷贝副本。 线程对该变量的所有操作都必须在 工作内存 中进行，而不能直接读写主内存中的变量。 不同的线程也无法 直接访问 其他线程中工作内存的变量。 线程间变量 值的传递 均需要通过 主内存 来完成。 内存间的交互操作8种操作主内存与工作内存间的具体交互，即：一个变量如何从主内存被拷贝到工作内存，又如何从工作内存被同步至主内存，是通过一下 8种 操作来完成的，虚拟机实现时必须保证下面提及的每一种操作都是 原子性、不可再分的。 lock（锁定） 作用于 主内存 中的变量； 把一个变量表示为 线程私有独占状态。 unlock（解锁） 作用于 主内存 中的变量； 把一个处于 锁定 状态的变量释放出来，然后此变量才能被其他线程锁定。 read（读取） 作用于 主内存 中的变量； 把一个 变量的值从主内存传递至线程的工作内存中，方便 load 动作的使用。 load（载入） 作用于 工作内存 中的变量； 把 read 操作中得到的变量值放入到 工作内存 的变量副本中。 use（使用） 作用于 工作内存 中的变量； 把工作内存中得到的变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时，将会执行这个操作。 assign（赋值） 作用于 工作内存 中的变量； 把一个从执行引擎接收到的值赋给工作内存中的变量。每当虚拟机遇到一个给变量赋值的字节码指令时，就执行该操作。 store（存储） 作用于 工作内存 中的变量； 把工作内存中一个变量的值传送到主内存中，以便 write 操作。 write（写入） 作用于 主内存 中的变量； 将从 store 操作中得到的变量的值赋给 主内存中 的变量。 变量的在内存间的移动一个变量从主内存复制到工作内存，需要顺序执行： 1read、load 把变量从工作区同步至主内存，需要顺序执行： 1store、write Volatile型变量的特殊规则1是 Java虚拟机 提供的 轻量级 同步机制 特性当一个变量被定义为 volatile 时，此变量将会具备2种特性： 可见性 禁止 指令重排序优化 Java内存模型中对volatile定义的规则 假定有1个线程：T，2个volatile变量：V、W，那么在进行read、load、use、assign、store、write操作时应满足如下规则： 规则1 - 刷新123只有当线程T对变量V的前一个动作是 `load` 时，线程T才能对变量V执行`use`动作；并且，只有当线程T对变量V执行的后一个动作是 `use` 时，线程T才能对变量V执行 `load` 操作。线程T对变量V的`use` 操作可以认为是和线程T对变量V的`load`与`read`操作相关联，必须连续一起出现。 此规则要求在工作内存中，每次使用变量V前都必须先从主内存刷新变量的最新值，用于保证当前线程能看到其他线程对变量V的值所做的修改 规则2 - 同步123只有当线程T对变量V的前一个动作是 `assign` 时，线程T才能对变量V执行`store`动作；并且，只有当线程T对变量V执行的后一个动作是 `store` 时，线程T才能对变量V执行 `assign` 操作。线程T对变量V的`assign` 操作可以认为是和线程T对变量V的`store`与`write`操作相关联，必须连续一起出现。 此规则要求在工作内存中，每次 修改 变量V的值后都必须立刻同步回主内存中，用于保证其他线程能看到自己对变量V的值所做的修改 规则3 - 禁止指令重排序12345假定动作A是线程T对变量V实施的`use`或`assign`操作，动作F是和动作A相关联的`load`或者`store`操作，动作P是和动作F相关联的`read`或者`write`操作；类似的：假定动作B是线程T对变量W实施的`use`或`assign`操作，动作G是和动作B相关联的`load`或者`store`操作，动作Q是和动作G相关联的`read`或者`write`操作；如果：A先于，那么 P先于Q。 此规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同 volatile - 可见性可见性定义： 当一个线程对一个变量的值进行修改之后，此变量的 新值 对于 其他线程 而言是可以 立即得知 的。 工作内存非一致性volatile变量在各个线程的工作内存中 不存在 一致性的问题。 在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但是由于线程在每次使用变量值的时候 都需要先刷新，因此导致执行引擎看不到不一致的情况。 volatile变量并发安全问题volatile变量时原子性的，但是Java的运算却并非是原子性操作，导致 volatile变量的运算在并发下一样是不安全的。 满足以下2种条件时，可以使用volatile关键字 运算结果不依赖其他其他变量的当前值，或者能够确保只有单一线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束 若是不能满足以上2点，则必须使用 synchronized 关键字来保持 原子性。 volatile - 禁止指令重排序优化Java内存模型3个特征 原子性 可见性 有序性 原子性 由Java的内存模型来直接保证原子性变量的操作包括6种操作。可以大致认为基本数据类型的访问、读写是具备原子性的。 如果 需要有一个范围更大的原子性保证，则可以使用 synchronized 关键字。synchronized 块之间的操作也具备有原子性。 层级 对应关系 描述 JVM lock，unlock 操作符 字节码 monitorenter，monitorexit 字节码指令 Java synchronized 关键字 可见性可见性是指：1当一个线程修改了一个变量的值，那么其他线程能够立即得知这个改变。 Java内存模型是通过在变量的值修改后将新值同步回主内存，在变量读取前，从主内存刷新变量的值。 就是 次变量的值由本线程的工作内存同步至主内存，其他线程的工作内存主动从主内存刷新此变量的值 1本质是通过依赖主内存作为传递媒介来实现可见性的。 实现方式 synchronized final volatile synchronized 关键字是因为规则： 1对一个变量执行 unlock 操作前，必须把此变量先同步回主内存中（执行store、write操作）。 final 关键字是因为： 1一旦构造器将被修饰的变量、对象正常初始化后，那么其他线程是可见的。 volatile 关键字是因为： 1JVM内存模型的原子操作使然。 有序性处理 指令重排序 ＋ 主内存、工作内存的同步 问题。 Java语言中天然的有序性可以总结为： 如果在本线程中观察，所有的操作均是有序的（线程内部表现为串行的语义）； 如果在一个线程中观察另个一线程，所有的操作均是无序的（指令重排序+工作内存与主内存同步延迟）。 通过使用 volatile 与 synchronized 关键字实现有序性。 volatile 关键字本身禁止指令重排序优化 synchronized 则是通过规则： 1一个变量在同一时刻只允许一个线程对其进行 `lock` 操作。 先行发生原则 此原则是判断：数据是否存在竞争、线程是否安全 的主要依据。 先行发生指的是：两项操作之间的偏序关系。 Java内存模型中“天然”的 8种先行发生原则 程序次序规则：一个线程内按照 控制流顺序执行 传递性：例如：A先于B，B先于C，则A先于C。 对象终结规则：一个对象的初始化先于它的终结。 volatile变量规则 线程启动规则：Thread 对象的start先行于后面的每一个操作 线程中断规则：对线程 interrupt() 的调用先行发生于 检测方法的调用。 线程终止规则：线程中的所有操作都先行于线程的终结检测。 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作，必须是同一个锁。 线程 线程调度方式 协同调度：由线程自身控制调度，通过通知的方式调度其他线程。 抢占式调度：由系统进行调度。 线程安全： 当多个线程同时访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不用考虑额外的同步，那么这个对象就是线程安全的。 线程优先级： 线程优先级分为10级，但是并不可靠。Java 中的线程是映射到原生线程的，原始线层是由操作系统进行调度的，但是不同的操作系统对于优先级并不相同。 线程安全体现： final关键字 修饰的基本数据类型、类。 线程安全的实现： synchronized互斥同步。这个Java中的关键字对应着 字节码 中的 monitorenter 和 monitorexit 指令。注意，如果指定了 次关键字对应的 reference那么使用指定的引用，如果未指定那么就要判断作用的是 实例方法 还是 类方法，然去、后取对应的对象实例或者类实例。 线程状态及解析 描述 线程的状态 是用一个 枚举类型 来描述的，严格来讲一个线程有 6种状态 ，分别是 6个枚举值： NEW： 尚未开始的线程处于此状态 RUNNABLE：在Java虚拟机中 执行的线程 处于此状态 BLOCKED：` 等待监视器锁定的 阻塞 线程状态 TIMED_WAITING： 正在等待另一个线程执行某个动作达到 指定等待时间 的线程处于此状态 WAITING： 无限期 等待另一个线程执行特定操作的线程处于此状态 TERMINATED： 已 退出 的线程处于此状态 只不过人们平时理解的时候经常会增加阻塞状态，可运行状态，还有挂起状态。 也可以概括为： New： 创建尚未运行。 Runable： 包括 Running 和 Ready。 Blocked： 处于同步状态。 等待： 包括： Waiting： 无限期 ,Object.wait(),Thread.join()未设定Timeout参数的，通过其他的线程的显示唤醒可以再次运行。 Timed Waiting,Object.wait(),Thread.join(),Thread.sleep().已设定Timeout参数的，可以通过自身进行运行。 Terminated： 已 退出 线程。 参考：https://www.cnblogs.com/kevin-yuan/p/4112434.htmlhttps://www.cnblogs.com/trust-freedom/p/6606594.htmlhttp://www.cnblogs.com/ELMND/p/4737580.html 虚拟机在并发运行时数据区域的情况（图片来自网络）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM理解-内存管理]]></title>
    <url>%2FJVM%E7%90%86%E8%A7%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[JVM理解 —— 内存管理 Java不是由开发人员来显示分配内存和回收内存，而是由JVM来 自动管理内存的分配和回收（又称为：垃圾回收、Garbage Collection：GC）。这降低了开发的难度，但是实际使用中遇到的问题就是由于不清楚JVM的 内存分配 和 回收机制，造成内存泄漏，最终导致JVM内存不够用。 1. 内存空间JDK遵照 JVM规范进行内存区域的划分，如下： 程序计数器 Java虚拟机栈 本地方法栈 方法区（非堆） 堆 1.1 程序计数器数据活动范围： 当前线程私有 说明： 占用一块较小的内存空间。 可以看做是当前线程所执行的 字节码 的 行号指示器。 抛出异常： 无 Java虚拟机栈数据活动范围： 当前线程私有；生命周期与线程相同 说明： Java方法执行的内存模型：每个方法在执行的同时创建一个栈帧（Stack Frame），用以存储： 局部变量表 操作数栈 动态连接 返回方法地址 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中执行 入栈 到 出栈 的过程。 抛出异常： 线程请求的栈深度大于虚拟机所允许的深度，抛出：StackOverflowError。 无法申请到足够内存时，抛出：OutOfMemoryError。 1.2 本地方法栈数据活动范围： 当前线程私有 说明： 与 虚拟机栈发挥的作用类似，不同点： 虚拟机栈为虚拟机执行Java方法（字节码）服务 本地方法栈为虚拟机执行的 Native方法服务 抛出异常： StackOverflowError。 OutOfMemoryError。 1.3 方法区（非堆）数据活动范围： 所有线程公有 说明： 存储已被 虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。 永久代 运行时常量池，存放编译期生成的各种 字面量 符号引用 直接引用 具有动态性（相对于常量池） 抛出异常： OutOfMemoryError。 1.4 堆数据活动范围： 所有线程公有 说明： 是Java虚拟机所管理的内存中最大的一块， 唯一目的：存放所有对象实例、数组 是垃圾收集器管理的主要区域，实行：分代收集算法（JDK 1.2开始）： 新生代：Eden Space，Survivor Space（From Space）+ Survivor Space (To Space)（From:To = 1:1） 旧生代（新:旧 = 1:2） TLAB(Thread Local Allocation Buffer) 线程私有缓冲区 抛出异常： OutOfMemoryError。 1.4.1 新生代（New Generation）1.4.1.1 新生代内存由： Eden Space 2块相同大小的 Survivor Space 构成，也被称为：From Space 和 To Space。 Eden Space 与 From Space 与 To Space 所占新生代内存空间的比值= 8:1:1 新建对象只会存在于 Eden Space 和 From Space 中， To Space 是空的 —— 此种分配方式与 复制回收算法 有关。 不同的GC方式会以不同的方式来划分或者根据运行状态调整 Eden Space 和 Survivor Space 的大小。 大多数情况下Java程序中所有新建的对象都是从 新生代 的内存中分配的，当 Eden Space 不足时，会把存活对象转移动 Survivor Space 中。 新创建的对象一般情况下都会分配到 Eden Space 中（大对象、大数组分配到 旧生代 中），当对象经过第一次 Minor GC 后（对象年龄+1），如果仍然存活则将存活对象移动至 Survivor Space 中，当对象的年龄达到一定的岁数时，将被移动至 旧生代 中。 1.4.1.2 为什么 新生代中会有 Survivor Space？ 如果没有 Survivor Space ， Eden Space 中每进行一次 Minor GC后，存活的对象就会被送到 旧生代 中，这样就会导致 旧生代 很快被填满，发生 Major GC或 Full GC。 但由于 旧生代 内存空间远大于 新生代 空间，所以进行一次 Full GC 会消耗大量的时间。而且若是在无 Survivor Space的情况下，旧生代 被填满的速度大大加快，结果就是导致 频繁 的发生 Full GC，这将会影响程序的执行和响应速度，更有甚至会因为 超时 产生其他问题。 在无 Survivor Space 的情况下，如何解决？ 方案 优点 缺点 增加老年代空间 更多存活对象才能填满老年代。降低Full GC频率 随着老年代空间加大，一旦发生Full GC，执行所需要的时间更长 减少老年代空间 Full GC所需时间减少 老年代很快被存活对象填满，Full GC频率增加 上述两种解决方案都不能从根本上解决问题。 结论一： Survivor Space 存在的意义就是 减少被移动至 旧生代 中的对象，进而减少 Full GC 发生。 1.4.1.3 为什么 Survivor Space 会有 From Space 与 To Space 2块空间？由上文已经说明了为什么没有 Survivor Space 不行，这次假设只有 1块 Survivor Space。 当只有 1块 Survivor Space 时，新建对象填满了 Eden Space ，此时就会触发 Minor GC ，然后 Eden Space 中的存活对象被复制至 Survivor Space 中。 这样的操作一直循环下去，虽然存活对象得到了转移，但是这2个区域中对象所占用的内存地址并不是连续的，这就导致了在只有 1块Survivor Space 的条件下产生的问题： 1内存地址碎片化 内存地址碎片化导致的问题就是： 严重影响Java程序的性能，堆空间中被散布的对象占据着不连续的内存，最直接的结果就是：没有足够大的连续空间，内存碎片。 1.4.1.4 建立 2块Survivor Space 的意义当建立 2块Survivor Space 时： 对已满的 Eden Space 进行 Minor GC 时，存活对象就会被复制至 From Space 中，Eden Space 被清空。 当对已满的 Eden Space 再次进行 Minor GC 时，再次执行 Minor GC，Eden Space 和 From Space 中的存活对象将被复制至 To Space 中（ ==这种 复制算法 保证了 To Space 中来自 Eden 和 From Space 2部分中存活对象所占用的内存空间地址是连续的，避免了碎片化的产生 == ）。 之后对 Eden Space 和 From Space 内存空间进行清空，将 From Space 和 To Space 进行交换即：将 To Space 中存活的对象复制至 From Space 中，保证 To Space 是空的。 所以，建立 2块Survivor Space 的意义就是： 1永远有一个 Survivor Space 是空的，另一个非空的 Survivor Space 无碎片。 参考：https://blog.csdn.net/u012799221/article/details/73180509 1.5 旧生代（Old Generation/Tenuring Generation） 是用于存放 新生代 内存中经过多次垃圾回收后仍然存活的对象，例如 缓存对象。 新建的对象也有可能在 旧生代 中直接分配内存。主要由2种情况决定： 新建对象为大对象 新建对象为大数组对象，且数组中无引用外部对象 2. 内存分配2.1 堆分配Java对象所占用的内存主要是从 堆 上进行分配，堆 是 所有线程共享 的，因此在堆上分配内存时是 需要加锁 的。这导致了创建对象开销比较大。当 堆 上的内存空间不足时，会触发 GC ，如过 GC 后内存空间仍然不足，则抛出 OOM。 2.2 TLAB（Thread Local Allocation Buffer）分配 JDK 为了提升内存分配效率，会为 每个新创建的线程 在 新生代的 Eden Space 上分配一块独立空间。这块空间称为 TLAB（Thread Local Allocation Buffer），其大小是由JVM根据运行情况而得出的。 在 TLAB 中分配内存是 不需要加锁 的，因此JVM在给线程中的对象分配内存时会尽量在 TLAB 上分配。如果对象过大或者 TLAB 空间已经用完了，则仍然在 堆 上分配内存 因此在编写Java程序时，通常多个 小的对象比大的对象在内存分配上 更高效。 3. 垃圾回收JVM 通过 GC 来回收 堆 和 栈 中的内存。 **GC 的基本原理是**： 首先找到程序中不在被使用的对象 然后回收这些对象所占用的内存 3.1 GC 分类： Java 中的堆也是 GC 收集垃圾的主要区域。 Minor GC - 新生代 - 复制算法 Full GC（又称 Major GC）- 旧生代 - 标记-清除算法 3.1.1 Minor GC堆 中 新生代 中对象的生命周期（80%）一般为 朝生夕死。所以在 新生代 中使用的垃圾回收算法是 复制算发。 在GC开始前，对象只会存在于 Eden Space 和 From Space 区，此时 To Space 是空的。 当GC运行时，Eden Space 中存活的对象被复制到 To Space 中；同时 From Space 中的对象根据其年龄值（年龄阈值可以通过-XX:MaxTenuringThreshold来设置）来决定去向： 到达一定值，则对象将移动至 旧生代 ； 未达到一定值，则对象被复制到 To Space 中。 之后 Eden Space 和 From Space 区域已经被清空，此时，将 From Space 和 To Space 的角色进行交换（保证命名为 To Space 是空的）。 Minor GC 会一直重复这样的过程，直到 To Space 被填满，将所有对象移动至 旧生代 中。 3.1.2 Major GC Major GC 是发生在 旧生代 的垃圾收集动作，所采用的是 标记-清除 算法。 旧生代 中的对象有部分是从 新生代 中移动过来的。所以不会轻易被回收掉，因此 Major GC 不会像 Minor GC 那样发生的频繁，并且做一次 Major GC 要比 Minor GC 消耗的时间长。 由于使用 标记-清除 算法时，会导致产生内存碎片（即：不连续的内存空间），当此后要为较大的对象分配内存空间且没有较大内存空间时，会提前触发一次GC操作。 3.2 回收算法回收算法分类： 引用计数 收集器：判断对象的 引用数量 可达性 收集器：判断对象的 引用链是否可达 可达性收集器 所涉及的内存区域： JVM栈中引用的对象 方法区中类静态引用的对象 方法区常量引用的对象 JNI引用的对象 3.3 引用计数 收集器 引用计数 收集器采用的是 分散式 的管理方式，通过 计数器 记录是否对 对象进行引用。当 一个对象的引用计数器为0 时，说明此对象已经不在被使用，于是进行回收。 不足 引用计数器 需要在每次对对象赋值时进行 计数器的增减，它有一定的消耗。 引用计数器 对于 循环引用 的场景是 无法实现回收 的。如：对象B 和 对象C 互相引用时， 对于Java这种面向对象的会形成复杂引用关系的语言而言，引用计数器 是非常不合适的，在 JDK 的 GC 实现中 未采用 此种方式。 3.4 可达性 收集器可达性收集器采用的是 集中式 管理方式。全局记录 数据的 引用状态。 基于一定条件（定时、空间不足时）的触发 ，使用跟踪收集器，执行时需要从 根集合 来扫描 对象的引用关系 ，这可能会造成 应用程序暂停。 实现算法有3种： 复制（Copying） 标记-删除（Mark-Sweep） 标记-压缩（Mark-Compact） 3.4.1 复制（Copying）复制采用的方式是： 从 根集合 扫描出 存活的对象， 将 找到的存活对象 复制到 一块新的完全未使用的空间中 复制特点： 当要回收的空间中 存活的对象较少时，复制算法会比较高效，但是其带来的成本是：要 增加一块 全新的内存空间 及进行 对象 的 移动 3.4.2 标记-清除（Mark-Sweep）此种方式采用的是方式： 从 根集合 开始扫描， 对 存活对象进行标记 标记完成之后，再次扫描 整个空间中 未标记的对象，并对其进行回收。 标记-清除 特点： 此种方式 不需要进行对象的移动， 仅对 不存活的对象 进行清除。因此在空间中 存活对象较多 的情况下，较为高效。 由于此方式采用的是 直接回收不存活对象所占用的内存空间，因此会造成 内存碎片。 3.4.3 标记-压缩（Mark-Compact） 此种方式采用和 标记-清除 一样的方式对 存活对象进行标记 在 回收不存活对象所占用的内存空间 后，会将 其他所有存活的对象 都往 左端空闲的空间进行移动，并 更新引用其对象的指针。 标记-压缩 特点： 需要 对存活对象进行移动，成本相对较高 不产生碎片 参考：https://www.cnblogs.com/sunniest/p/4575144.html 3.5 对象引用强弱问题 引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 在内存不足时 对象缓存 内存不足时终止 弱引用 在垃圾回收时 对象缓存 gc运行后终止 虚引用 Unknown 标记的对象被回收后发送一条通知 Unknown 3.6 对象创建 虚拟机接到 New 指令后，先检查这个 指令的参数 是否能在 常量池 中定位到一个 符号引用，并检查此符号引用是否经过了加载、验证等一系列步骤。 若未经过此步骤，那么 先执行类加载步骤。 类加载检查通过后，JVM在堆中为新生的对象分配内存空间，空间的大小在类加载完成之后就已经得知。分配方式: 若堆中的 内存足够规整，那么进行 指针碰撞 内存分配； 若堆中 内存不够规整，那么进行 空闲列表内存分配。 分配内存空间 结束后，将对对象的进行 实际创建，创建方式： 对分配内存空间的动作进行 同步处理； 对分配内存空间的操作按照 线程 划分在 不同的空间 TLAB 中进行。 内存分配 结束后，JVM要将内存空间 初始化为0值。 JVM对 对象进行必要的设置。如：此对象是哪个类的实例、如何找打类的元数据信息、对象的hash值、对象的GC年龄等信息。 到此为止，在JVM中一个新的对象产生了，但是 Java中一个对象才刚开始创建，接下来要执行: &lt;init&gt;()，所有字段都归0.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM理解-编译、加载]]></title>
    <url>%2FJVM%E7%90%86%E8%A7%A3-%E7%BC%96%E8%AF%91%E3%80%81%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[JVM理解 —— 源码的编译、执行 Android 的 Dalvik VM 是Android平台的核心组件平台之一，其并不是一个 Java虚拟机： 没有遵循Java虚拟机规范； 不能直接执行Java的Class文件； 使用的是 寄存器架构 而不是JVM中常见的 栈架构； Android与Java联系： 执行的 dex（Dalvik Executable）文件 是通过 Class文件 转化而来； 使用Java语法编写应用程序，可直接使用大部分Java API。 JDK 与 JRE Java源码编译实质 .java文件 -&gt; .class文件，使用 Javac 编译器。 Java源码编译过程3个步骤 解析与填充符号表 注解处理 分析与字节码生成 编译过程的方法(这张图太经典了，高频出现) 1. 解析与填充符号表1.1 解析（parseFiles()） 词法： 将 源代码 的 字节流 转换为 标记（Token）集合。 单个字符 是程序编写过程中的最小元素，而 标记 则是编译过程中的最小元素。 使用 com.sun.tools.javac.parser.Scanner 类实现。 语法： 是根据 标记序列 构造抽象语法树 的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式。 使用 com.sun.tools.javac.parser.Parser 类实现。 注意：生成抽象语法树后，后续的操作均是基于 抽象语法树 的操作。 1.2 填充符号表（enterTrees()） 符号表 是由一组 符号地址+符号信息 构成的表格。 符号表 中所登记的信息在 编译 的不同阶段都要使用到。 使用 com.sun.tools.javac.comp.Enter 类实现。 默认实例构造器 在此过程中被添加。 2. 注解处理（processAnnotations()） JDK 1.5 后，新增功能。 作用时间：运行期 作用：类似一组编译器插件，通过插件可以：读取、修改、添加 抽象语法树 中的任意元素。 只要修改了 抽象语法树 后，编译器就要从 解析与填充符号表 重新开始。 3. 语义分析和生成class文件（Analyse and Generate）语义分析 因为抽象语法树 仅能保证 源程序的 结构正确 ，不能保证 源程序的语句 符合逻辑。 标注检查 变量相关检查 常量折叠 数据、控制流分析 对程序的上下文进行进一步验证 解语法糖 语法糖：也叫糖衣语法。指在计算机语言中添加某种语法，对语言功能本身没有影响，为的是方便程序员使用 意义：增加程序可读性，降低程序的出错可能性。 解语法糖：虚拟机在执行时不支持处理语法糖语句，所以需要在编译阶段将其还原回最基础的语法结构。 生成字节码文件 Java语法糖类型1：泛型与类型擦除泛型（JDK 1.5 新增）其本质是 参数化类型的应用，操作的数据被指定为一个参数。 特点： Java中的泛型，只在源码中存在，在编译后的 字节码文件中 ，已经替换为原来的原生类型，并且在相应的位置插入强制转型代码。 例如：对于运行期的 ArrayList&lt;int&gt; 与 ArrayList&lt;String&gt; 是同一个类 List&lt;E&gt; Java中的泛型实现方法为 类型擦除。 当泛型作为 重载方法 的参数时，是无法被编译通过的，若是在方法中使用不同的返回值，则编译通过。 类型2：自动装箱、拆箱、遍历循环List 类型3：条件编译在Java中通过使用条件为 常量 if语句，即可实现条件编译。条件为 常量 的if语句不同于其他Java代码，他在编译阶段就会被 运行。仅运行条件成立下的语句，而条件不成立的代码块将会被消除，这个过程是在 分析与生成class文件 阶段完成的。 class文件描述 《Java虚拟机规范》：在未来，我们会对Java虚拟机做适当的扩展，以便更好的支持其他语言运行在JVM上（JDK1.7-1.8通过）。 字节码（*.class文件） 是构成 平台无关性 + 语言无关性 的基石。 正因为 字节码 是现实 语言无关性 的基石，所以 字节码 命令提供的语义描述能力、范围要大于Java语言本身。 class文件结构 class文件是一组以 8位字节为基础单位 的 二进制流，各个数据项目严格按照 顺序紧凑 的排列在 class文件 之中，中间没有添加任何 分隔符。 若遇到占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。 class文件一般采用类似于 C 语言结构体系的 伪结构 来存储数据，伪结构只有2种数据类型： 无符号数： 其属于基本的数据类型，可以用来描述数字、索引引用、数量值或其他。 表： 是由多个 无符号数 或者 其他表 作为数据项构成 复合的数据。所有表都以习惯性的 _info 结尾。表 用于描述 有层次关系 的 复合结构* 的数据。 无论是 无符号数 还是 表，当需要描述同一类型但数量不定的多个数据时，经常使用一个前置的 容量计数器 + 若干个连续的数据项的形式，这样的形式称为 某一类型的集合。 魔数- 确定class文件版本magic 的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件。 紧接着就是 minor_version(此版本号)、 major_version（主版本号） 常量池 常量池 可以理解为 class文件的资源仓库。 是与其他项目 关联最多 的数据类型，也是class文件中占用空间最大的数据项目之一。同时是class文件中第一个出现表类型的数据项目。 常量池每一个常量都是一个表 存放2大类常量： 字面量 符号引用 字面量 接近于Java语言中的 常量 概念。 符号引用属于编译原理方面的概念，包括以下3类： 类和接口的全限定名：路径 字段的名称和描述符：字段 描述符用来描述：字段的 数据类型、修饰符 方法的名称和描述符： 描述符是用来描述：方法的 参数列表（数量、类型、顺序）和返回值 注意：要区分 字节码中的描述规则 与 Java代码中的声明规则不同。 访问标志 - 确定类定义信息访问标志（access_flags），作用：识别一些类或者接口层次的 访问信息。 通俗的说就是和 类定义相关 的描述，例如：是类还是接口、是否为public、是否为 abstract等。 类索引、父类索引与接口索引集合 - 确定类继承关系 类索引、父类索引是一个u2类型的数据，而接口索引集合是一组 u2类型的数据的集合（Java不支持多继承，但是支持多实现）。 class文件中由这3项数据来确定这个类的继承关系 字段表集合 - 确定变量 用于描述接口或者类中声明的变量。 包含 类级变量 以及 实例级变量。 不包含在 方法内部声明的局部变量 方法表集合 方法中的 Java代码 在经过编译之后，存放在方法属性表集合中一个名为 Code 的属性中。 在 Java语言中，要重载一个方法，除了要与原方法具有相同的名称之外，还要求必须拥有一个与原方法不同的 特征签名。 特征签名：就是一个方法中 各个参数 在 常量池 中的 字段符号引用 的 集合，因为 返回值 不会包括在 特征签名 中，因此Java语言中无法根据返回对方法进行重载。 区别：因为 class文件中特征签名范围更广，只要描述符不一致，即可以重载。 属性表集合字节码指令Java虚拟机的解释器使用以下最为基本的伪模型： 123456do&#123; 自动计算 PC寄存器值 +1； 根据 PC寄存器指示的位置，从字节码流中取出操作码； if(字节码存在操作数) 从字节码中取出操作数； 执行操作码定义的操作；&#125;while(字节码流 &gt; 0) JVM执行类加载过程一个类的加载过程概括性的可分为 3个阶段： 1加载、连接、初始化 如果具体细分则为 7个过程： 1加载、验证、准备、解析、初始化、使用、卸载 类的生命周期图， 其中，有 5个阶段 是 必须要按顺序 执行的： 1加载 、验证、准备、初始化、卸载 加载 - 开发人员可介入（类加载器）虚拟机的非数组类加载操作 通过一个类的 全限定名 来获取定义此类的 二进制字节流。 将这个字节流所代表的 静态存储结构 转换为 方法区 的运行时数据结构。 在内存区生成一个 代表这个类的对象，作为方法区这个类的各种数据的 访问入口。 二进制字节流的获取途径 zip包中，例如 jar。 从网络中获取 运行时动态生成，反射。 有其他文件生成，例如 jsp 从数据库中读取。 虚拟机对于数组的创建 如果数组的组件类型是 引用类型 （例如Personp[]），那么递归采用定义的加载过程去加载，数组将在 加载该组件的类加载器 的 类名空间上被标示。 如果数组的组件类型不是引用类型（例如int[]）, Java虚拟机将会把数组标记为与 引导类加载器 关联。 数组可见性与其组件可见性一致，且数组组件不是引用类型，那么数据可见性默认为 public。 验证验证是 连接 的第一个阶段。验证目的：是为了确保 class文件 的字节流中 符合 class文件格式约束 且 包含的信息是符合当前虚拟机的要求 的，并且不会危害到虚拟机的自身安全。 验证过程分为4个阶段: 文件格式验证 该阶段的主要目的是：保证输入的字节流 能正确的解析并存储于方法区之中。 此阶段的验证是基于 二进制字节流 的，只有通过此阶段的验证，字节流才会进入内存的方法区进行存储。 因此，后面3个阶段的验证都是基于 方法区的存储结构 进行验证的。 元数据验证 对字节码描述的信息进行 语义分析、校验，保证其描述的信息 符合Java语言规范的要求。 此阶段对 类的元数据信息 进行校验。 字节码验证 此过程是验证过程最为复杂的阶段，在第二步对类的元数据信息校验结束后，通过 数据流 和 控制流分析，确定程序 语义是合法的、是符合逻辑的。 此阶段对 类的方法体 进行校验。 符号引用验证 此阶段是发生在虚拟机将 符号引用 转换为 直接引用 的时候，这个转换动作是发生在 解析 阶段中。 符号引用校验 是对 类自身以外（常量池中的各种符号引用）的信息 进行匹配校验 的过程。 符号引用验证的目的是 确保解析动作的正常执行 准备 - 类变量赋初值此阶段是正式为 类变量 分配内存 并 设置其初始值（零值） 的过程。这些变量所使用的内存是在 方法区的内存 中分配的。 解析是虚拟机将常量池中的 符号引用 抓换为 直接引用 的过程。 符号引用 与 直接引用区别符号引用 通过一组符号来描述所引用的目标。 符号引用于 虚拟机实现的内存布局无关 直接引用 直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。 直接引用与虚拟机实现的内存布局有关。 解析动作 类或接口 字段 类方法 接口方法 初始化 初始化 是类加载过程的最后一步，在此阶段才开始执行类中定义的 Java程序代码（字节码）。 此阶段是执行 类构造器&lt;clinit&gt;() 方法的过程。 &lt;clinit&gt;()解释 方法中的内容来源 — &lt;clinit&gt;() 是由 编译器 自动收集类中的 所有类变量的赋值动作 和 静态语句块（static{}）中的语句 合并产生的。 父类子类顺序 — &lt;clinit&gt;() 与类的构造函数（或者说是实例构造器&lt;init&gt;()）不同，它不需要显示调用父类构造器，虚拟机会保证在 子类的&lt;clinit&gt;() 调用之前 父类&lt;clinit&gt;() 已经执行完毕。 赋值先后顺序 — 由于父类与子类的 &lt;clinit&gt;() 执行顺序，父类中的静态语句块要优于子类变量的赋值。 必要性 — &lt;clinit&gt;() 对于类或接口而言是非必须的。 （父）接口的&lt;clinit&gt;()— 接口中不能使用静态语句块，但是接口中仍然有变量初始化赋值操作。因此接口与类都具有 &lt;clinit&gt;() 操作。接口与类不同的是：子接口（实现类）的 &lt;clinit&gt;() 不需要实现 父接口 的 &lt;clinit&gt;() ，只有使用到 父接口中定义的变量时，才会执行。 线程！ — 虚拟机能够保证一个类的 &lt;clinit&gt;() 在 多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只能有一个线程执行这个操作，其他线程都只能阻塞等待。 初始化阶段的触发条件Java虚拟机对于什么时间执行第一个阶段：加载，没有明确要求，但是对于 初始化 阶段则是 有且只有5种 明确要求： 1、遇到 new、getstatic、**putstatic、invokestatic这4个字节指令时，要先进行初始化。这4个指令对应于Java语言中的场景就是： new关键字实例化对象、读取一个静态字段、设置一个静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用类的静态方法** 2、进行 反射调用 的时候，如果没有进行初始化，则先要进行初始化。 3、当初始化一个类的时候，若其 父类 还未进行初始化，则先要对其父类进行初始化。 4、当虚拟机启动时，用户需要指定一个要 执行的主类（包含main()），虚拟机会先初始化这个类。 5、当使用JDK 1.7 的 动态语言支持 时，如果一个 MethodHandler 实例最后的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄时，这个方法对应的类要进行初始化。 类加载器 — 程序员自己决定如何获取所需类类 与 类加载器JVM中类的唯一性确立条件： 1类本身 + 加载它的类加载器 换一种表述方式即为： 123比较2个类是否“相等（equals()/isAssignableFrom()/isInstance()/instanceof关键字）”，只有在这2个类是由同一个类加载器加载的前提下才有意义。否则，若是同一个 class文件被同一个JVM加载，只要是加载这个类的 类加载器不同，那么这两个类必定不同。 加载器分类：从 JVM角度 来看，只存在 2种 不同的加载器： 启动类加载器（Bootstrap CLassLoader），由 C++ 实现，是虚拟机本身的一部分。 所有的其他类加载器，由 Java 实现，独立于虚拟机外部且全部继承自 java.lang.ClassLoader。 ClassLoader继承关系（图片来自网络） 从 开发人员角度 来看，存在 3种 不同的加载器： 启动类加载器 （Bootstrap ClassLoader） 此类使用 C++ 实现，并非CLassLoader的子类，在代码中无法拿到这个对象，没有子类。 JVM启动时， Bootstrap CLassLoader 也会同时跟着启动，完成 $JAVA_HOME/jre/lib/rt.jar 中所有class文件的加载，如java.lang.、 java.uti.等。 负责加载完核心类库后，并构造 Extension ClassLoader 和App ClassLoader 类加载器。 扩展类加载器 （Extension ClassLoader） 开发人员可以直接使用此加载类 加载位于 $JAVA_HOME/jre/lib/ext 目录下的扩展jar。 应用程序加载器（Application ClassLoader） 开发人员可以直接使用此加载类 父类是 Extension ClassLoader，加载 用户类 $CLASSPATH下的目录 和 jar； 它负责加载 应用程序主函数类。 若应用程序中没有自定义类加载器，一般情况下这个就是默认的类加载器。 自定义类加载器 （Custom ClassLoader） 要实现自己的类加载器，不管是实现抽象类ClassLoader，还是继承其他的子ClassLoader类，它的父加载器都是AppClassLoader，因为不管调用哪个父类加载器，创建的对象都必须最终调用getSystemClassLoader()作为父加载器，getSystemClassLoader()方法获取到的正是AppClassLoader。 双亲委派模型 双亲委派模型 要求：除了顶层的 启动类加载器 外，其余的类加载器都应有自己的父类加载器。 这里类加载器的关系不是 父子 而是 组合 关系。 双亲委派模型的工作过程为： 如果一个类加载器收到了类加载请求，他首先不会自己尝试加载这个类，而是把这个请求委派给自己的父类加载器去完成，每一层的类加载器都是如此。 因此所有的加载请求最终都应该传递到顶层的 启动器类加载器 中。 只有当父类加载器反馈自身无法完成这个加载请求时，子类加载器才能完成这个加载请求。 双亲委派模型的作用对Java程序的稳定运作很重要。使用此模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java类 随着 它的类加载器 一起具备了一种 带有优先级的层级关系。 例如 java.lang.Object 类，这个类无论是被那个类加载器加载，最终都是委派给模型最顶端的 启动类加载器，因此Object类在程序的各种类加载环境中 都是同一个类。 ClassLoader抽象类的几个关键方法 loadClass： 此方法是负责加载指定名字的类。加载过程为：先从已加载的类中寻找，如果没有再调用parent的loadClass中寻找，如果还是没有，那么从findBootstrapClassOrNull方法中寻找。如果以上都不行，那么执行findClass方法。 如果要改变类的加载顺序，则可以覆盖此方法； 如果加载顺序相同，则可通过覆盖findClass方法来 做特殊处理。 源代码为： 12345678910111213141516171819202122232425protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; return c;&#125; findLoadedClass 此方法负责从当前 ClassLoader 实例对象的缓存中寻找已存在的类。 findClass findSystemClass defineClass 此方法负责将二进制字节码 转换为 class对象，这个方法对自定义加载类非常重要。 如果二进制的字节码格式不符合JVM Class 文件的格式，抛出ClassFormatError异常 如果生成的类名和二进制字节码中的不同，抛出NoClassDefFoundError 如果加载的 class 是受保护的、采用不同签名的、或者类名是以 java开头的，抛出 SecurityException 如果加载的 class 在此ClassLoader中已经加载，那么抛出LinkageError resolveClass 此方法完成对Class的链接，如果已经链接过，那么直接返回。 当调用Class.forName来获取一个对应名称的class对象时，JVM 会先从方法栈栈上寻找第一个ClassLoader ，通常也就是执行 Class.forName 所在的类的ClassLoader，来加载此名称的类。 JVM为了保护加载、执行类的安全，他不允许ClassLoader直接卸载已加载了的类。只有JVM才能卸载，当CLassLoader对象没有引用时，此 CLassLoader 对象所加载的类才会被卸载。 2. 编译执行解释执行效率低，为提升代码的执行性能，JDK提供了将字节码编译为机器码的支持。JDK 在执行过程中对执行效率高的代码进行编译，对执行不频繁的代码则继续使用解释的方式。因此，JDK 又称为：Hotspot VM，在编译上JDK提供了2种模式： client compiler（-client）：轻量级。只做少量性能开销比高的优化，占用内存少，适合于桌面交互式应用。 在内存器分配策略上，采用线性扫描寄存器分配算法。其他的优化有方法内联、去虚拟化‘、冗余消除`` server compiler（-server）：重量级。采用大量的传统编译优化技巧来进行优化，占用内存多，适合于服务器端使用。与client不同的是： 寄存器分配策略：传统的图着色寄存器分配算法。 优化的范围：全局优化，而不仅仅是一个方法块的优化。 3. 反射执行基于反射可动态调用某对象实例中对应的方法、访问查看对象的属性等，无需在编写代码时就确定要创建的对象。 反射和直接创建对象实例，调用方法最大的不同在于创建的过程、方法的调用是动态的。如何实现动态调用：动态生成字节码、并加载到JVM中执行。 注意： 使用getMethod() 相对比较耗性能，一方面是权限的校验，另一方面是所有方法的扫描机Method对象的复制。因此，在使用反射调用多的系统中，应缓存getMethod()返回的Method对象。 Java对象4种引用强引用： 普遍存在的，类似”Object obj=new Object()”； 只要强引用还在，GC就永远不会回收被引用的对象，即时抛出OOM； 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。 软引用（Soft Reference） 用来描述有用但是非必须的对象； 如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；直到内存空间不够时（抛出OutOfMemoryError之前），才会被垃圾回收； 由 SoftReference类 实现。 12MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 重新获得对该实例的强引用 1MyObject anotherRef=(MyObject)aSoftRef.get(); 而回收之后，调用get()方法就只能得到null了。 软引用可用来实现内存敏感的高速缓存，使用软引用可以可以增强程序的健壮性、能防止内存泄漏。 弱引用（Weak Reference） 用来描述非必须的对象；只能生存到下一次垃圾回收之前，无论内存是否足够；由 WeakReference类 实现； 虚引用（Phantom Reference） 也称为幽灵引用或幻影引用； 完全不会对其生存时间构成影响； “==”运算符 和 “equals()” 方法实质上这两种方法本质上还是有区别的： equals() 方法是从String类中的方法，它用于比较两个 对象引用所指的内容 是否相等； == 运算符比较的是两个 对象引用的地址 是否相等。 参考：http://icyfenix.iteye.com/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-AsyncTask]]></title>
    <url>%2FAndroid%E7%BA%BF%E7%A8%8B-AsyncTask%2F</url>
    <content type="text"><![CDATA[线程总结-AsyncTask 1. 基本描述 AsyncTask 是一个抽象类，只有被继承之后才能使用。 AsyncTask 调用、实现了 ThreadPoolExecutor类参数配置、Executor接口调用。并且 子线程 和 UI主线程 之间切换、数据传递还是通过 Handler 和 Message 进行处理的。 AsyncTask支持正确、简单地使用UI线程。这个类允许你在后台执行操作并在UI线程上发布结果，而无需操纵Thread和Handler。 AsyncTask被设计为 Thread 和 Handler 的辅助类，并不构成通用的线程框架。 理想情况下，AsyncTasks应该用于 短操作（最多几秒）。如果需要长时间保持线程稳定，强烈建议使用由 java.util.concurrent提供的各种API，例如 Executor，ThreadPoolExecutor 和 FutureTask。 2. 涉及到的类 ThreadPoolExecutor Executor ThreadFactory FutureTask Handler Looper Message 2.1 线程池参数设置 1. int corePoolSize：核心池的大小（例如：正式工人。就是线程池大小） Android参数： 1private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); 2. int maximumPoolSize：线程池最大线程数（例如：正式工人 + 临时工人。任务量突然过大时的一种补救措施） Android参数： 1private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; 3. long keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。 Android参数： 1private static final int KEEP_ALIVE_SECONDS = 30; 4. TimeUnit unit：参数keepAliveTime的时间单位 Android参数： 1TimeUnit.SECONDS 5. BlockingQueue workQueue：用来存储等待执行任务的一个阻塞队列。 Android参数： 1private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); 6. ThreadFactory threadFactory：线程工厂，主要用来创建线程。 Android参数： 1234567private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;; 7. RejectedExecutionHandler handler：当拒绝处理任务时的策略。 2.2 Executor3. 运行原理3.1 3个泛型参数 AsyncTask &lt;Params, Progress, Result&gt; Params: 这个泛型指定的是我们传递给 异步任务执行 时的参数的类型 Progress: 这个泛型指定的是我们的异步任务在执行的时候将 执行的进度 返回给UI线程的参数的类型 Result: 这个泛型指定的异步 任务执行完 后返回给UI线程的结果的类型我们在定义一个类继承AsyncTask类的时候，必须要指定好这三个泛型的类型，如果都不指定的话，则都将其写成Void，例如： AsyncTask &lt;Void, Void, Void&gt; 3.2 4个方法： onPreExecute()：在任务执行前在UI线程上调用。此步骤通常用于设置任务，例如通过在用户界面中显示进度条。 doInBackground()：在 onPreExecute() 完成执行后立即在后台线程上调用。此步骤用于执行可能需要很 长时间的后台计算。异步任务的参数 传递给 此步骤。计算结果 必须通过该步骤返回并返回到最后一步。此步骤还可以使用 publishProgress() 发布 一个或多个进度单元。这些值将在UI线程的 onProgressUpdate() 步骤中发布。 onProgressUpdate() ：在调用 publishProgress() 后在 UI线程 上调用。执行的时间是未定义的。此方法用于在后台计算仍在执行时在用户界面中显示任何形式的进度。例如，它可以用来为进度条设置动画效果或在文本字段中显示日志。 之所用调用 publishProgress() 能够更新 onProgressUpdate() 是因为： 12345protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; onPostExecute()：任务在后台 计算完成后 ，在UI线程中调用。后台计算的结果作为参数传递给此步骤。 3.3 使用方法： 继承 AsyncTask抽象类 实现一个子类：MyAsyncTask 123456789101112131415161718public class MyAsyncTask extends AsyncTask&lt;String, Integer, byte[]&gt;&#123; @Override protected void onPreExecute() &#123;&#125; @Override protected byte[] doInBackground(String... params) &#123;&#125; @Override protected void onProgressUpdate(Integer... values) &#123;&#125; @Override protected void onPostExecute(byte[] result) &#123;&#125;&#125; 然后对 MyAsyncTask类 进行初始化并调用： 1new MyAsyncTask().execute(IMAGE_PATH); 3.4 4个方法间的调用顺序 执行：execute(Params... params) 123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 调用：executeOnExecutor(Executor exec, Params... params) 中的 onPreExecute(); 123456789@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture);&#125; 在这个方法中，第1个方法 onPreExecute(); 被调用，这是个空方法，需要自己实现。执行完此方法之后，将会调用 AsyncTask类 的构造方法，在构造方法中 mWorker 的变量初始化中调用 doInBackground(mParams);： 123456789101112131415161718mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125;&#125;; 在 AsyncTask类 的构造方法中，执行完 mWorker 变量初始化后，有执行了 mFuture 变量的初始化，在初始化中有调用了postResultIfNotInvoked(get());： 123456789101112131415mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occurred while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125;&#125;; 最终通过 Message 的来执行不同的方法： 12345678910111213141516private static class InternalHandler extends Handler &#123; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 方法 publishProgress(Progress... values) 的调用是发生在 doInBackground(mParams)： 1234567@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 通过发送 MESSAGE_POST_PROGRESS 标志来调用 调用 onProgressUpdate(Progress... values) 1234@SuppressWarnings(&#123;"UnusedDeclaration"&#125;)@MainThreadprotected void onProgressUpdate(Progress... values) &#123;&#125; 其中 result.mTask.finish(result.mData[0]); 表示调用 finish()： 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 如果在这个方法中走 onPostExecute() 表示执行完毕这个流程，重写 onPostExecute()： 1234 @SuppressWarnings(&#123;"UnusedDeclaration"&#125;)@MainThreadprotected void onPostExecute(Result result) &#123;&#125; 3.5 取消任务 任何时候都可以通过调用 cancel(boolean) 来取消任务。 调用此方法将导致对 isCancelled() 的后续调用返回true。在调用此方法后，将在 doInBackground(Object[]) 返回后调用onCancelled(Object)而不是 onPostExecute(Object)。 为了确保尽快取消任务，如果可能的话（例如在一个循环内部）应该始终从 doInBackground(Object[]) 定期检查 isCancelled()的返回值。 3.6 使用规则 AsyncTask类必须在UI线程上加载。 必须在UI线程上创建任务实例。 必须在UI线程上调用. 不要手动调用上面提到的执行任务的4个方法。 任务 只能执行一次（如果尝试执行第二次执行，则会引发异常）。 其他私有静态内部类 InternalHandler 中，用到了一个对象 result ，这个对象就是 AsyncTaskResult类的实例化，是 AsyncTask 中的另一个私有静态内部类。 AsyncTaskResult；类源代码描述为： 123456789private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 这个私有静态内部类 AsyncTaskResult 的作用就是封装了 AsyncTask 类 和 数据类 Data，对 当前AsyncTask任务和对应的数据进行整体封装。这个封装写的是极好的，好在对此类的对象使用时，仅通过此对象的某个成员变量就可以完成需要零散变量能完成的任务，将需要的需要用到数据做成一个整体性的类，数据从整体中获取，使得在使用中不会感到变量繁多，而是通过一种调用的方式，极好。 InternalHandler类 总结： 至此，通过以上分析可以得出的结论是：这个私有静态内部类主要是回调了 onCancelled(result)、onPostExecute(result)、onProgressUpdate(result.mData) 方法，即：InternalHandler类的作用是 AsyncTask 处理任务的后期结果显示阶段。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git的使用 版本控制系统的分类：本地VCS（LVCS） 例如：RCS 优点 适合文本文件 适合保存在本地硬盘上 缺点 不支持基于项目的文件 不支持网络协作 集中VCS （CVCS） 例如：SVN，CVS 优点： 适合多人协作 适合代码集中管理 缺点： 存在单点故障 必须联网，无法脱机本地工作 分散式VCS（DVCS） 例如：Git，Mercurial 特点： 分布式：各个Repo（仓库）都具有完整的镜像 快照：每次记录都是完整的信息 状态区：了解git的状态区是学习git的重要步骤，只有掌握 不同状态区的状态 才能掌握 git的核心思想。 分支：最重要的功能之一 标签：最重要的功能之一 Git介绍： 参考：https://git-scm.com/docs廖雪峰git网站：https://www.liaoxuefeng.com/wiki/896043488029600 git 中文意思：饭桶。是一个分布式版本控制系统，Git 原本是 linus torvalds 用来管理 Linux 开发版本，而专门开发的一个版本控制工具。 2005年，Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！ 2008年，GitHub网站上线了，它为开源项目免费提供Git存储。 特点：具有速度快、使用简单、非线性开发模式（分支合并）、分布式、可管理各种规模的项目。项目中所有文件都可以在本地完成。 重要概念： 采用的“快照”版本控制而非“保存”。 在项目版本发生改变时，发生改变的文件被复制到下一个版本中，未发生改变的文件产生”快照“链接到下一个版本中。 通过SSH协议产生的指纹码，git将项目发送至github仓库。 git提交原理： Working Directory（本地工作库） -&gt; Staying Area（暂存区域） -&gt; Git Directory（版本控制仓库） HEAD：指向的版本就是当前版本。可以通过 HEAD 进行版本 穿梭。 Git是基于修改 进行管理的：执行 add 命令后，有工作区添加到暂存区是 文件的修改，而不是修改的文件 。 远程 分支 标签 Git使用 参考：http://marklodato.github.io/visual-git-guide/index-zh-cn.html#commit Github 身份认证：本地Git仓库与远程Git仓库是通过 SSH身份认证进行通信的。进入.ssh文件夹下，输入命令： 1ssh-keygen -t rsa -C “邮箱名” 生成两个表明自己身份的文件： id_rsa ：私钥 id_rsa.pub ：公钥 将id_rsa.pub中的内容添加至Github中个人设置中的SSH Key中。 设置Git配置信息：12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 注意：注意 git config 命令的--global 参数，用了这个参数，表示你这台机器上 所有 的Git仓库都会使用这个配置，当然也可以对某个仓库 指定 不同的用户名和Email地址。 以上的命令等价于： 1git config --global --add user.name 名字 user.email 邮箱 删除配置: 1git config --global --unset user.name 名字 仓库创建方式1：先在GitHub中创建了一个仓库步骤： 首先登录自己的 GitHub 账号； 然后点击下图中的 New repository，然后输入 仓库名，选择 public，最后点击 create repository 即可在 GitHub 中创建完毕一个仓库： 方式2：现在本地创建了一个仓库步骤： 创建一个文件夹，作为仓库 进入新创建的文件夹，执行命令： 1git init 执行完毕此命令，将会出现多个隐藏文件，表示仓库 init 成功。 本地仓库 与 远程仓库 进行关联方式1关联： 远程 clone 至本地1git clone -b beta https://github.com/flutter/flutter.git 选项：-b beta 可选。 方式2关联：本地仓库 push 到远程仓库在执行完毕 方式2 中的 init 命令后，执行以下命令即可： 12345echo &quot;# ddd&quot; &gt;&gt; README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/YannisCheng/ddd.gitgit push -u origin master 其中： echo &quot;# ddd&quot; &gt;&gt; README.md ：命令表示 创建 一个 README.md 文件，并将 # ddd 内容写入到此文件中。 git add ：是Git库 工作区 的 最后一步。命令表示将 修改的文件 从 工作区 添加 到 暂存区。 git add -u：表示对于 已经被git管理 的所有 文件都加入到暂存区，不需要指定添加文件。 git commit ：是Git库 暂存区 的 最后一步。命令表示将 暂存区 的文件 改动提交 给 本地版本库，结果是会在 本地版本库 生成一个 40位的哈希值，这个哈希值也叫 commit-id。 commit-id 在 版本回退 的时候是非常有用的，它相当于一个 快照，可以在未来的任何时候通过与 git reset 的组合命令回到这里. git remote add origin 地址 ：表示将本地库与远程仓库地址关联 git push -u origin master ：表示将本地版本库 的 分支 推送 到 远程服务器 上 对应的分支。 说明： 在第1次推送master分支时，加上了 -u 参数，Git不但会把本地的master分支 内容 推送的远程新的master分支，还会把本地的master分支和远程的master分支 关联 起来，在以后的推送或者拉取时就可以简化命令。第1次建立起联系之后，后面的操作可以使用： git push 简化。 说明： 1 git push origin master ：表示远程分支被忽略，适合于2中情况： 将本地分支推送到与之存在 追踪关系 的远程分支（通常两者同名） 如果该远程分支不存在，则会被新建 2 git push origin ：refs/for/master ：忽略本地分支名称，表示将删除指定的远程分支。因为这等同于向远程分支推送了一个 空 的本地分支，等价于：git push origin – delete master。其中：refs/for 表示提交代码到服务器之后是需要经过 code review 之后才能进行merge 的，而 refs/heads 不需要。 3 git push origin：表示当前分支与远程分支存在 追踪关系 4 git push ：表示当前分支只有 一个 远程分支，那么主机名都可以省略。 Git提交- add，- commit 参考：https://www.cnblogs.com/forget0909-Angle-Qi/p/9564314.html 1工作区 --add--&gt; 暂存区 --commit（快照，手动存盘） --&gt; 本地版本库（工作区中隐藏的.git目录） --push--&gt; 远程仓库 本地版本库 在实际文件中是： Git文件操作Git回退 - reset 参考：https://www.cnblogs.com/ryq2014/p/6379364.html参考：https://www.cnblogs.com/chenlogin/p/6592228.html 本质： 版本回退、重现的本质是 将HEAD的指向移动至指定的版本号 命令1： 1git reset --hard HEAD^ 作用说明：此命令表示 回退到当前版本之前的版本 。参数说明： HEAD：用来表示 当前版本，HEAD^ 表示上一个版本，HEAD^^ 表示 上上一个版本，第100个表示为：HEAD-100。 实际操作1：回退到之前 通过 git log 查看历史提交后的结果为： 123456789101112131415161718192021commit 243f070d6b624e4e20c55cf1ebd0277ed5a252cf (HEAD -&gt; master)Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:47:27 2019 +0800 更新.gitignore文件commit 3408a34703107485ed5d97c7af387485011cdec9Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:45:09 2019 +0800 添加gradle目录commit ada5ac242317a70f91cdeeff090f384e6850d1e7Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:35:19 2019 +0800 添加ReadMe.md文件commit ff7241b453ada741afbdab3f83b8bd77f48bf295Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:31:54 2019 +0800 执行 git reset --hard HEAD^ 命令后： 1234567891011121314151617commit 3408a34703107485ed5d97c7af387485011cdec9 (HEAD -&gt; master)Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:45:09 2019 +0800 添加gradle目录commit ada5ac242317a70f91cdeeff090f384e6850d1e7Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:35:19 2019 +0800 添加ReadMe.md文件commit ff7241b453ada741afbdab3f83b8bd77f48bf295Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:31:54 2019 +0800 第一次提交初始化工程 命令2： 1git reset --hard id 作用说明：在 当前的命令窗口未关闭 的情况下，执行此命令可以 重现 曾经已经存在，但是经过 rest -- hard HEAD 又不存在的某一个版本。参数说明：id 具体表示为 要重现版本的 id 值的前几位。 实际操作2：- 重回之前的某一个版本 执行 git reset --hard 243f070d6 命令后，通过 git log 查看： 1234567891011121314151617181920212223commit 243f070d6b624e4e20c55cf1ebd0277ed5a252cf (HEAD -&gt; master)Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:47:27 2019 +0800 更新.gitignore文件commit 3408a34703107485ed5d97c7af387485011cdec9Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:45:09 2019 +0800 添加gradle目录commit ada5ac242317a70f91cdeeff090f384e6850d1e7Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:35:19 2019 +0800 添加ReadMe.md文件commit ff7241b453ada741afbdab3f83b8bd77f48bf295Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:31:54 2019 +0800 第一次提交初始化工程 命令3：指定 id值，重现某个已存在版本 通过 git reflog 可知， 最新的版本为 360ca61 (origin/master) HEAD@{4}: commit: 更新忽略文件，所以：commit id = 360ca61，命令为： 1git reset --hard 360ca61 结果为： 1234567891011121314151617181920212223242526272829commit 360ca6178668ee0d06c5b6f76dbb0712f31a01bb (HEAD -&gt; master, origin/master)Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 13:41:12 2019 +0800 更新忽略文件commit 243f070d6b624e4e20c55cf1ebd0277ed5a252cfAuthor: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:47:27 2019 +0800 更新.gitignore文件commit 3408a34703107485ed5d97c7af387485011cdec9Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:45:09 2019 +0800 添加gradle目录commit ada5ac242317a70f91cdeeff090f384e6850d1e7Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:35:19 2019 +0800 添加ReadMe.md文件commit ff7241b453ada741afbdab3f83b8bd77f48bf295Author: YannisCheng &lt;cwj1714@163.com&gt;Date: Tue May 14 11:31:54 2019 +0800 第一次提交初始化工程 联合使用 reset，checkout场景：修改了一个文件，然后这个文件执行了add命令，应添加到到了暂存区。 文件修改前内容为： 1初始化项目 文件修改后，内容为： 12初始化项目 临时西瓜，西瓜好甜啊！ 要求：将文件恢复至修改之前的状态。操作： git reset HEAD ReadMe.md 这个命令执行的是 git 命令 回滚，同时改变 文件修改 所在的区。如果新创建的文件，在未提交至远程仓库时，执行 reset HEAD^ 命令后，这个文件将丢失。 git checkout -- ReadMe.md 注意：（1）此处的 --，要是没有这个就变成了切换分支操作了。 第（1）步的作用是：回退操作命令，回退的是 add 操作命令。这一步执行完毕之后，通过 git status 命令查看 暂存区 提示： 1234567On branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: ReadMe.md 这就是 文件修改后未执行add命令 时的结果。因此这个结果也说明了 reset 确实是撤销了 add 命令。 第（2）步的作用是：丢弃工作区的修改，是丢弃作用。这一步命令执行完毕之后，通过 cat ReadMe.md 命令查看文件内容，结果为： 1初始化项目 即：通过这2步完成了修改文件的复原。 Git删除 - rm当一个文件（如：temp.txt）被添加至版本库后，如果 在本地删除了这个文件，那么： 如果 确实 想要删除这个文件，执行 12git rm temp.txtgit commit -m &quot;删除文件&quot; 这样2个命令操作执行之后，Git版本库 与 本地库 就一致了。 如果是 误删，在本地删错了，但是在 Git版本库 中还存在，想要恢复可执行： 1git checkout -- temp.txt git checkout 其实是 用Git版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意： 1从来没有被添加到版本库就被删除的文件，是无法恢复的！ Git历史命令记录：- reflog命令： 1git reflog 实际操作： 结果为： 123456789243f070 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 243f070d6243f070 (HEAD -&gt; master) HEAD@&#123;1&#125;: reset: moving to 243f070d63408a34 HEAD@&#123;2&#125;: reset: moving to HEAD^243f070 (HEAD -&gt; master) HEAD@&#123;3&#125;: reset: moving to HEAD^360ca61 (origin/master) HEAD@&#123;4&#125;: commit: 更新忽略文件243f070 (HEAD -&gt; master) HEAD@&#123;5&#125;: commit: 更新.gitignore文件3408a34 HEAD@&#123;6&#125;: commit: 添加gradle目录ada5ac2 HEAD@&#123;7&#125;: commit: 添加ReadMe.md文件ff7241b HEAD@&#123;8&#125;: commit (initial): 第一次提交初始化工程 Git分支（流） - branch常规操作创建12git checkout -b dev# 提示：Switched to a new branch &apos;dev&apos; 这行命令等价于： 12git branch devgit checkout dev 不同分支的特点：不同的分支有着不同的文件目录，例如： cwj分支中有 cwjtemp.txt 文件： 123456789101112total 80-rw-r--r-- 1 yannischeng staff 68B May 15 13:31 ReadMe.md-rw-r--r-- 1 yannischeng staff 950B May 14 11:13 UpEightMonthJiNan.imldrwxr-xr-x 9 yannischeng staff 288B May 15 08:04 app-rw-r--r-- 1 yannischeng staff 558B May 14 11:13 build.gradle-rw-r--r-- 1 yannischeng staff 19B May 15 15:33 cwjtemp.txtdrwxr-xr-x 3 yannischeng staff 96B May 14 11:13 gradle-rw-r--r-- 1 yannischeng staff 728B May 14 11:14 gradle.properties-rwxr--r-- 1 yannischeng staff 5.2K May 14 11:13 gradlew-rw-r--r-- 1 yannischeng staff 2.2K May 14 11:13 gradlew.bat-rw-r--r-- 1 yannischeng staff 441B May 14 11:13 local.properties-rw-r--r-- 1 yannischeng staff 15B May 14 11:13 settings.gradle 但是在 master 分支中就没有 cwjtemp.txt 文件： 1234567891011total 72-rw-r--r-- 1 yannischeng staff 68B May 15 13:31 ReadMe.md-rw-r--r-- 1 yannischeng staff 950B May 14 11:13 UpEightMonthJiNan.imldrwxr-xr-x 9 yannischeng staff 288B May 15 08:04 app-rw-r--r-- 1 yannischeng staff 558B May 14 11:13 build.gradledrwxr-xr-x 3 yannischeng staff 96B May 14 11:13 gradle-rw-r--r-- 1 yannischeng staff 728B May 14 11:14 gradle.properties-rwxr--r-- 1 yannischeng staff 5.2K May 14 11:13 gradlew-rw-r--r-- 1 yannischeng staff 2.2K May 14 11:13 gradlew.bat-rw-r--r-- 1 yannischeng staff 441B May 14 11:13 local.properties-rw-r--r-- 1 yannischeng staff 15B May 14 11:13 settings.gradle 切换1git checkout 分支名 合并1`git merge cwj 这个命令的作用是：合并指定分支（cwj）到当前分支（master）。将分支合并之后，之前不可见的文件目录就可见了。例如当前分支为master，文件目录中能够看到 cwjtemp.txt： 123456789101112total 80-rw-r--r-- 1 yannischeng staff 68B May 15 13:31 ReadMe.md-rw-r--r-- 1 yannischeng staff 950B May 14 11:13 UpEightMonthJiNan.imldrwxr-xr-x 9 yannischeng staff 288B May 15 08:04 app-rw-r--r-- 1 yannischeng staff 558B May 14 11:13 build.gradle-rw-r--r-- 1 yannischeng staff 19B May 15 15:33 cwjtemp.txtdrwxr-xr-x 3 yannischeng staff 96B May 14 11:13 gradle-rw-r--r-- 1 yannischeng staff 728B May 14 11:14 gradle.properties-rwxr--r-- 1 yannischeng staff 5.2K May 14 11:13 gradlew-rw-r--r-- 1 yannischeng staff 2.2K May 14 11:13 gradlew.bat-rw-r--r-- 1 yannischeng staff 441B May 14 11:13 local.properties-rw-r--r-- 1 yannischeng staff 15B May 14 11:13 settings.gradle 删除，强制删除 普通分支删除 1git branch -d 分支名 强制分支删除 1git branch -D 分支名 查看1234git branch``` 这个命令将会列出所有的分支，结果： devmaster1234567其中 `*` 表示`当前分支`。## 暂存 - stash### 将临时工作暂存：stash git stash Saved working directory and index state WIP on deb: 761ff60 merge with no-ff1234此时执行 `git status` 后，再次查看发现是干净的。### 查看暂存的工作现场 stash list git stash list12如果有 `暂存的工作区`，那么会单独弹窗提示: [6] + 65605 suspended git stash liststash@{0}: WIP on deb: 761ff60 merge with no-ff1234567如果没有，则无任何提示。### 恢复暂存工作区 pop, apply, drop**方式 1：** git stash pop1234`注意：`此种方式：恢复的同时把stash内容也删了**方式 2：** git stash apply12`注意：`此种方式：恢复后stash内容并不删除，还需要执行以下操作进行删除 git stash drop12## 多人推送 git push origin master12345678这个命令中：- `origin` 表示：远程仓库名称- `master` 表示：远程仓库中的分支名称### 抓取分支 git checkout -b dev origin/dev123456789101112这个命令的含义是：创建本地`dev`分支，并与远程`origin`的 `dev`分支建立联系。### 分支提交冲突如果你向远程 `origin/dev`分支`push`文件时，他人已经先于你提交了同一个文件，恰巧你也修改了此文件，此时就造成了`文件冲突`。**解决办法**：1. 自己首先从远程 `origin/dev`分支 `pull`文件，然后在自己的`本地`解决`文件冲突`。2. `文件冲突`解决之后，再次 `push`。如果这次提交再次失败，那么有可能是本地`dev`未能与`origin/dev`分支建立关联。3. 本地`dev`分支与`origin/dev`建立关联： git branch –set-upstream-to=origin/dev dev 1234 然后再次提交。 ### 本地新建分支在origin创建新分支并建立关联 git push –set-upstream origin 本地新建分支名123456这个命令出现的场景为：当我在本地创建了一个新分支后，我希望将这个新分支能够在远程`origin`中长期使用，于是在`origin`仓库未创建此分支的情况下，将 `本地新分支名` 作为`origin`中的一个新分支名称，同时建立关联。 ## ”直线流“ - rebase &gt; 参考：http://gitbook.liuhui998.com/4_2.html git rabase1234如果在 `rebase` 过程中出现`冲突`，git则会停止 `rebase`然后让你解决`冲突`。解决完毕之后，再用 `git add` 来更新修改之后的内容的索引。之后无需`commit`，继续执行 git rebase –continue12345这样Git就会继续（apply）剩下的补丁。要想终止`rebase`则可以通过 git rebase –abort1234567891011# Git标签 - TagGit中 `标签` 是指向某个`commit-id`的 **指针** 的 **版本库快照**。即：**`标签`** 和 **`commit`** 是挂钩的。## 创建标签（本地） - 普通1. 切换至要打标签的分支上： git checkout 分支名122. 创建一个标签 git tag 标签名123456## 创建标签（本地） - 过去的commit3. 对过去的指定的 `commit id` 打标签首先查看历史提交记录： git log –pretty=oneline –abbrev-commit12结果为： 8484aff (HEAD -&gt; master, origin/master) 修复bugC92ff081 修复bug30ab6ac7 修复bugdb56951 readMe文件修改 form 修改冲突之后的文件341b7fd readMe文件修改 form master2d703de readMe文件修改f3a1181 程文佳提交临时文件25b76a0 说明文件内容修改360ca61 更新忽略文件243f070 更新.gitignore文件3408a34 添加gradle目录ada5ac2 添加ReadMe.md文件ff7241b 第一次提交初始化工程12然后找到对应的commit-id如：0ab6ac7。打标签即可： git tag v1.0 0ab6ac712### 创建标签（本地） - 带有说明信息 git tag -a tag名 -m “说明信息”12### 创建标签（本地） - 综合版 git tag -a tag名 commit-id -m “说明信息”12查看在这种方式下创建的tag： git show v1.112结果为： tag v1.2Tagger: YannisCheng &#x63;&#x77;&#x6a;&#x31;&#55;&#x31;&#x34;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;Date: Wed May 15 23:50:31 2019 +0800 TAG: 最新版本修复 commit 8484afff9f692cad62874ae7588cf6347f2394b9 (HEAD -&gt; master, tag: v1.2, origin/master)Author: YannisCheng &#x63;&#x77;&#x6a;&#49;&#x37;&#49;&#52;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#111;&#109;Date: Wed May 15 23:00:57 2019 +0800 修复bugC diff –git a/bugC.md b/bugC.mdnew file mode 100644index 0000000..8760221— /dev/null+++ b/bugC.md@@ -0,0 +1 @@+修复了issue-1Cbug1234从显示结果上来看，与未加 `-m 说明信息` 的 `tag` 相比，信息顶部多了 2类 信息。### 标签远程推送 - 单个tag git push origin tag名12### 标签远程推送 - 全部tag git push origin –tags12结果为： Counting objects: 2, done.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 336 bytes | 0 bytes/s, done.Total 2 (delta 0), reused 0 (delta 0)To https://github.com/YannisCheng/UpEightMonthJiNan.git [new tag] v1.1 -&gt; v1.1 [new tag] v1.2 -&gt; v1.21234## 查看标签### 查看所有标签 git tag12### 查看某一个标签的详细信息 git show v1.012结果为： commit 0ab6ac72e3e4a009b5831298200332a2cb498074 (tag: v1.0)Author: YannisCheng &#x63;&#119;&#x6a;&#x31;&#55;&#x31;&#52;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;Date: Wed May 15 22:57:44 2019 +0800 修复bug diff –git a/bug.md b/bug.mdnew file mode 100644index 0000000..3c5540d— /dev/null+++ b/bug.md@@ -0,0 +1 @@+修复了issue-12bugdiff –git a/cwjtemp.txt b/cwjtemp.txtdeleted file mode 100644index 321dcaf..0000000— a/cwjtemp.txt+++ /dev/null@@ -1 +0,0 @@-cwj分支的文件1234 ## 删除标签### 本地删除 git tag -d tag名1234### 远程origin删除**方式 1：仅删除远程origin中的tag** git push origin –delete v1.112结果为： To https://github.com/YannisCheng/UpEightMonthJiNan.git [deleted] v1.112**方式 2：仅删除远程origin中的tag** git push origin :refs/tags/v1.212结果为： To https://github.com/YannisCheng/UpEightMonthJiNan.git [deleted] v1.212345678910# Git别名设置# Git服务器搭建# Git查看相关 - log- log中仅仅显示当前标签之前的log日志。 git log v1.112- log中显示日志中文件的具体（修改）补丁 git log -p12- log中显示所修改的文件 git log –stat12- 线性显示log日志 git log –pretty=oneline12- 简短信息 git log –pretty=short1234- 格式化输出log日志 git log –pretty=format:’%h:%s’ –topo-order –graph12结果： 8609962:Merge branch ‘devb’|\| * ddc8056:修改了三个bug文件 | 7073318:在master分支中，修改了三个bug文件|/ 8484aff:修复bugC 92ff081:修复bug3 0ab6ac7:修复bug db56951:readMe文件修改 form 修改冲突之后的文件|\| * 2d703de:readMe文件修改 | 341b7fd:readMe文件修改 form master|/ f3a1181:程文佳提交临时文件 25b76a0:说明文件内容修改 360ca61:更新忽略文件 243f070:更新.gitignore文件 3408a34:添加gradle目录 ada5ac2:添加ReadMe.md文件 ff7241b:第一次提交初始化工程12 git log –pretty=format:’%h:%s’ –date-order –graph12 SwipeBackLayoutLibrary/ 8609962:Merge branch ‘devb’|\ | 7073318:在master分支中，修改了三个bug文件| * ddc8056:修改了三个bug文件|/ 8484aff:修复bugC 92ff081:修复bug3 0ab6ac7:修复bug db56951:readMe文件修改 form 修改冲突之后的文件|\ | 341b7fd:readMe文件修改 form master| * 2d703de:readMe文件修改|/ f3a1181:程文佳提交临时文件 25b76a0:说明文件内容修改 360ca61:更新忽略文件 243f070:更新.gitignore文件 3408a34:添加gradle目录 ada5ac2:添加ReadMe.md文件 ff7241b:第一次提交初始化工程12- 查看当前master分支与origin/devb的区别 git log -p master ..origin/devb12345# Git查看区别 - diff- 查看当前分支的工作目录和上次提交与本地索引之间的差异 git diff12 - 比较任意2个分支的差异 git diff master..devc12结果 diff –git a/bug.md b/bug.mdindex e395991..3c5540d 100644— a/bug.md+++ b/bug.md@@ -1,2 +1 @@ 修复了issue-12bug-好大的一个西瓜啊diff –git a/bug3.md b/bug3.mdindex 746a91f..0943820 100644— a/bug3.md+++ b/bug3.md@@ -1,2 +1 @@ 修复了issue-13bug-太晚了diff –git a/bugC.md b/bugC.mddeleted file mode 100644index 3145cc4..0000000— a/bugC.md+++ /dev/null@@ -1,2 +0,0 @@-修复了issue-1Cbug-下雨了，我忘记带伞了12 - 查看2个分支 git diff master…devc123 结果 diff –git a/bug.md b/bug.mdnew file mode 100644index 0000000..3c5540d— /dev/null+++ b/bug.md@@ -0,0 +1 @@+修复了issue-12bugdiff –git a/bug3.md b/bug3.mdnew file mode 100644index 0000000..0943820— /dev/null+++ b/bug3.md@@ -0,0 +1 @@+修复了issue-13bugdiff –git a/cwjtemp.txt b/cwjtemp.txtdeleted file mode 100644index 321dcaf..0000000— a/cwjtemp.txt+++ /dev/null@@ -1 +0,0 @@-cwj分支的文件12345 # Git拉取 pull，fetch 从远程的origin仓库的master分支下载代码到本地的origin master git fetch origin branch112比较本地的仓库和远程参考的区别 git -p master..origin/master12把远程下载下来的代码合并到本地仓库，远程的和本地的合并 git merge origin/master12345678 &lt;!-- --&gt; - **`git remote -v`** 结果： origin https://github.com/YannisCheng/UpEightMonthJiNan.git (fetch)origin https://github.com/YannisCheng/UpEightMonthJiNan.git (push)123456从结果中可以看到有 `fetch（抓取）` 和 `push（推送）` 权限。- 查看git版本 git –version12- 查看当前git配置信息 git config –list12- 查看所有项目的配置信息 git config - -list - -global12- 查看所有的提交日志。在git仓库下查看提交记录日志 git log12- 分组查看信息。根据提交者的名字进行分组显示，显示每个开发者的commit信息 git shortlog12- **图形化的log记录** gitk12- 指定文件 ：查看指定文件的历史修改记录。在Android Studio中代码行区域中右键选择annotate查看该文件的历史操作人 git blame12- 查看代码库状态。每当文件有改动，可使用此命令查看git仓库的状态变化 git status12- 查看文件发生的具体变化 git diff HEAD – readme.txt12- 比较提交节点间的差异，注意：git支持第三方的diff工具进行diff操作 git diff 不同的HEAD```]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息机制]]></title>
    <url>%2FAndroid%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Handler、Looper、MessageQueue、Thread、ThreadLocal、HandlerThread、IntentService 概述 Android的消息机制主要是指Handler的运行机制，其运行机制包括：MessageQueue和Looper的支撑。 Handler：将一个任务切换至某个执行的线程中执行，系统之所以提供Handler是为了解决在子线程中无法访问UI矛盾。通过Handler更新UI仅仅是其的一个特殊使用场景。 MessageQueue：在机制中扮演：消息存储的角色。其内部是采用单链表的数据结构来存储消息队列，单链表在插入和删除上占有优势。 Looper：在机制中扮演：消息循环的角色。Handler创建时会采用当前线程中的Looper来构建消息循环。 ThreadLocal：ThreadLocal并不是线程，因为ThreadLocal可以在不同的线程中互不干扰的存储并提供数据，Handler通过ThreadLocal可以获取每个线程中的Looper。 UI主线程、子线程Android规定只能在主线程中访问UI，ViewRootImpl的checkThread()对UI操作做了验证. 123if(mThread ！= Thread.currentThread)&#123; 异常&#125; 为什么系统不允许在子线程中访问UI呢？这是因为Android的UI控件不是安全线程。如果在多线程中并发访问UI控件可能会导致不可预期的状态。为什么系统不为UI控件添加锁机制呢？这是因为： 使得UI访问逻辑变得复杂。 会降低UI访问的效率，锁机制本身会阻塞线程的执行。 注意： ==线程默认是没有Looper的，如果需要使用Handler就必须为线程创建Looper== 经常使用的UI主线程就是ActivityThread，其在创建的过程中会初始化Looper，这就是UI主线程中默认可以使用Handler的原因。 HandlerHandlerl类的结构 Handler 创建Handler创建时会采用当前线程的Looper来创建内部的消息循环系统。因此想要在当前单独的Thread中使用Handler，需要为当前的Thread创建Looper即可，具体创建方法（其实此创建方法在HandlerThread 的 run()中就有具体的应用）参考 Looper主题。 待Handler创建结束之后，Looper和MessageQueue就可以和Handler协同工作了。 Handler消息的处理：12345/** * Subclasses must implement this to receive messages. */public void handleMessage(Message msg) &#123;&#125; Handler 发送消息： post() send() post()调用方法： Handler -&gt; post() 1234public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; Handler -&gt; sendMessageDelayed() 1234567public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; Handler -&gt; sendMessageAtTime() 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; Handler -&gt; enqueueMessage() -&gt; MessageQueue -&gt; enqueueMessage()：将消息放入到消息对列中 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; MessageQueue -&gt; enqueueMessage()：内部单链表存储消 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; sendMessage()调用方式相同：1234public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125; Handler 中的 LooperHandler 中的 Looper 获取消息队列Looper在Handler的构造函数中进行初始化处理: Handler -&gt; Handler() 1234567891011121314151617public Handler(Callback callback, boolean async) &#123; ··· mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; ···&#125; Handler 中的 Looper 清空循环中的消息Handler -&gt; dump() -&gt; Looper -&gt; dump() 12345678public final void dump(Printer pw, String prefix) &#123; pw.println(prefix + this + " @ " + SystemClock.uptimeMillis()); if (mLooper == null) &#123; pw.println(prefix + "looper uninitialized"); &#125; else &#123; mLooper.dump(pw, prefix + " "); &#125;&#125; Looper -&gt; dump() -&gt; MessageQueue -&gt; dump() 12345678910/** * Dumps the state of the looper for debugging purposes. * * @param pw A printer to receive the contents of the dump. * @param prefix A prefix to prepend to each line which is printed. */public void dump(@NonNull Printer pw, @NonNull String prefix) &#123; pw.println(prefix + toString()); mQueue.dump(pw, prefix + " ", null);&#125; MessageQueue -&gt; dump() 1234567891011121314void dump(Printer pw, String prefix, Handler h) &#123; synchronized (this) &#123; long now = SystemClock.uptimeMillis(); int n = 0; for (Message msg = mMessages; msg != null; msg = msg.next) &#123; if (h == null || h == msg.target) &#123; pw.println(prefix + "Message " + n + ": " + msg.toString(now)); &#125; n++; &#125; pw.println(prefix + "(Total messages: " + n + ", polling=" + isPollingLocked() + ", quitting=" + mQuitting + ")"); &#125;&#125; Handler中的MessageQueueHandler中的MessageQueue 查询消息对列Handler -&gt; hasMessages() -&gt; MessageQueue -&gt; hasMessages() 1234567/** * Check if there are any pending posts of messages with code 'what' in * the message queue. */public final boolean hasMessages(int what) &#123; return mQueue.hasMessages(this, what, null);&#125; MessageQueue -&gt; hasMessages() 12345678910111213141516boolean hasMessages(Handler h, Runnable r, Object object) &#123; if (h == null) &#123; return false; &#125; synchronized (this) &#123; Message p = mMessages; while (p != null) &#123; if (p.target == h &amp;&amp; p.callback == r &amp;&amp; (object == null || p.obj == object)) &#123; return true; &#125; p = p.next; &#125; return false; &#125;&#125; 注意：此处的p.target就是Handler，因为源代码中：Message p = mMessages; 在Message类中： Handler中的MessageQueue 移除消息对列Handler -&gt; removeMessages() -&gt; MessageQueue -&gt; removeMessages() 1234567/** * Remove any pending posts of messages with code 'what' that are in the * message queue. */public final void removeMessages(int what) &#123; mQueue.removeMessages(this, what, null);&#125; MessageQueue -&gt; removeMessages() 123456789101112131415161718192021222324252627282930313233void removeMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // Remove all messages at front. while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; p.recycleUnchecked(); p = n; &#125; // Remove all messages after front. while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.what == what &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); p.next = nn; continue; &#125; &#125; p = n; &#125; &#125;&#125; MessageQueue MessageQueue的类结构 MessageQueue主要包含2个操作：插入+读取，读取本身伴随着删除。 插入：参考Handler的MessageQueue 读取（伴随删除）： next() LooperLooper类 的实例化是在 Activity 中的创建，但是实际是在 ActivityThread类 中的 main() 创建的：1234567891011121314151617181920212223public static void main(String[] args) &#123; // Looper 初始化 Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // Looper 循环 Looper.loop();&#125; Activity类 中的 recreate() 方法： 123456789public void recreate() &#123; if (mParent != null) &#123; throw new IllegalStateException("Can only be called on top-level activity"); &#125; if (Looper.myLooper() != mMainThread.getLooper()) &#123; throw new IllegalStateException("Must be called from main thread"); &#125; mMainThread.scheduleRelaunchActivity(mToken);&#125; 代码中的 mMainThread 变量就是 ActivityThread类 的实例，即：在 Activity类 中通过 ActivityThread类 完成 Looper类 的实例化，如果没有初始化Looper类，则抛出异常： 1"Must be called from main thread" 所以在 ActivityThread类 中： 123public Looper getLooper() &#123; return mLooper;&#125; ActivityThread类 中创建: 1final Looper mLooper = Looper.myLooper(); Looper类 实例化的通用方式： 1final Looper mLooper = Looper.myLooper(); 返回与当前线程关联的Looper类对象。 如果调用线程未与Looper类关联，则返回null，myLooper()的实现： 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 到这一步，方法的调用就从Looper类 转向了 ThreadLocal类，get() 的具体实现： 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 使用Looper谨记一点：当前线程。 Looper的类结构 会以无限循环的方式去查找新消息，是一种阻塞式的执行方式。 从Looper类中的成员变量，可以看出此类的作用： 通过当前线程`Thread`的`ThreadLocal`，操作`MessageQueue`。 构造方法之一：创建一个MessageQueue，保存当前线程的对象。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 为一个线程创建Looper 12345678910111213141516171819* This is a typical example of the implementation of a Looper thread,* using the separation of &#123;@link #prepare&#125; and &#123;@link #loop&#125; to create an* initial Handler to communicate with the Looper.* * class LooperThread extends Thread &#123;* public Handler mHandler;** public void run() &#123;* Looper.prepare();** mHandler = new Handler() &#123;* public void handleMessage(Message msg) &#123;* // process incoming messages here* &#125;* &#125;;** Looper.loop();* &#125;* &#125; 退出： 方式1：直接退出 Looper -&gt; quit() -&gt; MessageQueue -&gt; quit() 123public void quit() &#123; mQueue.quit(false);&#125; MessageQueue -&gt; quit() 123456789101112131415161718192021void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit."); &#125; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; 方式2：通过设定退出标记，安全退出 Looper -&gt; quitSafely() -&gt; MessageQueue -&gt; quit() 123public void quitSafely() &#123; mQueue.quit(true);&#125; 注意： prepareMainLooper()是给主线程ActivityThread创建Looper使用的，其内部也是调用了prepare()。 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; 退出。如果在子线程手动创建了Looper，那么在所有事件结束时，应当调用quit()来终止循环。否则这个子线程会一直处于等待状态。 最重要的方法 myQueue() 返回与当前线程关联的 MessageQueue 对象。 这必须从运行Looper的线程调用，否则将引发NullPointerException。 123public static @NonNull MessageQueue myQueue() &#123; return myLooper().mQueue;&#125; Looper类的重点方法： prepare() 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 注意此处使用到的 ThreadLocal类，在后面会有描述。 只有调用了loop()，消息循环系统才能真正的起作用，删减之后的 Loop(): 12345678910111213public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block msg.target.dispatchMessage(msg); msg.recycleUnchecked(); &#125;&#125; 注意： 源代码中的Message msg = queue.next();表示读取MessageQueue中的消息。在此处，MessageQueue与Looper建立联系。 源代码中的msg.target.dispatchMessage(msg);可以写为handler.dispatchMessage(msg);。在此处，Handler与Looper`建立联系。 dispatchMessage(msg)在Handler中是一个重要的方法： 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 因为在此方法中直接调用了handleMessage(msg);，即：将子线程中的消息作用于UI主线程，消息处理的终点。 结论：在Looper类中，将Handler、MessageQueue、Message统一了起来。 ThreadLocalThreadLocal并不是线程，其作用是在不同的线程中**互不干扰的存储并提供数据**，对于其他线程而言是无法获取数据的。 对于某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，采用ThreadLocal。 对于Handler来说，他需要获取当前线程的Looper，而Looper的作用域就是线程，而且不同的线程具有不同的Looper。此时通过ThreadLocal就可以实现Looper在线程中的存取。 只要线程处于活动状态且可以访问ThreadLocal实例，每个线程就会保留对其线程局部变量副本的隐式引用; 在线程消失后，线程本地实例的所有副本都将进行垃圾回收（除非存在对这些副本的其他引用）。 ThreadLocal的类结构 public方法 使用1ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;Boolean&gt;(); 123456789101112131415161718mBooleanThreadLocal.set(true);new Thread("a")&#123; @Override public void run() &#123; super.run(); mBooleanThreadLocal.set(false); Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; run : " + mBooleanThreadLocal.get()); &#125;&#125;;new Thread("2")&#123; @Override public void run() &#123; super.run(); Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; run : " + mBooleanThreadLocal.get()); &#125;&#125;; 输出结果为： 12306-26 09:24:00.722 27466-27466/com.yannischeng.guard E/MainActivity: ヽ(｀Д´)ﾉ -&gt; onCreate main : true06-26 09:24:00.723 27466-27490/com.yannischeng.guard E/MainActivity: ヽ(｀Д´)ﾉ -&gt; run : a : false06-26 09:24:00.723 27466-27491/com.yannischeng.guard E/MainActivity: ヽ(｀Д´)ﾉ -&gt; run : 2 : null 从结果可以看出，同一个对象在不同的线程中，赋的值不同，输出的值不同。 set() 和 get()这2个方法是在 Looper类 的 prepare() 中使用到的： ThreadLocal -&gt; set() 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; ThreadLocalMap -&gt;set() 123456789101112131415161718192021222324252627private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; ThreadLocal -&gt; ThreadLocalMap -&gt;Entry 这个哈希映射中的条目扩展了WeakReference，使用它的主要引用字段作为键（它始终是一个ThreadLocal对象）。 请注意，null键（即entry.get（）== null）表示该键不再被引用，因此该条目可以从表中删除。 这些条目在下面的代码中被称为“陈旧条目”。 123456static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 从以上代码可以看出，在调用set()时，先获取当前线程，然后通过当前线程获取该线的ThreadLocal，即： getMap() 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 代码中的t.threadLocals就是： 1ThreadLocal.ThreadLocalMap threadLocals = null; 然后调用： 1234if (map != null) map.set(this, value);else createMap(t, value); 将当前线程Thread的ThreadLocal作为key值，将自己设置的value值作为value，存储到ThreadLocalMap的对象map中。 ThreadLocal -&gt; get() 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; get()同set(). Thread、ThreadLocal、ThreadLocalMap、Entry 之间的关系：12345public class Thread&#123; ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;&#125; 1234567891011public class ThreadLocal&lt;T&gt; &#123; static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; &#125;&#125; MessageMessage的类结构 参考：https://blog.csdn.net/u011240877/article/details/72892321 HandlerThread 参考：https://blog.csdn.net/javazejian/article/details/52426353参考：https://blog.csdn.net/u011240877/article/details/72905631 HandlerThread类结构 HandlerThread继承Thread类调用Looper类，就足以说明这个类的作用。 方便的类，用于启动具有循环的新线程。 然后可以使用循环来创建处理程序类。 请注意，start()仍然必须被调用。 使用过程：12345678// 创建异步HandlerThreadHandlerThread handlerThread = new HandlerThread("download");// 必须先开启线程handlerThread.start();// 子线程HandlerHandler childHandler = new Handler(handlerThread.getLooper(),new ChildCallback()); 根据 HandlerThread 类 用于启动具有循环的新线程，然后可以使用循环来创建处理程序类 的使用场景，对 handlerThread 所在地 Handler 进行调用。 1234for(int i=0;i&lt;7;i++)&#123; //每个1秒去更新图片 childHandler.sendEmptyMessageDelayed(i,1000*i);&#125; 意义：这是 在Thread中手动加入Looper的好示例。这个类很简单，只有165行。源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; private @Nullable Handler mHandler; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; /** * @return a shared &#123;@link Handler&#125; associated with this thread * @hide */ @NonNull public Handler getThreadHandler() &#123; if (mHandler == null) &#123; mHandler = new Handler(getLooper()); &#125; return mHandler; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; /** * Returns the identifier of this thread. See Process.myTid(). */ public int getThreadId() &#123; return mTid; &#125;&#125; 实现：通过源代码可以发现，此类在实现上主要是在Thread类中的run()中对Looper进行了创建和调用。即： 12345678910111213@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 并且着重处理了Looper的退出操作：quitSafely()与quit()。 线程处理：此类在线程处理上使用了wait()和notifyAll()。而且尤其重要的一点是：在使用时要先调用Thread的start()，然后在调用getLooper()。 通过Handler处理当前Thread中的消息，需要对Handler进行初始化操作。初始化时需要传入Looper对象，在HandlerThread类中，Looper对象的获取是在getLooper()之后得到的，但是getLooper()中调用了wait()，只有先调用run()中notifyAll()才能返回已经创建结束的Looper对象。 IntentService IntentService类的结构 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; /** * Unless you provide binding for your service, you don't need to implement this * method, because the default implementation returns null. * @see android.app.Service#onBind */ @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 基本类描述 使用参考：https://blog.csdn.net/javazejian/article/details/52426425 IntentService是一个继承Service的抽象类，有一个内部类ServiceHandler继承Handler并实现handleMessage(Message msg)方法，并在方法内调用onHandleIntent(@Nullable Intent intent)抽象方法。抽象方法onHandleIntent(@Nullable Intent intent)是提供给外界调用的处理耗时任务的方法。 内部实现描述IntentService类内部创建并调用了Looper、Handler、HandlerThread。 实际上：IntentService是在Service中对Handler+HandlerThread进行了综合实现。 具体实现： 在onCreate()中 对HandlerThrad和Handler进行实现。 1234567public void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 在onStart()中对消息进行处理，注意 Message对象的赋值。 12345678910111213@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125;@Overridepublic int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125; 根据Service的生命周期： 可知，当执行完毕onCreate()、onStart()、onStartCommand()后，基本上所有的类的对象已经初始化完毕。即：左侧的生命周期。 在实际使用中，onCreate()仅调用1次，onStartCommand()调用多次。为了符合Service的这一运行特性，仅在onCreate()中进行创建、在onStart()中进行数据发送。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程-概述]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B-%E6%A6%82%E8%BF%B0%20%2F</url>
    <content type="text"><![CDATA[线程总结-1 Java 参考：https://www.cnblogs.com/xdp-gacl/p/3633936.html参考：https://www.cnblogs.com/wxd0108/p/5479442.html 名词释义： 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源。 线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如synchronized关键字。 在同一个时间点上，一个CPU只能支持一个线程在执行。因为CPU运行的速度很快，因此我们看起来的感觉就像是多线程一样。 基本线程类：Thread类，Runnable接口。 线程优先级： 优先级范围：1 - 10；1最低，5是正常级 在不指定的情况下，所有线程的优先级是一样的。 线程的优先级应该在start()方法调用之前被设置 线程的状态线程状态转换关于阻塞(Blocked)情况 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断，IO完成都会回到(Runnable)状态，等待JVM的调度。 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）。 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。 Thread类中的yield()可以让一个Running状态的线程转入(Runnable)状态。 在Runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的，有可能刚刚处于Runnable状态的线程，会马上被再次调用。 基本控制方法： 参考：https://blog.csdn.net/maoyeqiu/article/details/50215123 方法 功能 isAlive() 判断线程是否终止 getPriority() 获得线程优先级 setPriority() 设置线程优先级 Thread.sleep() 指定当前线程的睡眠毫秒数 join() thread.join()把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B。 yield() 让出cpu，当前线程进入就绪队列等待调用 wait() 当前线程进入对象的wait pool，让当前线程释放锁，使得其他线程获取锁 notify()/notifyAll() 唤醒对象的wait pool中的一个或者所有等待的线程 sleep() 让当前线程睡眠，持有锁 每个对象都有的方法（机制）synchronized, wait(), notify() 是任何对象都具有的同步工具。 讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait()/notify()必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait()之后，其他线程可以进入同步块执行。 关键字 synchronized一个线程变为一个对象的锁的拥有者是通过下列三种方法： 执行这个对象的 synchronized 方法 执行这个对象的 synchronized 语句块，这个语句块中锁的对象 执行 synchronized 静态方法 synchronized单独使用:直接用于方法:相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。 12345public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125; 代码块：在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 12345678public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;&#125; synchronized 作用于方法1234567891011121314151617181920212223242526272829303132333435class Bank&#123; private int money = 1000; public synchronized int getMoney(int number)&#123; money -= number; System.out.println("Left Money: " + money); return number; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println("操作金额：" + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Thread t01 = new MoneyThread(bank);// 从银行取钱 Thread t02 = new MoneyThread(bank);// 从取款机取钱 t01.start(); t02.start(); &#125;&#125; 运行结果： 1234Left Money: 800操作金额：200Left Money: 600操作金额：200 synchronized 作用于代码块 - 同一个类的同一个对象12345678910111213141516171819202122232425262728293031323334353637class Bank&#123; private int money = 1000; public int getMoney(int number)&#123; synchronized (this)&#123; money -= number; System.out.println("Left Money: " + money); return number; &#125; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println("操作金额：" + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Thread t01 = new MoneyThread(bank);// 从银行取钱 Thread t02 = new MoneyThread(bank);// 从取款机取钱 t01.start(); t02.start(); &#125;&#125; 运行结果： 1234Left Money: 800操作金额：200Left Money: 600操作金额：200 synchronized 作用于代码块 - 同一个类的不同对象12345678910111213141516171819202122232425262728293031323334353637class Bank&#123; private int money = 1000; public int getMoney(int number)&#123; synchronized (this)&#123; money -= number; System.out.println("Left Money: " + money); return number; &#125; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println("操作金额：" + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Bank bank2 = new Bank(); Thread t1 = new MoneyThread(bank);// 从银行取钱 Thread t2 = new MoneyThread(bank2);// 从取款机取钱 t1.start(); t2.start(); &#125;&#125; 运行结果： 1234Left Money: 800Left Money: 800操作金额：200操作金额：200 synchronized 作用于代码块 - 作用域的范围修改前 123456789101112131415161718192021222324252627282930313233343536373839class Bank&#123; private int money = 1000; public int getMoney(int number)&#123; number = number + 12; System.out.println(" Money + 12 is : " + number); synchronized (this)&#123; money -= number; System.out.println("Left Money: " + money); return number; &#125; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println("操作金额：" + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Thread t01 = new MoneyThread(bank);// 从银行取钱 Thread t02 = new MoneyThread(bank);// 从取款机取钱 t01.start(); t02.start(); &#125;&#125; 运行结果 123456 Money + 12 is : 212 Money + 12 is : 212Left Money: 788操作金额：212Left Money: 576操作金额：212 修改后 123456789101112131415161718192021222324252627282930313233343536373839class Bank&#123; private int money = 1000; public int getMoney(int number) &#123; synchronized (this)&#123; number = number + 12; System.out.println(" Money + 12 is : " + number); money -= number; System.out.println("Left Money: " + money); return number; &#125; &#125;&#125;class MoneyThread extends Thread &#123; private Bank bank; public MoneyThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; System.out.println("操作金额：" + bank.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Bank bank = new Bank(); Thread t01 = new MoneyThread(bank);// 从银行取钱 Thread t02 = new MoneyThread(bank);// 从取款机取钱 t01.start(); t02.start(); &#125;&#125; 运行结果： 123456 Money + 12 is : 212Left Money: 788操作金额：212 Money + 12 is : 212Left Money: 576操作金额：212 由以上示例的运行结果的输出顺序可以看出：在 synchronized 代码块之外的的代码，在进行多线程运行时，是不受 synchronized 关键字控制的。 synchronized 作用于静态方法1234567891011121314151617181920212223242526272829303132333435class BankStatic &#123; private static int money = 1000; public synchronized static int getMoney(int number) &#123; money -= number; System.out.println("Left Money: " + money); return number; &#125;&#125;class MoneyThreadStatic extends Thread &#123; private Bank bank; @Override public void run() &#123; System.out.println("操作金额：" + BankStatic.getMoney(200)); &#125;&#125;public class ThreadMain &#123; public static void main(String[] args)&#123; Thread t3 = new MoneyThreadStatic();// 从银行取钱 Thread t4 = new MoneyThreadStatic();// 从取款机取钱 t3.start(); t4.start(); Thread t5 = new MoneyThreadStatic();// 从银行取钱 Thread t6 = new MoneyThreadStatic();// 从取款机取钱 t5.start(); t6.start(); &#125;&#125; 运行结果 12345678Left Money: 800Left Money: 600操作金额：200操作金额：200Left Money: 400操作金额：200Left Money: 200操作金额：200 synchronized 关键字的组合使用 - 生产者消费者问题synchronized, wait(), notify()结合典型场景。 生产者消费者问题是研究多线程程序时绕不开的经典问题之一，它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。要解决此问题可以通过：同步机制实现的生产者/消费者问题。 同步问题核心在于：如何保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用加锁机制，保证资源在任意时刻至多被一个线程访问。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 仓库类Storage实现缓冲区 */public class Storage &#123; private final int MAX_SIXE = 5; private LinkedList&lt;Object&gt; linkedList = new LinkedList&lt;&gt;(); //生产num个产品 public void produce(int num) &#123; synchronized (linkedList) &#123; // 如果仓库剩余容量不足 while (linkedList.size() + num &gt; MAX_SIXE) &#123; System.out.println(Thread.currentThread().getName() + ", wait:【要生产的产品数量】:" + num + "/t【库存量】:" + linkedList.size() + "/t暂时不能执行生产任务!"); try &#123; linkedList.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 生产条件满足情况下，生产num个产品 for (int i = 0; i &lt; num; i++) &#123; linkedList.add(new Object()); &#125; System.out.println("【已经生产产品数】:" + num + "/t【现仓储量为】:" + linkedList.size()); linkedList.notifyAll(); &#125; &#125; public void constume(int num) &#123; synchronized (linkedList) &#123; // 如果仓库存储量不足 while (linkedList.size() &lt; num) &#123; System.out.println(Thread.currentThread().getName() + ", wait:R【要消费的产品数量】:" + num + "/t【库存量】:" + linkedList.size()); // 由于条件不满足，消费阻塞 try &#123; linkedList.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 消费条件满足情况下，消费num个产品 for (int i = 1; i &lt;= num; ++i) &#123; linkedList.remove(); &#125; System.out.println("【已经消费产品数】:" + num + "/t【现仓储量为】:" + linkedList.size()); linkedList.notifyAll(); &#125; &#125; public LinkedList&lt;Object&gt; getLinkedList() &#123; return linkedList; &#125; public void setLinkedList(LinkedList&lt;Object&gt; linkedList) &#123; this.linkedList = linkedList; &#125; public int getMAX_SIXE() &#123; return MAX_SIXE; &#125;&#125; 123456789101112131415161718192021222324252627/** * 生产者类Producer继承线程类Thread */public class Producer extends Thread &#123; // 每次生产的产品数量 private int num; // 所在放置的仓库 private Storage storage; // 构造函数，设置仓库 public Producer(int num, Storage storage) &#123; this.num = num; this.storage = storage; &#125; // 调用仓库Storage的生产函数 private void produce(int num) &#123; storage.produce(num); &#125; @Override public void run() &#123; produce(num); &#125;&#125; 1234567891011121314151617181920212223242526/** * 消费者类Consumer继承线程类Thread */public class Consumer extends Thread &#123; // 每次消费的产品数量 private int num; // 所在放置的仓库 private Storage storage; public Consumer(int num, Storage storage) &#123; this.num = num; this.storage = storage; &#125; // 调用仓库Storage的生产函数 private void consume(int num) &#123; storage.constume(num); &#125; @Override public void run() &#123; consume(num); &#125;&#125; 12345678910111213141516171819public class TestMain &#123; public static void main(String[] args)&#123; // 仓库对象 Storage storage = new Storage(); // 消费者对象 Consumer c1 = new Consumer(1,storage); Consumer c2 = new Consumer(3,storage); // 生产者对象 Producer p1 = new Producer(2,storage); // 线程开始执行 c1.start(); p1.start(); c2.start(); &#125;&#125; 123456Thread-0, constume wait:R【要消费的产品数量】:1/t【库存量】:0Thread-1, constume wait:R【要消费的产品数量】:3/t【库存量】:0Thread-2, produce【已经生产产品数】:2/t【现仓储量为】:2Thread-1, constume wait:R【要消费的产品数量】:3/t【库存量】:2Thread-0, constume【已经消费产品数】:1/t【现仓储量为】:1Thread-1, constume wait:R【要消费的产品数量】:3/t【库存量】:1 死锁问题产生死锁的原因： 资源不足、分配不当 请求、释放资源的顺序不对。 产生死锁的条件 互斥条件：在一段时间内，资源仅为一个线程所占有。此时，其他线程想要占用只能等待。 请求与保持条件：线程已经保持了一个资源，同时又提出了新的资源请求，此新资源却又被其他线程占用，即：请求被阻塞、自身持有资源又保持不放。 不可剥夺条件：线程中持有的资源为被使用完毕之前，不能别其他线程强行夺走，只能是自己来释放。 循环等待条件：若干线程间形成收尾相连的循环资源等待关系。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[他山之石，可以攻玉]]></title>
    <url>%2F%E5%BF%83%E5%BE%97-%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%94%BB%E7%8E%89%2F</url>
    <content type="text"><![CDATA[总结 学习编程是有加速度的：知识结构越丰富，跑的就越快。 阅读源代码永远不是一件轻松的事，大部分情况下读不下去，不是方法不好而是投入力度不够。 为何阅读源代码那么难？ 语言自身特点 现在看到的源码：基本上都经过若干年迭代、很多人不断地完善后的，且枝枝蔓蔓非常多，魔鬼都在细节中，阅读的时候很容易陷进去。 什么？还有不可忽视的工具？ Github 那么，该怎么做？昨夜西风凋碧树，独上高楼，望尽天涯路登高望远，对其有一个宏观概念，了解源码概貌。 1. 阅读源码之前，需要有一定的技术储备 2. 必须得会使用这个框架/类库， 最好是精通各种各样的用法 3. 找书，找资料，了解这个软件的整体设计 4. 搭建系统，把源代码跑起来 衣带渐宽终不悔，为伊消得人憔悴 静态：看代码 动态：debug (从业务的角度) 5. 设计主要测试案例，进行debug 第1遍尽可能 抛弃细节，抓主要流程 。 第2遍、第3遍 …… 再看细节。 6. 文档记录 代码太复杂，人脑容量有限，因此记不住所有的细节。 而文档可以帮助记住关键点， 写作的同时对知识作出梳理，防止遗忘。 7. 丰富测试案例，debug分支流程 继续 debug。 众里寻他千百度，蓦然回首，那人却在灯火阑珊处坚持。 没有上下的求索，就不会有瞬间的顿悟和理解。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android屏幕适配]]></title>
    <url>%2FAndroid%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[屏幕适配总结 参考：https://blog.csdn.net/xxf377376701/article/details/78925646参考：https://www.jianshu.com/p/cd66b7e01d4a 概念 计算公式： px = density（基准比例） * dp; density（基准比例） = dpi / 160; px = dp * (dpi / 160); 参数获取方式： 12345678910DisplayMetrics dm = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(dm);dm.ydpi; //得到物理屏幕上 Y 轴方向每英寸的像素dm.xdpi; //得到物理屏幕上 X 轴方向每英寸的像素dm.density; //获取当前设备的基准比例dm.densityDpi; //获取系统dpi，随着 build.prop 文件中的代码而改变。dm.widthPixels; //获取屏幕宽度的像素数量 屏幕尺寸：inch 手机对角线的物理尺寸，单位：英寸（inch），1英寸=2.54cm。 屏幕分辨率：px 手机在横向、纵向上的像素点数总和。一般描述成屏幕的”宽x高”=AxB。例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点 单位：px（pixel），1px=1像素点。 屏幕像素密度：dpi 每英寸的像素点数，单位：dpi（dots per ich）。假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi。 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度： 密度类型|代表的分辨率（px）|屏幕像素密度（dpi）—|—|—低密度（ldpi）|240x320 |120中密度（mdpi）| 320x480 |160高密度（hdpi）| 480x800 |240超高密度（xhdpi） |720x1280 |320超超高密度（xxhdpi） |1080x1920 |480 屏幕尺寸、分辨率、像素密度 3者关系 密度无关像素：dp/dip Density-independent pixel，与终端上的实际物理像素点无关，以保证在不同屏幕像素密度的设备上显示相同的效果。 标准是160dip。即1dp对应1个pixel，计算公式如：px = dp * (dpi / 160) 。即：屏幕密度越大，1dp 对应 的像素点越多。 独立比例像素：sp/sip scale-independent pixel，单位：sp。Android开发时用此单位设置文字大小，可根据字体大小首选项进行缩放。 dp与px的转换 px = dp * (dpi / 160); 在Android中，规定以160dpi（即屏幕分辨率为320x480）为基准：1dp=1px 密度类型 代表的分辨率（px） 屏幕密度（dpi） 换算（px/dp） 比例 低密度（ldpi） 240x320 120 1dp=0.75px 3 中密度（mdpi） 320x480 160 1dp=1px 4 高密度（hdpi） 480x800 240 1dp=1.5px 6 超高密度（xhdpi） 720x1280 320 1dp=2px 8 超超高密度（xxhdpi） 1080x1920 480 1dp=3px 12 Android中资源限定符的 优先级顺序 及 匹配关系 参考：https://blog.csdn.net/jamikabin/article/details/50541652 详细：https://www.jianshu.com/p/1d0bfbdaab17?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation 适配碎片化 Android系统 Android屏幕尺寸 Android屏幕分辨率 适配 本质：使得“布局”、“布局组件”、“图片资源”匹配不同的屏幕尺寸。 图片资源匹配本质：使得图片资源在不同屏幕密度上显示相同的像素效果。 使用自动拉伸位图：Nine-Patch 的图片类型，后缀名是.9.png，放置在 drawable文件夹即可。 4个方向 黑线 的作用 参考： https://blog.csdn.net/zhaokaiqiang1992/article/details/45419023#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E4%BC%B8%E4%BD%8D%E5%9B%BE https://www.jb51.net/article/77482.htm https://blog.csdn.net/oudetu/article/details/78968067 UI设计师的.9.PNG：https://www.zcool.com.cn/article/ZMTExODI4.html 根据各个密度文件夹 drawable- 生成相关的切图。理论上来说只需要提供一种分辨率规格的图片资源就可以了，重点是选择哪一中屏幕密度的文件夹。 Android 图片文件处理Android SDK会根据 屏幕密 度自动选择 对应的资源文件 进行渲染加载。如果屏幕所对应的文件夹没有要找的图片，这个时候就需要根据一定的策略去寻找图片了。 Android系统寻找图片的步骤 到 对应密度屏幕文件夹 中寻找，有就用； 若没有，到比此密度文件夹高一级的 密度文件夹 中寻找，有就用； 若 上一级文件夹也没有，则继续向上级寻找； 如果到了 顶级密度文件夹中 仍没有图片，则到比自己低的密度文件夹中寻找，以此类推。注意：若当前查找的密度文件夹为：mhpi，且此文件夹中没有图片，则是直接到drawable中查找。若drawable中没有，则向ldpi文件夹中寻找 Android 对图片的缩放对于放在不同目录下的图片， 系统会按照一定比例对原始的图片进行放大或者缩小， 布局控件匹配-基本限定符的使用参考：https://blog.csdn.net/lecepin/article/details/51206896 本质：使得布局组件在不同屏幕密度上显示相同的像素效果。 多使用相对布局 使用”wrap_content”、”match_parent”和”weight“来控制视图组件的宽度和高度。 使用密度无关像素 ：由于各种屏幕的像素密度都有所不同，因此相同数量的像素在不同设备上的实际大小也有所差异，这样使用像素（px）定义布局尺寸就会产生问题。因此，使用密度无关像素 dp 或独立比例像素 sp 单位指定尺寸。 dp能兼容不同分辨率的设备的原因参考：https://www.jianshu.com/p/cd66b7e01d4a dpi 是内置的，例如在 1920*1080 分辨率的手机上 默认就使用480 的 dpi ，不管的你的尺寸是多大都是这样，除非厂家手动修改了配置文件。 亲自尝试一下以验证： .xml文件中： 12345&lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;Hello World!&quot; /&gt; 按照我们之前的公式手动计算，结果应为： height = 100 x 445 / 160 = 278.5px width = 200 x 445 / 160 = 556.25px .java文件中： 12345678layout = (RelativeLayout)findViewById(R.id.la);//要在控件绘制完成后才能获取到相关信息，所以这里要监听绘制状态layout.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123; public boolean onPreDraw() &#123; Log.d(&quot;hehehe&quot;, textView.getHeight() + &quot;/&quot; + textView.getWidth()); return true; &#125;&#125;); 内部实际计算过程为： height = 100 x 480 / 160 = 300px width = 200 x 480 / 160 = 600px 这是因为手机中的 /system/build.prop 文件，其中有一行是这样： ro.sf.lcd_density=480 这就指定了这个机型使用的dpi是多少。在系统中使用的全部都是系统 dpi，没有使用物理 dpi，也获取不到物理 dpi。物理 dpi 主要用于厂家对于手机的参数描述。 但是： Android屏幕设备的多样性，如果使用dp来作为度量单位，并不是所有的屏幕的宽度都具备相同的dp长度。 为什么？ 假设我们UI设计图是按屏幕宽度为360dp来设计的，那么在上述设备上，屏幕宽度其实为1080/(440/160)=392.7dp，也就是屏幕是比设计图要宽的。这种情况下， 即使使用dp也是无法在不同设备上显示为同样效果的。 同时还存在部分设备屏幕宽度不足360dp，这时就会导致按360dp宽度来开发实际显示不全的情况。 而且上述屏幕尺寸、分辨率和像素密度的关系，很多设备并没有按此规则来实现， 因此dpi的值非常乱，没有规律可循，从而导致使用dp适配效果差强人意。 所以说： dp 解决了同一数值在不同分辨率中展示相同（相似）尺寸大小的问题（即屏幕像素密度匹配问题）;没有解决设备尺寸大小匹配的问题。（即屏幕尺寸匹配问题）。 总结 因为屏幕密度（分辨率）不一样，所以不能用固定的px 因为屏幕宽度不一样，所以要小心的用dp 因为本质上是希望使得布局组件在不同屏幕密度上显示相同的像素效果，那么，之前是绕了个弯使用dp解决这个问题，==那么到底能不能直接用px解决呢==？ 1即根据不同屏幕密度，控件选择对应的像素值大小。 升级配置方式1：百分比法 以某一分辨率为基准，生成所有分辨率对应像素数列表 以某一分辨率为基准，生成所有分辨率对应像素数列表 将生成像素数列表存放在res目录下对应的values文件下 根据UI设计师给出设计图上的尺寸，找到对应像素数的单位，然后设置给控件即可 1. 以320x480的分辨率为基准： 将屏幕的宽度分为320份，取值为x1~x320。 将屏幕的高度分为480份，取值为y1~y480。 lay_x.xml（宽） 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;x1&quot;&gt;1.0px&lt;/dimen&gt; &lt;dimen name=&quot;x2&quot;&gt;2.0px&lt;/dimen&gt; &lt;dimen name=&quot;x3&quot;&gt;3.0px&lt;/dimen&gt; &lt;dimen name=&quot;x4&quot;&gt;4.0px&lt;/dimen&gt; ... &lt;dimen name=&quot;x316&quot;&gt;316.0px&lt;/dimen&gt; &lt;dimen name=&quot;x317&quot;&gt;317.0px&lt;/dimen&gt; &lt;dimen name=&quot;x318&quot;&gt;318.0px&lt;/dimen&gt; &lt;dimen name=&quot;x319&quot;&gt;319.0px&lt;/dimen&gt; &lt;dimen name=&quot;x320&quot;&gt;320px&lt;/dimen&gt;&lt;/resources&gt; lay_y.xml（高） 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;y1&quot;&gt;1.0px&lt;/dimen&gt; &lt;dimen name=&quot;y2&quot;&gt;2.0px&lt;/dimen&gt; &lt;dimen name=&quot;y3&quot;&gt;3.0px&lt;/dimen&gt; &lt;dimen name=&quot;y4&quot;&gt;4.0px&lt;/dimen&gt; ... &lt;dimen name=&quot;y480&quot;&gt;480px&lt;/dimen&gt;&lt;/resources&gt; 生成其他分辨率的文件 如：写1080x1920的分辨率 因为基准是320x480，所以 宽：1080/320=3.375px，高：1920/480=4px。 所以相应文件应该是： lay_x.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;x1&quot;&gt;3.375px&lt;/dimen&gt; &lt;dimen name=&quot;x2&quot;&gt;6.65px&lt;/dimen&gt; &lt;dimen name=&quot;x3&quot;&gt;10.125px&lt;/dimen&gt; ... &lt;dimen name=&quot;x320&quot;&gt;1080px&lt;/dimen&gt;&lt;/resources&gt; lay_y.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;y1&quot;&gt;4px&lt;/dimen&gt; &lt;dimen name=&quot;y2&quot;&gt;8px&lt;/dimen&gt; &lt;dimen name=&quot;y3&quot;&gt;12px&lt;/dimen&gt; &lt;dimen name=&quot;y4&quot;&gt;16px&lt;/dimen&gt; ... &lt;dimen name=&quot;y480&quot;&gt;1920px&lt;/dimen&gt;&lt;/resources&gt; 不同分辨率下生成不同的像素列表工具： https://github.com/hongyangAndroid/Android_Blog_Demos/tree/master/blogcodes/src/main/java/com/zhy/blogcodes/genvalues 例如：需要设置的基准是800x1280，额外支持尺寸：735x1152 ；3200x4500； java -jar 文件名.jar 800 1280 735，1152_3200,4500 2. 将生成像素数列表存放在res目录下对应的values文件下将生成像素数列表（lay_x.xml和lay_y.xml）存放在res目录下对应的values文件 注： values-480x320 是分辨率限定符 必须在 默认values 里面也创建对应 默认lay_x.xml 和 lay_y.xml 文件 lay_x.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt;&lt;resources&gt; &lt;dimen name=&quot;x1&quot;&gt;1.0dp&lt;/dimen&gt; &lt;dimen name=&quot;x2&quot;&gt;2.0dp&lt;/dimen&gt; ...&lt;/resources&gt; 对于没有生成对应分辨率文件的手机，会使用 默认values 文件夹，如果默认values文件夹没有（即没有对应的分辨率、没有对应dimen）就会报错，从而无法进行屏幕适配。 对应单位改为dp，而不同于上面的px。因为不知道机型的分辨率，所以默认分辨率文件只好默认为x1=1dp以保证尽量兼容（又回到dp老方法了），这也是这个解决方案的一个弊端. 3. 根据UI设计设计图上的尺寸，找到对应像素数的单位，设置给控件即可.123456&lt;Button android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/hello_world&quot; android:layout_width=&quot;@dimen/x160&quot; android:layout_height=&quot;@dimen/y160&quot;/&gt; 总结 使用的是 px 而非 dp ，未能使用 google 提倡的使用方式。 Material Design 提供的设计规范参考在实际开发中无法得到应用。如：间距一般为 8 的倍数，8，16，32等。 生成的 values- 文件无法动态覆盖所有机型，只能是手动编写已知机型的相关文件。 后期维护麻烦。 AutoLayout 使用 博客：https://blog.csdn.net/lmj623565791/article/details/49990941GitHub：https://github.com/hongyangAndroid/AndroidAutoLayout 作者原话： 那么首先说一下：这个1px并不代表1像素，我在内部会进行百分比化处理，也就是说：720px高度的屏幕，你这里填写72px，占据10%；当这个布局文件运行在任何分辨率的手机上，这个72px都代表10%的高度，这就是本库适配的原理。 根据设计图的 px 数值直接填写到 xml 的标签中。 分析 AutoLayout的使用方式之一就是在xml文件中的控件标签中直接使用com.zhy.autolayout.AutoLinearLayout。所以在AutoAttr 类中：比较auto字符串 1boolean log = view.getTag() != null &amp;&amp; view.getTag().toString().equals(&quot;auto&quot;); ScreenUtils 类，设备宽、高数据的获取： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ScreenUtils&#123; public static int getStatusBarHeight(Context context) &#123; int result = 0; try &#123; int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; result = context.getResources().getDimensionPixelSize(resourceId); &#125; &#125; catch (Resources.NotFoundException e) &#123; e.printStackTrace(); &#125; return result; &#125; public static int[] getScreenSize(Context context, boolean useDeviceSize) &#123; int[] size = new int[2]; WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); Display d = w.getDefaultDisplay(); DisplayMetrics metrics = new DisplayMetrics(); d.getMetrics(metrics);// since SDK_INT = 1; int widthPixels = metrics.widthPixels; int heightPixels = metrics.heightPixels; if (!useDeviceSize) &#123; size[0] = widthPixels; size[1] = heightPixels - getStatusBarHeight(context); return size; &#125;// includes window decorations (statusbar bar/menu bar) if (Build.VERSION.SDK_INT &gt;= 14 &amp;&amp; Build.VERSION.SDK_INT &lt; 17) try &#123; widthPixels = (Integer) Display.class.getMethod(&quot;getRawWidth&quot;).invoke(d); heightPixels = (Integer) Display.class.getMethod(&quot;getRawHeight&quot;).invoke(d); &#125; catch (Exception ignored) &#123; &#125;// includes window decorations (statusbar bar/menu bar) if (Build.VERSION.SDK_INT &gt;= 17) try &#123; Point realSize = new Point(); Display.class.getMethod(&quot;getRealSize&quot;, Point.class).invoke(d, realSize); widthPixels = realSize.x; heightPixels = realSize.y; &#125; catch (Exception ignored) &#123; &#125; size[0] = widthPixels; size[1] = heightPixels; return size; &#125;&#125; AutoLayoutConifg类，自己设置的宽、高数据的获取： 获取在AndroidManifest.xml文件中获取的设置宽、高参数： 123456789101112private void getMetaData(Context context)&#123; ... applicationInfo = packageManager.getApplicationInfo(context .getPackageName(), PackageManager.GET_META_DATA); if (applicationInfo != null &amp;&amp; applicationInfo.metaData != null) &#123; mDesignWidth = (int) applicationInfo.metaData.get(KEY_DESIGN_WIDTH); mDesignHeight = (int) applicationInfo.metaData.get(KEY_DESIGN_HEIGHT); &#125; ...&#125; AutoLayoutConifg类在 AutoLayoutHelper 、AutoUtils 、UseDeviceSizeApplication 中被调用 在 AutoUtils 中的作用为： 1会直接将view的LayoutParams上设置的width，height直接进行百分比处理 在UseDeviceSizeApplication中进行Application初始化操作： 123456789public class UseDeviceSizeApplication extends Application&#123; @Override public void onCreate() &#123; super.onCreate(); AutoLayoutConifg.getInstance().useDeviceSize().init(this); &#125;&#125; 在AutoLayoutHelper中进行初始化和检查操作 123456789101112private void initAutoLayoutConfig(ViewGroup host)&#123; mAutoLayoutConifg = AutoLayoutConifg.getInstance(); mAutoLayoutConifg.init(host.getContext());&#125;public void adjustChildren()&#123; AutoLayoutConifg.getInstance().checkParams(); ...&#125; AutoLayoutHelper在AutoLinearLayout中的作用： 1234567@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)&#123; if (!isInEditMode()) mHelper.adjustChildren(); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; AutoLayoutActivity的作用： 12345678910111213141516171819202122232425public class AutoLayoutActivity extends FragmentActivity &#123; private static final String LAYOUT_LINEARLAYOUT = &quot;LinearLayout&quot;; private static final String LAYOUT_FRAMELAYOUT = &quot;FrameLayout&quot;; private static final String LAYOUT_RELATIVELAYOUT = &quot;RelativeLayout&quot;; @Override public View onCreateView(String name, Context context, AttributeSet attrs) &#123; View view = null; if (name.equals(LAYOUT_FRAMELAYOUT)) &#123; view = new AutoFrameLayout(context, attrs); &#125; if (name.equals(LAYOUT_LINEARLAYOUT)) &#123; view = new AutoLinearLayout(context, attrs); &#125; if (name.equals(LAYOUT_RELATIVELAYOUT)) &#123; view = new AutoRelativeLayout(context, attrs); &#125; if (view != null) return view; return super.onCreateView(name, context, attrs); &#125;&#125; 是做了name的判断，如果是属性中的3中Layout，会自动替换成对应的AutoXXXLayout LinearLayout -&gt; AutoLinearLayout RelativeLayout -&gt; AutoRelativeLayout FrameLayout -&gt; AutoFrameLayout 如果不是，直接调用父类的View onCreateView（String name，Context context，AttributeSet attrs）。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存相关]]></title>
    <url>%2FAndroid%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Android内存总结 参考：https://www.cnblogs.com/lenkevin/p/5484610.html Android App为什么会OOM呢？其实就是申请的内存超过了Dalvik Heap的最大值。 Android常见内存问题：内存的溢出是内存分配达到了最大值；而内存泄漏是无用内存充斥了内存堆。 Android内存分配回收机制Anroid基于进程中运行的组件及其状态规定了默认的五个回收优先级： Empty process(空进程) Background process(后台进程) Service process(服务进程) Visible process(可见进程) Foreground process(前台进程) 系统需要进行内存回收时最先回收空进程,然后是后台进程，最后才会回收前台进程。Android中由ActivityManagerService 集中管理所有进程的内存资源分配。 内存泄漏与内存溢出1. 内存泄露 单例（主要原因还是因为一般情况下单例都是全局的，有时候会引用一些实际生命周期比较短的变量，导致其无法释放） 静态变量（同样也是因为生命周期比较长） Handler内存泄露[7] 匿名内部类（匿名内部类会引用外部类，导致无法释放，比如各种回调） 资源使用完未关闭（BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap） 2. 图片相关 分辨率：将图片放到hdpi/xhdpi/xxhdpi等不同文件夹进行适配。 压缩：BitmapFactory 在解码图片时，可以带一个Options。 资源文件需要选择合适的文件夹进行存放 3. 内存抖动Android里内存抖动是指内存频繁地分配和回收，而频繁的gc会导致卡顿，严重时还会导致OOM。因为大量小的对象频繁创建，导致内存碎片，从而当需要分配内存时，虽然总体上还是有剩余内存可分配，而由于这些内存不连续，导致无法分配，系统直接就返回OOM了。 4. 注意监听器的注销在Android程序里面存在很多需要register与unregister的监听器，需要确保在合适的时候及时unregister那些监听器。自己手动add的listener，需要记得及时remove这个listener。 5. 注意WebView的泄漏为WebView开启另外一个进程，通过AIDL与主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。 6. 注意Cursor对象是否及时关闭在程序中经常会进行查询数据库的操作，但时常会存在不小心使用Cursor之后没有及时关闭的情况。这些Cursor的泄露，反复多次出现的话会对内存管理产生很大的负面影响，需要对Cursor对象的及时关闭。 7. 优化布局层次，减少内存消耗越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的View无法实现足够扁平的时候考虑使用自定义View来达到目的。 工具1. LeakCanary使用参考 https://github.com/square/leakcanaryhttps://blog.csdn.net/wolinxuebin/article/details/52766817https://www.jianshu.com/p/1e7e9b576391 MAT使用参考 https://blog.csdn.net/itachi85/article/details/77075455]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IPC]]></title>
    <url>%2FAndroid%20IPC%2F</url>
    <content type="text"><![CDATA[Android IPC 总结 1. IPC简介IPC（Inter-Process Communication）进程间通信/跨进程通信。指两个进程之间进行数据交换。 名称 描述 进程 一个执行单元；在Android中指一个一个程序或一个App；包含多个线程 线程 是CPU最小的调度单元；是一种有限的系统资源 在Android中：主线程也叫UI主线程，在UI主线程才能操作界面。 如果在UI主线程中进行大量耗时任务就会造成界面无法响应——ANR（Application Not Responding）。为耗时任务开辟新线程将会解决此问题。 在Android中：最有特色的进程间通信方式为：Binder，Socket、ContentProvider也可实现。 2. Android 多进程模式一般情况下，Android中的多进程是指 同一个应用中存在多个进程 的情况。 2.1 开启多进程1. 查看进程列表 参考：https://blog.csdn.net/moonshine2016/article/details/53422082 可使用 ： 1adb shell ps 进行查看。 Android系统会为每一个应用分配一个唯一的UID。具有相同UID并且相同签名的应用才能共享数据。 在Android中使用多进程只有一种方法，就是给四大组件的 AndroidManifest.xml 文件中设置 android:process=&quot;:remote&quot; 属性。 2. 开启方式 android:process=”:remote” 简写。是指要在当前进程名前附加当前包名。完整进程名为：com.exaple:remote 私有进程，其他应用组件不能和它跑在一个进程。 android:process=”com.exaple.remote” 完整的命名方式。 全局进程，其他应用可通过 ShareUID 运行在同一个进程中。 实际使用场景：百度地图。 在AndroidManifest.xml文件中，需要配置： 12345&lt;service android:name=&quot;com.baidu.location.f&quot; android:enabled=&quot;true&quot; android:process=&quot;:remote&quot; android:screenOrientation=&quot;portrait&quot;/&gt; 2.2 多进程的运行机制使用多进程带来的问题 - 内存问题 多进程带来的主要影响： 开启多进程的方式很简单，但是实际运行会出很多问题，绝非仅仅只是 android:process=&quot;:remote&quot; 那么简单。 Android为每一个应用（进程）分配一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间这就导致不同的虚拟机在访问同一个类的对象时，会产生多个副本，副本之间互不影响，即：修改了一个进程A中的对象的属性值后，进程B中同一个对象的属性值仍为修改之前的值。 所以，运行在 不同进程中的四大组件，通过 内存 来 共享数据 都会失败 使用对进城会造成一下几个问题： 静态成员 + 单例模式完全失效 线程同步机制完全失效 不是一块内存，那么不管锁定的是对象还是全局类都无法保证线程同步，不同进程，不是同一块内存。 SharedPreference可靠性下降 SharedPreference 不支持2个进程同时去执行读/写操作，否则会导致一定几率的数据丢失，因为SharedPreference是通过 XML文件实现的。 Application多次创建 运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的，运行在不同进程中的组件拥有同的虚拟机和不同的Application及内存空间。 多进程模式的本质 同一个应用间的多进程就相当于：两个不同的应用采用SharedUID的模式 3. IPC基础概念 Serializable接口 Parcelable接口 Binder 3.1. Parcelable和Serializable3.1.1 的区别 参考：https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html参考：https://www.jianshu.com/p/a60b609ec7e7 这两个都是和序列化相关的接口。 Serializable只需要对某个类以及它的属性实现Serializable 接口即可。Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。 缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。 Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。 3.1.2 序列化、反序列化是什么？ 对象的序列化：Java对象 转化为 字节流 的过程； 对象的反序列化：字节流 转化为 Java对象 的过程。 3.1.3 两者区别是什么? Serializable 的作用是为了保存对象的属性到本地文件、数据库、网络流以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。 Android的 Parcelable 的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。 3.1.4 效率及选择？Parcelable的性能比Serializable好，在内存开销方面较小，所以在 内存间数据传输 时推荐使用Parcelable，如activity间传输数据，而Serializable可将数据持久化方便保存，所以在需要 保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。 3.1.5 Java 序列化中的一些高级认识 序列化 ID 问题 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（即：private static final long serialVersionUID = 1L） 静态变量序列化问题代码 12345678910111213141516171819202122232425262728293031323334public class Test implements Serializable &#123; private static final long serialVersionUID = 1L; public static int staticVar = 5; public static void main(String[] args) &#123; try &#123; //初始时staticVar为5 ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); out.writeObject(new Test()); out.close(); //序列化后修改为10 Test.staticVar = 10; ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); Test t = (Test) oin.readObject(); oin.close(); //再读取，通过t.staticVar打印新的值 System.out.println(t.staticVar); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。这个 System.out.println(t.staticVar) 语句输出的是 10。 之所以打印 10 的原因在于：序列化时并不保存静态变量。 这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。 3.1.6 父类的序列化与 Transient 关键字 情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。 解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。 Transient 关键字 其作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 除了使用 Transient 关键字可以使得字段不被序列化，还可以根据父类对象序列化的规则，将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化 上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient。 对敏感字段加密 情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单 3 展示了这个过程。 3.1.7 序列化存储规则1234567891011121314151617181920ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); Test test = new Test(); //试图将对象两次写入文件 out.writeObject(test); out.flush(); System.out.println(new File(&quot;result.obj&quot;).length()); out.writeObject(test); out.close(); System.out.println(new File(&quot;result.obj&quot;).length()); ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); //从文件依次读出两个文件 Test t1 = (Test) oin.readObject(); Test t2 = (Test) oin.readObject(); oin.close(); //判断两个引用是否指向同一个对象 System.out.println(t1 == t2); 对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。 一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如图: 第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是因为Java 序列化机制为了节省磁盘空间，具有特定的存储规则： 当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。 3.2 Binder Binder是Android中的一个类，实现了IBinder接口。 从IPC角度而言：Binder是Android中一种跨进程间通信的方式。 从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService()时，客户端可以接受服务端提供的服务或者数据。 从Android的Framework层来说，Binder是ServiceManager连接各种Manager和响应ManagerService的桥梁。 Android开发中，Binder主要用在Service中，包括AIDL（Android Interface Definition Language）和Messenger。普通Service中的Binder不涉及进程间通信。而Messenger底层是AIDL。 AIDL使用参考：https://blog.csdn.net/JoneRen/article/details/72885807要点：虽然在同一个包内，但是依然要手动导包，这是aidl的特殊之处。 详细示例查阅《Android开发艺术探索》P47-P61 4. IPC方式 Bundle 共享文件 Messager AIDL ContentProvider Socket 4.1 Bundle四大组件中，Activity、Service、Receiver都支持在Intent中传递Bundle数据，Bundle实现了Parcelable接口，方便在不同进程间传输。 特点： 典型：最简单的进程间通信方式。 特殊： 如：A进程进行计算，计算结束后启动B进程的一个组件并把结果传递给B进程，但是问题是这个计算结果不能放入Bundle中，无法使用Intent进行传递。 一个简单的实现方案是：使用Intnent启动进程B的Service组件，在Service中进行计算，计算完毕后再启动B进程真正需要启动的组件。因为Service也在进程B中，所以目标组件可以直接获取数据。 核心思想是：将A进程中的计算任务转移至B进程中的Service中进行。避免了进程间通信。 4.2 共享文件两个进程通过读/写同一个文件来交换数据。 特点： 并发读/写问题。所以此方式适合对数据同步要求不高的进程之间的通信，切要妥善处理读/写并发问题 不建议使用 SharedPreference。 4.3 Messager是一种轻量级的IPC解决方法。 通过 Messenger 可以在不同进程中传递Message对象，在 Message 中放入我们需要传递的数据即可。其底层是现实AIDL。 特点： 其一次处理一个请求，无需考虑线程同步问题，服务端不存在并发执行。 Messenger 的具体实现分为：客户端、服务端。 特点： Messenger 是以串行方式处理客户端发送的数据，如果有大量并发请求信息，那么使用 Messenger 则不合适。 Messenger 作用是主要是传递消息，要跨进程调用 服务端 方法时，则 Messenger无法做到。 4.4 AIDL支持的数据类型： 基本数据类型：4类8种 String 和 CharSequence List：只支持ArrayList，里面每个元素都必须能够被AIDL支持。 Map：只支持HashMap，里面每个元素都必须能够被AIDL支持，包括 key 和 value。 Parcelable：所有实现了Parcelable接口的对象。 AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。 注意： 自定义的Parcelable对象和AIDL对象必须要显示的import进来，无论是否和当前的AIDL文件在同一个包中。 如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和他同名的AIDL文件，并在其中将其声明为Parcelable类型。 AIDL中只支持方法，不支持声明静态变量。 AIDL的包结构在客户端和服务端要保持一致，否则出错，因为客户端要反序列化服务端中和AIDL接口相关的所有类 AIDL中除了基本数据类型之外，其他参数类型必须标上方向： in：输入型参数 out：输出型参数 inout：输入输出型参数 不能一概使用 inout，因为这在底层实现是有开销的。 实现过程： 服务端 客户端 4.5 ContentProvider4.6 Socket]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代模式Iterator]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8FIterator%2F</url>
    <content type="text"><![CDATA[参考《Head First 设计模式》 封装变化 定义：迭代器模式提供一种方法：顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示。 迭代器模式源于对容器的访问，比如 Java 中的 List、Map、数组等。 使用场景： 访问一个聚合中的对象，而不需要暴露其内部的具体表示 对不同类型聚合中对象的进行遍历，提供统一的接口。 示例代码结构 示例 有两份“菜单”，其中一份是“List”结构，另一份的是“Array”结构，要在一个类中定义一个方法，在这个方法中：将两种不同结构的数据进行遍历输出。 以下为代码实现，测试结果见最下方。 对象类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MenuItem &#123; String name; String description; boolean vegerarian; double price; public MenuItem(String name, String description, boolean vegerarian, double price) &#123; this.name = name; this.description = description; this.vegerarian = vegerarian; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public boolean isVegerarian() &#123; return vegerarian; &#125; public void setVegerarian(boolean vegerarian) &#123; this.vegerarian = vegerarian; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125;&#125; 1.1 原始实现数组菜单1234567891011121314151617181920212223242526272829public class DinerMenu &#123; private static final int MAX_ITEMS = 4; private int numberOfItems = 0; private MenuItem[] menuItems; public DinerMenu() &#123; menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 1&quot;, true, 2.99); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 2&quot;, true, 1.97); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 3&quot;, true, 7.23); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 4&quot;, true, 5.56); &#125; private void addItem(String name, String description, boolean vegerarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegerarian, price); if (numberOfItems &gt;= MAX_ITEMS) &#123; System.out.println(&quot;has over!&quot;); &#125; else &#123; menuItems[numberOfItems] = menuItem; numberOfItems++; &#125; &#125; public MenuItem[] getMenuItems() &#123; return menuItems; &#125;&#125; List菜单12345678910111213141516171819202122public class PancakeHouseMenu &#123; private ArrayList&lt;MenuItem&gt; menuItems; public PancakeHouseMenu() &#123; menuItems = new ArrayList&lt;&gt;(); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 1&quot;, true, 2.99); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled fresh, tost - 2&quot;, true, 9.91); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 3&quot;, false, 4.29); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 4&quot;, true, 3.19); &#125; private void addItem(String name, String description, boolean vegerarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegerarian, price); menuItems.add(menuItem); &#125; public ArrayList&lt;MenuItem&gt; getMenuItems() &#123; return menuItems; &#125;&#125; 遍历菜单的 Waitress 类123456789101112131415161718192021222324252627282930public class Waitress &#123; private PancakeHouseMenu pancakeHouseMenu; private DinerMenu dinerMenu; public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; public void printMenu() &#123; ArrayList&lt;MenuItem&gt; arrayList = pancakeHouseMenu.getMenuItems(); MenuItem[] menuItems = dinerMenu.getMenuItems(); for (int i = 0; i &lt; arrayList.size(); i++) &#123; MenuItem menuItem = arrayList.get(i); System.out.print(menuItem.getName() + &quot; &quot;); System.out.print(menuItem.getPrice() + &quot; &quot;); System.out.println(menuItem.getDescription()); &#125; for (int i = 0; i &lt; menuItems.length; i++) &#123; MenuItem menuItem = menuItems[i]; System.out.print(menuItem.getName() + &quot; &quot;); System.out.print(menuItem.getPrice() + &quot; &quot;); System.out.println(menuItem.getDescription()); &#125; &#125;&#125; 测试1234567891011public class TestMain &#123; public static void main(String[] args) &#123; PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu(); DinerMenu dinerMenu = new DinerMenu(); Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu); waitress.printMenu(); &#125;&#125; UML类图 存在问题需要优化、修改就是 printMenu() 方法，2个方面。 暴露了具体的遍历过程 有相似、重复的代码 1.2 对 printMenu() 方法进行优化、去重自定义一个接口，封装 printMenu() 中的遍历操作123456public interface Iterator &#123; boolean hasNext(); Object next();&#125; 2个菜单分别实现 遍历接口数组菜单12345678910111213141516171819202122232425public class DinerMenuIterator implements Iterator &#123; MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if (position &gt;= items.length || items[position] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; MenuItem menuItem = items[position]; position++; return menuItem; &#125;&#125; List菜单12345678910111213141516171819202122232425public class PancakeHouseMenuIterator implements Iterator &#123; private int position = 0; private ArrayList&lt;MenuItem&gt; arrayList; public PancakeHouseMenuIterator(ArrayList&lt;MenuItem&gt; arrayList) &#123; this.arrayList = arrayList; &#125; @Override public boolean hasNext() &#123; if (position &gt;= arrayList.size() || arrayList.get(position) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; MenuItem menuItem = arrayList.get(position); position++; return menuItem; &#125;&#125; 在 Waitress类 中调用 遍历接口1234567891011121314151617181920212223242526272829public class Waitress &#123; private PancakeHouseMenu pancakeHouseMenu; private DinerMenu dinerMenu; public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; public void printMenu() &#123; Iterator panckIterator = pancakeHouseMenu.createIterator(); Iterator dinerIterator = dinerMenu.createIterator(); System.out.println(&quot;panck menu is :&quot;); doIterator(panckIterator); System.out.println(&quot;diner menu is :&quot;); doIterator(dinerIterator); &#125; private void doIterator(Iterator iterator) &#123; while (iterator.hasNext()) &#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.print(menuItem.getName() + &quot; &quot;); System.out.print(menuItem.getPrice() + &quot; &quot;); System.out.println(menuItem.getDescription()); &#125; &#125;&#125; 测试1234567891011public class IteratorMain &#123; public static void main(String[] args) &#123; DinerMenu dinerMenu = new DinerMenu(); PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu(); Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu); waitress.printMenu(); &#125;&#125; UML类图 存在问题在 Waitress 中： 1234567private PancakeHouseMenu pancakeHouseMenu;private DinerMenu dinerMenu;public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu;&#125; 可以发现，2个菜单的 遍历实现接口 完全一样， 但是没有为2个菜单设计一个共同的接口，目前2个菜单的还是独立的：PancakeHouseMenu、DinerMenu。 若2个菜单拥有共同的接口，在 Waitress 类中的代码更为简洁，面向对象中 多态 的 特性也得到体现。 1.3 使用 java.util.Iterator 作为共同接口定义一个共同的接口在 共同接口 Menu 中，定义一个方法使用 java.util.Iterator，实现 Iterator。 123public interface Menu &#123; public Iterator createIterator();&#125; 两个菜单分别实现 Menu 接口。PancakeHouseMenu12345678910111213141516171819202122232425262728public class PancakeHouseMenu implements Menu &#123; private ArrayList&lt;MenuItem&gt; menuItems; public PancakeHouseMenu() &#123; menuItems = new ArrayList&lt;&gt;(); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 1&quot;, true, 2.99); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled fresh, tost - 2&quot;, true, 9.91); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 3&quot;, false, 4.29); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;, &quot;Panackes with scrambled eggs, tost - 4&quot;, true, 3.19); &#125; private void addItem(String name, String description, boolean vegerarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegerarian, price); menuItems.add(menuItem); &#125; public ArrayList&lt;MenuItem&gt; getMenuItems() &#123; return menuItems; &#125; // 调用 java.util.Iterator 接口 @Override public Iterator createIterator() &#123; return menuItems.iterator(); &#125;&#125; 其中，在 PancakeHouseMenu 类中通过使用ArrayList已经实现的Iterator来实现 createIterator()。 DinerMenu1234567891011121314151617181920212223242526272829303132333435public class DinerMenu implements Menu &#123; private static final int MAX_ITEMS = 4; private int numberOfItems = 0; private MenuItem[] menuItems; public DinerMenu() &#123; menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 1&quot;, true, 2.99); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 2&quot;, true, 1.97); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 3&quot;, true, 7.23); addItem(&quot;Frank&apos;s Pancake Diner&quot;, &quot;Fruits with scrambled juice - 4&quot;, true, 5.56); &#125; private void addItem(String name, String description, boolean vegerarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegerarian, price); if (numberOfItems &gt;= MAX_ITEMS) &#123; System.out.println(&quot;has over!&quot;); &#125; else &#123; menuItems[numberOfItems] = menuItem; numberOfItems++; &#125; &#125; public MenuItem[] getMenuItems() &#123; return menuItems; &#125; // 将 getMenuItems 修改为此方法。 @Override public Iterator createIterator() &#123; return new DinerMenuIterator(menuItems); &#125;&#125; 其中，此处的 createIterator() 方法 类 DinerMenuIterator() 是继承 Iterator 后，自定义实现的内部细节。 DinerMenuIterator 类的实现12345678910111213141516171819202122232425public class DinerMenuIterator implements Iterator &#123; MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if (position &gt;= items.length || items[position] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; MenuItem menuItem = items[position]; position++; return menuItem; &#125;&#125; 执行具体遍历的类：Waitress1234567891011121314151617181920212223242526272829public class Waitress &#123; private Menu pancakeHouseMenu; private Menu dinerMenu; public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; public void printMenu() &#123; Iterator panckIterator = pancakeHouseMenu.createIterator(); Iterator dinerIterator = dinerMenu.createIterator(); System.out.println(&quot;panck menu is :&quot;); doIterator(panckIterator); System.out.println(&quot;diner menu is :&quot;); doIterator(dinerIterator); &#125; private void doIterator(Iterator iterator) &#123; while (iterator.hasNext()) &#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.print(menuItem.getName() + &quot; &quot;); System.out.print(menuItem.getPrice() + &quot; &quot;); System.out.println(menuItem.getDescription()); &#125; &#125;&#125; 测试12345678910public class ClassMain &#123; public static void main(String[] args) &#123; Menu dinerMenu = new DinerMenu(); Menu pancakeHouseMenu = new PancakeHouseMenu(); Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu); waitress.printMenu(); &#125;&#125; 对比 UML类图 1.4 3个版本的测试结果12345678910panck menu is :K&amp;B&apos;s Pancake Breakfast 2.99 Panackes with scrambled eggs, tost - 1K&amp;B&apos;s Pancake Breakfast 9.91 Panackes with scrambled fresh, tost - 2K&amp;B&apos;s Pancake Breakfast 4.29 Panackes with scrambled eggs, tost - 3K&amp;B&apos;s Pancake Breakfast 3.19 Panackes with scrambled eggs, tost - 4diner menu is :Frank&apos;s Pancake Diner 2.99 Fruits with scrambled juice - 1Frank&apos;s Pancake Diner 1.97 Fruits with scrambled juice - 2Frank&apos;s Pancake Diner 7.23 Fruits with scrambled juice - 3Frank&apos;s Pancake Diner 5.56 Fruits with scrambled juice - 4]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-Hash]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Hash%2F</url>
    <content type="text"><![CDATA[参考：https://blog.csdn.net/u010297957/article/details/51974340 哈希(Hash，也翻译为：散列)1. 名词释义 哈希算法：指的是一类算法； 哈希函数：在 关键字 和 存储位置 之间建立一个 确定的对应关系 f，此关系使得每个关键字和结构中一个唯一的存储位置对应。此函数称为 哈希函数。形式大概就是 value = hash(key)。 哈希表（Hash table，也叫散列表）：由哈希函数构建的表就是哈希表。更为严谨的表示：根据设定的 哈希函数H(key) 和 处理冲突的方法，将 一组关键字 映像（通过H(key)）到一个 有限的连续的地址集（区间）上，并以关键字在地址集中的 映像（通过H(key)的值 作为记录在表中的 存储位置。 冲突：不同的关键字得到得到同一哈希地址。即： k1 != k2，但是 f(k1) = f(k2)。 2. 用处 加密： Hash哈希是把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做HASH值，Hash函数逼近单向函数，所以可以用来对数据进行加密。最广泛应用的Hash算法有MD4、MD5、SHA1。 压缩： Hash哈希是指 把一个大范围映射到一个小范围，往往是为了节省空间，使得数据容易保存。 2. 哈希表(Hash Table)2.1 查找问题：线性表、树这些结构中，记录 在 结构 中的相对位置是随机的，位置和记录的关键字之间不存在确定关系。因此，在结构中查找时需要进行一系列和关键字的比较，即：这一类查找方法建立在比较的基础上。 理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的 存储位置 和它的 关键字之间建立一个 确定的关系f ，使每个关键字和结构中一个唯一的存储位置相对应。 哈希表是通过 对应关系f 由 键来找到要查询的值，这是它区别于 比较 查询法的最大不同。 2.3 常用的Hash函数 构造方法： 平方取中法： 先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。 折叠法： 将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。 随机数法： 选择一个随机函数，取关键字的随机函数值作为Hash地址，通常用于关键字长度不同的场合。即f(key)=random(key)特点：通常，关键字长度不相等时，采用此法构建Hash函数 较为合适。 除留取余法： f(k)=k mod p ， p&lt;=m取关键字被某个不大于Hash表 长m 的数p 除后所得的余数为Hash地址 。 特点：这是最简单也是最常用的Hash函数构造方法。可以直接取模，也可以在平法法、折叠法之后再取模。 值得注意的是，在使用除留取余法 时，对p 的选择很重要，如果p 选的不好会容易产生同义词。由经验得知：p 最好选择不大于表长m 的一个质数、或者不包含小于20的质因数的合数。 2.4 处理冲突处理冲突：假设哈希表的地址集为 : 0−(n−1) ，那么 冲突 是指 : 由关键字得到的哈希地址为 j(0≤j≤n−1) 的位置上已存有记录，而 处理冲突 : 就是为该关键字的记录找到另一个 空的哈希地址 。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解、反射]]></title>
    <url>%2FJava%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考：https://blog.csdn.net/wzgiceman/article/details/53406248参考：https://blog.csdn.net/wzgiceman/article/details/53483665参考：https://www.cnblogs.com/be-forward-to-help-others/p/6846821.html参考：https://blog.csdn.net/BabyGoodMorning/article/details/76349855 使用注解的作用 更早的发现程序的问题或者错误 更好的增加代码的描述能力 更加利于我们的一些规范约束 0. 注解：Annotation关键词：3种内置，4种类型 在Java中，注解(Annotation)引入始于Java5，用来描述Java代码的元数据，通常情况下注解不会直接影响代码的执行，尽管有些注解可以用来做到影响代码执行。 Annotation 是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，程序开发人员可以在不改变原有逻辑的情况下，在源文件嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation 提供了一条为程序元素设置元数据的方法，从某些方面来看，Annotation就像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被存储在Annotation的“name=value”对中。 需要指出的是：Annotation不能影响程序代码的执行，无论增加、删除Annotation，代码都始终如一地执行。如果希望让程序中的Annotation能在运行时起一定的作用，只有通过某种配套的工具对Annotation中的信息进行访问的处理，访问和处理Annotation的工具统称APT（Annotation Processing Tool）。 0.1 元数据（MetaData） 参考：http://www.ruanyifeng.com/blog/2007/03/metadata.html 元数据是用来描述数据的数据（Data that describes other data）。 一个列子： 一张RAW格式的数码照片，我们直接看到的照片是数据，而看不到的附加EXIF信息则是对于照片的额外描述。此时EXIF信息就是照片的元数据。级：EXIF信息是描述照片本身之外的数据。 0.2 java从源码到运行有3个阶段： source class runtime 0.3 功能 生成文档。这是最常见的，也是 java 最早提供的注解。常用的有 @param @return 等。 跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都 使用了这种配置来减少配置文件的数量 在编译时进行格式检查。如 @override 0.4 Java内置注解 - 3种 @Deprecated @Override @SuppressWarnings @Deprecated：已过时这个注释是一个标记注释。所谓标记注释，就是在源程序中加入这个标记后，并不影响程序的编译，但有时编译器会显示一些警告信息。 @Override：限定重写父类的方法@SuppressWarnings：抑制编译器警告当我们的一个方法调用了弃用的方法或者进行不安全的类型转换，编译器会生成警告。我们可以为这个方法增加@SuppressWarnings注解，来抑制编译器生成警告可以修饰的元素为类，方法，方法参数，属性，局部变量 0.5 注解类型（元Annotation）- 4种 @Documented @Inherited @Retention @Target @Documented：表示含有该注解类型的元素(带有注释的)会通过javadoc或类似工具进行文档化该类型应用于注解那些影响客户使用带注释(comment)的元素声明的类型。如果类型声明是用Documented来注解的，这种类型的注解被作为被标注的程序成员的公共API @Inherited：表示注解类型能被自动继承如果用户在当前类中查询这个元注解类型并且当前类的声明中不包含这个元注解类型，那么也将自动查询当前类的父类是否存在Inherited元注解，这个动作将被重复执行知道这个标注类型被找到，或者是查询到顶层的父类。 即：如果某个类使用了A Annotation（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动具有A注释。 eg: 12345678@Documented@Inheritedpublic @interface Ety &#123; @Deprecated String value(); @Deprecated String name();&#125; @Retention：表示该注解类型的注解保留的时长当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留方式 name explain SOURCE 注解仅存在于源码中，在class字节码文件中不包含 CLASS 存在Java源文件，以及经编译器后生成的Class字节码文件，但在运行时VM不再保留注释 RUNTIME 存在源文件、编译生成的Class字节码文件，以及保留在运行时VM中，可通过反射性地读取注解 eg: 123456789@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface Ety &#123; @Deprecated String value(); @Deprecated String name();&#125; @Target：表示注解类型所适用的程序元素的种类当注解类型声明中没有@Target元注解，则默认为可适用所有的程序元素。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素 ElementType explain TYPE 类、接口（包括注解类型）或枚举声明 CONSTRUCTOR 构造方法声明 PACKAGE 包声明 LOCAL_VARIABLE 局部变量声明 METHOD 方法声明 ANNOTATION_TYPE 注解类型声明 PARAMETER 参数声明 FIELD 字段声明（包括枚举常量） 0.6 自定义Annotation0.6.1 自定义自定义方式 1 ：无成员变量 定义新的Annotation类型使用@interface关键字，它用于定义新的Annotation类型。定义一个新的Annotation类型与定义一个接口非常像，如下代码可定义一个简单的Annotation： 12345@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface AValue &#123;&#125; 自定义方式 2 ：有成员变量 Annotation还可以带成员变量，Annotation的成员变量在Annotation定义中以无参数方法的形式声明。其方法名和返回值定义了该成员的名字和类型。如下代码可以定义一个有成员变量的Annotation： 123456@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface AValue &#123; int value();&#125; 自定义方式 3 ：有成员变量 123456@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface AValue &#123; int value() default 90;&#125; 0.6.2 使用定义了该Annotation之后，就可以在程序任何地方来使用该Annotation，使用Annotation时的语法非常类似于public、final这样的修饰符。通常可用于修饰程序中的类、方法、变量、接口等定义，通常我们会把Annotation放在所有修饰符之前，而且由于使用Annotation时可能还需要为其成员变量指定值，因而Annotation长度可能比较长，所以通常把Annotation另放一行，如下程序所示： 123456789101112public class MyBean &#123; @AValue(value = 48) private int valueDeal; @Override public String toString() &#123; return "MyBean&#123;" + "valueDeal=" + valueDeal + '&#125;'; &#125;&#125; 07 注解处理器1. 反射：提取 Annotation 的信息Annotation接口是所有Annotation类型的父接口。 Java在java.lang.reflect包下有AnnotateElement接口，该接口代表程序中可以接受注释的程序元素，该接口主要有如下几个实现类（注意以下是类）： Package：类的包定义。 Class：类定义。 Constructor：构造器定义。 Field：类的成员变量定义。 Method：类的方法定义。 java.lang.reflect包下主要包含一些实现反射功能工具类，实际上，java.lang.reflect包提供的反射API扩充了读取运行时Annotation的能力。当一个Annotation类型被定义为运行时Annotation后，该注解才是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。 AnnotatedElement接口是所有程序元素（如Class、Method、Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象（如Class、Method、Constructor）之后，程序就可以调用该对象的如下三个方法来访问Annotation信息： getAnnotation(Class annotationClass); //返回该程序元素上存在的、指定类型的注释，如果该类型的注释不存在，则返回null。 Annotation[] getAnnotations(); //返回该程序元素上存在的所有注释。 boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass); //判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。 1.1 Field 注解、反射1234567891011/** * @author wenjia.Cheng cwj1714@163.com * @date 2018/5/31 * 生成一个 自定义注解 */@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface AValue &#123; int value();&#125; 123456789101112131415161718/** * @author wenjia.Cheng cwj1714@163.com * @date 2018/5/31 * 使用注解的类 */public class MyBean &#123; @AValue(value = 48) private int valueDeal; @Override public String toString() &#123; return &quot;MyBean&#123;&quot; + &quot;valueDeal=&quot; + valueDeal + &apos;&#125;&apos;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author wenjia.Cheng cwj1714@163.com * @date 2018/5/31 * 反射、注解的使用 */public class MainTest &#123; /** * bingo ： 反射 reflect * 首先反射注解，那么保留策略必须是Runtime，也就是@Retention(RetentionPolicy.RUNTIME) * @param args . */ public static void main(String[] args) &#123; try &#123; // 获取成员变量 Field field = MyBean.class.getDeclaredField("valueDeal"); System.out.println("field is : " + field.toString()); // 设置此元素可访问 field.setAccessible(true); // 判断此元素是否是AValue中的注解 if (field.isAnnotationPresent(AValue.class)) &#123; // 获取定义在 MyBean类 中的 成员变量 所属的注解 AValue AValue aValue = field.getAnnotation(AValue.class); // 从 AValue 中获取 value 属性的值 int valueRel = aValue.value(); // 将获取到的 数值 赋值到 具体使用注解的类中 MyBean myBean = new MyBean(); field.setInt(myBean, valueRel); //验证结果 System.out.println(myBean); &#125; else &#123; System.out.println("不是"); &#125; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果 1234/** * 当 定义为：int value() default 100; 调用为：@AValue()/@AValue时 ：MyBean&#123;valueDeal=100&#125; * 当 定义为：int value() default 100;或者 int value(); 调用为：@AValue(48)/@AValue(value = 48)时 ：MyBean&#123;valueDeal=48&#125; */ 1.2 Method 注解、反射自定义注解 123456789@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Login &#123; String username() default "zhangsan"; String password() default "123456";&#125; 反射 1234567891011121314151617181920212223242526272829303132public class MethoidMainTest &#123; @Login public void info()&#123; &#125; public static void main(String[] args) throws NoSuchMethodException &#123; // 通过反射获取info方法 Method method = MethoidMainTest.class.getMethod("info"); // 判断此方法是否存在 @Login 注解 if (method.isAnnotationPresent(Login.class)) &#123; System.out.println("info方法上存在@Login注释"); // 获取此方法上的所有注释 Annotation[] annotations = method.getAnnotations(); for (Annotation annotation : annotations) &#123; if (annotation != null &amp;&amp; annotation instanceof Login) &#123; String name = ((Login) annotation).username(); String pwd = ((Login) annotation).password(); System.out.println("name: " + name + ", pwd :" + pwd); &#125; &#125; System.out.println(annotations); &#125; else &#123; System.out.println("info方法上 不 存在@Login注释"); &#125; &#125;&#125; 1.3 Method 注解、反射自定义注解 12345678@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123; String testName() default "hahaha"; String testPwd() default "00000";&#125; 使用注解 12345678910111213141516public class Junit &#123; @Test public void test1() &#123; &#125; public void test2() &#123; &#125; public void test3() &#123; &#125; @Test public void test4() &#123; &#125;&#125; 反射 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ClassMainTest &#123; public static void main(String[] args)&#123; try &#123; Class classes = Class.forName("com.example.shortcutsmy.reflect_class.Junit"); System.out.println("classes name is : " + classes.getName()); //Method[] methods = Junit.class.getDeclaredMethods(); Method[] methods = classes.getDeclaredMethods(); for (Method m : methods) &#123; System.out.println("method name is : " + m.getName()); &#125; //测试的数量 int checkCount = 0; //未测试的数量 int uncheckCount = 0; for (Method m : methods) &#123; if (m.isAnnotationPresent(Test.class)) &#123; Annotation[] annotations = m.getAnnotations(); for (Annotation a : annotations) &#123; String name = ((Test)a).testName(); String pwd = ((Test)a).testPwd(); System.out.println("name is : " + name + ", pwd is : " + pwd); &#125; checkCount++; &#125; else &#123; uncheckCount++; &#125; &#125; System.out.println("测试的方法有" + checkCount); System.out.println("未测试的方法有" + uncheckCount); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2. Android-注解 参考：https://blog.csdn.net/wzgiceman/article/details/53483665 ##2.1 Android注解给我们提供了三种主要和其他注释供我们使用： IntDef和StringDef注解； 资源类型注解； Null注解； 其他实用注解 ###2.1.1 一个使用 IntDef注解 替代枚举 使用注解修饰参数 1234567891011121314151617181920212223242526public class UserInter &#123; public static final int CHILDE = 0x1; public static final int MAN = 0x2; public static final int GIRL = 0x3; public static final int OTHER = 0x4; @Documented @Retention(RetentionPolicy.RUNTIME) @IntDef(&#123;CHILDE, MAN, GIRL&#125;) public @interface UInter&#123;&#125; private int mUType; public int getUserType()&#123; return mUType; &#125; public void setUertType(@UInter int type)&#123; this.mUType = type; &#125; public void setUertType2(@IdRes int type)&#123; this.mUType = type; &#125;&#125; 调用 123UserInter userInter = new UserInter();userInter.setUertType(UserInter.CHILDE);// userInter.setUertType(UserInter.OTHER); 2.1.2 资源类型注解资源注解是为了防止我们在使用程序资源的时候，错误传递资源类型给函数，导致程序错误。 name explain AnimRes 动画 AnimatorRes animator资源类型 AnyRes 任何资源类型 ArrayRes 数组资源类型 AttrRes 属性资源类型 BoolRes bool类型资源类型 ColorRes 颜色资源类型 DimenRes 长度资源类型 DrawableRes 图片资源类型 IdRes 资源id InterpolatorRes 动画插值器 LayoutRes layout资源 MenuRes me nu资源 RawRes raw资源 StringRes 字符串资源 StyleRes style资源 StyleableRes Styleable资源类型 TransitionRes transition资源类型 XmlRes xml 资源 2.1.3 Null注解null注解对应的有两个详细的注解： @NonNull：不能为空 @Nullable：可以为空 2.1.4 其他注解2.1.4.1 Threading 注解thread注解是帮助我们指定方法在特定线程中执行处理，如果和指定的线程不一致，抛出异常；Threading 注解类型： @UiThread： UI线程 @MainThread ：主线程 @WorkerThread： 子线程 @BinderThread ： 绑定线程 2.1.4.2 Value Constraints注解 @Size 这里size定了一个参数length的最小和最大长度 当搭配 String 使用时 123private void testDo(@Size(min = 1,max = 2)String s)&#123; Log.e("tag","--------&gt;"+s);&#125; 使用效果为 此时，max = 2 表示的是 String 类型的参数的 长度即： 12"22" length = 2, 2 &lt;= max;"223" length = 3, 3 &gt;= max; @IntRange IntRange是用来指定int类型范围的注解 123private void setSizet(@IntRange(from = 1, to = 20) int s)&#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; setStrTest : " + s);&#125; 运行结果 @FloatRange 同 @IntRange 使用。 @CallSuper @CallSuper注解主要是用来强调在覆盖父类方法时，需要实现父类的方法，及时调用对应的super.*方法,当用@CallSuper修饰了该方法，如果子类覆盖的后没有实现对呀的super方法会抛出异常。 @CheckResult 假设你定义了一个方法返回一个值，你期望调用者用这个值做些事情，那么你可以使用@CheckResult注解标注这个方法，强制用户定义一个相应的返回值，使用它。 public class ResultClass { @CheckResult public int getParam(){ return 11; } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-aar]]></title>
    <url>%2FAndroid%20aar%2F</url>
    <content type="text"><![CDATA[参考：https://developer.android.com/studio/projects/android-library 1. 比较 结构上：Android 库 与 app 相同.可以提供构建应用所需的一切内容，包括源代码、资源文件和 Android 清单。 产生的文件：Android 库将编译到您可以用作 Android 应用模块依赖项的 Android 归档 (AAR) 文件，而不是在设备上运行的 APK。 AAR与JAR：AAR 文件可以包含 Android 资源和一个清单文件，这样，除了 Java 类与方法外，您还可以捆绑布局和可绘制对象等共享资源。 2. 作用 构建使用 某些相同组件（例如 Activity、服务或 UI 布局）的多个应用。 构建存在 多个 APK 变体（例如免费版本和付费版本）的应用并且需要在两种版本中 使用相同的核心组件。 3. 创建 将希望重用的文件移动到库模块中 然后以依赖的形式为每个应用模块添加库 3.1 直接创建 Android库3.2 将应用模块转换为库模块如果现有的应用模块包含有希望重用的所有代码，则可以按照以下步骤将其转换为库模块： 打开现有应用模块的 build.gradle 文件。您应在顶部看到以下内容： 1apply plugin: &apos;com.android.application&apos; 按照下面所示更改插件分配： 1apply plugin: &apos;com.android.library&apos; 点击 Sync Project with Gradle Files。 就这么简单。模块的整个结构仍然相同，但是现在它将作为 Android 库运行，构建也将创建一个 AAR 文件。 4. 注意事项 库模块不得包含原始资源 工具不支持在库模块中使用原始资源文件（保存在 assets/ 目录中）。应用使用的任何原始资源都必须存储在应用模块自身的 assets/ 目录中。 资源合并冲突 构建工具会将库模块中的资源与相关应用模块的资源合并。如果在两个模块中均定义了给定资源 ID，将使用应用中的资源。 如果多个 AAR 库之间发生冲突，将使用依赖项列表首先列出（位于 dependencies 块顶部）的库中的资源。 库模块可以包含 JAR 库 可以开发一个自身包含 JAR 库的库模块；不过需要手动编辑相关应用模块的构建路径，并添加 JAR 文件的路径。 库模块可以依赖外部 JAR 库 您可以开发一个依赖于外部库（例如 Maps 外部库）的库模块。在这种情况下，相关应用必须针对包含外部库（例如 Google API 插件）的目标构建。另外也要注意，库模块和相关应用都必须在其清单文件的 元素中声明外部库。 应用模块的 minSdkVersion 必须大于或等于库定义的版本 库作为相关应用模块的一部分编译，因此，库模块中使用的 API 必须与应用模块支持的平台版本兼容。 每个库模块都会创建自己的 R 类 在您构建相关应用模块时，库模块将先编译到 AAR 文件中，然后再添加到应用模块中。因此，每个库都有其自己的 R 类，并根据库的软件包名称命名。从主模块和库模块生成的 R 类会在所需的所有软件包（包括主模块的软件包和库的软件包）中创建。 5. AAR 文件详解AAR 文件的文件扩展名为 .aar，Maven 工件类型也应当是 aar。文件本身是一个包含以下强制性条目的 zip 文件： /AndroidManifest.xml /classes.jar /res/ /R.txt 此外，AAR 文件可能包含以下可选条目中的一个或多个： /assets/ /libs/名称.jar /jni/abi 名称/名称.so（其中 abi 名称 是 Android 支持的 ABI 之一） /proguard.txt /lint.jar]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle与Android]]></title>
    <url>%2FGradle%E4%B8%8EAndroid%2F</url>
    <content type="text"><![CDATA[Groovy：http://docs.groovy-lang.org/Gradle DSL: https://docs.gradle.org/current/javadoc/org/gradle/api/Project.htmlAndroid DSL 与 Task: http://google.github.io/android-gradle-dsl/current/index.html 关键词： Android、Groovy、DSL语言、Gradle 关系：-&gt; Android采用Gradle作为首选的构建自动化系统，使用Gradle强大的依赖关系管理功能-&gt; Gradle基于Groovy（一种用于编写Gradle的脚本语言），是一个开源构建自动化系统，它引入了基于Groovy的领域特定语言（DSL）来配置项目-&gt; Groovy是一种运行在JVM虚拟机上的脚本语言，能够与Java语言无缝结合。 区分：Android Plugin 版本 和 Gradle版本 Gradle插件 在Android中的用处： 插件化 VirtualAPK 热修复 Tinker、Robust 构建系统：多渠道打包 Gradle插件 1. Gradle概述 参考：https://docs.gradle.org/current/userguide/installation.html 1.1 安装1.1.1 前提条件Gradle可在所有主要操作系统上运行，并且只需要Java JDK 7或更高版本即可运行。检查，运行java -version。你应该看到这样的东西： 123❯java -version java version“1.8.0_151” Java™SE运行时环境（build 1.8.0_151-b12）Java HotSpot™64位服务器虚拟机（内置版本25.151-b12，混合模式） Gradle自带Groovy库，因此Groovy不需要安装。Gradle将忽略任何现有的Groovy安装。Gradle使用它在您的路径中找到的任何JDK。或者，您可以将JAVA_HOME环境变量设置为指向所需JDK的安装目录。 1.1.2 安装通过 homebrew 安装： 1brew install gradle 1.1.3 验证安装输入命令： 1gradle -v 得到的结果，如果为： 12345678910111213141516171819202122Welcome to Gradle 4.7!Here are the highlights of this release: - Incremental annotation processing - JDK 10 support - Grouped non-interactive console logs - Failed tests are re-run first for quicker feedbackFor more details see https://docs.gradle.org/4.7/release-notes.html------------------------------------------------------------Gradle 4.7------------------------------------------------------------Build time: 2018-04-18 09:09:12 UTCRevision: b9a962bf70638332300e7f810689cb2febbd4a6cGroovy: 2.4.12Ant: Apache Ant(TM) version 1.9.9 compiled on February 2 2017JVM: 1.8.0_131 (Oracle Corporation 25.131-b11)OS: Mac OS X 10.13.4 x86_64 则表示安装成功。 1.2 创建新的Gradle项目1.2.1 创建一个新的目录1mkdir Gradle_Projects 进入新创建的目录 1cd Gradle_Projects/ 1.2.2 初始化项目1gradle init 结果为： 1234Starting a Gradle Daemon (subsequent builds will be faster)BUILD SUCCESSFUL in 3s2 actionable tasks: 2 executed 表示初始化成功。 初始化成功后，项目的目录及文件功能说明： 1.2.3 创建一个新任务Gradle提供了用于通过基于Groovy或Kotlin的DSL创建和配置任务的API。 在项目的“根目录”下创建一个文件夹“src” 1mkdir src 并进入此文件夹 1cd src/ 在新创建的“src”目录下创建一个新文件“myfile.txt”，并写入“Hello,Word !”： 在项目配置脚本文件build.gradle中，定义一个copy方法，具体为： 1234task copy(type: Copy, group: &quot;Custom&quot;, description: &quot;Copies sources to the dest directory&quot;) &#123; from &quot;src&quot; into &quot;dest&quot;&#125; 在项目的“根目录”下执行 copy 方法的命令： 1./gradlew copy 若显示： 12BUILD SUCCESSFUL in 10m 11s1 actionable task: 1 executed 则表示任务添加成功。成功之后的项目树结构为： 1234567891011121314Gradle_Projects├── Gradle_Projects├── build.gradle├── dest│ └── myfile.txt├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat├── settings.gradle└── src └── myfile.txt 注意：本人在执行 copy 方法命令时，并没有直接显示结果，而是先下载了一个gradle-4.7-bin.zip文件 1.2.4 应用一个插件Gradle包含一系列插件，Gradle插件门户中提供了许多插件。插件中包含的其中一个插件就是base插件。结合调用的核心类型Zip，可以使用配置的名称和位置创建项目的zip存档。 使用语法将base插件添加到build.gradle文件中plugins。确保plugins {}在文件顶部添加该块（否则失败）。 123plugins &#123; id &quot;base&quot;&#125; 现在添加一个从该src目录创建一个zip存档的任务。 123task zip(type: Zip, group: &quot;Archive&quot;, description: &quot;Archives sources in a zip file&quot;) &#123; from &quot;src&quot;&#125; 若显示： 12BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 则表示任务执行成功，文件树为： 1234567891011121314151617Gradle_Projects├── Gradle_Projects├── build│ └── distributions│ └── Gradle_Projects.zip├── build.gradle├── dest│ └── myfile.txt├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat├── settings.gradle└── src └── myfile.txt 此任务是将 src 文件夹中的 所有文件 打包。zip包中的内容为： 1.2.5 发现更多的可用 task执行命令： 1./gradlew tasks 结果为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374------------------------------------------------------------All tasks runnable from root project------------------------------------------------------------Android tasks-------------androidDependencies - Displays the Android dependencies of the project.（显示项目的Android依赖项）signingReport - Assembles and tests this project.(显示每个变体的签名信息)sourceSets - Prints out all the source sets defined in this project.(打印出此项目中定义的所有源集)Build tasks-----------assemble - Assembles all variants of all applications and secondary packages（组装所有应用程序和辅助包的所有变体）。assembleAndroidTest - 组装所有Test应用程序。assembleDebug - 组装所有 Debug 构建。assembleRelease - 汇总所有 Release 构建。build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it（以及依赖它的所有项目）.buildNeeded - Assembles and tests this project and all projects it depends on（及其依赖的所有项目。）.clean - Deletes the build directory.cleanBuildCache - Deletes the build cache directory.compileDebugAndroidTestSourcescompileDebugSourcescompileDebugUnitTestSourcescompileReleaseSourcescompileReleaseUnitTestSourcesmockableAndroidJar - Creates a version of android.jar that&apos;s suitable for unit tests.Build Setup tasks-----------------init - Initializes a new Gradle build.wrapper - Generates Gradle wrapper files.Help tasks----------buildEnvironment - Displays all buildscript dependencies declared in root project &apos;2018-07&apos;.components - Displays the components produced by root project &apos;2018-07&apos;. [incubating]dependencies - Displays all dependencies declared in root project &apos;2018-07&apos;.dependencyInsight - Displays the insight into a specific dependency in root project &apos;2018-07&apos;.dependentComponents - Displays the dependent components of components in root project &apos;2018-07&apos;. [incubating]help - Displays a help message.model - Displays the configuration model of root project &apos;2018-07&apos;. [incubating]projects - Displays the sub-projects of root project &apos;2018-07&apos;.properties - Displays the properties of root project &apos;2018-07&apos;.tasks - Displays the tasks runnable from root project &apos;2018-07&apos; (some of the displayed tasks may belong to subprojects).Install tasks-------------installDebug - Installs the Debug build.installDebugAndroidTest - Installs the android (on device) tests for the Debug build.uninstallAll - Uninstall all applications.uninstallDebug - Uninstalls the Debug build.uninstallDebugAndroidTest - Uninstalls the android (on device) tests for the Debug build.uninstallRelease - Uninstalls the Release build.Verification tasks------------------check - Runs all checks.connectedAndroidTest - Installs and runs instrumentation tests for all flavors on connected devices.connectedCheck - Runs all device checks on currently connected devices.connectedDebugAndroidTest - Installs and runs the tests for debug on connected devices.deviceAndroidTest - Installs and runs instrumentation tests using all Device Providers.deviceCheck - Runs all device checks using Device Providers and Test Servers.lint - Runs lint on all variants.lintDebug - Runs lint on the Debug build.lintRelease - Runs lint on the Release build.lintVitalRelease - Runs lint on just the fatal issues in the release build.test - Run unit tests for all variants.testDebugUnitTest - Run unit tests for the debug build.testReleaseUnitTest - Run unit tests for the release build.To see all tasks and more detail, run gradlew tasks --allTo see more detail about a task, run gradlew help --task &lt;task&gt; 说明： task任务参数 与 build.gradle 文件中的代码对比： 1.3 命令1.3.1 一般命令： Gradle命令符合以下结构，在任务名称之前和之后允许选项： 1gradle [taskName ...] [--option-name ...] 如果指定了多个任务，则应该用空格分隔。 接受值的选项可以在选项和参数之间使用或不使用=指定; 然而，推荐使用=。 1--console=plain 启用行为的选项具有长形式的选项，而用--no-指定的反向选项。 以下是相对的命令。 12--build-cache--no-build-cache 许多长期形式的期权都有相当于短期期权的选择。 以下是等同的： 12--help-h 1.3.2 执行任务 运行任务及。 1gradle myTask 在多项目构建中执行任务 在多项目构建中，可以使用 : 分隔 子项目名称 和 任务名称 来执行子项目任务。 从根项目运行时，以下内容得到的结果是等价的。 12gradle :mySubproject:taskNamegradle mySubproject:taskName 也可以仅使用任务名称为所有子项目运行任务。 例如，这将从根项目目录中调用时为所有子项目运行“测试”任务。 1gradle test 从子项目中调用Gradle时，应该省略项目名称： 12cd mySubprojectgradle taskName 执行多任务 1gradle test deploy 排除执行任务中的引用任务 您可以使用-x或--exclude-task命令行选项排除正在执行的任务，并提供要排除的任务的名称。 12345678910gradle dist --exclude-task test&gt; Task :compilecompiling source&gt; Task :distbuilding the distributionBUILD SUCCESSFUL in 0s2 actionable tasks: 2 executed 您可以看到 test 任务未执行，即使它是 dist 任务的依赖项。 测试任务的依赖项（如compileTest）也不会执行。 另一个任务所需的测试依赖关系，如编译，仍然执行。 强制任务执行 您可以使用 --rerun-tasks 选项强制Gradle执行所有忽略最新检查的任务： 1gradle test --rerun-tasks 发生故障时继续构建 默认情况下，一旦任何任务失败，Gradle将中止执行并使构建失败。 这样可以尽快完成构建，但隐藏了可能发生的其他故障。 为了在单个构建执行中发现尽可能多的失败，可以使用 --continue 选项。 1gradle test --continue 当使用--continue执行时，Gradle将执行每个要执行的任务，而该任务的所有依赖关系完成时不会失败，而不会在遇到第一个失败时立即停止。 每次遇到的故障将在构建结束时报告。 如果任务失败，则任何依赖它的后续任务将不会执行。 例如，如果测试中的代码出现编译失败，测试将不会运行; 因为测试任务将取决于编译任务（直接或间接）。 任务名称缩写 在命令行中指定任务时，不必提供任务的全名。 您只需提供足够的任务名称即可唯一标识任务。 举例来说，Gradle可能足以让Gradle识别检查任务。 您还可以缩写骆驼案件任务名称中的每个单词。 例如，您可以通过运行gradle compTest或gradle cT来执行任务compileTest。 示例：缩写骆驼案例任务名称 1gradle cT 您还可以将这些缩写与-x命令行选项一起使用。 1.3.3 常用 Task以下是由内置和最主要的Gradle插件应用的任务约定。 计算所有输出 在Gradle构建中，通常build指定汇编所有输出并运行所有检查。 1gradle build 运行应用程序 1gradle run 运行所有检查 所有验证任务都是常见的，包括测试和测试，都是使用check任务执行的 1gradle check 清洁输出 您可以使用clean任务删除构建目录的内容，但这样做会导致预先计算的输出丢失，从而导致后续任务执行的额外构建时间大大增加。 1gradle clean 1.3.4 项目信息 TaskGradle提供了几个内置任务，这些任务显示了构建的特定细节。这对理解构建的结构和依赖关系以及调试问题很有用。 列出 项目 1gradle projects 结果为： 12345678&gt; Task :projects------------------------------------------------------------Root project------------------------------------------------------------Root project &apos;HelloGradle&apos;\--- Project &apos;:app&apos; 列出 task -1： :app:tasks 1gradle :app:tasks 列出 task -2： gradle tasks 1gradle tasks 列出 task -3：gradle tasks –all 1gradle tasks --all 显示 task 使用详情 1gradle help --task check 结果为： 1234567891011121314&gt; Task :helpDetailed task information for check // 详细任务信息Path // 路径 :app:checkType // 类型 Task (org.gradle.api.Task)Description // 描述 Runs all checks.Group // 组 verification 列出项目依赖关系 参考：https://docs.gradle.org/current/userguide/inspecting_dependencies.html 运行gradle dependencies将为您提供所选项目的依赖关系列表，按配置细分。对于每个配置，该配置的直接和传递依赖关系都显示在树中。以下是此报告的一个示例： 1gradle dependencies 运行 gradle buildEnvironment 可视化所选项目的构建脚本依赖关系，类似于 gradle dependencies 可视化正在构建的软件的依赖关系。 列出项目属性 1gradle properties 列出 model 信息 1gradle model 结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&gt; Task :model------------------------------------------------------------Root project------------------------------------------------------------+ tasks | Type: org.gradle.model.ModelMap&lt;org.gradle.api.Task&gt; | Creator: Project.&lt;init&gt;.tasks() + buildEnvironment | Type: org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask | Value: task &apos;:buildEnvironment&apos; | Creator: tasks.addPlaceholderAction(buildEnvironment) | Rules: ⤷ copyToTaskContainer + clean | Type: org.gradle.api.tasks.Delete | Value: task &apos;:clean&apos; | Creator: Project.&lt;init&gt;.tasks.clean() | Rules: ⤷ copyToTaskContainer + components | Type: org.gradle.api.reporting.components.ComponentReport | Value: task &apos;:components&apos; | Creator: tasks.addPlaceholderAction(components) | Rules: ⤷ copyToTaskContainer + dependencies | Type: org.gradle.api.tasks.diagnostics.DependencyReportTask | Value: task &apos;:dependencies&apos; | Creator: tasks.addPlaceholderAction(dependencies) | Rules: ⤷ copyToTaskContainer + dependencyInsight | Type: org.gradle.api.tasks.diagnostics.DependencyInsightReportTask | Value: task &apos;:dependencyInsight&apos; | Creator: tasks.addPlaceholderAction(dependencyInsight) | Rules: ⤷ HelpTasksPlugin.Rules#addDefaultDependenciesReportConfiguration(DependencyInsightReportTask, ServiceRegistry) ⤷ copyToTaskContainer + dependentComponents | Type: org.gradle.api.reporting.dependents.DependentComponentsReport | Value: task &apos;:dependentComponents&apos; | Creator: tasks.addPlaceholderAction(dependentComponents) | Rules: ⤷ copyToTaskContainer + help | Type: org.gradle.configuration.Help | Value: task &apos;:help&apos; | Creator: tasks.addPlaceholderAction(help) | Rules: ⤷ copyToTaskContainer + init | Type: org.gradle.buildinit.tasks.InitBuild | Value: task &apos;:init&apos; | Creator: tasks.addPlaceholderAction(init) | Rules: ⤷ copyToTaskContainer + model | Type: org.gradle.api.reporting.model.ModelReport | Value: task &apos;:model&apos; | Creator: tasks.addPlaceholderAction(model) | Rules: ⤷ copyToTaskContainer + projects | Type: org.gradle.api.tasks.diagnostics.ProjectReportTask | Value: task &apos;:projects&apos; | Creator: tasks.addPlaceholderAction(projects) | Rules: ⤷ copyToTaskContainer + properties | Type: org.gradle.api.tasks.diagnostics.PropertyReportTask | Value: task &apos;:properties&apos; | Creator: tasks.addPlaceholderAction(properties) | Rules: ⤷ copyToTaskContainer + tasks | Type: org.gradle.api.tasks.diagnostics.TaskReportTask | Value: task &apos;:tasks&apos; | Creator: tasks.addPlaceholderAction(tasks) | Rules: ⤷ copyToTaskContainer + wrapper | Type: org.gradle.api.tasks.wrapper.Wrapper | Value: task &apos;:wrapper&apos; | Creator: tasks.addPlaceholderAction(wrapper) | Rules: ⤷ copyToTaskContainer model信息 - 模型元素的细节 详情 描述 类型-Type 这是模型元素的基础类型，通常是完全限定的类名。 值-Value 当模型元素可以表示为字符串时，在报告中有条件地显示。 创造者-Creator 每个模型元素都有一个创建者。创建者表示模型元素的起源（即创建模型元素的原因） 规则-Rules 是规则的列表，不包括为给定模型元素执行的创建者规则。规则的显示顺序反映了它们的执行顺序 2. Gradle 与 Android Studio 结合Android应用程序使用 Gradle 作为构建工具，通常通过唯一受支持的IDE：Android Studio。本小节来描述创建新的Android应用程序时生成的Gradle构建文件的细节，以及如何使用Gradle为其调用相关的构建任务。 Gradle 文件与语法关系 Gradle 中重要的2个对象 project task 2.1 Gradle WrapperWrapper 就是对 Gradle 的一层包装。在项目开发过程中，使用到的都是 Wrapper 方式，而不是专门的手动下载Zip压缩包，配置 Gradle 环境 这些操作。 2.1.1 生成 Wrapper在项目根目录中，输入 12345gradle wraapper``` 即可生成 `wrapper` 文件夹。 此外，在执行以上命令时，还可以通过添加参数的方式，来决定具体使用哪个版本的 gradle 来管理项目（若不声明，则表示使用当前版本）。例如一下命令表示使用的是“2.4版本”： gradle wrapper –gradle-version 2.41234**注意：** - 1、在配置了 `gradle` 的环境下，执行 gradle init12345678910111213141516171819202122232425262728293031323334353637383940 命令后，已经生成 `gradle` 文件夹。 - 2、 根据其他博客的描述，将 `distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-bin.zip` 中的 `bin` 修改为 `all` 时，是可以看到Gradle源码的。### 2.1.2 在 `Android studio` 中当使用 `Wrapper` 第一次启动 `Gradle` 时，首先检查相应版本的Gradle是否被下载，若未下载则是先按照配置文件对其进行下载，然后再使用，若已经存在，则是直接使用。**Gradle 的 Wrapper配置** 如图所示：![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-14%2015.29.18.png)其中：前4行表示 `Wrapper` 路径，最后一行表示 `使用的相应版本的gradle的下载路径`。有了这个文件，我们就可以通过 `Wrapper` 非常方便的的使用gradle。## 2.2 Android 应用程序模块 的默认项目结构![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/project-structure_2x.png)`Android Studio` 将每个模块的**源代码**和**资源逻辑**分组到 **源集（Source Set）**中。`Android Studio` **不会自动创建它们**。而是 Gradle 在特定版本的 Android插件下构建它们。`src/main/`：该源代码集包括所有构建变体的 **通用代码和资源**。## 2.3 工程配置文件![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/Project-View-Android.png)- **(Project: HelloWorldGradle)**- **(Module: app)** 附加（include &apos;:app&apos;）到 顶层构建文件。- **gradle.properties**。 - 一个是本地项目。 - 一个只有gradle.properties在.gradle主目录的子目录中有全局文件的同名文件才存在。- **settings.gradle**由Gradle用于 **配置多项目构建**，应该由一行代码组成： include ‘:app’1234 这告诉Gradle该app子目录也是一个Gradle项目。- **gradle-wrapper.properties**，它配置了所谓的 **Gradle Wrapper**。这使您可以构建Android项目，而无需首先安装Gradle。该文件的内容应该类似于： distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip12345678910111213前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在主目录`.gradle/wrapper/dists`中的目录中。最后一行显示了`distributionUrl` Gradle将下载指定分布的位置的值。- **local.properties**配置构建系统的本地环境属性，例如SDK安装路径。由于此文件的内容是由Android Studio自动生成的，并且特定于本地开发人员环境，因此您不应该手动修改此文件或将其检入您的版本控制系统。### 2.3.1 Project 中的 build.gradle文件&gt; **DSL元素** http://google.github.io/android-gradle-dsl/current/ // Top-level build file where you can add configuration options common to all sub-projects/modules. / ** buildscript块是为Gradle本身配置存储库和依赖项的地方，也就是说，不应该在这里为模块包含依赖项。 例如，此块包含用于 Gradle 的Android插件作为依赖项，因为它提供了Gradle 生成Android应用程序模块所需的附加指令。 /buildscript { / ** repositories块配置Gradle用来 搜索或下载依赖项的存储库。 Gradle预先配置对远程存储库的支持，如JCenter，Maven Central和Ivy。你也可以使用本地存储库或定义您自己的远程存储库。 下面的代码将JCenter 、google定义为Gradle应该用来查找其依赖项的存储库。*使用Android Studio 3.0及更高版本创建的新项目还包括 Google的Maven存储库。 /repositories { google() jcenter()} / * 依赖关系块配置Gradle需要使用来构建项目的依赖项。以下行将Gradle 版本3.0.1的Android插件添加为类路径依赖项。 /dependencies {/*坐标语法：‘group：name：version’ 指定所需的插件，并告诉Gradle在哪里找到它，各个 : 间的字段说明为： 组 com.android.tools.build 名称 gradle名 版本 3.0.1。 / classpath ‘com.android.tools.build:gradle:3.0.1’ // NOTE: Do not place your application dependencies here; they belong// in the individual module build.gradle files}} / ** allprojects块是您配置 项目中所有模块使用的存储库和依赖项的位置，例如第三方插件或lib。 但是，您应该在 每个模块级别的build.gradle文件中配置模块特定的依赖项。 对于新项目， 默认情况下，Android Studio 包含JCenter和Google的Maven存储库，但不会 配置任何依赖关系。 对于包含多个模块的Android项目，在项目级别定义某些属性并在所有模块间共享它们可能会很有用。您可以通过向顶层文件中的块添加额外的属性来完成此操作。 额外属性：https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:extra_properties /allprojects { repositories {google() jcenter() }} // 特设任务task clean(type: Delete) { delete rootProject.buildDir} /** 自定义任务 注意：虽然Gradle允许您在模块级别定义项目范围的属性，但应该避免这样做，因为它会导致共享这些属性的模块被耦合。模块耦合使以后将模块作为独立项目导出变得更加困难*/ ext { compileSdkVersion = 26}12在 **build.gradle(app)** 文件中调用 **`ext`** 时： android { // Use the following syntax to access properties you defined at the project level: // rootProject.ext.property_name compileSdkVersion rootProject.ext.compileSdkVersion …}123### 2.3.2 Module 中的 build.gradle 文件 / ** 构建配置中的第一行将Gradle 的Android插件应用于此构建，并使android块可用于指定Android特定的构建选项。 /apply plugin: ‘com.android.application’ / ** android块是您配置所有Android特定构建选项的地方。 /android { compileSdkVersion 27 / ** defaultConfig块封装所有构建变体的默认设置和条目 并且可以从构建系统动态地覆盖main/AndroidManifest.xml 中的一些属性 /defaultConfig { / ** 每个Android应用程序都有一个唯一的应用程序ID，applicationId 此ID在设备和Google Play商店中唯一标识您的应用，你永远不应该改变应用程序ID。 应用程序ID 和 软件包名 彼此独立 但是，您的源代码仍应引用 main/ AndroidManifest.xml文件中的包属性定义的包名。*/applicationId “com.esint.hellogradle”//定义运行应用程序所需的最低API级别。minSdkVersion 19//指定用于测试应用程序的API级别。targetSdkVersion 27//定义您的应用程序的版本号。versionCode 1//为应用定义一个用户友好的版本名称。versionName “1.0”testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”} / ** buildTypes块是您可以配置多个构建类型的位置。 默认情况下，构建系统定义两种构建类型：调试和发布。 调试版本类型没有在默认已经明确显示，但它包含调试工具，并用调试密钥签名。 构建类型应用Proguard设置，并且默认情况下未进行签名。*/buildTypes { release { //为发布构建类型启用代码缩小。 minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } / ** productFlavors块是您可以配置多个产品风格的地方。这允许您创建不同版本的应用程序，可以用自己的设置覆盖defaultConfig块。 产品风格是可选的，构建系统默认不会创建它们。这个例子： 创建一个免费和付费的产品风格。然后指定每种产品风格自己的应用程序ID，以便它们可以同时存在于Google Play商店或Android设备上。 如果您使用Android插件3.0.0或更高版本，则还需要声明并将每种风味分配到风味维度。*/productFlavors { free { applicationId &apos;com.example.myapp.free&apos; } paid { applicationId &apos;com.example.myapp.paid&apos; }}/ ** 分割块是您可以配置不同的APK构建的地方 每个仅包含支持屏幕密度或ABI的代码和资源。您还需要配置您的版本，以便每个APK具有不同的版本代码。*/splits {//设置根据屏幕密度构建多个APK。density { //启用或禁用构建多个APK。 enable false //构建多个APK时排除这些密度。 exclude “ldpi”, “tvdpi”, “xxxhdpi”, “400dpi”, “560dpi”}}}} dependencies { implementation fileTree(dir: ‘libs’, include: [‘*.jar’]) implementation ‘com.android.support:appcompat-v7:27.1.1’ implementation ‘com.android.support.constraint:constraint-layout:1.1.0’ testImplementation ‘junit:junit:4.12’ androidTestImplementation ‘com.android.support.test:runner:1.0.2’ androidTestImplementation ‘com.android.support.test.espresso:espresso-core:3.0.2’}12**配置文件块 - dependencies** dependencies { implementation fileTree(dir: ‘libs’, include: [‘*.jar’]) implementation ‘com.android.support:appcompat-v7:27.1.1’ implementation ‘com.android.support.constraint:constraint-layout:1.1.0’ testImplementation ‘junit:junit:4.12’ androidTestImplementation ‘com.android.support.test:runner:1.0.2’ androidTestImplementation ‘com.android.support.test.espresso:espresso-core:3.0.2’}1234567891011121314151617**配置** `依赖关系`是构建Gradle应用程序的基础部分。在这种情况下，`dependencies`部分显示的值`implementation`，`testImplementation`和`androidTestImplementation`配置。- 最简单的一个，**`testImplementation`**依赖关系只包含最新的稳定JUnit 4发行版。JUnit类和测试注释将在编译时在`src/test/java`层次结构中可用。- 有三条线添加了对**`implementation`** 配置的依赖关系： - 第一，`fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])`是一个 **fileTree依赖项**，它将文件libs夹中的所有jar文件添加到编译类路径中 - 第二，`com.android.support:appcompat-v7:26.1.0`将 **Android兼容性库** 添加到项目中。这使您可以在SDK版本7以前的任何Android应用程序中使用Material设计主题和其他功能。 - 第三，`com.android.support.constraint:constraint-layout:1.0.2`将Android约束布局添加到项目中。这使您可以在SDK版本9以前的任何Android应用程序中使用ConstraintLayout布局类。- `androidTestImplementation`依赖关系是指Espresso测试库，用于Android应用程序的集成测试。## 2.4 在终端中运行 Android 的 Gradle 命令在通过 Android Studio 构建和部署应用程序时，可以通过在 `终端中` 进入项目的根目录，在该目录下，运行： ./gradlew build12这将运行许多任务，并最终返回“构建成功”。要查看生成的APK（Android包，Android应用的可部署版本），可看目录`app/build/outputs/apk`。在那里你会找到一个debug和一个release目录。该debug目录包含app-debug.apk将被部署到模拟器或连接设备的APK版本。如果您想部署发行版APK，则需要首先创建签名配置. ./gradlew：app：dependencies –configuration releaseCompileClasspath ./gradlew：app：dependencyInsight –dependency support-annotations –configuration releaseCompileClasspath123456789101112131415161718192021222324252627**注意：任何Gradle项目中都有 dependency 和 dependencyInsight 任务可用。它们可以帮助 追踪并解决与库版本冲突有关 的任何问题。**## 2.5 使用 Android Studio 中的 Gradle窗口Android Studio包含一个执行Gradle任务的特殊窗口。Android项目提供超过80种不同的任务，并且此窗口尝试将它们组织到不同的类别中。![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/Gradle-window-signingReport.png)可以通过此窗口，手动点击要执行的任务，查看在执行一种操作时，背后执行的具体tasks。## 2.6 Gradle调试### 2.6.1 日志输出（6种）-| 级别 | 描述 || :-- | :-- || ERROR | 错误消息 || QUIET | 重要消息 || WARNING | 警告消息 || LIFECYCLE | 进度消息 || INFO | 信息消息消息 || DEBUG | 调试消息 |对于以上6种命令的使用，是通过 “命令行” 的方式来开启的 输出 INFO 级别之上的日志信息gradle -i build12### 2.6.2 错误输出 -s （精简部分信息）或者 -S（信息最全）gradle -s build123456789### 2.6.3 使用信息调试- 通过 `print` 系列方法（QUIET级别）- 通过 `logger` （6种）### 2.7 gradle 命令- 多任务（task）调用 填写多个任务，各个任务之间通过 空格 进行分割./gradlew clean build12- 使用任务（task）名缩写执行调用 ./gradlew assembleD123456789101112131415161718192021222324252627282930313233343536373839# 3. Gradle 与 APK 的构建&gt; 参考：https://developer.android.com/studio/build/gradle-tips- **Gradle 运行过程** - Initializatin：初始化 - Configuration：配置 - Execution：执行- **在构建App时，Gradle配置文件的执行过程：** **`settings.gradle`** -&gt; **`(Project)build.gradle`** -&gt; **`(Module)build.gradle`** （可以使用 println()进行验证） 即： **顺序执行** — **先运行 settings配置文件，再运行 Project，再运行 Module**。 ## 3.1 applicationId### 3.1.1 applicationId 与 Java包名称 每个Android应用程序都有一个唯一的应用程序ID，看起来像一个Java包名称，**此ID在设备和Google Play商店中唯一标识您的应用**。如果想上传应用程序的**新版本**，则应用程序ID（以及您对其签名的证书）**必须**与**原始APK相同**，如果更改应用程序ID，则Google Play Store会将APK视为完全不同的应用程序应用程序。所以一旦你发布你的应用程序，你永远不应该改变应用程序ID。 当在 Android Studio中 创建新项目时，applicationId 与在安装过程中选择的 Java风格包名称完全匹配。 但是，除此之外， 应用程序ID 和 软件包名称 彼此独立。 可以更改代码的包名称（代码名称空间），它不会影响应用程序ID，反之亦然（但是，一旦发布应用程序，不应再更改您的应用程序ID）。 **命名规则：** - 它必须至少有两个部分（一个或多个点）。 - 每个部分必须以字母开头。 - 所有字符必须是字母数字或下划线[a-zA-Z0-9_]。**注意：** applicationId用于 **直接绑定到代码的包名称** ; 所以一些Android API在其方法名称和参数名称中使用术语 **包名称** ，但这实际上是 **applicationId**。 ### 3.1.2 更改 包名称 尽管默认情况下 **项目的包名称** 与 **应用程序ID** 相匹配，但可以更改它。如果要更改软件包名称，请注意**`软件包名称`（由项目目录结构定义）应始终与 `AndroidManifest.xml` 文件中的 `package` 属性匹配** &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 12345678910111213141516gradle 使用这个 **package属性** 来做两件事情：- 将此名称用作应用程序生成的 **R.java类的名称空间** 。 例子：通过上面的清单，R该类将会是 `com.example.myapp.R`。- 使用它来 **解析** 清单文件中声明的 **任何相关类名称**。 示例：通过上面的清单，声明为 `&lt;activity android:name=&quot;.MainActivity&quot;&gt;` 已解析为 的活动为 `com.example.myapp.MainActivity`。### 3.1.3 一个参考示例： 更改applicationId - “免费”和“专业版”如果想创建不同版本的应用在Google Play商店中显示为**单独列表**，例如“**免费**”和“**专业版**”，则需要创建单独的构建变体，每个变体都具有不同的应用程序标识。在这种情况下，应该将**每个构建变体**定义为**独立的产品风格**。对于 productFlavors块内的每种风格，您可以**重新定义该 applicationId 属性**，或者可以使用以下代码段将缺省应用程序ID附加到一个段中applicationIdSuffix，如下所示： android { defaultConfig { applicationId “com.example.myapp” } productFlavors { free { applicationIdSuffix “.free” } pro { applicationIdSuffix “.pro” } }}1234这样，“免费”产品风格的应用程序ID是`com.example.myapp.free`。您也可以使用`applicationIdSuffix`基于您的**构建类型**添加细分，如下所示： android { … buildTypes { debug { applicationIdSuffix “.debug” } }}1234567891011121314151617181920212223242526因为Gradle在 **产品风格** 之后应用了 **构建类型配置（debug、release）**，所以 **免费-调试版apk** 构建变体的 `applicationId` 现在是： **com.example.myapp.free.debug**。当希望将 **免费-调试版本apk** 和 **免费-发布版本apk** 构建在 **同一设备上**时，这非常有用，因为没有两个APK可以具有相同的应用程序ID。## 3.2 构建流程### 3.2.1 典型 APK 的构建流程 ![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/build-process_2x.png)**注意**- 编译器 **源代码** 转换成 **DEX（Dalvik Executable) 文件**（其中包括运行在 Android 设备上的字节码），将所有**其他内容**转换成**已编译资源**。- APK 打包器将 DEX 文件和已编译资源 **合并** 成单个 **APK**。不过，**必须先签署 APK**，才能将应用**安装并部署**到 Android 设备上。- APK 打包器使用**调试或发布密钥库签署** APK： - 如果您构建的是**调试版本的应用**（即专用于测试和分析的应用），打包器会**使用调试密钥库**签署您的应用。Android Studio 自动使用调试密钥库配置新项目。 - 如果您构建的是打算向外**发布的发布版本应用**，打包器会使用**发布密钥库签署**应用。要创建发布密钥库。- 在生成最终 APK 之前，打包器会**使用 zipalign 工具对应用进行优化，减少其在设备上运行时的内存占用**。- **task执行过程**：既可以执行 **单个task**，又可以将 **多个tasks串联执行** 参照对应：**apk的打包流程图**![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/3606778-b978b976f8d0f591.png)在对 APK 执行具体的构建时，Gradle 运行的顺序为： settings.gradle -&gt; (Project)build.gradle -&gt; (Module)build.gradle -&gt; 所需的 Tasks12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758如图，执行 **assembleDebu** task 的过程：![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-14%2011.14.24.png)### 3.2.2 常用task- **assemble**- **clean**- **build**- **check**- **install**## 3.3 配置文件中几种常见的配置- **Build Types** 构建类型定义了Gradle在**构建**和**打包应用程**序时使用的**特定属性**，并且通常针对开发生命周期的**不同阶段**进行配置。例如， - 调试构建类型启用调试选项并使用调试密钥对APK进行签名， - 发布构建类型可能会缩小、混淆并用发布密钥对APK进行签名进行分发。 必须至少定义一种构建类型，才能构建应用程序。Android Studio默认创建 **调试** 和 **发布** 构建类型。- **Product Flavors** `产品风格` 代表您可能发布给用户的不同版本的应用，例如免费和付费版本的应用。您可以自定义产品风格以使用不同的代码和资源，同时共享和重复使用适用于所有版本应用程序的通用部件。产品风格是可选的，须手动创建它们- **Manifest Entries**您可以在构建变体配置中为清单文件的某些属性指定值。这些构建值会 **覆盖清单文件中的现有值**。如果您希望为您的模块生成多个APK，其中每个apk文件都具有不同的应用程序名称，最低SDK版本或目标SDK版本- **Dependencies**构建系统从 **本地文件系统** 和 **远程存储库管理项目** 依赖关系。这样可以防止您必须手动搜索，下载和复制依赖关系的二进制包到项目目录中- **Signing**构建系统使您能够在构建配置中指定签名设置，并且可以在构建过程中自动签署APK。- **ProGuard**构建系统使您能够为每个构建变体指定不同的ProGuard规则文件。构建系统可以在构建过程中运行ProGuard来混淆你的类。## 3.4 依赖项：dependencies问题&gt; https://developer.android.com/studio/build/dependencies&gt; DSL参考：http://google.github.io/android-gradle-dsl/current/### 3.4.1 依赖的3种类型- **本地库模块依赖关系** compile project(“:mylibrary”)12- **本地依赖** compile fileTree(dir: ‘libs’, include: [‘*.jar’])12- **远程依赖** compile ‘com.example.android:app-magic:12.3’12345678910111213141516171819202122### 3.4.2 库依赖配置在dependencies块内部，可以使用几种不同的依赖配置之一来声明库依赖关系（如上compile所示）。每个依赖配置都提供了有关**如何使用该库的Gradle不同指导**。- **compile**Gradle将该依赖项**添加**到**编译类路径**和**APK中**。- **apk**Gradle只将相关性添加到APK（它不会被添加到编译类路径中）。- **provided**Gradle**仅将编译类路径**添加到编译类路径中（**它不会添加到APK中**）。这在创建Android库模块时非常有用， 并且在编译期间需要依赖关系，但在运行时存在此选项是可选的。也就是说，如果你使用这个配置，那么你的库模块必须包含一个运行时条件来检查依赖关系是否可用，然后适当地改变它的行为，以便它在没有提供时仍然可以运行。这有助于减少最终APK的大小，因为不会添加不重要的临时依赖项。**注意：**以上配置适用于项目的**主源集**，该集**适用于所有构建变体**。如果您不想为特定的构建变体源集或 测试源集声明一个依赖项 ，则必须**大写配置名称**，并在其前面加上构建变体或测试源集的名称。1) 要**将compile依赖项仅添加到“免费”产品特征**（使用远程二进制依赖项），它看起来像这样： dependencies { freeCompile ‘com.google.firebase:firebase-ads:9.8.0’}122) 如果要**为组合产品风格**和**构建类型的变体**添加依赖项，则必须在**configurations块**中初始化配置名称。以下示例将apk依赖项添加到“freeDebug”构建变体（使用本地二进制依赖项）： configurations { // Initializes a placeholder for the freeDebugApk dependency configuration. freeDebugApk {}} dependencies { freeDebugApk fileTree(dir: ‘libs’, include: [‘*.jar’])}123) 要compile为您的**本地测试**和**仪器测试**添加依赖项，它看起来像这样： dependencies { // Adds a remote binary dependency only for local tests. testCompile ‘junit:junit:4.12’ // Adds a remote binary dependency only for the instrumented test APK. androidTestCompile &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos; }124) 如果你的**lib模块**提供了多种变体，你可以为不同的应用变体添加不同的lib变体，如下所示 dependencies { // Adds the ‘debug’ variant of the library to the debug variant of the app debugCompile project(path: ‘:my-library-module’, configuration: ‘debug’) // Adds the ‘release’ variant of the library to the release variant of the app releaseCompile project(path: ‘:my-library-module’, configuration: ‘release’)}123456### 3.4.3 远程存储库当依赖项**不是本地库**或**文件树**时，Gradle会在文件`repositories块`中指定的任何联机存储库中查找这些 build.gradle文件。默认情况下，新的`Android Studio`项目将`JCenter`声明为项目顶层build.gradle文件中的存储库位置，如下所示： allprojects { repositories { jcenter() }}12如果想从Maven中央存储库中获取某些内容，请添加 mavenCentral()或为本地存储库使用mavenLocal()： allprojects { repositories { jcenter() mavenCentral() mavenLocal() }}12或者，可以按如下方式声明特定的Maven或Ivy存储库： allprojects { repositories { maven { url “https://repo.example.com/maven2“ } maven { url “file://local/repo/“ } ivy { url “https://repo.example.com/ivy“ } }}12345678910111213141516### 3.4.4 Google的Maven存储库Google的Maven存储库提供了以下Android库的最新版本- Android Support Library- Architecture Components Library- Constraint Layout Library- Android Test- Databinding Library- Android Instant App Library- Wear OS- Google Play services- Firebase要将这些库中的一个添加到您的版本中，请在您的顶级build.gradle文件中包含Google的Maven存储库 allprojects { repositories { google() // If you&apos;re using a version of Gradle lower than 4.1, you must instead use: // maven { // url &apos;https://maven.google.com&apos; // } // An alternative URL is &apos;https://dl.google.com/dl/android/maven2/&apos; } }12然后将所需的库添加到您的模块的`dependencies块`。例如， `appcompat库` 看起来像这样： dependencies { compile ‘com.android.support:appcompat-v7:27.1.1’}1234567891011121314151617181920212223### 3.4.5 依赖顺序第一个库的优先级高于第二个，第二个的优先级高于第三个，依此类推。在`资源合并`或 `清单元素`从库中合并到您的应用中时，此顺序非常重要 。例如，如果您的项目声明以下内容: Dependency on LIB_A and LIB_B (依次) And LIB_A depends on LIB_C and LIB_D (依次) And LIB_B also depends on LIB_C然后，平面相关性顺序如下： LIB_A LIB_D LIB_B LIB_C ### 3.4.6 收缩代码要使用`ProGuard`缩小代码，`minifyEnabled true`请注意缩短代码会减慢构建时间，所以如果可能的话，应该避免在调试版本上使用它。 android { buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’ } } …}``` 注意：使用Instant Run时，Android Studio会禁用ProGuard。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-算法复杂度]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[参考：https://blog.csdn.net/zolalad/article/details/11848739 对于给定的算法，通常做2项分析： 数学证明正确性 分析算法复杂度 度量一个程序的执行时间通常有2种方法： 事后统计分析：不建议。一是必须要先运行；二是计算机本身硬件环境易掩盖算法本身缺陷。 事前估算分析：建议。依据统计方法对算法进行估算。 一个用高级语言编写的程序在计算机上运行的时间取决于：（1）算法采用的策略、方法（2）编译产生的代码质量（3）问题的输入规模（4）机器执行指令的速度 一个算法是由控制结构（顺序、分支、循环3种）和原操作（固有数据类型的操作）构成的，算法的时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常的做法是：从算法中选取一种对于所研究的问题（活算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间度量。 1.时间复杂度（1）时间频度 一个算法执行所耗费的时间。从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 （2）时间复杂度 在时间频度中，n为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n))为算法的渐进时间复杂度，简称时间复杂度。 另外，上面公式中用到的 Landau符号其实是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。 T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 $ T (n) ≤ C*f(n) $ 。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T (n)的上界是C f(n)。其虽然对 $f(n)$没有规定，但是一般都是取尽可能简单的函数。例如，$ O(2n^2+n +1) = O (3n^2+n+3) = O (7n^2 + n) = O ( n2 ) $，一般都只用 $O(n^2) $表示就可以了。注意到*大O符号里隐藏着一个常数C，所以 $ f(n)$ 里一般不加系数。如果把 $T(n)$当做一棵树，那么 $ O(f(n)) $ 所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。 在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如 $ T(n)=n^2+3n+4 $ 与 $ T(n)=4n^2+2n+1 $ 它们的频度不同，但时间复杂度相同，都为 $ O(n^2) $。 （3）按数量级递增排列，常见的时间复杂度有： 常数阶：$O(1)$ 。表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。 对数阶：$O(log_2 n)$。 多项式时间 线性阶：$O(n)$。 多项式时间 线性对数阶：$O(nlog_2 n)$。 多项式时间 平方阶：$O(n^2)$。 多项式时间 立方阶：$O(n^3)$。 多项式时间 … k次方阶：$O(n^k)$。 多项式时间 指数阶：$O(2^n)$。指数时间 $ Ο(n!) $。 指数时间 随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 注意： 多项式时间复杂度的算法是有效算法，把这类问题称为P（Polynomial,多项式）类问题； 指数时间复杂度的算法称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。 从图中可见，我们应该尽可能选用多项式阶O(nk)的算法，而不希望用指数阶的算法。 常见的算法时间复杂度由小到大依次为： $$ Ο(1)＜Ο(log_2 n)＜Ο(n)＜Ο(nlog_2 n)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)$$ （4）求解算法的时间复杂度的具体步骤是： 找出算法中的基本语句： 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 计算基本语句的执行次数的数量级： 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 用大 $Ο$ 记号表示算法的时间性能： 将基本语句执行次数的数量级放入大 $Ο$ 记号中。如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加 示例： 12345678// 第1个for (i = 1; i &lt;= n; i++) x++; // 第2个for ( i=1 ; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) x++; 时间复杂度解： 第1个：$ O(n) $ 第2个：$ O(n^2) $ （5）计算算法时间复杂度的几个简单的分析法则: 对于一些简单的输入输出语句或赋值语句,近似认为需要$O(1)$时间 对于顺序结构，需要依次执行一系列语句所用的时间可采用 $大O$ 下”求和法则“ 求和法则： 同n时，是指若算法的2个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$ ,则 $T1(n)+T2(n)=O(max(f(n), g(n)))$。 不同n时，特别地，若 $T1(m)=O(f(m)), T2(n)=O(g(n))$，则 $T1(m)+T2(n)=O(f(m) + g(n))$ 对于选择结构，如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要 $O(1)$ 时间。 对于循环结构，循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用 $大O$ 下”乘法法则“ 乘法法则: 是指若算法的2个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$，则 $ T1T2=O(f(n)g(n)) $ 对于复杂的算法,可以将它拆分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度 另外还有以下2个运算法则:(1) 若 $g(n)=O(f(n))$ ，则 $O(f(n))+ O(g(n))= O(f(n))$；(2) $O(Cf(n)) = O(f(n))$，其中C是一个正常数 2.空间复杂度]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TensorFlow]]></title>
    <url>%2F%E5%85%B3%E4%BA%8ETensorFlow%2F</url>
    <content type="text"><![CDATA[TensorFlow入门，2018年五一节。 时代发展的综合产物：大数据 + 云计算 = 人工智能 Android ？ TensorFlow ？ Google？ TensorFlow 是一个用于人工智能的开源神器 作为一个Android开发者，其实在人工智能火爆的开始也想着自己怎么能加入到开发的大军中。可是自己却迟迟没有下手，这其中是有很多原因的：如何入手？从哪个方面？哪个领域？哪个方向？以及入手后如何开始，如何使这项学习长期继续下去？有哪些已有成果能作为参考？ 当然最重要的一点：如何与自己目前所做的Android开发联系起来，因为一旦建立联系后，在自己熟悉的领域作为起步，可能得到的成就感和实际效果会好的多。 在去年就看到了关于TensorFlow的消息，当时就对其有了印象。以至于每每想到“人工智能”、“深度学习”这个词汇总是想到他。 更重要的一点：Android与TensorFlow都是Google的产品，同出一门。 一、 前言1. 深度学习深度学习是什么？它能够为我们做什么？如何把这个技术应用到实际场景当中去？ 深度学习并不是一个突然出现的技术领域，它的核心算法就是神经网络。神经网络是一种机器学习的模型，这个模型主要特点就是，它可以拟合任何数学上的函数，特别是利用大数据反复迭代的一种类似方法来训练好这个模型。 这个以神经网络模型为核心的深度学习技术，在很多应用领域都可以大大提高过去软件系统需要完成的任务。最经典的应用领域大家肯定很熟悉，就是图像识别。自2012年以来，在这个领域，自动图像识别的错误率从20%一直持续下降到4%左右，已经超过了一个普通人分辨图像的能力。 2. TensorFlow Google在2015年10月开源了TensorFlow。 2.1 关于TensorFlowTensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。 2.2 什么是数据流图（Data Flow Graph）? 数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。 1(Tensor)张量：size可动态调整的多维数据数组 TensorFlow可被用于语音识别或图像识别等多项机器学习和深度学习领域，对2011年开发的深度学习基础架构DistBelief进行了各方面的改进，它可在小到一部智能手机、大到数千台数据中心服务器的各种设备上运行。 2.3 TensorFlow的特征 高度的灵活性 TensorFlow 不是一个严格的“神经网络”库。只要你可以将你的计算表示为一个数据流图，你就可以使用Tensorflow。你来构建图，描写驱动计算的内部循环。我们提供了有用的工具来帮助你组装“子图”（常用于神经网络），当然用户也可以自己在Tensorflow基础上写自己的“上层库”。定义顺手好用的新复合操作和写一个python函数一样容易，而且也不用担心性能损耗。当然万一你发现找不到想要的底层数据操作，你也可以自己写一点c++代码来丰富底层的操作。 真正的可移植性（Portability） Tensorflow 在CPU和GPU上运行，比如说可以运行在台式机、服务器、手机移动设备等等。想要在没有特殊硬件的前提下，在你的笔记本上跑一下机器学习的新想法？Tensorflow可以办到这点。准备将你的训练模型在多个CPU上规模化运算，又不想修改代码？Tensorflow可以办到这点。想要将你的训练好的模型作为产品的一部分用到手机app里？Tensorflow可以办到这点。你改变主意了，想要将你的模型作为云端服务运行在自己的服务器上，或者运行在Docker容器里？Tensorfow也能办到。 将科研和产品联系在一起 过去如果要将科研中的机器学习想法用到产品中，需要大量的代码重写工作。那样的日子一去不复返了！在Google，科学家用Tensorflow尝试新的算法，产品团队则用Tensorflow来训练和使用计算模型，并直接提供给在线用户。使用Tensorflow可以让应用型研究者将想法迅速运用到产品中，也可以让学术性研究者更直接地彼此分享代码，从而提高科研产出率。 自动求微分 基于梯度的机器学习算法会受益于Tensorflow自动求微分的能力。作为Tensorflow用户，你只需要定义预测模型的结构，将这个结构和目标函数（objective function）结合在一起，并添加数据，Tensorflow将自动为你计算相关的微分导数。计算某个变量相对于其他变量的导数仅仅是通过扩展你的图来完成的，所以你能一直清楚看到究竟在发生什么。 多语言支持 Tensorflow 有一个合理的c++使用界面，也有一个易用的python使用界面来构建和执行你的graphs。你可以直接写python/c++程序，也可以用交互式的ipython界面来用Tensorflow尝试些想法，它可以帮你将笔记、代码、可视化等有条理地归置好。当然这仅仅是个起点——我们希望能鼓励你创造自己最喜欢的语言界面，比如Go，Java，Lua，Javascript，或者是R。 性能最优化 比如说你又一个32个CPU内核、4个GPU显卡的工作站，想要将你工作站的计算潜能全发挥出来？由于Tensorflow 给予了线程、队列、异步操作等以最佳的支持，Tensorflow 让你可以将你手边硬件的计算潜能全部发挥出来。你可以自由地将Tensorflow图中的计算元素分配到不同设备上，Tensorflow可以帮你管理好这些不同副本。 2.4 持多种硬件的平台TensorFlow现在已经演化成一个相当完整的深度学习软件开放平台。它支持CPU、GPU混合搭建的数据中心的训练平台，它也支持将数据中心训练好的模型，相对便捷地部署到不同的移动端应用上，可以支持类似Google自主研发的TPU处理器。 2.5 支持多种开发环境支持多种硬件的平台是基础，TensorFlow一直以来的一个目标，就是能够帮助尽量多的开发者，能够把深度学习的技术利用起来，最终使得广大的用户从中能力得到益处，基于这个想法，TensorFlow一直很重视多种程序员开发环境的支持。比如说，开发者可以在主要的开发环境中使用TensorFlow。 TensorFlow在Google内部的应用推广是非常全面和彻底的，比如说TensorFlow很早就帮助Google的核心业务（搜索和广告），实施了深度学习的模型，并且在核心业务上体现了他们的性能。 在垃圾邮件过滤中，我们也使用了TensorFlow训练的模型，同时在安卓的应用程序推荐上，也上线了TensorFlow的模型等等。很多TensorFlow应用都是发生后台，大多数用户可能没有直接的体验。 2.6 深入移动端 安卓手机自拍功能 安卓手机最近的版本当中增加了一个自拍功能，这个自拍功能就是通过应用深度学习训练出来的视觉模型，可以非常准确地分离前景像素和后景像素，对前景像素和后景像素分别处理，这样就可以实现背景虚化。实现这种功能，传统上手机厂商需要增加第二个摄像头，这就会增加手机的成本，同时现有的手机就不太容易获得这样的效果，通过新的算法，我们可以实现一些过去可能非常昂贵才能实现的效果。 智能音箱 和图像处理一样，语音处理是另一个被深度学习深刻改变的领域，语音识别要比图像处理更早地采用神经网络。产品方面，这些年智能音箱语音主力大行其道，其中一个很大的原因就是深度学习算法把语音识别和语音生成的技术门槛大大地降低了，过去可能需要20—50个博士的团队才能完成的任务，现在下载一个现有模型定制一下，就可以达到同样的效果。通用的机器学习框架，可以帮助到更多的开发人员，开发出适合特定应用场景的语音应用。 机器翻译 现在你可以用手机拍一张照片，手机软件可以自动的识别出图形中的文字，把文字翻译成另外一种语言，看似简单的应用，其实是图像技术和机器翻译技术很自然的结合。 邮件自动回复功能 比如说你今天早上收到一份你朋友发的邮件，“晚上是不是要到哪里吃饭”，大多数情况只有三种可能的回答：我会准时到；对不起我没有空不能来；我有空，但是我可能需要晚一点到。 我们现在邮箱会自动地给你提供三个选择，这样的话在路上看到邮箱，只要一键就可以完成邮件回复，极大方便了用户在手机上处理邮件的效率。 2.7 其他领域 AlphaGo 过去两年努力推进AlphaGo的工作，这就得益于TensorFlow框架本身的帮助，因为TensorFlow可以利用超大计算机集群，支持最新的加速器，AlphaGo团队可以更加专注于算法的研究。 智能医疗 由于TensorFlow是一个通用的框架，他们可以很方便地重用现在已有的图像识别模型或者是自然语言处理的模型，针对特定的应用领域和数据，重新训练微调一下模型，就可以在检测视网膜病变任务上面获得超过95%的准确率，这个准确率已经超过了普通眼科专家91%的水平。 自动驾驶 在自动驾驶方面，也在利用TensorFlow不断改进自动驾驶系统当中的深度模型，包括对路况场景的分割、雷达信号的处理等等。 婴儿食品制作 过去两年我们看到很多和互联网毫无相关的行业，也开始尝试利用深度学习的技术和方法，比如说这家公司是一个婴儿食品制作的公司，引进了TensorFlow训练好的智能系统，这个智能系统可以把婴儿食品的原料进行分类，把一些烂掉的苹果和香蕉更准确地排除出去，这样可以准确地控制婴儿食品的质量。 科学研究——太空 TensorFlow在计算机科学以外的科学研究上也得到了使用，比如说上个月美国航天总署宣布一项研究成果，美国航天总署有个开普勒计划，他们的科学家和我们的同事联合开发了一个TensorFlow的模型。 科学研究——海洋 人们不仅仰望星空，同时我们在回望我们的地球，在这个应用的例子里面，澳大利亚的科学家用TensorFlow开发的图像识别模型，在数万张海洋航拍图照片中，快速并且准确地找到需要保护的大型海洋哺乳类动物，比如说珍惜动物海牛。 3. TensorFlow在中国 TensorFlow的中文网站：http://www.tensorfly.cn/ 公司： 京东内部搭建了TensorFlow训练平台，用于开发图像、自然语言相关的模型，并且把他们用到客服广告等领域。 小米也在尝试类似的技术路线，支持他们生态线上各种特殊的应用。 网易的有道笔记、网易翻译君也使用了TensorFlow视觉和语言的模型。 Eager模式 一个TensorFlow模式，这个模式能够更加有利于前端的开发，便于调试，支持更多动态的编程模式。 Lite模式 TensorFlow Lite模式，这个模式是专门针对移动和嵌入式应用场景打造的机器学习平台，它的目标是希望把在云端训练的机器学习模型，更加简单、高效的迁移到移动端上进行部署。 第二代TPU 二、 配置1. python版本在 终端 环境中，直接输入 python3 即可将python的解释环境切换至python3。 2. 安装 TensorFlow CPU版，环境 macOS、Python3使用virtualenv安装 2.1 安装pip,若已经安装 pip ,忽略此步骤； 1sudo easy_install pip 检查 pip 更新 1pip install --upgrade pip 2.2 安装 virtualenv， 1sudo pip install --upgrade virtualenv 或者，指定python3编译环境。关于 Python 3 virtualenv问题可参考：https://stackoverflow.com/questions/28923926/python-3-virtualenv-problems 1pip3 install virtualenv 2.3 创建虚拟环境，此处为python3环境，TensorFlowDir 为 自己定义的目录文件名 1virtualenv --system-site-packages -p python3 TensorFlowDir # for Python 3.n 2.4 激活虚拟环境，如果你的终端运行的是bash, sh, ksh, or zsh，注意，此处TensorFlowDir为上一条命令中的自定义目录文件名 1source ~/TensorFlowDir/bin/activate 如果是：csh or tcsh，执行 1source ~/TensorFlowDir/bin/activate.csh 2.5 安装 TensorFlow 及其所有依赖 1pip3 install --upgrade tensorflow 2.6 激活虚拟环境，其中TensorFlowDir 表示创建环境时自定义的 目录文件名 注意：每打开一个新的 shell 使用 TensorFlow 都必须激活虚拟环境。如果当前虚拟环境没有被激活（也就是提示符不是 TensorFlowDir），执行以下任一命令 12$ source ~/TensorFlowDir/bin/activate # bash, sh, ksh, or zsh$ source ~/TensorFlowDir/bin/activate.csh # csh or tcsh 提示符变成下面这样说明 TensorFlow 环境已经激活： 1(TensorFlowDirDir) YannisCheng:~ yannischeng$ 2.7 退出虚拟环境 1(TensorFlowDirDir) YannisCheng:~ yannischeng$ deactivate 2.8 卸载TensorFlow 环境 1rm -r ~/tensorflow 2.9 删除 virtualenv环境 1rm -r virtualenv venv 3. 配置TensorFlow与PyCharm3.1 选择路径查看安装了tensorflow的python3.6在本地的位置，如果知道知道安装位置，可忽略 进入 python3 -&gt; tensorflow 环境后， 1tf.__path__ 输出位置：[‘/Users/yannischeng/TensorFlowDir/lib/python3.6/site-packages/tensorflow’] 直接通过 preference 进行选择： 3.2 在 pycharm 中创建新项目，选择刚刚配置的路径 4. 异常 1. tensorflow/core/platform/cpu_feature_guard.cc:140] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA 您的CPU支持未编译使用此TensorFlow二进制文件的说明：AVX2 FMA 参考：https://blog.csdn.net/PJ7410/article/details/78886048， https://github.com/lakshayg/tensorflow-buildhttps://stackoverflow.com/questions/47068709/your-cpu-supports-instructions-that-this-tensorflow-binary-was-not-compiled-to-u?answertab=votes#tab-top 三、 相关工具1. NumPy官网：http://www.numpy.org/# NumPy是用Python进行科学计算的基础软件包。它包含以下内容： 一个强大的N维数组对象 复杂的（广播）功能 用于集成C / C ++和Fortran代码的工具 有用的线性代数，傅里叶变换和随机数能力 除了明显的科学用途外，NumPy还可以用作通用数据的高效多维容器。可以定义任意数据类型。这使得NumPy能够与各种数据库无缝并快速地整合。 四、 TensorFlow 的使用1. 综述TensorFlow是一个编程系统，使用 图来表示计算任务。图中的结点被称为op（操作的缩写）。一个op获得0个或多个Tensor（张量），执行计算，产生0个或多个Tensor。每个张量是一个类型化的多维数组。 一个TensorFlow图描述了计算的过程。为了进行计算，图必须在会话（Session）里被启动。 会话将图的op分发到诸如CPU或GPU之类的设备上，同时提供执行op的方法。这些方法执行后，将产生的张量返回。在Python语言中，返回的张量是 numpy ndarray对象; 在C和C ++语言中，返回的张量是 tensorflow::Tensor实例。 2. TensorFlow 名词 使用图（graph）来表示计算任务。 在被称之为会话 (Session)的上下文（context）中执行图。 使用张量（Tensor）表示数据。 通过变量 (Variable)维护状态。 使用feed和fetch可以为任意的操作赋值或从其中获取数据。 3. 计算图TensorFlow程序通常有2个阶段： 构建阶段。在构建阶段，op的执行步骤被描述为一个图，通常在构建阶段创建一个图来表示和训练神经网络。 执行阶段。在执行阶段，使用会话执行图中的操作，在执行阶段反复执行图中的训练op。 TensorFlow支持C，C ++，Python编程语言。目前，TensorFlow的Python库更加易于使用，它提供了大量的辅助函数来简化构建图的工作，这些函数尚未被C和C ++库支持。 4. 构建图图文档：http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph 构建图的第一步，是创建源op（source op）。源op不需要任何输入，例如常量 (Constant)。源op的输出被传递给其它op做运算。 Python库中，op构造器的返回值代表被构造出的op的输出，这些返回值可以传递给其它op构造器作为输入。 TensorFlow Python库有一个默认图，op构造器可以为其增加节点。这个默认图对许多程序来说已经足够用了。阅读图类文档来了解如何管理多个图。 5. 在一个会话中启动图]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本变更]]></title>
    <url>%2FAndroid%20%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%2F</url>
    <content type="text"><![CDATA[Android各个版本的变更 ww Android 6.0（API 23）1. 运行时权限 参考：https://developer.android.com/guide/topics/permissions/overview 检查应用是否被授予权限：checkSelfPermission()；请求权限：requestPermissions() 2. 低电耗模式和应用待机模式 参考：https://developer.android.com/training/monitoring-device-state/doze-standby 2.1 低电耗模式如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。 2.2 应用待机模式应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。 优化 - 加入白名单 应用可以触发ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS Intent，让用户直接进入 Battery Optimization，他们可以在其中添加应用。 具有 REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 权限的应用可以触发系统对话框，让用户无需转到“设置”即可直接将应用添加到白名单。应用将通过触发ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Intent 来触发该对话框。 3. 取消支持 Apache HTTP 客户端Android 取消了 HttpClient 的使用，仅能使用 HttpURLConnection 4. 硬件标识访问权为给用户提供更严格的数据保护，从此版本开始，对于使用 WLAN API 和 Bluetooth API 的应用，Android 移除了对设备本地硬件标识符的编程访问权。WifiInfo.getMacAddress() 方法和 BluetoothAdapter.getAddress() 方法现在会返回常量值 02:00:00:00:00:00。 要通过 Bluetooth 和 WLAN 扫描访问附近外部设备的硬件标识符，您的应用必须拥有 ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION 权限。 5. 通知改用 Notification.Builder 类来构建通知。要重复更新通知，请重复使用 Notification.Builder 实例。调用 build() 方法可获取更新后的 Notification 实例。 6. 音频管理器变更不再支持通过 AudioManager 类直接设置音量或将特定音频流静音。setStreamSolo() 方法已弃用，您应该改为调用 requestAudioFocus() 方法。类似地，setStreamMute() 方法也已弃用，请改为调用 adjustStreamVolume() 方法并传入方向值 ADJUST_MUTE 或 ADJUST_UNMUTE。 7. WLAN和网络连接变更现在，您的应用只能更改由您创建的 WifiConfiguration 对象的状态。系统不允许您修改或删除由用户或其他应用创建的 WifiConfiguration 对象。在之前的版本中，如果应用利用带有 disableAllOthers=true 设置的 enableNetwork() 强制设备连接特定 WLAN 网络，设备将会断开与移动数据网络等其他网络的连接。在此版本中，设备不再断开与上述其他网络的连接。如果您的应用的 targetSdkVersion 为 “20” 或更低，则会固定连接所选 WLAN 网络。如果您的应用的 targetSdkVersion 为 “21” 或更高，请使用多网络 API（如 openConnection()、bindSocket() 和新增的 bindProcessToNetwork() 方法）来确保通过所选网络传送网络流量。 8. 相机服务变更访问模式由 先到先得 -&gt; 高优先级进程优先。 带有对用户可见 Activity 或前台 Activity 的应用进程一般会被授予较高的优先级，从而使相机资源的获取和使用更加可靠； 当高优先级的应用尝试使用相机时，系统可能会“驱逐”正在使用相机客户端的 低优先级 应用 多进程用例中 禁止同时访问。即使并没有其他应用直接尝试访问同一相机设备，此变更也可能导致低优先级客户端被“驱逐”。 更改当前用户会导致之前用户帐户拥有的应用内活动相机客户端被驱逐 9. APK验证该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。 Android 7.0（API 24）1. 低电耗模式 Android 6.0（API 级别 23）引入了低电耗模式，当用户设备未插接电源、处于静止状态且屏幕关闭时，该模式会推迟 CPU 和网络活动，从而延长电池寿命。 Android 7.0 则通过在设备未插接电源且屏幕关闭状态下、但 不一定要处于静止状态（例如用户外出时把手持式设备装在口袋里）时应用部分 CPU 和网络限制，进一步增强了低电耗模式。 分级应用 当设备处于 充电状态 且 屏幕已关闭一定时间后，设备会进入低电耗模式并应用 第一部分 限制：关闭应用网络访问、推迟作业和同步 进入低电耗模式 后设备 处于静止状态达到一定时间，系统则会对 PowerManager.WakeLock、AlarmManager闹铃 、GPS 和 WLAN 扫描应用余下的低电耗模式限制。 无论是应用部分还是全部低电耗模式限制，系统都会唤醒设备以提供简短的维护时间窗口，在此窗口期间，应用程序可以访问网络并执行任何被推迟的作业/同步。 1.2 后台优化移除了三项隐式广播，因为隐式广播会在后台频繁启动已注册侦听这些广播的应用。 不会收到 CONNECTIVITY_ACTION 广播，即使它们已有清单条目来请求接受这些事件的通知。在前台运行的应用如果使用 BroadcastReceiver 请求接收通知，则仍可以在主线程中侦听 CONNECTIVITY_CHANGE。 无法发送或接收 ACTION_NEW_PICTURE 或 ACTION_NEW_VIDEO 广播。 2. 权限更改应用私有目录被限制访问 私有文件的文件权限不应再由所有者放宽，为使用 MODE_WORLD_READABLE 和/或 MODE_WORLD_WRITEABLE 而进行的此类尝试将触发 SecurityException。 传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:// URI 会触发 FileUriExposedException。分享私有文件内容的推荐方法是使用 FileProvider。 DownloadManager 不再按文件名分享私人存储的文件。对于由 DownloadManager 公开的文件，首选的访问方式是使用ContentResolver.openFileDescriptor()。 3. 在应用间共享文件要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。 Android 7.1（API 25）多窗口支持App Shortcuts通过使用新的快捷方式功能，可以将用户从启动器直接发送到应用中的关键操作界面中。用户只需长按应用程序的启动器图标，即可显示应用程序的快捷方式，然后点击快捷方式跳转到相关操作。 每个快捷方式都引用一个intent，每个intent都会启动一个特定的操作或任务。 您可以通过将应用程序添加到APK中的资源文件来静态创建应用程序的快捷方式，也可以在运行时动态添加它们。静态快捷方式是常见操作的理想选择，动态快捷方式允许您根据用户的首选项，行为，位置等突出显示操作。可以在每个应用中提供最多五个快捷方式。 图形、图标资源应用程序现在可以定义圆形启动器图标，这些图标在支持它们的设备上使用。当启动器请求应用程序图标时，框架将返回 android:icon 或android:roundIcon，具体取决于设备构建配置。 改进的VR线程调度Android 7.1提供了改进VR线程调度的新功能。虚拟现实应用对延迟非常敏感。 应用程序现在可以将一个线程指定为VR线程。当应用程序处于 VR模式时，系统将更积极地调度该线程以最小化延迟。一个进程一次只能有一个VR线程，系统可能会对该线程的运行时间进行限制。当应用程序未处于VR模式时，该设置无效。 Android 8.0 （API 26）针对所有API 应用后台执行限制 参考：https://developer.android.com/about/versions/oreo/background 为提高电池续航时间而引入的变更之一是：当您的应用进入已缓存状态时，如果没有活动的组件，系统将解除应用具有的所有唤醒锁。 为提高设备性能，系统会限制未在前台运行的应用的某些行为。具体而言： 现在，在后台运行的应用对后台服务的访问受到限制。 应用无法使用其清单注册大部分隐式广播（即，并非专门针对此应用的广播）。 Android 8.0 还对特定函数做出了以下变更： 如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 startService() 函数，则该函数将引发一个 IllegalStateException。 新的 Context.startForegroundService() 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 Context.startForegroundService()。不过，应用必须在创建服务后的五秒内调用该服务的 startForeground() 函数。 Android 后台位置限制 参考：https://developer.android.com/about/versions/oreo/background-location-limits 为节约电池电量、保持良好的用户体验和确保系统健康运行，在运行 Android 8.0 的设备上使用后台应用时，降低了后台应用接收位置更新的频率。 此类变更会影响以下 API： Fused Location Provider (FLP) Geofencing Location Manager Wi-Fi Manager 为确保您的应用按预期方式运行，请完成以下步骤： 查看您的应用的逻辑，并确保您使用的是最新的位置 API。 测试您的应用是否在每个用例中都表现出预期行为。 考虑使用 Fused Location Provider (FLP) 或地理围栏来处理依赖于用户当前位置的用例。 应用快捷键 参考：https://developer.android.com/about/versions/oreo/android-8.0-changes Android 8.0 对应用快捷方式做出了以下变更： com.android.launcher.action.INSTALL_SHORTCUT 广播不再会对您的应用有任何影响，因为它现在是私有的隐式广播。相反，您应使用 ShortcutManager 类中的 requestPinShortcut() 函数创建应用快捷方式。 现在，ACTION_CREATE_SHORTCUT Intent 可以创建可使用 ShortcutManager 类进行管理的应用快捷方式。此 Intent 还可以创建不与 ShortcutManager 交互的旧版启动器快捷方式。在以前，此 Intent 只能创建旧版启动器快捷方式。 现在，使用 requestPinShortcut() 创建的快捷方式和在处理 ACTION_CREATE_SHORTCUT Intent 的操作组件中创建的快捷方式均已转换为功能齐全的应用快捷方式。因此，应用现在可以使用 ShortcutManager 中的函数来更新这些快捷方式。 旧版快捷方式仍然保留了它们在旧版 Android 中的功能，但您必须在应用中手动将它们转换成应用快捷方式。 提醒窗口如果应用使用 SYSTEM_ALERT_WINDOW 权限并且尝试使用以下窗口类型之一来在其他应用和系统窗口上方显示提醒窗口： TYPE_PHONE TYPE_PRIORITY_PHONE TYPE_SYSTEM_ALERT TYPE_SYSTEM_OVERLAY TYPE_SYSTEM_ERROR 那么，这些窗口将始终显示在使用 TYPE_APPLICATION_OVERLAY 窗口类型的窗口下方。如果应用针对的是 Android 8.0，则应用会使用 TYPE_APPLICATION_OVERLAY 窗口类型来显示提醒窗口。 网页表单自动填充针对8.0应用权限在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。 对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。 例如，假设某个应用在其清单中列出 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE。应用请求 READ_EXTERNAL_STORAGE，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予 WRITE_EXTERNAL_STORAGE，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 READ_EXTERNAL_STORAGE；不过，如果该应用后来又请求 WRITE_EXTERNAL_STORAGE，则系统会立即授予该权限，而不会提示用户。 Android 8.1 （API 27）Android P （API 28）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>版本变更</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于NFC（Near Field Communication）近场通讯]]></title>
    <url>%2FAndroid%20NFC%EF%BC%88Near%20Field%20Communication%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目前NFC已经出现了一些应用，例如电子标签识别、刷手机、点对点付款、身份识别、信息记录等 NFC（Near Field Communication，近场通信）是一种数据传输技术。与Wi-Fi、蓝牙、红外线等数据传输技术的一个主要差异就是有效距离一般不能超过4厘米。 使用到的类 NfcManager : 用于获取此设备NfcAdapter。可以使用获取实例: getSystemService(Class) NfcAdapter : 代表本地NFC适配器。 它是您进行NFC操作的入口点。您可以通过getDefaultAdapter()或 获取实例getDefaultAdapter(android.content.Context)。 NdefMessage : 代表不可变的NDEF消息。这是在设备和标签之间传输携带数据的“记录”的标准格式。您的应用程序可以从ACTION_TAG_DISCOVERED意图中接收这些消息。 NdefRecord : 代表不可变的NDEF记录。 它在a中提供，NdefMessage并描述正在共享的数据类型并携带数据本身。 NfcEvent : 包装与任何NFC事件相关的信息。 Tag : 代表已发现的NFC标签。 使用到的接口 NfcAdapter.CreateBeamUrisCallback ： NfcAdapter.CreateNdefMessageCallback ：当另一个能够进行NDEF推送的NFC设备（Android Beam）处于范围内时，要调用的回调。 NfcAdapter.OnNdefPushCompleteCallback ： 系统成功将您的NdefMessage 设备交付给其他设备时要调用的回调。 NfcAdapter.OnTagRemovedListener ： 将标记从字段中删除时调用的回调。 NfcAdapter.ReaderCallback ：当前台活动在阅读器模式下运行时系统找到标签时要调用的回调。 释义NFC是一组短距离无线技术，通常需要4cm（近场）距离或更短距离才能启动连接。NFC可让您在NFC标签和Android设备之间或两台Android设备之间共享小型有效载荷数据。 标签的范围可能很复杂： 简单的标签：只提供读写语义，有时还有一次性可编程区域，使卡片成为只读。 更复杂的标签：提供数学运算，并具有加密硬件来验证对扇区的访问。 最复杂的标签：包含操作环境，允许与标签上执行的代码进行复杂的交互。 存储在标签中的数据也可以用各种格式编写，但许多Android框架API基于称为NDEF（NFC数据交换格式）的NFC论坛标准。 采用NFC的Android设备同时支持三种主要的操作模式： 读写器模式：允许NFC设备读取和/或写入无源NFC标签和贴纸。 P2P模式：允许NFC设备与其他NFC对等设备交换数据; 此操作模式由Android Beam使用。 卡模拟模式：允许NFC设备本身充当NFC卡。然后可以通过外部NFC阅读器访问仿真的NFC卡，例如NFC销售点终端。 NFC 基础知识在使用NDEF数据和Android时有两种主要用例： 从NFC标签读取NDEF数据 从NFC标签读取NDEF数据由标签调度系统处理,此系统分析发现的NFC标签，对数据进行适当分类，并启动对分类数据感兴趣的应用程序。想要处理扫描的NFC标签的应用程序可以声明意图过滤器并请求处理数据。 使用Android Beam将NDEF消息从一台设备传送到另一台设备 Android Beam功能允许设备将NDEF消息推送到另一台设备上，方法是将这些设备一起物理地轻击。这种交互提供了一种比其他无线技术（如蓝牙）更容易发送数据的方式，因为使用NFC时，不需要手动设备发现或配对。当两个设备进入范围时，连接自动启动。Android Beam通过一组NFC API可用，因此任何应用程序都可以在设备之间传输信息。例如，联系人，浏览器和YouTube应用程序使用Android Beam与其他设备共享联系人，网页和视频。 标签调度系统除非在设备的“设置”菜单中禁用NFC，否则Android设备通常会在屏幕解锁时查找NFC标签。当Android设备发现NFC标签时，理想的行为是让最合适的活动处理意图，而不要询问用户使用什么应用程序。由于设备在非常短的范围内扫描NFC标签，因此使用户手动选择活动可能会迫使他们将设备从标签移开并中断连接。所以应该开展活动以仅处理您的活动关心的NFC标签，以防止活动选择器出现。 为了帮助实现这一目标，Android提供了一个特殊的标签调度系统，用于分析扫描的NFC标签，对其进行分析并尝试定位对扫描数据感兴趣的应用程序。它是这样做的： 解析NFC标签并找出标识标签中数据有效载荷的MIME类型或URI。 将MIME类型或URI和有效负载封装到意图中。 根据意图启动一项活动。 NFC标签如何映射到MIME类型和URI在开始编写NFC应用程序之前，了解 NFC标签的不同类型、标签调度系统解析NFC标签的方式以及标签调度系统在检测到NDEF消息时执行的特殊工作非常重要。 NDEF数据封装在NdefMessage包含一个或多个记录（NdefRecord）的消息中。每个NDEF记录必须按照您要创建的记录类型的规范进行格式良好。 NDEF数据的操作 当Android设备驱动的设备扫描包含NDEF格式数据的NFC标签时，它会解析该消息并尝试找出数据的MIME类型或标识URI。 为此，系统读取第一个NdefRecord内容NdefMessage以确定如何解释整个NDEF消息（NDEF消息可以具有多个NDEF记录）。在格式良好的NDEF消息中，第一个NdefRecord 包含以下字段： 3位TNF（类型名称格式） 指示如何解释可变长度类型字段。 可变长度类型 描述记录的类型。如果使用TNF_WELL_KNOWN，使用此字段指定记录类型定义（RTD）。 可变长度ID 记录的唯一标识符。此字段不常使用，但如果您需要唯一标识标签，则可以为其创建标识。 可变长度有效载荷 您想要读取或写入的实际数据有效载荷。NDEF消息可以包含多个NDEF记录，因此不要假定完整的有效负载位于NDEF消息的第一个NDEF记录中。 标签调度系统使用TNF和类型字段尝试将MIME类型或URI映射到NDEF消息。如果成功，它会将该信息ACTION_NDEF_DISCOVERED与实际有效负载一起封装在意图中。但是，有些情况下，标签调度系统无法根据第一个NDEF记录确定数据的类型。当NDEF数据无法映射到MIME类型或URI，或者NFC标签不包含NDEF数据时，会发生这种情况。在这种情况下，Tag具有关于标签的技术和有效载荷的信息的对象被封装在ACTION_TECH_DISCOVERED意图的内部。 表1描述了标签调度系统如何将TNF和类型字段映射到MIME类型或URI。它还描述了哪些TNF不能映射到MIME类型或URI。在这些情况下，标签调度系统会回退到 ACTION_TECH_DISCOVERED。 例如，如果标签调度系统遇到类型记录TNF_ABSOLUTE_URI，它会将该记录的可变长度类型字段映射到URI中。标签调度系统将该URI ACTION_NDEF_DISCOVERED与其他关于标签的信息（例如有效载荷）一起封装在意图的数据字段中。另一方面，如果它遇到类型记录TNF_UNKNOWN，它会创建一个封装标签技术的意图。 NFC标签如何分配给应用程序当标签调度系统完成创建封装NFC标签及其标识信息的意图时，它将意向发送给感兴趣的应用程序，以针对意图进行过滤。如果多个应用程序可以处理该意图，则显示活动选择器，以便用户可以选择该活动。标签调度系统定义了三个意图，按照从高到低的顺序列出： ACTION_NDEF_DISCOVERED： 当包含NDEF有效载荷的标签被扫描并且是识别类型时，该意图用于启动Activity。这是最高优先级的意图，并且标签调度系统尽可能在任何其他意图之前尝试用此意图启动一个活动。 ACTION_TECH_DISCOVERED： 如果没有活动注册来处理ACTION_NDEF_DISCOVERED 意图，则标签调度系统会尝试以此意图启动应用程序。ACTION_NDEF_DISCOVERED如果扫描的标签包含无法映射到MIME类型或URI的NDEF数据，或者该标签不包含NDEF数据，但是具有已知的标记技术，则此直接启动（无需先启动）。 ACTION_TAG_DISCOVERED： 如果没有任何活动处理ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED 意图，则此意图开始。 标签调度系统的基本工作方式如下 尝试使用解析NFC标签（ACTION_NDEF_DISCOVERED或者ACTION_TECH_DISCOVERED）时由标签调度系统创建的意图启动一个活动 。 如果没有任何活动过滤该意图，请尝试启动具有下一个最低优先级意图的活动（ACTION_TECH_DISCOVERED或者ACTION_TAG_DISCOVERED），直到应用程序过滤该意图或直到标签调度系统尝试所有可能的意图。 如果没有应用程序筛选任何意图，则不执行任何操作。 只要有可能，就使用NDEF消息和ACTION_NDEF_DISCOVERED意图，因为它是三者中最具体的。这种意图使您能够在比其他两种意图更合适的时间启动您的应用程序，从而为用户提供更好的体验。 具体使用1. 在Android清单中请求NFC访问在访问设备的NFC硬件并正确处理NFC意图之前，请在AndroidManifest.xml文件中声明这些项目： 用于访问NFC硬件的NFC 元件： 1&lt;uses-permission android:name=&quot;android.permission.NFC&quot; /&gt; 您的应用程序可以支持的最低SDK版本。API级别9仅支持有限的标签分发ACTION_TAG_DISCOVERED，并且只能通过EXTRA_NDEF_MESSAGES额外的方式访问NDEF消息。没有其他标签属性或I / O操作可以访问。API级别10包括全面的读写器支持以及前台NDEF推送，而API level 14提供了一种使用Android Beam和其他便捷方法将NDEF消息推送到其他设备以创建NDEF记录的更简单的方法。 1&lt;uses-sdk android:minSdkVersion=&quot;10&quot;/&gt; 该uses-feature元素使您的应用程序仅在具有NFC硬件的设备上显示在Google Play中： 1&lt;uses-feature android:name=&quot;android.hardware.nfc&quot; android:required=&quot;true&quot; /&gt; 如果应用程序使用NFC功能，但这些功能是不是你的应用是至关重要的，你可以省略uses-feature元素和检查，看看是否在运行时检查NFC avalailbility getDefaultAdapter() 是null。 2. 过滤NFC intent要扫描想要处理的NFC标签时启动应用程序，您的应用程序可以筛选Android清单中的一个、两个或全部三个NFC意图 但是，通常需要筛选ACTION_NDEF_DISCOVERED意图，以便在您的应用程序启动时进行最大限度的控制。ACTION_TECH_DISCOVERED目的是回退ACTION_NDEF_DISCOVERED时没有应用程序过滤器ACTION_NDEF_DISCOVERED或当负载不NDEF。过滤ACTION_TAG_DISCOVERED通常过于笼统。 许多应用程序会为之前ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED之前进行过滤ACTION_TAG_DISCOVERED，因此您的应用程序的启动概率较低。 ACTION_TAG_DISCOVERED仅适用于在没有安装其他应用程序来处理ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED意图的情况下过滤应用程序的最后手段 。 由于NFC标签的部署有所不同并且多次不受控制，因此这并非总是可行，因此您可以在必要时回退到其他两个意图。当可以控制写入的标签和数据类型时，建议使用NDEF格式化标签。以下各节介绍如何针对每种意图类型进行过滤。 ACTION_NDEF_DISCOVERED 要过滤ACTION_NDEF_DISCOVERED意图，请声明意图过滤器以及要过滤的数据类型。以下示例筛选ACTION_NDEF_DISCOVERED MIME类型为以下内容的意图text/plain： 12345&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:mimeType=&quot;text/plain&quot; /&gt;&lt;/intent-filter&gt; 以下示例以URI形式过滤 http://developer.android.com/index.html。 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;developer.android.com&quot; android:pathPrefix=&quot;/index.html&quot; /&gt;&lt;/intent-filter&gt; ACTION_TECH_DISCOVERED 如果您的action按照ACTION_TECH_DISCOVERED意图进行过滤，则必须创建一个XML资源文件，以指定您的活动在一个tech-list集合内支持的技术。如果某个tech-list集合是标记所支持的技术的子集，则您的活动被视为匹配，您可以通过调用获取该技术getTechList()。 例如，如果扫描的标签支持MifareClassic，NdefFormatable和NfcA，则您的 tech-list设置必须指定全部三种，两种或一种技术（而不是其他任何技术），以便使您的活动得到匹配。 以下示例定义了所有技术。你可以删除那些你不需要的。保存这个文件（你可以将它命名为任何你想要的）在 /res/xml文件夹中。 12345678910111213&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcV&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NdefFormatable&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.MifareClassic&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.MifareUltralight&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt; 您也可以指定多个tech-list集合。每个tech-list 集合都是独立考虑的，如果任何一个tech-list集合是返回的技术的子集，那么您的活动就被认为是匹配 的getTechList()。这提供了AND与OR 匹配技术，语义。以下示例匹配可以支持NfcA和Ndef技术或可以支持NfcB和Ndef技术的标签： 12345678910111213&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt;&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt; 在你的AndroidManifest.xml文件中， 像下面的例子那样，在元素内部的元素中指定刚创建的资源文件： 12345678910&lt;activity&gt; ... &lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot; android:resource=&quot;@xml/nfc_tech_filter&quot; /&gt; ...&lt;/activity&gt; ACTION_TAG_DISCOVERED 要过滤ACTION_TAG_DISCOVERED使用以下意图过滤器： 123&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.TAG_DISCOVERED&quot;/&gt;&lt;/intent-filter&gt; 3. 从intent获取信息如果某个action是由于NFC的intent而启动的，则您可以从intent获取有关扫描的NFC标签的信息。intent可以包含以下附加内容，具体取决于扫描的标签： EXTRA_TAG（必需）：Tag代表扫描标签的对象。 EXTRA_NDEF_MESSAGES（可选）：从标签解析的NDEF消息数组。这个额外的ACTION_NDEF_DISCOVERED意图是强制性的 。 EXTRA_ID （可选）：标签的低级ID。 要获取这些附加内容，请检查您的活动是否以NFC意图之一启动，以确保扫描标签，然后从意图中获取附加信息。以下示例检查ACTION_NDEF_DISCOVERED 意图并从意图附加中获取NDEF消息。 1234567891011121314151617@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); ... if (intent != null &amp;&amp; NfcAdapter.ACTION_NDEF_DISCOVERED.equals(intent.getAction())) &#123; Parcelable[] rawMessages = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES); if (rawMessages != null) &#123; NdefMessage[] messages = new NdefMessage[rawMessages.length]; for (int i = 0; i &lt; rawMessages.length; i++) &#123; messages[i] = (NdefMessage) rawMessages[i]; &#125; // Process the messages array. ... &#125; &#125;&#125; 或者，您可以Tag从intent获取对象，该对象将包含有效内容并允许枚举标记的技术： 1Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG); 4. 创建常见的NDEF记录类型以下将会介绍创建常见类型的NDEF记录以在使用Android Beam编写NFC标签或发送数据时使用。从Android 4.0（API级别14）开始，该 createUri()方法可以帮助您自动创建URI记录。在开始的Android 4.1（API级别16）， createExternal() 并且createMime()可以帮助您创建MIME和外部类型NDEF记录。尽可能使用这些帮助器方法，以避免在手动创建NDEF记录时出错。 以下还将会介绍如何为记录创建相应的intent过滤器。所有这些NDEF记录示例应该放在NDEF消息的第一个NDEF记录中，您正在写入标签或发送。 TNF_ABSOLUTE_URI 建议使用 RTD_URI类型而不是TNF_ABSOLUTE_URI，因为它更高效。您可以TNF_ABSOLUTE_URI通过以下方式创建NDEF记录： 1234NdefRecord uriRecord = new NdefRecord( NdefRecord.TNF_ABSOLUTE_URI , &quot;http://developer.android.com/index.html&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;)), new byte[0], new byte[0]); 以前的NDEF记录的intent filter 如下所示： 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;developer.android.com&quot; android:pathPrefix=&quot;/index.html&quot; /&gt;&lt;/intent-filter&gt; TNF_MIME_MEDIA 您可以TNF_MIME_MEDIA通过以下方式创建NDEF记录：使用createMime()方法： 12NdefRecord mimeRecord = NdefRecord.createMime(&quot;application/vnd.com.example.android.beam&quot;, &quot;Beam me up, Android&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;))); NdefRecord手动创建： 1234NdefRecord mimeRecord = new NdefRecord( NdefRecord.TNF_MIME_MEDIA , &quot;application/vnd.com.example.android.beam&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;)), new byte[0], &quot;Beam me up, Android!&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;))); 以前的NDEF记录的意图过滤器如下所示 12345&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.com.example.android.beam&quot; /&gt;&lt;/intent-filter&gt; TNF_WELL_KNOWN与RTD_TEXT 1234567891011121314public NdefRecord createTextRecord(String payload, Locale locale, boolean encodeInUtf8) &#123; byte[] langBytes = locale.getLanguage().getBytes(Charset.forName(&quot;US-ASCII&quot;)); Charset utfEncoding = encodeInUtf8 ? Charset.forName(&quot;UTF-8&quot;) : Charset.forName(&quot;UTF-16&quot;); byte[] textBytes = payload.getBytes(utfEncoding); int utfBit = encodeInUtf8 ? 0 : (1 &lt;&lt; 7); char status = (char) (utfBit + langBytes.length); byte[] data = new byte[1 + langBytes.length + textBytes.length]; data[0] = (byte) status; System.arraycopy(langBytes, 0, data, 1, langBytes.length); System.arraycopy(textBytes, 0, data, 1 + langBytes.length, textBytes.length); NdefRecord record = new NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_TEXT, new byte[0], data); return record;&#125; 以前的创建方式 12345&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;text/plain&quot; /&gt;&lt;/intent-filter&gt; TNF_WELL_KNOWN与RTD_URI 使用 createUri(String) 创建 1NdefRecord rtdUriRecord1 = NdefRecord.createUri(&quot;http://example.com&quot;); 使用 createUri(Uri) 创建 12Uri uri = new Uri(&quot;http://example.com&quot;);NdefRecord rtdUriRecord2 = NdefRecord.createUri(uri); NdefRecord手动创建： 123456byte[] uriField = &quot;example.com&quot;.getBytes(Charset.forName(&quot;US-ASCII&quot;));byte[] payload = new byte[uriField.length + 1]; //add 1 for the URI Prefixbyte payload[0] = 0x01; //prefixes http://www. to the URISystem.arraycopy(uriField, 0, payload, 1, uriField.length); //appends URI to payloadNdefRecord rtdUriRecord = new NdefRecord( NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_URI, new byte[0], payload); 以前的创建方式 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;example.com&quot; android:pathPrefix=&quot;&quot; /&gt;&lt;/intent-filter&gt; TNF_EXTERNAL_TYPE 使用 createExternal() 方法 1234byte[] payload; //assign to your dataString domain = &quot;com.example&quot;; //usually your app&apos;s package nameString type = &quot;externalType&quot;;NdefRecord extRecord = NdefRecord.createExternal(domain, type, payload); NdefRecord手动创建： 1234byte[] payload;...NdefRecord extRecord = new NdefRecord( NdefRecord.TNF_EXTERNAL_TYPE, &quot;com.example:externalType&quot;, new byte[0], payload); 以前的创建方式 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;vnd.android.nfc&quot; android:host=&quot;ext&quot; android:pathPrefix=&quot;/com.example:externalType&quot;/&gt;&lt;/intent-filter&gt; 5. Android应用程序记录 Android Application Record (AAR)在Android 4.0（API级别14）中引入Android应用程序记录（AAR）可以更强有力地确定您的应用程序在扫描NFC标签时启动。 AAR具有嵌入NDEF记录内的应用程序的包名称。 您可以将AAR添加到NDEF消息的任何NDEF记录中，因为Android会在整个NDEF消息中搜索AAR。 如果它发现AAR，它将根据AAR中的包名称启动应用程序。 如果设备上没有应用程序，则会启动Google Play以下载应用程序。 如果想要阻止其他应用程序针对相同的意图进行过滤并可能处理您已部署的特定标记，则AAR很有用。AAR仅在应用程序级别受支持，因为包名称约束，而不是在意图过滤的活动级别。 如果标签包含AAR，则标签分派系统按以下方式分派：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>NFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager与Fragment]]></title>
    <url>%2FAndroid%20ViewPager%E4%B8%8EFragment%2F</url>
    <content type="text"><![CDATA[在ViewPager与Fragment的搭配使用中，生命周期函数的调用顺序 注意：此处的log输出是 RadioGroup + ViewPager + Fragment 实现的 在此种情况的搭配下: 在宿主Activity中不会调用Fragment的 ‘onDestroy()’ 与 ‘onDetach()’ 方法 ViewPager与Fragment搭配说明：主MainActivity中有1个ViewPager与4个Fragment，其中第2个Fragment中嵌套1个ViewPager与2个Fragment. Activity调用顺序Activity的生命周期有7个函数 启动时，生命周期函数的调用顺序：12303-22 13:35:18.621 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 13:35:18.782 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 13:35:18.787 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onResume : 在长期黑屏后，调用： 1203-22 13:36:18.400 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 13:36:18.458 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onStop : 再次被唤醒 后，调用： 12303-22 13:42:43.822 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onRestart : 03-22 13:42:43.834 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 13:42:43.884 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onResume : 由当前ActivityA跳转至另一个ActivityB后，原ActivityA调用顺序为： 12345ActivityB调用onCreate、onStart、onResume后，再调用：03-22 13:44:20.090 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 13:44:20.888 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onStop :03-22 13:50:01.678 LoginActivity: ヽ(｀Д´)ﾉ -&gt; onDestroy : Fragment调用顺序参考：https://www.cnblogs.com/fajieyefu/p/6092465.html Fragment的生命周期有11个函数 Fragment声明周期函数： Fragment声明周期函数调用： 进入宿主Activity中时： 123456789101112131415161718192021222303-22 14:36:54.109 MainActivity: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:36:54.147 MainActivity: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:36:54.151 MainActivity: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:36:54.178 AA: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:36:54.178 AA: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:36:54.178 AA: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:36:54.230 AA: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:36:54.233 AA: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:36:54.233 AA: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:36:54.256 BB: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:36:54.256 BB: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:36:54.178 BB: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:36:54.256 CC: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:36:54.256 CC: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:36:54.178 CC: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:36:54.276 BB: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:36:54.279 BB: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:36:54.279 BB: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:36:54.294 CC: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:36:54.297 CC: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:36:54.297 CC: ヽ(｀Д´)ﾉ -&gt; onResume : 在长期黑屏后，调用： 1234567803-22 14:37:20.726 AA: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:37:20.726 BB: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:37:20.726 CC: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:37:20.726 MainActivity: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:37:20.786 AA: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:37:20.786 BB: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:37:20.787 CC: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:37:20.787 MainActivity: ヽ(｀Д´)ﾉ -&gt; onStop : 再次被唤醒 后，调用： 12345678903-22 14:37:39.228 MainActivity: ヽ(｀Д´)ﾉ -&gt; onRestart : 03-22 14:37:39.240 AA: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:37:39.240 BB: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:37:39.240 CC: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:37:39.241 MainActivity: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:37:39.244 MainActivity: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:37:39.245 AA: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:37:39.245 BB: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:37:39.245 CC: ヽ(｀Д´)ﾉ -&gt; onResume : 当点击第2个Fragment时，第4个Fragment的调用： 12345603-22 14:38:46.521 DD: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:38:46.521 DD: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:38:46.521 DD: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:38:46.556 DD: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:38:46.558 DD: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:38:46.559 DD: ヽ(｀Д´)ﾉ -&gt; onResume : 直接点击第4个Fragment时，第1、5个Fragment的调用： 12345678910111213141503-22 14:41:31.900 DD: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:41:31.900 DD: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:41:31.900 DD: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:41:31.900 EE: ヽ(｀Д´)ﾉ -&gt; onAttach : 03-22 14:41:31.900 EE: ヽ(｀Д´)ﾉ -&gt; onCreate : 03-22 14:41:31.900 EE: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:41:31.930 DD: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:41:31.933 DD: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:41:31.933 DD: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:41:31.976 EE: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:41:31.979 EE: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:41:31.979 EE: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:41:32.322 AA: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:41:32.322 AA: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:41:32.323 AA: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 点击第5个Fragment时，第1、2、3个Fragment的调用： 12345678903-22 14:41:32.322 AA: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:41:32.322 AA: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:41:32.323 AA: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 03-22 14:42:59.494 BB: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:42:59.494 CC: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:42:59.494 BB: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:42:59.494 CC: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:42:59.495 BB: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 03-22 14:42:59.497 CC: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 再次点击第1个Fragment时，第4、5个Fragment的调用： 1234567891003-22 14:44:16.794 AA: ヽ(｀Д´)ﾉ -&gt; onCreateView : 03-22 14:44:16.794 AA: ヽ(｀Д´)ﾉ -&gt; onActivityCreated : 03-22 14:44:16.797 EE: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:44:16.798 EE: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:44:16.798 EE: ヽ(｀Д´)ﾉ -&gt; onDestroyView : 03-22 14:44:16.799 AA: ヽ(｀Д´)ﾉ -&gt; onStart : 03-22 14:44:16.799 AA: ヽ(｀Д´)ﾉ -&gt; onResume : 03-22 14:44:36.074 DD: ヽ(｀Д´)ﾉ -&gt; onPause : 03-22 14:44:36.074 DD: ヽ(｀Д´)ﾉ -&gt; onStop : 03-22 14:44:36.075 DD: ヽ(｀Д´)ﾉ -&gt; onDestroyView :]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView]]></title>
    <url>%2FAndroid%20RecycleView%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[RecyclerView RecyclerView 是一个用于大量数据展示的新控件，它的使用非常的灵活多变。RecyclerView 的使用有6部分组成： Adapter：为每一项item创建视图 ViewHolder：承载item的子布局 LayoutManager：负责item布局的显示管理 ItemDecoration：负责item的布局修饰 ItemAnimator：负责item布局的动画 Recycler：负责 RecyclerView 中子View 的回收与复用 组成AdapterRecyclerView 与 ListView Adapter 的不同之处在于： ListView适配器：直接返回的是一个 View，将这个 View加入到ListView内部。 RecyclerView适配器：直接返回的是一个 ViewHolder，而且不是将这个 ViewHolder 直接添加到视图内部，而是添加到 缓存区域 中。在视图需要的时候去缓存区中先寻找到holder，然后间接的找到holder所对应的View。 方法： 12345public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType)&#123;&#125;public void onBindViewHolder(MyViewHolder holder, int position)&#123;&#125;public int getItemCount()&#123;&#125; ViewHolder我们实际使用 RecyclerView 的时候，必须要创建一个 RecyclerView.ViewHolder 的子类。因为 RecyclerView 并不是像 ListView 那样缓存一个View，而是缓存一个 ViewHolder，在 ViewHolder 内部持有一个 View。 LayoutManagerLayoutManager 是布局的管理器。实际上，RecyclerView 就是将 onMeasure()、onLayout() 交给了 LayoutManager 去处理，因此如果给 RecyclerView 设置不同的 LayoutManager 就可以达到不同的显示效果。 RecyclerView#onMeasure() 最终都会调用：mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);，这里的 mLayout 就是 LayoutManager，最终还是调用了RecyclerView自己的方法对布局进行了测量。 RecyclerView#onLayout()中会调用：mLayout.onLayoutChildren(mRecycler, mState);，这个方法在LayoutManager中是空实现。 系统提供了3个实现类： LinearLayoutManager：现行管理器，支持横向、纵向。 GridLayoutManager：网格布局管理器 StaggeredGridLayoutManager：瀑布就式布局管理器 ItemDecoration是为了显示每个item之间 分隔样式 的。它的本质实际上就是一个Drawable。 当 RecyclerView 执行到 onDraw() 方法的时候，就会调用到他的 onDraw()，这时，如果你重写了这个方法，就相当于是直接在 RecyclerView 上画了一个 Drawable表现的东西。 getItemOffsets() 方法，用来 偏移 每个item视图的。当在每个item视图之间强行插入Drawable，那么如果再照着原本的逻辑去绘 item视图，就会覆盖掉Decoration了，所以需要getItemOffsets()这个方法，让每个item往后面偏移一点，不要覆盖到之前画上的分隔样式了。 源码： 1234567891011121314151617181920public static abstract class ItemDecoration &#123;public void onDraw(Canvas c, RecyclerView parent, State state) &#123; onDraw(c, parent); &#125;public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123; onDrawOver(c, parent); &#125;public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(), parent);&#125;@Deprecatedpublic void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; outRect.set(0, 0, 0, 0); &#125; ItemAnimator每一个item在特定情况下都会执行的动画。说是特定情况，其实就是手动调用notifyxxxx()的时候，视图发生改变。更新数据集不是用 adapter.notifyDataSetChanged() 而是 notifyItemInserted(position) 与 notifyItemRemoved(position) 否则没有动画效果。 Recycler12345678910111213141516public final class Recycler &#123; final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; private RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; ……&#125; RecyclerView的4级缓存策略： 屏幕内 屏幕外 缓存池 自定义缓存 屏幕内缓存：指的是在 屏幕内显示 的ViewHolder，会缓存在 mAttachedScrap、mChangedScrap 中。 mAttachedScrap：未与RecyclerView分离的ViewHolder列表 mChangedScrap：数据已经改变的ViewHolder列表 屏幕外缓存：当 列表滑动出屏幕 时，ViewHolder会被缓存在 mCachedViews 中。 其大小由 mViewCacheMax 决定，默认DEFAULT_CACHE_SIZE = 2，可通过 Recyclerview.setItemViewCacheSize() 动态设置。 缓存池：ViewHolder 首先 会缓存在 mCachedViews 中，当 超过了2个（默认为2），就会添加到 mRecyclerPool 中。 mRecyclerPool 会根据 ViewType 把 ViewHolder 分别存储在 不同的集合中，每个集合最多缓存5个ViewHolder。 自定义缓存：可以自己实现ViewCacheExtension类实现自定义缓存，可通过Recyclerview.setViewCacheExtension()设置。通常我们也不会去设置他，系统已经预先提供了两级缓存了，除非有特殊需求，比如：调用系统的缓存池之前，返回一个特定的视图，才会用到他。 RecyclerView的最多的缓存数 N = 屏幕内缓存数 + 屏幕外缓存2个 + 5*M（M代表M个ViewType，缓存池的缓存） 实际使用item 滑动删除、更改位置：SimpleItemTouchHelperCallback类的使用12345678private ItemTouchHelper.Callback mCallback = null;...mCallback = new SimpleItemTouchHelperCallback(mAdapter);ItemTouchHelper touchHelper = new ItemTouchHelper(mCallback);touchHelper.attachToRecyclerView(mRecyclerView); 注意： 12345678910111213141516@Override public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) &#123; . . . // 此处的操作是根据 具体的item view布局具体执行的。 if ((int) dX &gt; oldDX) &#123; ((TextView) mViewGroup.getChildAt(1).findViewById(R.id.notice_view)).setText("松手取消删除"); &#125; else &#123; ((TextView) mViewGroup.getChildAt(1).findViewById(R.id.notice_view)).setText("继续左划删除"); &#125; . . . &#125; 数据加载滑动处理xml局部布局文件注意：在布局文件中，SwipeToLoadLayout 、RefreshHeadView、RecyclerView 、 LoadMoreFooterView 控件的 id值均是固定的，不可修改的。 123456789101112131415161718192021222324252627282930313233343536373839&lt;com.zhy.autolayout.AutoRelativeLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/tv_nodate" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:text="暂无数据" android:textColor="@color/Deep_Orange_700" android:textSize="@dimen/text56" android:visibility="gone"/&gt; &lt;com.aspsine.swipetoloadlayout.SwipeToLoadLayout android:id="@+id/swipeToLoadLayout" style="@style/SwipeToLoadLayout"&gt; &lt;smallb.com.smallenterpriseserver.view.recycler_view_load_refresh.RefreshHeadView android:id="@+id/swipe_refresh_header" android:layout_width="match_parent" android:layout_height="300px" android:gravity="center" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/swipe_target" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/Grey_100"/&gt; &lt;smallb.com.smallenterpriseserver.view.recycler_view_load_refresh.LoadMoreFooterView android:id="@+id/swipe_load_more_footer" android:layout_width="match_parent" android:layout_height="300px" android:gravity="center"/&gt; &lt;/com.aspsine.swipetoloadlayout.SwipeToLoadLayout&gt;&lt;/com.zhy.autolayout.AutoRelativeLayout&gt; xml布局中使用到的style样式文件1234567891011121314151617181920&lt;!-- RecyclerView上拉、下拉样式--&gt;&lt;style name="SwipeToLoadLayout"&gt; &lt;!--是否可以上拉、下拉刷新--&gt; &lt;item name="refresh_enabled"&gt;true&lt;/item&gt; &lt;item name="load_more_enabled"&gt;true&lt;/item&gt; &lt;!-- 宽高--&gt; &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt; &lt;item name="android:layout_height"&gt;match_parent&lt;/item&gt; &lt;!-- 上拉、下拉持续时间--&gt; &lt;item name="load_more_complete_delay_duration"&gt;50&lt;/item&gt; &lt;item name="refresh_complete_delay_duration"&gt;50&lt;/item&gt; &lt;!--上拉、下拉最大可拖动量--&gt; &lt;item name="load_more_final_drag_offset"&gt;200px&lt;/item&gt; &lt;item name="refresh_final_drag_offset"&gt;200px&lt;/item&gt; &lt;!-- 释放上拉、下拉持续的时间--&gt; &lt;item name="release_to_loading_more_scrolling_duration"&gt;1000&lt;/item&gt; &lt;item name="release_to_refreshing_scrolling_duration"&gt;1000&lt;/item&gt; &lt;!-- 设置下拉刷新与上拉加载的样式，其值为classic，above，blew或scale--&gt; &lt;item name="swipe_style"&gt;blew&lt;/item&gt;&lt;/style&gt; java代码中使用 加载控件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119@Overridepublic void connectOK() &#123; mData.setVisibility(View.VISIBLE); mNullData.setVisibility(View.GONE); initMyView(); initMyData(); initSwipeLayout(); click();&#125;private void click() &#123; searchBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mSwipeToLoadLayout.isLoadingMore()) &#123; mSwipeToLoadLayout.setLoadMoreEnabled(false); &#125; mListBeans.clear(); list_num = 1; initMyData(); mSwipeToLoadLayout.setLoadMoreEnabled(true); mSwipeToLoadLayout.setRefreshing(false); &#125; &#125;); &#125;// 初始化 刷新、加载控件private void initSwipeLayout() &#123; mSwipeToLoadLayout.setRefreshHeaderView(mSwipeRefreshHeader); mSwipeToLoadLayout.setLoadMoreFooterView(mSwipeLoadMoreFooter); mSwipeToLoadLayout.setLoadMoreEnabled(true); mSwipeToLoadLayout.setRefreshEnabled(true); //刷新 mSwipeToLoadLayout.setOnRefreshListener(new OnRefreshListener() &#123; @Override public void onRefresh() &#123; if (mSwipeToLoadLayout.isLoadingMore()) &#123; mSwipeToLoadLayout.setLoadMoreEnabled(false); &#125; mListBeans.clear(); list_num = 1; initMyData(); mSwipeToLoadLayout.setLoadMoreEnabled(true); mSwipeToLoadLayout.setRefreshing(false); &#125; &#125;); //加载更多 mSwipeToLoadLayout.setOnLoadMoreListener(new OnLoadMoreListener() &#123; @Override public void onLoadMore() &#123; if (mSwipeToLoadLayout.isRefreshing()) &#123; mSwipeToLoadLayout.setRefreshEnabled(false); &#125; list_num = list_num + 1; initMyData(); mSwipeToLoadLayout.setRefreshEnabled(true); mSwipeToLoadLayout.setLoadingMore(false); &#125; &#125;);&#125;// 在 网络请求获取数据的过程中使用private void initMyData() &#123; HttpParams params = new HttpParams(); params.put(&quot;idcode&quot;, choseidcode); params.put(&quot;page&quot;, list_num); OkGo.post(MEASURE_HISTORY_PRESSURE).params(params).execute(new StringDialogCallback(mContext) &#123; @Override public void onSuccess(String s, Call call, Response response) &#123; Log.e(&quot;aaaaaa&quot;, s); History_Pressure history_pressure = JSON.parseObject(s, History_Pressure.class); if (history_pressure.getCode() == 100) &#123; if (history_pressure.getData().getList().get(0) != null) &#123; nodataTv.setVisibility(View.GONE); mSwipeToLoadLayout.setVisibility(View.VISIBLE); if (history_pressure.getData().getList().size() &lt; 10) &#123; mSwipeToLoadLayout.setLoadMoreEnabled(false); showToast(HistoryPressureActivity.this, &quot;没有更多数据&quot;); &#125; if (history_pressure.getData().getList().size() &gt; 0) &#123; for (History_Pressure.DataBean.ListBean listBean : history_pressure.getData().getList()) &#123; mListBeans.add(listBean); mAdapter.notifyDataSetChanged(); &#125; &#125; else &#123; showToast(HistoryPressureActivity.this, &quot;没有更多数据&quot;); mSwipeToLoadLayout.setLoadMoreEnabled(false); &#125; &#125; else &#123; if (list_num == 1) &#123; nodataTv.setVisibility(View.VISIBLE); mSwipeToLoadLayout.setVisibility(View.GONE); &#125; // showToast(HistoryPressureActivity.this, &quot;暂无数据&quot;); mSwipeToLoadLayout.setLoadMoreEnabled(false); &#125; &#125; else &#123; showToast(mContext, &quot;加载数据失败&quot;); &#125; &#125; &#125;);&#125;// 初始化界面中的各个控件private void initMyView() &#123; mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mRecyclerView.setItemAnimator(new DefaultItemAnimator()); mAdapter = new HealthAdapter(HistoryPressureActivity.this, mListBeans); mRecyclerView.setAdapter(mAdapter); lists = new ArrayList&lt;&gt;(); mFamilyBeans = new ArrayList&lt;&gt;();&#125; 适配器库万能适配器：点击事件处理 compile ‘com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.15’数据加载、刷新 ：自己的工具类item条目的处理（滑动、位置移动）：自己的工具类 使用参考：https://www.jianshu.com/p/1e20f301272e，https://blog.csdn.net/lmj623565791/article/details/45059587官方参考：http://www.recyclerview.org/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架-MVP初探]]></title>
    <url>%2FAndroid%20%E6%A1%86%E6%9E%B6-MVP%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[关于Android 的 MVP 框架 csdn 参考：https://www.jianshu.com/p/2ecfc1f4561d简书 参考：http://blog.csdn.net/hanchendong/article/details/61919599简书 对象销毁 参考：https://www.jianshu.com/p/1f91cfd68d48简书 命名规范（个人）：https://www.jianshu.com/p/c43b558c72b4 铺垫 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 项目分析设计原则：面向接口编程 他山之石，可以攻玉： 接口的作用类似给层与层之间制定的一种通信协议，两个不同的层级相互交流，只要遵守这些协议即可，并不需要知道具体的实现是怎样 构建框架的最终目的是增强项目代码的可读性 ，维护性，和方便测试 。要解决上述的三个问题，核心思想有两种： 分层 模块化 。 两个方法最终要实现的就是解耦，分层讲的是纵向层面上的解耦，模块化则是横向上的解耦。 说明 Activity是全体的控制器，它创建并连接views和presenters 一般来说，业务逻辑在presenter中，并且依赖view（在相应的Activity中实现各个View接口）去做Android UI（在View接口的方法中进行数据布置）的工作。 view几乎不包含业务逻辑，它将presenter的命令转换为UI动作（在View接口的方法中进行数据布置），并且监听用户动作传递给presenter（接口方法被回调）。 合同接口用于定义views和presenters之间的联系。 注意： 在一个MVP环境中，”View”项被重载（实现各个View接口）。 在MVP中从presenter接受命令的视图被简单的称为”view” 各个角色 Contract（合同） Activity Fragment Presenter（主持人-业务逻辑） View（UI动作） Mode（数据操作） 简述引用了诸多 mvp、mvc架构的网络图片，总有那么几张能让自己豁然开朗。 Android MVC框架 Activity 或者 Fragment 直接与数据层交互 Android MVP框架 多了两个层，一个是 Presenter 和 DataManager 层。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库-Retrofit2]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E5%BA%93-Retrofit2%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/ljd2038/article/details/51046512参考：https://www.jianshu.com/p/af8bd1abda82 retrofit2.0它依赖于OkHttp,不需要显示的导入okHttp,在retrofit中已经导入okhttp3。 retrofit的官网 ：http://square.github.io/retrofit/ 1. 基本使用1.1 将HTTP API 转换为 java接口1234public interface GitHubService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125; 1.2 接口的实现类12345Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .build();GitHubService service = retrofit.create(GitHubService.class); 1.3 Call创建的每个GitHubService请求都可以向远程Web服务器发出同步或异步HTTP请求。12345678910111213Call &lt;List &lt;Repo &gt;&gt; repos = service.listRepos（“octocat”）;call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; ··· &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125;&#125;); 1.4 取消请求我们可以终止一个请求。终止操作是对底层的httpclient执行cancel操作。即使是正在执行的请求，也能够立即终止。 1call.cancel(); 2. 配置2.1.1 为Retrofit添加Gson转换器1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); gson依赖： 1compile &apos;com.squareup.retrofit2:converter-gson:2.0.1&apos; Simple XML依赖: 1compile &apos;com.squareup.retrofit2:converter-simplexml&apos; 2.1.2 自定义转换器如果您需要与使用Retrofit不支持开箱即用的内容格式（例如YAML，txt，自定义格式）的API进行通信，或者希望使用不同的库来实现现有格式，则可以轻松创建你自己的转换器。创建一个扩展Converter.Factory类并在构建适配器时传入实例的类。 2.2 增加日志信息在retrofit2.0中是没有日志功能的。但是retrofit2.0中依赖OkHttp，所以也就能够通过OkHttp中的interceptor来实现实际的底层的请求和响应日志。 12345678910111213// 创建 OkHttp日志拦截器HttpLoggingInterceptor httpLoggingInterceptor = new HttpLoggingInterceptor();httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);OkHttpClient okHttpClient = new OkHttpClient.Builder() .addInterceptor(httpLoggingInterceptor) .build(); // 在 Retrofit 2.0 中通过&apos;client()&apos;进行配置Retrofit retrofit = new Retrofit.Builder() .client(okHttpClient) .baseUrl(&quot;https://api.github.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); 日志信息-需要添加如下依赖。 1compile &apos;com.squareup.okhttp3:logging-interceptor:3.1.2&apos; 2.3 添加请求头例如： 1234567@Headers(&#123; &quot;Accept: application/vnd.github.v3.full+json&quot;, &quot;User-Agent: RetrofitBean-Sample-App&quot;, &quot;name:ljd&quot;&#125;)@GET(&quot;repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)Call&lt;List&lt;Contributor&gt;&gt; contributorsAndAddHeader(@Path(&quot;owner&quot;) String owner,@Path(&quot;repo&quot;) String repo); http的header：https://www.cnblogs.com/printN/p/6534529.html : http://blog.csdn.net/qingkongyeyue/article/details/54925741 3 请求每个方法都必须有一个提供请求方法和相对URL的HTTP注释。有五个内置注释：GET，POST，PUT，DELETE，和HEAD。资源的相对URL在注释中指定。 3.1 Get请求3.1.1 请求方法直接一个url：，@Url，它允许我们直接传入一个请求的URL 12@GETCall&lt;List&lt;Contributor&gt;&gt; repoContributorsPaginate(@Url String url); 路径式 1@GET(&quot;users/list&quot;) 3.1.2 网址操作可以使用方法上的替换块和参数动态更新请求URL。替换块是由{和包围的字母数字字符串}。相应的参数必须@Path使用相同的字符串进行注释。 12@GET(&quot;group/&#123;id&#125;/users&quot;)Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId); 您也可以在URL中指定查询参数。 1@GET(&quot;users/list?sort=desc&quot;) 3.1.3 查询参数也可以添加查询参数也可以添加。 12@GET(&quot;group/&#123;id&#125;/users&quot;)Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @Query(&quot;sort&quot;) String sort); 3.1.4 对于复杂的查询参数组合，Map可以使用对于复杂的查询参数组合，Map可以使用。 12@GET(&quot;group/&#123;id&#125;/users&quot;)Call&lt;List&lt;User&gt;&gt; groupList(@Path(&quot;id&quot;) int groupId, @QueryMap Map&lt;String, String&gt; options); 4. Form encoded：发送表单数据4.1 表单数据使用@FormUrlEncoded注解来发送表单数据。使用 @Field注解和参数来指定每个表单项的Key，value为参数的值。 123@FormUrlEncoded@POST("user/edit")Call&lt;User&gt; updateUser(@Field("first_name") String first, @Field("last_name") String last); 4.2 多个表单参数可以通过@FieldMap注解和Map对象参数来指定每个表单项的Key，value的值。 123@FormUrlEncoded@POST(&quot;user/edit&quot;)Call&lt;User&gt; updateUser(@FieldMap Map&lt;String,String&gt; fieldMap); 5. Multipart 图片上传 参考：http://blog.csdn.net/ITjianghuxiaoxiong/article/details/52135748单图片：http://blog.csdn.net/sw5131899/article/details/52062321http://blog.csdn.net/sk719887916/article/details/51755427完整：http://blog.csdn.net/sk719887916/article/details/51755427封装：https://www.jianshu.com/p/29c2a9ac5abf基础：https://www.jianshu.com/p/308f3c54abddhttp基础：https://www.jianshu.com/p/e544b7a76dac 示例： 123@Multipart @POST("/member/uploadMemberIcon.do") Call&lt;Result&lt;String&gt;&gt; uploadMemberIcon(@Part MultipartBody.Part part/*, @Part(ParamKey.TOKEN) RequestBody token*/); 6. Retrofit与RxJava结合创建retrofit对象实例时，通过addCallAdapterFactory来添加对RxJava的支持。 123456Retrofit retrofit = new Retrofit.Builder() .client(okHttpClient) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .baseUrl("https://api.github.com/") .build(); 使用Observable创建一个API接口。 12@GET("repos/&#123;owner&#125;/&#123;repo&#125;/contributors")Observable&lt;List&lt;Contributor&gt;&gt; contributorsByRxJava(@Path("owner") String owner,@Path("repo") String repo); API使用参考：https://blog.csdn.net/carson_ho/article/details/73732076框架源码参考：https://yq.aliyun.com/articles/658544?spm=a2c4e.11153940.blogcont637930.23.15874c0aavn6rS]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment]]></title>
    <url>%2FFragment%2F</url>
    <content type="text"><![CDATA[Fragment相关 1 FragmentFragment 俗称碎片，自Android 3.0开始被引进并大量使用。其实是对 View 的封装，它持有 view, containerView, fragmentManager, childFragmentManager 等信息。 在 Activity 中管理 Fragment 时，如果是Support.v4 包，那么使用 getSupportFragmentManager()，如果不是那么使用 getFragmentManager()；在通过 Fragment 管理 子Fragment 时，其使用 getChildFragmentManager()。 1.1 特点： Fragment 是界面的一部分，必须依赖 Activity 或者 Fragment。 Fragment 有自己的生命周期，而且与 Activity 的生命周期相关联，受其影响。 Fragment 可以重复使用，多个 Activity可以重复使用一个 Fragment。 1.2 生命周期 1.3 Fragment生命周期方法调用场景 方法 解释 onAttach() Fragment与Activity建立关联，获取Activity实例及其传递的值 onCreateView() 为Fragment创建View onActivityCreated() Activity的onCreate()执行完毕后调用 onDestoryView() Fragment被移除 onDetach() Fragment与Activity解除关联 注意： 在 Fragment 中获取 Activity 对象时：不应使用getActivity()，而是应该在 onAttach() 中将 Context 对象 强转 为Activity对象。 在 Fragment 中 onCreateView() 中加载布局的inflate() 的第3个参数必须是 false，否则会导致 重复添加，抛出异常。因为在Fragment内部实现中，会把该布局添加到container中，如果设为true，那么就会重复做两次添加，则会抛如下异常： 1Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child&apos;s parent first. Fragment不是一个View，而是和Activity一个层级 1.4 Fragment在不同场景下的生命周期方法调用顺序 场景 生命周期方法调用顺序 创建Fragment onAttach()-&gt;onCreate()-&gt;onCreateView-&gt;onActivityCreated() Fragment可见 onStart()-&gt;onResume() Fragment进入后台 onPause()-&gt;onStop() Fragment退出应用/被销毁 onPause()-&gt;onStop()-&gt;onDestoryView()-&gt;onDestory()-&gt;onDetach() 屏幕灭掉/直接回到桌面 onPause()-&gt;onSaveInstanceState()-&gt;onStop() 屏幕解锁/直接回到应用 onStart()-&gt;onResume() 切换到其他Fragment onPause()-&gt;onStop()-&gt;onDestoryView() 切换回本身Fragment onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() 注意： onSaveInstanceState() 的调用顺序： 1onPause() -&gt; onSaveInstanceState() -&gt; onStop() onRestoreInstanceState() 的调用顺序： 1onStart() -&gt; onRestoreInstanceState() -&gt; onResume() 不要把Fragment事务放在 异步线程 的回调中，比如不要把Fragment事务放在AsyncTask的onPostExecute()，因为：onPostExecute()可能会在onSaveInstanceState()之后执行。因为如果 commit() 是在 onSaveInstanceState() 后调用，那么就会抛出异常： 12345java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341) at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352) at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595) at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574) 1.5 Fragment和Activity生命周期对应图 可以看到，除了 onCreate() 与 onDestory() 方法的不同外，其他的周期方法还是相同的。同时应该清楚： 在创建流程中：先执行Activity的生命周期，再执行Fragment生命周期。 在销毁流程中：先销毁Fragment的生命周期，再销毁Activity的生命周期。 以上这2点通过理解 Fragment 与 Activity 或 Fragment 的之间的依附关系，就很清楚了。 注意： Fragment的 onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在Activity的onStart()中调用的： 123456789101112131415161718192021222324252627BasicActivity: [onCreate] BEGINBasicActivity: [onCreate] ENDBasicActivity: [onStart] BEGINFragment1: [onAttach] BEGIN Fragment1: [onAttach] ENDBasicActivity: [onAttachFragment] BEGINBasicActivity: [onAttachFragment] ENDFragment1: [onCreate] BEGINFragment1: [onCreate] ENDFragment1: [onCreateView]Fragment1: [onViewCreated] BEGINFragment1: [onViewCreated] ENDFragment1: [onActivityCreated] BEGINFragment1: [onActivityCreated] ENDFragment1: [onStart] BEGINFragment1: [onStart] ENDBasicActivity: [onStart] ENDBasicActivity: [onPostCreate] BEGINBasicActivity: [onPostCreate] ENDBasicActivity: [onResume] BEGINBasicActivity: [onResume] ENDBasicActivity: [onPostResume] BEGINFragment1: [onResume] BEGINFragment1: [onResume] ENDBasicActivity: [onPostResume] ENDBasicActivity: [onAttachedToWindow] BEGINBasicActivity: [onAttachedToWindow] END Fragment的onResume()在Activity的onResume()之后调用。 是否设置 addToBackStack() 方法对 Fragment 的影响 执行replace将F1替换为F2(不加addToBackStack())： 1F2.onAttach()-&gt;Activity.onAttachFragment()-&gt;F2.onCreate()-&gt;F1.onPause()~onDetach()-&gt;F2.onCreateView()~onResume() 执行replace将F1替换为F2(加addToBackStack()) F1被替换只会调用onDestoryView()而不会调用后续生命周期。 1.6 Fragment的添加方式1.6.1 静态添加在进行静态加载Fragment时，要注意： 如果Fragment属于android.support.v4.app.Fragment，所用的Activity必须继承自FragmentActivity； 如果Fragment属于android.app.Fragment，直接使用Activity即可。 所谓的静态添加 Fragment 指的就是通过 Activity 的布局文件 引用 Fragment 的布局文件，在 Activity 的子类中不做代码处理。 创建一个Fragment布局 123456789101112&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.cwj.SubFragment"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:text="@string/sub_fragment" /&gt;&lt;/FrameLayout&gt; 创建一个Fragment子类并加载布局文件 1234567891011 public FragmentSub() &#123; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // 参数注意：第3个参数必须为`false`，否则会加载两次布局并且抛出异常 return inflater.inflate(R.layout.fragment_blank, container, false); &#125;&#125; 在Activity的布局文件中引用Fragment子类 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.example.cwj.MainActivity"&gt; &lt;fragment android:id="@+id/example_fragment" android:name="com.example.程文佳.SubFragment" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 1.6.2 动态添加动态添加与静态添加的不同之处在于： 在 Activity 的布局文件中，不再使用 fragment 标签，而是直接使用 FragmentLayout 标签。 12345678910111213&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.cwjMainActivity"&gt; &lt;FrameLayout android:id="@+id/main_activity_container" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/FrameLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 在 Activity 中动态的处理 Fragment 的添加及其他操作 123456789101112131415161718public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //1. 获取FragmentManager FragmentManager fragmentManager = getFragmentManager(); //2. 获取FragmentTransaction FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); //3. 创建Fragment SubFragment subFragment = new SubFragment(); //4. 将Fragment替换到Activity的布局中(Framelayout) fragmentTransaction.add(R.id.main_activity_container, subFragment); fragmentTransaction.commit(); &#125;&#125; 所谓的 动态添加 指的就是：在 Activity的 布局文件中先设置一个 占位符布局文件（FragmentLayout），然后在 Activity 的代码中再通过代码 动态 的将 Fragment 的子类替换掉占位符布局文件。 1.6.3 非正常添加 - 重复添加问题描述： Fragment 是依附于 Activity 而存在的，是在 Activity 的 onCreate() 中进行初始化的，但是有一种情况就是：当手机的屏幕发生旋转时，Activity 的生命周期会进行重新调用，会多次调用 onCreate() 方法，结果就导致 Fragment 的处理执行多次。 问题解决： 通过 onSaveInstanceState参数 来确定 onCreate() 是否多次执行： 12345678protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main_java); if(savedInstanceState == null)&#123; // 执行 Fragment操作 &#125;&#125; FragmentTransaction定义了对 Fragment 的 添加、替换、隐藏等操作，还有四种提交方法，其具体实现是在 BackStackRecord 中。 addToBackStack()将此次事物添加到后台堆栈，按下“回退键”不会退出该Activity而是回到上一个操作时的状态。相当于：按下“回退键”= 执行了add()对应的remove()，加入回退栈，则用户点击返回按钮，会回滚Fragment事务。 show()、hide() hide(fragment)：隐藏一个存在的fragment show(fragment)：显示一个被隐藏过的fragment hide()和show() ： 其实add()是一层层的将 Fragment 添加上去的，通过show() 去显示当前界面，hide()去隐藏其他的界面，这时候的FrameLayout是会有 很多层 的。 hide()、show()不会调用任何生命周期方法，只是控制显隐藏。但是重写onHiddenChanged()可以对Fragment的hide()、show()状态进行监听。 replace()replace() 与 add() + hide() + show() 的方式相比，是会替换掉 原有的Fragment，所以这种方式的FrameLayout是只有一层. attach()、detach() detach(fragment)：分离fragment的UI视图 attach(fragment)：重新关联一个Fragment(必须在detach后才能执行) 对生命周期的影响： 当Fragment被detach()后，Fragment的生命周期执行完onDestroyView()就 终止,Fragment的 实例并没有被销毁，只是UI界面被移除（和remove有区别）。 当Fragment被detach()后，执行attach()操作，会让Fragment从onCreateView()开始执行，一直执行到onResume()。 setCustomAnimations() 给Fragment的 进入/退出 设置指定的 动画资源 getSupportFragmentManager() 不支持属性动画，仅支持补间动画。 getFragmentManager() 支持属性动画。 setCustomAnimations()一定要放在 add()、remove() 等操作之前。 addSharedElement(View sharedElement, String name)作用是设置 共享View 供其他 Fragment 使用。 提交方式 commit()：安排一个事务的提交。 commitNow()：同步的提交这个事务。（API_24添加） commitAllowingStateLoss()：和commit一样，但是允许Activity的状态保存之后提交。 commitNowAllowingStateLoss()：和commitNow()一样，但是允许Activity的状态保存之后提交。（API_24添加） FragmentManger是一个抽象类，它定义了对一个 Activity/Fragment中 添加进来的 Fragment列表、Fragment回退栈的操作、管理方法，同时还定义了获取事务对象的方法，其具体实现类是在 FragmentImpl 中。 Fragment通信Fragment向Activity传递数据通过回调：在 Fragment 中设置回调接口，并在合适的方法中调用此接口实例，在 Activity 中具体实现这个接口。 Activity向Fragment传递数据setArguments(Bundle bundle)，getArguments() 在创建Fragment时要传入参数，必须要通过setArguments(Bundle bundle)方式添加，而不建议通过为Fragment添加带参数的构造函数，因为通过setArguments()方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。 Fragment之间传递数据 需要借助Activity进行数据通信 Activity中通过 FragmentManager 的findFragmentById()去获取Fragment。 简单、解耦的方式EventBus DialogFragmentDialogFragment是Android 3.0提出的，代替了Dialog，用于实现 对话框。他的优点是：即使旋转屏幕，也能保留对话框状态。 FragmentPagerAdapter与FragmentStatePagerAdapter的区别： 由于FragmentStatePagerAdapter在destoryItem()的时候调用mCurTransaction.remove(fragment)，会回收内存的，而页面比较多的时候，就比较消耗内存，所以适合于 页面比较多 的情况。 FragmentPagerAdapter在destoryItem()的时候调用mCurTransaction.detach(fragment)，没有回收内存，只是将fragment与activity的UI进行分离，所以适合于 页面比较少 的情况。 Fragment懒加载当使用viewpager+adapter作为应用大的布局时，viewpager会通过setOffscreenPageLimit()来设置 预加载的项目，不设置setOffscreenPageLimit()，则默认为1（设置0无效，可以查看该方法源码知道），也就是当我们打开应用看到的时候fragmentOne时，实际上其他fragment（例如fragmentSecond）也进行了加载，只不过没有显示出来罢了，但是这样就造成了不必要的资源浪费（例如，fragmentSecond没有显示，但是却进行了大量的网络加载操作）。 什么是懒加载ViewPager默认会 预加载左右相邻的Fragment，但是在一些有耗时操作的情况下，就需要进行懒加载处理了，即：在打开相应Fragment时才加载数据。 如何实现懒加载懒加载的实现思路：用户不可见的界面，只初始化UI，但是不做任何数据加载。等滑到该页，才会异步做数据加载并更新UI。因此通过：Fragment 的 setUserVisibleHint() 方法，可以实现懒加载。 Fragment 的 setUserVisibleHint() 方法setUserVisibleHint()的方法就是判断这个fragment对用户是否可见的。唯一需要值得注意的是，setUserVisibleHint()是在onCreateView()周期 前 调用，此时布局中各View还未初始化，所以只能在setUserVisibleHint()中进行 纯数据加载。 调用 setUserVisibleHint() 方法]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-数组、链表C]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8C%2F</url>
    <content type="text"><![CDATA[温故知新 根本： 一般：存储不一样，操作不一样； 泛型：存储不一样，操作也一样。 流程 –&gt; 功能 –&gt; 试数 1. 数据存储1.1 存储结构 线性结构：把所有的结点（数组中的元素、个体）用一根直线穿起来。 连续存储：数组 离散存储：链表 非线性结构 1.2 存储结构应用 栈 队列 2. 存储结构 - 数组【连续存储】2.1 数组定义：元素类型相同，大小相等。 2.2 数组定义： 优点： 存取效率高 缺点： 插入、删除慢 需要占用大块连续的内存空间 需要知道数组的长度 2.3 代码实践：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &lt;stdio.h&gt;#include &lt;mm_malloc.h&gt;#include &lt;stdbool.h&gt;// 定义一个数据类型，该数据类型名字叫：struct ArrayYCA。数组所具有的条件:4个struct ArrayYCA&#123; int * arrayBase; // 存储的是数组的第一个元素的地址 int length; // 数组所能容纳的最大元素个数 int cnt; // 当前数组的有效个数 int increment; // 数组自动增长因子：当当前数组的元素个数已达到最大元素个数时,通过增加“increment”个元素个数，来扩充当前数组的内存空间。&#125;;// 定义一个数据类型，该数据类型名字叫：struct ArrayYCB。数组所具有的条件：3个struct ArrayYCB&#123; int * arrayBase; // 存储的是数组的第一个元素的地址 int length; // 数组所能容纳的最大元素个数 int cnt; // 当前数组的有效个数&#125;;// 是否已满bool is_full(struct ArrayYCB * array)&#123; if (array-&gt;cnt == array-&gt;length) return true; else return false;&#125;// 追加bool append_array(struct ArrayYCB * array, int value)&#123; if (is_full(array)) &#123; printf("当前数组已满！\n"); return false; &#125; else &#123; array-&gt;arrayBase[array-&gt;cnt] = value; array-&gt;cnt++; return true; &#125;&#125;// 插入 position的值从1开始bool insert_array(struct ArrayYCB * array, int value, int position)&#123; int i = 0; if (is_full(array)) &#123; printf("已满，插入失败\n"); return false; &#125; if (position &lt; 1 || position &gt; array-&gt;cnt + 1) &#123; printf("position参数输入异常\n"); return false; &#125; for (i = array-&gt;cnt - 1; i &gt;= position - 1; i--) &#123; array-&gt;arrayBase[i+1] = array-&gt;arrayBase[i]; &#125; array-&gt;arrayBase[position-1] = value; array-&gt;cnt++; return true;&#125;// 判空bool is_empty(struct ArrayYCB * array)&#123; if (0 == array-&gt;cnt) return true; else return false;&#125;// 删除 删除指定元素后，既能返回 删除bool值，又能返回所删除的具体值。bool delete_array(struct ArrayYCB * array, int position, int * delValue)&#123; if (is_empty(array)) return false; if (position &lt; 1 || position &gt; array-&gt;cnt) &#123; return false; &#125; int i = 0; // 主函数中获取删除的数值 * delValue = array-&gt;arrayBase[position - 1]; for (i = position; i &lt; array-&gt;cnt; ++i) &#123; printf("更新前数值为： %d, 更新后数值为： %d， 当前i值为： %d \n", array-&gt;arrayBase[i-1], array-&gt;arrayBase[i], i); array-&gt;arrayBase[i-1] = array-&gt;arrayBase[i]; &#125; array-&gt;cnt--; return true;&#125;// 输出void show_array(struct ArrayYCB * array)&#123; if (is_empty(array)) printf("当前数组为空！\n"); else &#123; for (int i = 0; i &lt; array-&gt;cnt; i++) &#123; printf("%d ",array-&gt;arrayBase[i]); &#125; printf("\n"); &#125;&#125;// 排序bool sort_array(struct ArrayYCB * array)&#123; int temp; for (int i = 0; i &lt; array-&gt;cnt; i++) &#123; printf("i is %d\n", array-&gt;arrayBase[i]); for (int j = i+1; j &lt; array-&gt;cnt; j++) &#123; printf("j is %d, ", array-&gt;arrayBase[j]); if (array-&gt;arrayBase[i] &gt; array-&gt;arrayBase[j]) &#123; temp = array-&gt;arrayBase[i]; array-&gt;arrayBase[i] = array-&gt;arrayBase[j]; array-&gt;arrayBase[j] = temp; &#125; &#125; printf("\n第 %d 次排序后的结果为：", i+1); show_array(array); printf("\n"); &#125; return true;&#125;// 倒序void inversion_array(struct ArrayYCB * array)&#123; int i = 0; int j = array-&gt;cnt - 1; int temp; while (i &lt; j) &#123; temp= array-&gt;arrayBase[i]; array-&gt;arrayBase[i] = array-&gt;arrayBase[j]; array-&gt;arrayBase[j] = temp; i++; j--; &#125;&#125;// 初始化void init_array(struct ArrayYCB * array, int length)&#123; // array这个指针变量指向结构体变量中的arrayBase； array-&gt;arrayBase = (int *)malloc(sizeof(int) * length); if (NULL == array-&gt;arrayBase) &#123; printf("状态内存分配异常！\n"); // 终止整个程序 exit(-1); &#125; else &#123; //(*array).length = 99; array-&gt;length = length; array-&gt;cnt = 0; &#125; return;&#125;// 主函数int main(int argc, const char * argv[]) &#123; struct ArrayYCB arr; init_array(&amp;arr,6); append_array(&amp;arr, 11); append_array(&amp;arr, 22); append_array(&amp;arr, 33); append_array(&amp;arr, 44); append_array(&amp;arr, 55); insert_array(&amp;arr,99,2); // if (!append_array(&amp;arr, 7)) &#123;// printf("追加失败\n");// &#125; printf("删除前结果为："); show_array(&amp;arr); int val; // 为获取删除元素的数值声明变量 if (delete_array(&amp;arr, 3, &amp;val)) &#123; printf("删除成功！\n"); printf("删除的数值 = %d\n",val); &#125; printf("到序前结果为："); show_array(&amp;arr); inversion_array(&amp;arr); printf("到序结果为："); show_array(&amp;arr); sort_array(&amp;arr); printf("排序结果为："); show_array(&amp;arr); return 0;&#125; 运行结果： 1234567891011121314151617181920212223242526272829删除前结果为：11 99 22 33 44 55 更新前数值为： 22, 更新后数值为： 33， 当前i值为： 3 更新前数值为： 33, 更新后数值为： 44， 当前i值为： 4 更新前数值为： 44, 更新后数值为： 55， 当前i值为： 5 删除成功！删除的数值 = 22到序前结果为：11 99 33 44 55 到序结果为：55 44 33 99 11 i is 55j is 44, j is 33, j is 99, j is 11, 第 1 次排序后的结果为：11 55 44 99 33 i is 55j is 44, j is 99, j is 33, 第 2 次排序后的结果为：11 33 55 99 44 i is 55j is 99, j is 44, 第 3 次排序后的结果为：11 33 44 99 55 i is 99j is 55, 第 4 次排序后的结果为：11 33 44 55 99 i is 99第 5 次排序后的结果为：11 33 44 55 99 排序结果为：11 33 44 55 99 3. 存储结构 - 链表【离散存储】3.1 重要性链表 -&gt; 树、图 3.2 链表定义： n个结点地址离散分配，彼此通过指针相连； （除首尾结点外）每个结点只有一个前驱结点和一个后续结点； 首结点没有前驱结点，尾结点没有后续结点。 3.3 名词： 头结点：第一个有效结点之前的结点。 无数据 无链表中结点个数 无实际含义，仅方便操作 头结点与首结点数据类型形同 首结点：第一个有效结点（存放数据） 尾结点：最后一个有效结点（存放数据） 头指针：指向头结点的指针变量 尾指针：指向尾结点的指针变量 通过函数对一个链表进行处理，只需要1个参数确定唯一链表：头指针 3.3 链表分类： 单链表 双链表：每一个结点有2个指针域 循环链表：能通过任何一个结点找到其他所有的结点。 非循环链表 3.4 链表算法： 优点： 空间没有限制 插入、删除元素快 缺点： 存取速度慢 3.5 链表算法： 遍历、输出元素 查找 清空 销毁 求长度 排序 删除结点 插入结点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;stdio.h&gt;#include &lt;mm_malloc.h&gt;#include &lt;stdlib.h&gt;// 链表数据结构typedef struct Node&#123; int data; // 数据域 struct Node * pNext; // 指针域&#125; NODE, * PNODE;// 函数声明// 创建链表PNODE create_link(void);// 输出链表void traverse_link(PNODE pHead);// 判空bool is_empty(PNODE pHead);// 长度int length_link(PNODE pHead);// 插入bool insert_link(PNODE pHead, int postion, int val);// 删除bool delete_link(PNODE pHead, int postion, int * val);// 排序void sort_link(PNODE pHead);int main(void)&#123; PNODE pHead = NULL; pHead = create_link(); if (is_empty(pHead)) printf("该链表为空！"); else traverse_link(pHead); int length = length_link(pHead); printf("link length = %d\n",length); // link length = 2 sort_link(pHead); traverse_link(pHead); // data = 12, data = 34, data = 54, data = 88, insert_link(pHead, 4, 76); traverse_link(pHead); int val; delete_link(pHead,3,&amp;val); traverse_link(pHead); printf("删除的数据 = %d\n",val);&#125;// 创建链表PNODE create_link(void)&#123; int len; int i; int val; // 1.分配了一个不存放数据的 头结点 PNODE pHead = (PNODE)malloc(sizeof(NODE)); if (NULL == pHead) &#123; printf("程序内存分配失败，终止！"); exit(-1); &#125; // 2. 指向 头结点 PNODE pTail = pHead; pTail-&gt;pNext = NULL; printf("请输入链表结点个数 = "); scanf("%d",&amp;len); for (i = 0; i &lt; len; i++) &#123; printf("请输入第%d个数值:",i+1); scanf("%d",&amp;val); // 3.创建带有实际数据的结点 PNODE pNew = (PNODE)malloc(sizeof(NODE)); if (NULL == pNew) &#123; printf("程序内存分配失败，终止！"); exit(-1); &#125; // pTail的出现是使得pNew永远指向 尾结点 pNew-&gt;data = val; // 将新生成的pNew结点 “挂” 到链表中 pTail-&gt;pNext = pNew; // 使得 pNew成为尾结点 pNew-&gt;pNext = NULL; // 使得pTail成为尾结点 pTail = pNew; &#125; return pHead;&#125;// 输出链表void traverse_link(PNODE pHead)&#123; PNODE p = pHead-&gt;pNext; while (NULL != p) &#123; printf("data = %d, ",p-&gt;data); // data = 21, data = 23, p = p-&gt;pNext; &#125; printf("\n");&#125;/** 请输入链表结点个数 = 4 请输入第1个数值:21 请输入第2个数值:23 请输入第3个数值:34 请输入第4个数值:45 data = 21, data = 23, data = 34, data = 45, */// 判空bool is_empty(PNODE pHead)&#123; if (NULL == pHead-&gt;pNext) return true; else return false;&#125;// 长度int length_link(PNODE pHead)&#123; int count = 0; PNODE p = pHead-&gt;pNext; while (NULL != p) &#123; count++; p = p-&gt;pNext; &#125; return count;&#125;// 排序void sort_link(PNODE pHead)&#123; int length = length_link(pHead); int i, j, temp; PNODE p,q; for (i = 0, p = pHead-&gt;pNext; i &lt; length - 1; i++, p = p-&gt;pNext) &#123; for (j = i + 1, q = p-&gt;pNext; j &lt;length; j++, q = q-&gt;pNext) &#123; if (p-&gt;data &gt; q-&gt;data) &#123; temp = p-&gt;data; p-&gt;data = q-&gt;data; q-&gt;data = temp; &#125; &#125; &#125; return;&#125;// 插入// 在pHead所指向的链表的第position个结点前面插入一个新的结点。插入结点的值是val，并且position的值是1bool insert_link(PNODE pHead, int postion, int val)&#123; int i = 0; PNODE p = pHead; printf("pHead 当前地址 = %X\n",p); // 进行条件判断 while (NULL != p &amp;&amp; i &lt; postion - 1) &#123; // 获取到对应position-1位置的链表结点 p = p-&gt;pNext; int pVal = p-&gt;data; printf("pHead %d 当前地址 = %X, 对应的数据为 = %d\n",i, p, pVal); i++; &#125; if (i &gt; postion || NULL == p) &#123; return false; &#125; // 声明一个新结点 PNODE pNew = (PNODE)malloc(sizeof(PNODE)); if (NULL == pNew) &#123; printf("内次分配失败，退出！"); exit(-1); &#125; // 为新增加的结点赋值 pNew-&gt;data = val; PNODE q = p-&gt;pNext; p-&gt;pNext = pNew; pNew-&gt;pNext = q; return true;&#125;// 删除 , 得到删除的元素值bool delete_link(PNODE pHead, int postion, int * val)&#123; int i = 0; PNODE p = pHead; while (NULL != p-&gt;pNext &amp;&amp; i &lt; postion - 1) &#123; p = p-&gt;pNext; i++; &#125; if (i &gt; postion || NULL == p) &#123; return false; &#125; PNODE q = p-&gt;pNext; *val = q-&gt;data; p-&gt;pNext = p-&gt;pNext-&gt;pNext; free(q); q = NULL; return true;&#125; 运行结果为： 123456789101112131415请输入链表结点个数 = 4请输入第1个数值:21请输入第2个数值:32请输入第3个数值:14请输入第4个数值:55data = 21, data = 32, data = 14, data = 55, link length = 4data = 14, data = 21, data = 32, data = 55, pHead 当前地址 = 4072E0pHead 0 当前地址 = 407360, 对应的数据为 = 14pHead 1 当前地址 = 40C520, 对应的数据为 = 21pHead 2 当前地址 = 601040, 对应的数据为 = 32data = 14, data = 21, data = 32, data = 76, data = 55, data = 14, data = 21, data = 76, data = 55, 删除的数据 = 32 汉诺塔 手动分析步骤： 123456789101112131415161718192021222324252627282930313233(1） n == 1 第1次 1号盘 A----&gt;C sum = 1 次(2) n == 2 第1次 1号盘 A----&gt;B 第2次 2号盘 A----&gt;C 第3次 1号盘 B----&gt;C sum = 3 次(3) n == 3 第1次 1号盘 A----&gt;C 第2次 2号盘 A----&gt;B 第3次 1号盘 C----&gt;B 第4次 3号盘 A----&gt;C 第5次 1号盘 B----&gt;A 第6次 2号盘 B----&gt;C 第7次 1号盘 A----&gt;C sum = 7 次 . . . 移动次数为：2^n - 1 分析 实现这个算法可以简单分为三个步骤： （1） 把n-1个盘子由A 移到 B； （2） 把第n个盘子由 A移到 C； （3） 把n-1个盘子由B 移到 C； 继续细节分析： （1）中间的一步是把最大的一个盘子由A移到C上去； （2）中间一步之上可以看成把A上n-1个盘子通过借助辅助塔（C塔）移到了B上， （3）中间一步之下可以看成把B上n-1个盘子通过借助辅助塔（A塔）移到了C上； Java代码实现 12345678910111213141516171819202122232425262728public class Hannuo &#123; static int m = 0; public static void main(String[] args) &#123; int disks = 3; char A = &apos;A&apos;; char B = &apos;B&apos;; char C = &apos;C&apos;; Hannuo.hannuo(disks, A, B, C); &#125; private static void move(int disks, char M, char N) &#123; System.out.println(&quot;第&quot; + (++m) + &quot; 次移动 : &quot; + &quot; 把 &quot; + disks + &quot; 号圆盘从 &quot; + M + &quot; -&gt;移到-&gt; &quot; + N); &#125; public static void hannuo(int n, char A, char B, char C) &#123; if (n == 1) &#123; Hannuo.move(n, A, C); &#125; else &#123; hannuo(n - 1, A, C, B); Hannuo.move(n, A, C); hannuo(n - 1, B, A, C); &#125; &#125;&#125; 运行结果 1234567第1 次移动 : 把 1 号圆盘从 A -&gt;移到-&gt; C第2 次移动 : 把 2 号圆盘从 A -&gt;移到-&gt; B第3 次移动 : 把 1 号圆盘从 C -&gt;移到-&gt; B第4 次移动 : 把 3 号圆盘从 A -&gt;移到-&gt; C第5 次移动 : 把 1 号圆盘从 B -&gt;移到-&gt; A第6 次移动 : 把 2 号圆盘从 B -&gt;移到-&gt; C第7 次移动 : 把 1 号圆盘从 A -&gt;移到-&gt; C]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温故知新-数据结构-C指针]]></title>
    <url>%2F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[温故知新 根本： 一般：存储不一样，操作不一样； 泛型：存储不一样，操作也一样。 流程 –&gt; 功能 –&gt; 试数 1. 基础1.1 数据结构定义： 完整： 把现实中大量而复杂的问题以特定的数据类型（个体）和特定的存储结构（个体间的关系）保存到主存储器（内存）中，以及在此基础上为实现某一个功能而执行的相应操作，这个操作就叫做算法。 数据结构是转门研究数据存储的问题。 数据的存储包含2方面：个体的存储 + 个体关系的存储 简述： 数据结构 = 个体 + 个体间的关系 算法 = 对存储数据的操作 - 狭义的算法：与数据的存储方式密切相关 - 伪算法。 - 广义的算法：与数据的存储方式无关 - 代码算法。 泛型：利用某种技术达到的效果就是：不同的数据存储方式，执行的操作是一样的。 1.2 衡量算法的标准： 时间复杂度：研究中。算法执行过程中大概执行的次数，而非时间。 空间复杂度：研究中。算法执行过程中大概所占用的最大内存 难易程度：应用中。 健壮性 1.3 数据结构重要性： 程序 = 数据存储（数据结构） ＋ 数据操作（算法） ＋ 可以被计算机执行的语言（语言） 1.4 其他 地址： 地址 就是 内存单元编号。地址对应的内存中的位置是固定的，但地址对应的内存中的位置的数值是可变的。 从0开始的非负整数 范围：［0 － 4G-1］ 指针： 指针是C语言的灵魂。 指针 ＜＝＞ 地址 指针变量是存放内存单元地址的变量 指针本质是一个操作受限的非负整数 指针分类： 结构体 动态内存分配和释放 1.5 存储方式 1. 线性：数组 数组名：一维数组名是个指针常量，存放的是一维数组的的第一个元素的地址，他的值不能被改变，一维数组名指向的是数组的第一个元素。 下标：a[i] &lt;&lt; = = &gt;&gt; *(a +i) 常见应用： 栈 队列 2. 离散：链表 3. 数组存储不一样，操作不一样，泛型 2. 指针、指针变量、指针指向 在函数没有返回值的情况下，通过函数修改实参的值，仅通过获取实参地址。 修改变量地址的写法： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main(void)&#123; int * p; // 这个一个指针变量。'p'是变量名字，是内存抽象地址的实例表示;'int *' 表示p变量只能存储‘int类型变量’的地址，即，此时的p仅能存储‘int类型’的地址 printf("init p address :%X\n",p); printf("init p value :%D\n",*p); int i = 12; // 这是一个普通变量 int j; printf("init value : %d, %d, %d\n",i,j,*p); printf("init i address :%X\n",&amp;i); p = &amp;i; // int *p = &amp;i; printf("change p address :%X\n",p); printf("change p value :%D\n",*p); // 修改*p的数值 *p = 21; printf("change p value %d\n", *p); printf("init i value :%d\n",i); // 修改i的数值 i = 33; printf("change p value %d\n", *p); printf("init i value :%d\n",i); j = *p; // j = i; printf("chagne value : %d, %d, %d\n",i,j,*p); return 0;&#125; 运行结果 1234567891011init p address :EFBFF590init p value :0init value : 12, 0, 0init i address :EFBFF56Cchange p address :EFBFF56Cchange p value :12change p value 21init i value :21change p value 33init i value :33chagne value : 33, 33, 33 通过方法改变变量的数值 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;// 注意：此处不是定义了一个名字叫做 *p的形参(int *p)，而是定义了一个形参，形参的名字叫做p(int * p),类型是int *// 此处有误' ',都不形象参数的类型。void func(int * p)&#123; *p = 100;&#125;int main(void)&#123; int * p; // 这个一个指针变量。'p'是变量名字，是内存抽象地址的实例表示;'int *' 表示p变量只能存储‘int类型变量’的地址，即，此时的p仅能存储‘int类型’的地址 printf("init p address :%X\n",p); printf("init p value :%D\n",*p); int i = 12; // 这是一个普通变量 int j = 0; printf("init value : %d, %d, %d\n",i,j,*p); printf("init i address :%X\n",&amp;i); p = &amp;i; // int *p = &amp;i; printf("change p address :%X\n",p); printf("change p value :%D\n",*p); // 修改*p的数值 *p = 21; printf("change p value %d\n", *p); printf("init i value :%d\n",i); // 修改i的数值 i = 33; printf("change p value %d\n", *p); printf("init i value :%d\n",i); j = *p; // j = i; printf("chagne value : %d, %d, %d\n",i,j,*p); func(&amp;j); printf("j = %d\n",j); // 结果：j = 100 return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void func(int * temp)&#123; *temp = 100;&#125;// 仅需要知道一个数组的 首地址 和 数组长度 ，即可操作此数组void Show_Array(int *p, int len)&#123; p[2] = 33; for(int i = 0; i &lt; len;i++) &#123; printf("%d\n", p[i]); &#125; /** 1 2 33 4 5 */&#125;void array()&#123; int a[5] = &#123;1,2,3,4,5&#125;; printf("a[0] address is %d,*a address is %d\n",&amp;a[0],a); printf("*a + 3 = %d\n",*a+3); printf("a[0] is %d,*a is %d\n",a[0],*a); printf("a[4] is %d,*(a+4) is %d\n",a[4],*(a+4)); printf("a[0] address is %d\n",&amp;a[0]); printf("a[1] address is %d\n",&amp;a[1]); printf("a[2] address is %d\n",&amp;a[2]); printf("a[3] address is %d\n",&amp;a[3]); printf("a[4] address is %d\n",&amp;a[4]); /** a[0] address is -272632336,*a address is -272632336 a[0] is 1,*a is 1 a[4] is 5,*(a+4) is 5 a[0] == *(a),a[3] == *(a+3) a[0] address is -272632336 a[1] address is -272632332 a[2] address is -272632328 a[3] address is -272632324 a[4] address is -272632320 */ Show_Array(a,5); printf("a[2] = %d\n",a[2]); /** a[2] = 33 */&#125;int main(void)&#123; int j = 10; func(&amp;j); printf("j is %d\n",j); array(); return 0;&#125; 3. 结构体描述： 类似java类，模拟事物 只有属性，没有方法 为了表示一些复杂的数据，而普通的基本数据无法满足需要。用户根据自己的实际需要，自己定义的数据类型，非变量，未分配内存。 123456789101112131415161718// 结构体, 数据类型叫：struct Student，struct Student&#123; int sid; char name[200]; int age;&#125;;int main(void)&#123; // 结构体声明变量 struct Student stu = &#123;101,"zhansan",32&#125;; // 访问结构体变量的成员 printf("%d, %s, %d\n",stu.age,stu.name,stu.age); // 32, zhansan, 32 return 0;&#125; 修改结构体数值方式 12345678910// 修改数值方式1 stu.age = 33; // age = 33 printf("age = %d\n",stu.age); // 修改数值方式2 pst = &amp;stu; pst-&gt;age = 23;// pst-&gt;age == (*pst).age == stu.age printf("age age = %d\n",(*pst).age); // age age = 23 pst-&gt;age含义（链表）：pst所指向的结构体变量中的age这个成员 注意： 结构体变量之间不能“+ - /”，但是*可以相互赋值 普通结构体变量 和 结构体指针变量作为函数传参的问题： 1234567891011// 输出结构体 方式1：整个结构体内存void goStruct(struct Student stu)&#123; printf("goStruct data is %d, %s, %d\n",stu.sid,stu.name,stu.age);&#125;// 输出结构体 方式2：仅传递结构体地址void goStructPointer(struct Student * stu)&#123; printf("goStructPointer data is %d, %s, %d\n",stu-&gt;sid,stu-&gt;name,stu-&gt;age);&#125; 应用函数： 123456789struct Student stu = &#123;101,"zhansan",32&#125;;// 不推荐，耗时、内存goStruct(stu);// goStruct data is 1111, www, 66 // 推荐goStructPointer(&amp;stu);// goStructPointer data is 1111, www, 66 4. 动态内存分配和释放java中的new 实例： A aa = new A(); 类似于c中的： A * aaM = (A *)malloc(sizeof(A)); 主要语句： 12345#include &lt;mm_malloc.h&gt;// int类型地址int * mArray = (int *)malloc(sizeof(int) * len);free(mArray); 完整： 12345678910111213141516171819202122232425262728293031323334// malloc() 动态函数void myMalloc()&#123; int len; printf("input length:\n"); // 手动输入数组长度 scanf("%d",&amp;len); // int类型地址 int * mArray = (int *)malloc(sizeof(int) * len); // 手动初始数组: printf("input array item :\n"); for (int i = 0; i &lt; len; i++) &#123; scanf("%d, ",&amp;mArray[i]); &#125; // 1 2 3 4 5 // 遍历数组 for (int i = 0; i &lt; len; i++) &#123; printf("%d, ",*(mArray+i)); &#125; // 1, 2, 3, 4, 5, printf("\n"); free(mArray);&#125;int main(void)&#123; // 动态内存 myMalloc(); return 0;&#125; 跨函数调用内存空间 -通过动态申请内存空间一般情况下，当一个函数调动完毕之后，该函数之前占用的内存将会被释放。下图展示的是，当一个main函数调用另一个fun函数后，fun函数中的变量所占用的内存仍然保留，未释放的例子： 实例： 123456789101112131415161718192021222324252627282930// 动态分配内存struct StudentA * CreateStudentA(void)&#123; struct StudentA * newSA = (struct StudentA *)malloc(sizeof(struct StudentA)); printf("newSA address is : %d\n",&amp;newSA); newSA-&gt;age = 120; newSA-&gt;sid = 1001; return newSA;&#125;// 展示内存中的数据void ShowStudentA(struct StudentA * aa)&#123; printf("ShowStudentA ：aa = %d , sid = %d \n", aa-&gt;age, aa-&gt;sid);&#125;int main(void)&#123; struct StudentA * sa; sa = CreateStudentA(); printf("sa address is : %d\n",&amp;sa); ShowStudentA(sa); printf("sa address is : %d\n",&amp;sa); /** init sa address is : -272632288 newSA address is : -272632328 sa address is : -272632288 ShowStudentA ：aa = 120 , sid = 1001 */ return 0;&#125; 图文 5. struct与typedef的使用1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;// typedef 的使用// typedef的作用就是为已存在的数据类型重新取一个名字，即：别名typedef int YC;typedef struct Student&#123; int sid; char name[100]; int age;&#125; ST;int main(int argc, const char * argv[]) &#123; YC num = 100; printf("YC's num is %d \n",num); //struct Student stu; 等价于 ST stu; //struct Student * stuA; 等价于 ST * stuA; ST stu; stu.age = 32; printf("stu age = %d\n", stu.age); return 0;&#125; 运行结果 12YC's num is 100 stu age = 32 12345678typedef struct Student&#123; int sid; char name[100]; int age;&#125; * PST,ST;// * PS 等价于 struct Student *// ST 等价于 struct Student]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源的许可证GPL、LGPL、BSD、Apache 2.0的通俗解释]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E7%9A%84%E8%AE%B8%E5%8F%AF%E8%AF%81GPL%E3%80%81LGPL%E3%80%81BSD%E3%80%81Apache-2-0%E7%9A%84%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[参考：https://www.cnblogs.com/jacob-tian/p/5976088.html 软件开发者要开源软件，不单单是开放源代码就可以了，选择一种许可证很重要，一个许可证之于软件就相当于价值观之于普通人，代表了这个软件的基本品性。一个错误的许可证选择可能会直接导致整个项目的失败。 各种开源的许可证主要的限制还是在redistribution（发布），所以个人/商业公司开发的软件包含了GPL的代码，只要你不发布，是可以任意使用的。 下面是几个开源许可证的区别： GPL GPL软件的使用者有权力得到软件的代码，只要使用了GPL，在发布(redistribution)时，整个项目也必须是GPL的，即主程序和静态链接的库（linux的.a和Windows的.lib）必须是GPL的，动态链接库(Linux的.so，Windows的.dll)必须是GPL兼容的。所谓GPL兼容，也就是GPL软件中可以使用的库，这些许可证必须比GPL弱(如LGPL，BSD)，而不能是某个商业许可证。正因如此，GPL是带有很强的传染性，只要你的软件使用了GPL的代码，那么就请以GPL开放源代码吧，并且你的项目中也不能有任何和GPL不兼容的库。 LGPL GPL 带有很强的传染性，那么如果一个库使用GPL发布，那么使用这个库的所有软件也必须使用GPL发布，这对不想开放源代码的商业软件来讲是致命的打击——你可以不使用其他的库，但最基本的libc是无论如何绕不开的，如果libc是以GPL发布，就相当于所有软件必须以GPL发布了。所以，LGPL(Lesser GPL)诞生了。 LGPL定义为，在以LGPL发布的库的基础上开发新的库的时候，新的库必须以LGPL发布，但是如果仅仅是动态链接，那么则不受任何限制。这样商业软件就可以随意的使用LGPL的库了。因此，LGPL也具有传染性，但限制在其基础上开发的库上，而并不限制使用它的程序本身——它的传染性远小于GPL。 BSD、Apache 2.0 相对GPL/LGPL的开放源代码，BSD，Apache 2.0就宽松许多——商业软件可以任意的使用BSD，Apache 2.0发布的软件代码，而不需要开放源代码，只需要提及代码的原出处就可以了。BSD和Apache 2.0提及的方式稍有不同，具体可以参考协议的详细内容。它们是GPL兼容的 看看下面选择开源许可证的案例： andorid 使用宽松的Apache 2.0发布，因为Google作为一个商业公司，并不想失去商业软件的支持，它希望团结一切可以团结的力量加入的Android的开发中来，壮大自己的阵营，使用Apache 2.0就无可厚非了。而Google本身，并没有丧失对Android的控制权，不会担心另外一个公司拿走了Android的代码开发出一个闭源 Android的对手。因为，只要Android不断的出新版，社区不停的跟进，并且不停的修改API，其他基于Android开发的公司不得不把自己的Patch提回到主干上，否则，必然将耗费大量人力物力在维护自己的Patch上(钱这方面你斗得过Google？)，得不偿失。而且，闭源之后，与整个社区为敌，作为一个定位软件平台的项目，会流失大量应用软件开发者，以小博大，任何一个商业公司都不会干这种胜算不高的蠢事。 再看以GPL发布的Linux为什么比以BSD发布的FreeBSD成功。其实正是因为GPL的传染性。当一个开发人员在Linux基础上开发一个新功能之后， 不得不以GPL开放源代码，贡献回Linux，这样Linux本身才能越来也越壮大而且留住了相当的开发人员，形成了一个 优秀软件-&gt;很多使用者和贡献者-&gt;贡献－&gt;更优秀的软件-&gt;更多的使用者和贡献者… 的良性循环。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Service]]></title>
    <url>%2FAndroid%20Service%2F</url>
    <content type="text"><![CDATA[参考：http://www.sunnyang.com/215.html 简介Service 是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。 服务不提供用户界面。 例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与 Activity 的交互。 诸如 Activity 等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 Service 并不是一个进程也不是一个线程，是运行在主线程中的，因此如果处理cpu密集工作，建议在service开启一个新的子线程的。 应用程序告诉系统在后台处理一些事情，甚至不需要用户同应用程序直接交互，系统主要是通过Context.startService()来启动服务的，除非Service本身或者其他人明确来停止它否则将一直运行下去。 将应用程序自己的某些功能暴露给其它程序，这种交互主要通过Context.bindService(),允许长连接的服务来与之交互。 服务基本上分为两种形式：启动当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。 绑定当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 注意： 服务可以同时以这两种方式运行，也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是在于您是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。 无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，您可以通过清单文件将服务声明为私有服务，并阻止其他应用访问 服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。 基础要创建服务，必须创建 Service 子类（或使用它的一个现有子类）。在实现中，您需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括： onStartCommand()当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。） onBind()当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。 onCreate()首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。 onDestroy()当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。 如果组件通过调用startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。 如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。 清单文件声明服务要声明服务，请添加 元素作为 元素的子元素。例如： 1234567&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;service android:name=&quot;.ExampleService&quot; /&gt; ... &lt;/application&gt;&lt;/manifest&gt; 为了确保应用的安全性，请始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。 此外，还可以通过添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。 服务生命周期: 左图显示了使用 startService() 所创建的服务的生命周期，右图显示了使用 bindService() 所创建的服务的生命周期。 服务生命周期的两个嵌套循环： 服务的整个生命周期从调用 onCreate() 开始起，到 onDestroy() 返回时结束。与 Activity 类似，服务也在 onCreate() 中完成初始设置，并在 onDestroy() 中释放所有剩余资源。例如，音乐播放服务可以在 onCreate() 中创建用于播放音乐的线程，然后在 onDestroy() 中停止该线程。无论服务是通过 startService() 还是 bindService() 创建，都会为所有服务调用 onCreate() 和 onDestroy() 方法。 服务的有效生命周期从调用 onStartCommand() 或 onBind() 方法开始。每种方法均有 {Intent 对象，该对象分别传递到 startService() 或 bindService()。对于启动服务，有效生命周期与整个生命周期同时结束（即便是在 onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在 onUnbind() 返回时结束。 启动方式1：创建启动服务启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。 服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。 应用组件（如 Activity）可以通过 调用startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。 例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。 可以扩展两个类来创建启动服务： Service这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。 IntentService这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果您不要求服务同时处理多个请求，这是最好的选择。 您只需实现 onHandleIntent()方法即可，该方法会接收每个启动请求的 Intent，使您能够执行后台工作。 启动方式2：创建绑定服务绑定服务允许应用组件通过调用 bindService() 与其绑定，以便创建长期连接。 如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。 要创建绑定服务，必须实现 onBind() 回调方法以返回 IBinder，用于定义与服务通信的接口。然后，其他应用组件可以调用 bindService() 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（不必按通过 onStartCommand() 启动的服务那样来停止绑定服务）。 要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 IBinder 的实现，并且服务必须从 onBind() 回调方法返回它。一旦客户端收到 IBinder，即可开始通过该接口与服务进行交互。 多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。 可以通过三种方法定义接口： 扩展 Binder 类 如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service 中可用的公共方法。如果服务只是您的自有应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，您的服务被其他应用或不同的进程占用。 使用 Messenger 如需让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口。服务可以这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，后者随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向服务发送命令。此外，客户端还可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，这样就不必对服务进行线程安全设计 使用 AIDL AIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的服务必须具备多线程处理能力，并采用线程安全式设计。如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。 扩展 Binder 类注：此方法只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效。 具体的设置方法： 在您的服务中，创建一个可满足下列任一要求的 Binder 实例： 包含客户端可调用的公共方法 返回当前 Service 实例，其中包含客户端可调用的公共方法 或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法 从 onBind() 回调方法返回此 Binder 实例。 在客户端中，从 onServiceConnected() 回调方法接收 Binder，并使用提供的方法调用绑定服务。 向用户发送通知 Toast 通知是指出现在当前窗口的表面、片刻随即消失不见的消息，而状态栏通知则在状态栏中随消息一起提供图标，用户可以选择该图标来采取操作（例如启动 Activity）。 通常，当某些后台工作已经完成（例如文件下载完成）且用户现在可以对其进行操作时，状态栏通知是最佳方法。 当用户从展开视图中选定通知时，通知即可启动 Activity（例如查看已下载的文件）。 在前台运行服务前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。 例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。 要请求让服务运行于前台，请调用startForeground()。此方法采用两个参数：唯一标识通知的整型数和状态栏的 Notification。例如： 1234567Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 注意：提供给 startForeground() 的整型 ID 不得为 0。 要从前台移除服务，请调用 stopForeground()。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被移除。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android各个支持库]]></title>
    <url>%2FAndroid%E5%90%84%E4%B8%AA%E6%94%AF%E6%8C%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[参考：https://developer.android.google.cn/topic/libraries/support-library/features.html 一般而言，建议添加 v4 支持库和 v7 appcompat 库，因为它们支持一系列 Android 版本，并且可以为推荐的用户界面模式提供 API。 v4 支持库这些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。 注意：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果您在 Gradle 脚本中列出了 support-v4，您的 APK 将包含所有的 v4 模块。不过，要减少 APK 大小，我们建议仅列出应用需要的特定模块。 v4 compat 库为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-compat:24.2.0 v4 core-utils 库提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-core-utils:24.2.0 v4 core-ui 库实现各种 UI 相关组件，例如 ViewPager、NestedScrollView 和 ExploreByTouchHelper。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-core-ui:24.2.0 v4 media-compat 库向后移植部分媒体框架，包括 MediaBrowser 和 MediaSession。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-media-compat:24.2.0 v4 fragment 库添加对使用片段封装用户界面和功能的支持，从而使应用能够提供可以在大屏幕设备与小屏幕设备之间进行调节的布局。此模块依赖于compat、core-utils、core-ui 和 media-compat。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-fragment:24.2.0 v7 支持库一些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。这些库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。 v7 appcompat 库此库添加了对操作栏用户界面设计模式的支持。此库包含对 Material Design 用户界面实现的支持。 注意：此库依赖于 v4 支持库。 下面是 v7 appcompat 库中包含的一些关键类： ActionBar - 提供操作栏用户界面模式的实现。如需了解有关使用操作栏的详细信息，请参阅操作栏开发者指南。 AppCompatActivity - 添加一个应用 Activity 类，此类可作为使用支持库操作栏实现的 Activity 的基础类。 AppCompatDialog - 添加一个对话框类，此类可作为 AppCompat 主题对话框的基础类。 ShareActionProvider - 包含对可以添加到操作栏中的标准化分享操作（例如电子邮件或发帖至社交应用）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:appcompat-v7:24.2.0 v7 cardview 库此库添加了对 CardView 小部件的支持，让您能够在卡片内显示信息，从而使应用具备一致的外观。这些卡片对 Material Design 实现非常有用，并在电视应用布局中广为使用。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:cardview-v7:24.2.0 v7 gridlayout 库下载 Android 支持库后，此库可以添加对 GridLayout 类的支持，让您能够使用网状方格安排用户界面元素。如需了解有关 v7 gridlayout 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.widget 软件包。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:gridlayout-v7:24.2.0 v7 mediarouter 库此库可以提供 MediaRouter、MediaRouteProvider 和支持 Google Cast 的相关媒体类。 一般而言，利用 v7 mediarouter 库中的 API，您可以控制当前设备到外部屏幕、扬声器和其他目标设备的媒体渠道和流的路由。此库包含的 API 可以用于发布应用特定的媒体路由提供程序、发现和选择目标设备，以及检查媒体状态，等等。如需了解有关 v7 mediarouter 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.media 软件包。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:mediarouter-v7:24.2.0 v7 palette 库v7 palette 支持库包含 s 类，此类让您可以从图像中抽取突出颜色。例如，音乐应用可以使用 Palette 对象从专辑封面抽取主要颜色，然后使用这些颜色创建一个色彩协调的歌曲标题卡。 此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:palette-v7:24.2.0 v7 recyclerview 库recyclerview 库添加了 RecyclerView 类。此类能够为 RecyclerView 小部件提供支持，RecyclerView 是一种通过提供有限的数据项窗口有效显示大数据集的视图。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:recyclerview-v7:24.2.0 v7 Preference 支持库首选项软件包提供的 API 支持添加 preference 对象（例如 CheckBoxPreference 和 ListPreference），方便用户修改 UI 设置。 v7 Preference 库添加了对接口（例如 Preference.OnPreferenceChangeListener 和 Preference.OnPreferenceClickListener）以及类（例如 CheckBoxPreference 和 ListPreference）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:preference-v7:24.2.0 Dalvik 可执行文件分包支持库此库可以为使用多个 Dalvik Executable (DEX) 文件开发应用提供支持。引用超过 65536 个方法的应用须使用 Dalvik 可执行文件分包配置。如需了解有关使用 Dalvik 可执行文件分包的详细信息，请参阅使用超过 6.4 万种方法开发应用。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:multidex:1.0.0 注解支持库注解软件包提供的 API 支持向应用中添加注解元数据。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:support-annotations:24.2.0 设计支持库设计软件包提供的 API 支持向应用中添加 Material Design 组件和模式。 设计支持库添加了对应用开发者依赖的各种 Material Design 组件和模式的支持，例如抽屉式导航栏、浮动操作按钮 (FAB)、快捷信息栏和标签页。此库的 Gradle 构建脚本依赖关系标识符如下所示： 1com.android.support:design:24.2.0]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android传统蓝牙开发]]></title>
    <url>%2FAndroid%E4%BC%A0%E7%BB%9F%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[参考：https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html 蓝牙这项无线技术的名称取自古代丹麦维京国王Harald Blåtand的名字，他以统一了因宗教战争和领土争议而分裂的挪威与丹麦而闻名于世，而这个名字的英文便是Harald Bluetooth。 “Bluetooth”一词是斯堪的纳维亚语言词汇Blåtand/Blåtann的英语化。这个词的来源是10世纪丹麦和挪威国王蓝牙哈拉尔（丹麦语：Harald Blåtand Gormsen），借国王的绰号“Blåtand”当名称，直接翻译成中文为“蓝牙”（blå＝蓝，tand＝牙）。2006年，蓝牙技术联盟组织已将全球中文译名统一改采直译为“蓝牙”，并注册为该组织的注册商标。 蓝牙的标志是卢恩字母 Runic letter ior.svg（Hagall，ᚼ）和 Runic letter berkanan.svg（Bjarkan，ᛒ）的组合，也就是Harald Blåtand的首字母HB的合写。 这是一种无线通讯技术标准，用来让固定与移动设备，在短距离间交换数据，以形成个人局域网（PAN）。其使用短波特高频（UHF）无线电波，经由2.4至2.485 GHz的ISM频段来进行通信。1994年由电信商爱立信（Ericsson）发展出这个技术。它最初的设计，是希望创建一个RS-232数据线的无线通信替代版本。它能够链接多个设备，克服同步的问题。 蓝牙2.1+EDR/3.0+HS版本(通常指“标准蓝牙技术”)与蓝牙低能耗(BLE)技术有许多共同点：它们都是低成本、短距离、可互操作的鲁棒性无线技术，工作在免许可的2.4GHz ISM射频频段。 重要区别：蓝牙低能耗技术从一开始就设计为超低功耗(ULP)无线技术，而标准蓝牙技术主要是能够构成“低功耗的”无线连接。 工作方式蓝牙技术分为基础率/增强数据率（BR/EDR）和低耗能（LE）两种技术类型。其中BR/EDR型是以点对点网络拓扑结构创建一对一设备通信；LE型则使用点对点（一对一）、广播（一对多）和网格（多对多）等多种网络拓扑结构 发展 不同版本的特性，参考:http://www.eepw.com.cn/article/201709/364609.htm 第三代，2009年4月21日，蓝牙技术联盟颁布了蓝牙核心规范3.0版（3.0+HS），是一种全新的交替射频技术。蓝牙3.0+HS提高了数据传输速率，集成802.11PAL最高速度可达24Mbps。是蓝牙2.0速度的8倍。此外，引入了增强电源控制，实际空闲功耗明显降低。 第四代，2010年7月7日，蓝牙技术联盟推出了蓝牙4.0规范。其最重要的特性是支持省电。Bluetooth 4.0是Bluetooth从诞生至今唯一的一个综合协议规范。还提出了“低功耗蓝牙”、“传统蓝牙”和“高速蓝牙”三种模式。 高速蓝牙主：攻数据交换与传输； 传统蓝牙：则以信息沟通、设备连接为重点； 蓝牙低功耗：顾名思义，以不需占用太多带宽的设备连接为主。前身其实是NOKIA开发的Wibree技术，本是作为一项专为移动设备开发的极低功耗的移动无线通信技术，在被SIG接纳并规范化之后重命名为Bluetooth Low Energy（后简称低功耗蓝牙）。 这三种协议规范还能够互相组合搭配、从而实现更广泛的应用模式，此外，Bluetooth 4.0还把蓝牙的传输距离提升到100米以上（低功耗模式条件下） 2013年底，蓝牙技术联盟推出了蓝牙4.1规范，其目的是为了让 Bluetooth Smart 技术最终成为物联网(Internet of Things)发展的核心动力。 第五代，在2016年6月宣布蓝牙5.0。在有效传输距离上将是4.2LE版本的4倍（理论上可达300米），传输速度将是4.2LE版本的2倍（速度上限为24Mbps）。蓝牙5.0还支持室内定位导航功能（结合WiFi可以实现精度小于1米的室内定位），允许无需配对接受信标的数据（比如广告、Beacon、位置信息等，传输率提高了8倍），针对物联网进行了很多底层优化。 相关名词ISM频段ISM频段（Industrial Scientific Medical Band），中文意思分别是工业的(Industrial)、科学的(Scientific)和医学的(Medical)，因此顾名思义ISM频段就是各国挪出某一段频段主要开放给工业，科学和医学机构使用。应用这些频段无需许可证或费用，只需要遵守一定的发射功率（一般低于1W），并且不要对其它频段造成干扰即可。ISM频段在各国的规定并不统一。因此无线局域网（IEEE 802.11b/IEEE 802.11g），蓝牙，ZigBee等无线网络，均可工作在2.4GHz频段上。 RS-232个人计算机上的通讯接口之一，由电子工业协会(Electronic Industries Association，EIA) 所制定的异步传输标准接口。通常 RS-232 接口以9个引脚 (DB-9) 或是25个引脚 (DB-25) 的型态出现，一般个人计算机上会有两组 RS-232 接口，分别称为 COM1 和 COM2。 rs232（9针）接口 蓝牙技术联盟（Bluetooth Special Interest Group：SIG）其拥有蓝牙的商标，负责制定蓝牙规范、认证制造厂商，授权他们使用蓝牙技术与蓝牙标志，但本身不负责蓝牙设备的设计、生产及贩售。 蓝牙协议堆栈依照其功能可分四层： 核心协议层（HCI、LMP、L2CAP、SDP） 线缆替换协议层（RFCOMM） 电话控制协议层（TCS-BIN） 选用协议层（PPP、TCP、IP、UDP、OBEX、IrMC、WAP、WAE） 蓝牙规范（Profile） 更多参考：https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99%E8%A6%8F%E7%AF%84 释义其是指蓝牙通信在哪一种用途下应该使用的通信协议和相关的规范。Profile目的是要确保Bluetooth设备间的互通性（interoperability）。Profile中文译名有很多，比如配置文件，剖面，应用协议，轮廓等，每一种翻译代表了一种对于profile的不同理解， 剖面 这个说法可能更贴切一点。 因为profile其实是蓝牙对应于每一个具体的应用场景以及每一种应用的不同的协议栈，也就是说它其实是实现某种功能对应的自下而上的协议的组合。类似于对于横向协议的纵向组合。 结构porile之间也并非平行的关系，他们是相互依赖组合构成的，存在明显的层级关系的。 蓝牙1.1定义的profile有13个。SIG认为蓝牙设备有4个最基本的Profile： 通用接入剖面：General Access Profile（GAP） 定义两个蓝牙单元如何发现对方并建立连接，保证两个蓝牙单元，无论其生产厂商及进行的应用，可以通过蓝牙交换信息从而发现个单元支持何种应用。所有蓝牙单元都必须支持GAP以保证基本的互操作性和共存性。 服务发现应用剖面：Service Discovery Application Profile（SDAP） 定义如何发现蓝牙单元支持的业务，该剖面可以用来搜索已知的特定业务，也可以用来进行普通业务浏览搜索。 串行端口剖面：Serial Port Profile（SPP） 定义如何在两个设备之间建立虚拟串行端口，并用蓝牙将其连接。采用串行端口剖面可在蓝牙单元上仿真基于RS-232控制信令的串行线缆，该剖面可保证高达128kbit/s的数据速率。 普通对象交换剖面：General Object Exchange Profile（GOEP） 定义处理对象交换的应用需采用的协议和程序，基于GOEP的应用模型（如文件传输、同步等）假定链路和信道已经建立如GAP所述，GOEP描述从一个蓝牙设备Push数据到另一个蓝牙设备的程序，还规定如何在两个单元之间Pull数据。 干扰Bluetooth在2.4GHz的电波干扰问题一直为大家所诟病，特别和无线局域网间的互相干扰问题。有干扰发生时，就以重新发送数据包的方法来解决干扰。 Android 传统蓝牙 Bluetooth API传统蓝牙适用于电池使用强度较大的操作，例如 Android 设备之间的流式传输和通信等。使用 Bluetooth API，Android 应用可执行以下操作： 扫描其他蓝牙设备 查询本地蓝牙适配器的配对蓝牙设备 建立 RFCOMM 通道 通过服务发现连接到其他设备 与其他设备进行双向数据传输 管理多个连接 基础使用 Android Bluetooth API 来完成使用蓝牙进行通信的四项主要任务： 设置蓝牙 查找局部区域内的配对设备或可用设备 连接设备 在设备之间传输数据 创建蓝牙连接所需的类和接口：BluetoothAdapter表示本地蓝牙适配器（蓝牙无线装置）。 BluetoothAdapter 是所有蓝牙交互的入口点。 利用它可以发现其他蓝牙设备，查询绑定（配对）设备的列表，使用已知的 MAC 地址实例化 BluetoothDevice，以及创建 BluetoothServerSocket 以侦听来自其他设备的通信。 BluetoothDevice表示远程蓝牙设备。利用它可以通过 BluetoothSocket 请求与某个远程设备建立连接，或查询有关该设备的信息，例如设备的名称、地址、类和绑定状态等。BluetoothSocket表示蓝牙套接字接口（与 TCP Socket 相似）。这是允许应用通过 InputStream 和 OutputStream 与其他蓝牙设备交换数据的连接点。 BluetoothServerSocket表示用于侦听传入请求的开放服务器套接字（类似于 TCP ServerSocket）。 要连接两台 Android 设备，其中一台设备必须使用此类开放一个服务器套接字。 当一台远程蓝牙设备向此设备发出连接请求时， BluetoothServerSocket 将会在接受连接后返回已连接的 BluetoothSocket。 BluetoothClass描述蓝牙设备的一般特征和功能。 这是一组只读属性，用于定义设备的主要和次要设备类及其服务。 不过，它不能可靠地描述设备支持的所有蓝牙配置文件和服务，而是适合作为设备类型提示。BluetoothProfile表示蓝牙配置文件的接口。 蓝牙配置文件是适用于设备间蓝牙通信的无线接口规范。 免提配置文件便是一个示例。 如需了解有关配置文件的详细讨论，请参阅使用配置文件 BluetoothHeadset提供蓝牙耳机支持，以便与手机配合使用。 其中包括蓝牙耳机和免提（1.5 版）配置文件。 BluetoothA2dp定义高质量音频如何通过蓝牙连接和流式传输，从一台设备传输到另一台设备。“A2DP”代表高级音频分发配置文件。 BluetoothHealth表示用于控制蓝牙服务的健康设备配置文件代理。 BluetoothHealthCallback用于实现 BluetoothHealth 回调的抽象类。您必须扩展此类并实现回调方法，以接收关于应用注册状态和蓝牙通道状态变化的更新内容。 BluetoothHealthAppConfiguration表示第三方蓝牙健康应用注册的应用配置，以便与远程蓝牙健康设备通信。 BluetoothProfile.ServiceListener在 BluetoothProfile IPC 客户端连接到服务（即，运行特定配置文件的内部服务）或断开服务连接时向其发送通知的接口。 蓝牙权限 蓝牙权限 BLUETOOTH : 要在应用中使用蓝牙功能，必须声明蓝牙权限 BLUETOOTH。您需要此权限才能执行任何蓝牙通信，例如请求连接、接受连接和传输数据等。 蓝牙权限 BLUETOOTH_ADMIN : 如果你希望你的应用启动设备发现或操作蓝牙设置 注意：如果要使用 BLUETOOTH_ADMIN 权限，则还必须拥有 BLUETOOTH 权限。 设置蓝牙获取BluetoothAdapter，并检测设备是否支持蓝牙1234BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();if (mBluetoothAdapter == null) &#123; // Device does not support Bluetooth&#125; 启用蓝牙1234if (!mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125; 注意 ： 此处的 REQUEST_ENABLE_BT 是自己编写定义的局部常量（必须&gt;0） 进行判断之后，监听用户的操作：方式1： 重写onActivityResult()如果成功启用蓝牙，Activity 将会在 onActivityResult() 回调中收到 RESULT_OK 结果代码。 如果由于某个错误（或用户响应“No”）而没有启用蓝牙，则结果代码为 RESULT_CANCELED。 方式2：侦听 ACTION_STATE_CHANGED 广播 Intent每当蓝牙状态发生变化时，系统都会广播此 Intent。 此广播包含额外字段 EXTRA_STATE 和 EXTRA_PREVIOUS_STATE，二者分别包含新的和旧的蓝牙状态。 这些额外字段可能的值包括 STATE_TURNING_ON、STATE_ON、STATE_TURNING_OFF 和 STATE_OFF。侦听此广播适用于检测在您的应用运行期间对蓝牙状态所做的更改。 提示 ：启用可检测性将会自动启用蓝牙。 如果您计划在执行蓝牙 Activity 之前一直启用设备的可检测性，则可以跳过 “启用蓝牙”步骤 查找设备使用 BluetoothAdapter，可以通过设备发现或通过查询配对（绑定）设备的列表来查找远程蓝牙设备。 设备发现是一个扫描过程，它会搜索局部区域内已启用蓝牙功能的设备，然后请求一些关于各台设备的信息。但局部区域内的蓝牙设备仅在其当前已启用可检测性时才会响应发现请求。 如果设备可检测到，它将通过共享一些信息（例如设备名称、类及其唯一 MAC 地址）来响应发现请求。 利用此信息，执行发现的设备可以选择发起到被发现设备的连接。 在首次与远程设备建立连接后，将会自动向用户显示配对请求。 设备完成配对后，将会保存关于该设备的基本信息（例如设备名称、类和 MAC 地址），并且可使用 Bluetooth API 读取这些信息。 利用远程设备的已知 MAC 地址可随时向其发起连接，而无需执行发现操作（假定该设备处于有效范围内）。 注：Android 设备默认处于不可检测到状态。 用户可通过系统设置将设备设为在有限的时间内处于可检测到状态，或者，应用可请求用户在不离开应用的同时启用可检测性。 查询已配对的设备在执行设备发现之前，有必要查询已配对的设备集，以了解所需的设备是否处于已知状态。 123456Set&lt;BluetoothDevice&gt; devices = mBluetoothAdapter.getBondedDevices(); if (devices.size() &gt; 0) &#123; for (BluetoothDevice device: devices) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; dealBluetooth device Name : " + device.getName() + ", Address : " + device.getAddress()); &#125; &#125; 若要发起连接，BluetoothDevice 对象仅仅需要提供 MAC 地址即可。 发现设备要开始发现设备，只需调用 startDiscovery()。该进程为异步进程，并且该方法会立即返回一个布尔值，指示是否已成功启动发现操作。 发现进程通常包含约12 秒钟的查询扫描，之后对每台发现的设备进行页面扫描，以检索其蓝牙名称。 您的应用必须针对 ACTION_FOUND Intent 注册一个 BroadcastReceiver，以便接收每台发现的设备的相关信息。 针对每台设备，系统将会广播 ACTION_FOUND Intent。此 Intent 将携带额外字段 EXTRA_DEVICE 和 EXTRA_CLASS，二者分别包含 BluetoothDevice 和 BluetoothClass。 例如，下面说明了在发现设备时如何注册以处理广播。 12345678910111213141516// Create a BroadcastReceiver for ACTION_FOUNDprivate final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); // When discovery finds a device if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123; // Get the BluetoothDevice object from the Intent BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); // Add the name and address to an array adapter to show in a ListView mArrayAdapter.add(device.getName() + "\n" + device.getAddress()); &#125; &#125;&#125;;// Register the BroadcastReceiverIntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);registerReceiver(mReceiver, filter); // Don't forget to unregister during onDestroy 注意：执行设备发现对于蓝牙适配器而言是一个非常繁重的操作过程，并且会消耗大量资源。 在找到要连接的设备后，确保始终使用 cancelDiscovery()停止发现，然后再尝试连接。 此外，如果您已经保持与某台设备的连接，那么执行发现操作可能会大幅减少可用于该连接的带宽，因此不应该在处于连接状态时执行发现操作。 启用可检测性如果希望将本地设备设为可被其他设备检测到，请使用 ACTION_REQUEST_DISCOVERABLE 操作 Intent 调用 startActivityForResult(Intent, int)。这将通过系统设置发出启用可检测到模式的请求（无需停止您的应用）。 默认情况下，设备将变为可检测到并持续 120 秒钟。您可以通过添加 EXTRA_DISCOVERABLE_DURATION Intent Extra 来定义不同的持续时间。 应用可以设置的最大持续时间为 3600 秒，值为 0 则表示设备始终可检测到。 任何小于 0 或大于 3600 的值都会自动设为120秒。 例如，以下片段会将持续时间设为 300 秒： 123Intent discoverableIntent = newIntent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300); 如果您将要发起到远程设备的连接，则无需启用设备可检测性。 仅当您希望您的应用托管将用于接受传入连接的服务器套接字时，才有必要启用可检测性，因为远程设备必须能够发现该设备，然后才能发起连接 连接设备要在两台设备上的应用之间创建连接，必须同时实现服务器端和客户端机制，因为其中一台设备必须开放服务器套接字，而另一台设备必须发起连接（使用服务器设备的 MAC 地址发起连接）。 当服务器和客户端在同一 RFCOMM 通道上分别拥有已连接的 BluetoothSocket 时，二者将被视为彼此连接。 这种情况下，每台设备都能获得输入和输出流式传输，并且可以开始传输数据。 服务器设备和客户端设备分别以不同的方法获得需要的 BluetoothSocket。服务器将在传入连接被接受时收到套接字。 客户端将在其打开到服务器的 RFCOMM 通道时收到该套接字。 一种实现技术是自动将每台设备准备为一个服务器，从而使每台设备开放一个服务器套接字并侦听连接。然后任一设备可以发起与另一台设备的连接，并成为客户端。 或者，其中一台设备可显式“托管”连接并按需开放一个服务器套接字，而另一台设备则直接发起连接。 如果两台设备之前尚未配对，则在连接过程中，Android 框架会自动向用户显示配对请求通知或对话框。因此，在尝试连接设备时，您的应用无需担心设备是否已配对。 连接为服务器当您需要连接两台设备时，其中一台设备必须通过保持开放的 BluetoothServerSocket 来充当服务器。 服务器套接字的用途是侦听传入的连接请求，并在接受一个请求后提供已连接的 BluetoothSocket。 从 BluetoothServerSocket 获取 BluetoothSocket 后，可以（并且应该）舍弃 BluetoothServerSocket，除非您需要接受更多连接。 连接为客户端待续……]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android BLE 蓝牙开发]]></title>
    <url>%2FAndroid%20BLE%20%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[参考文章：https://www.jianshu.com/p/3a372af38103参考文章：https://www.jianshu.com/p/29a730795294android developers：https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html#terms部分图片来源：https://www.youtube.com/watch?v=vUbFB1Qypg8经典蓝牙使用参考：http://blog.csdn.net/axinmeng88/article/details/79059468BLE设备地址参考：http://www.wowotech.net/bluetooth/ble_address_type.html 蓝牙唯一身份标识 MAC地址：这个地址是唯一的，就像网络上的IP地址 UUID（Universally Unique Identifier）：可以把它理解为是IP地址中的端口号 12更多UUID接口参考：https://www.jianshu.com/p/3de46c75f8ce，官网：https://www.bluetooth.com/zh-cn/specifications/assigned-numbers/service-discovery MAC + UUID = IP地址 + 端口号。这两者合起来就是蓝牙的唯一身份标识。BLE扫描的过程，设备会生成随机地址。根据随机地址也能进行连接。 BLE (Bluetooth Low Energy) 低功耗蓝牙Android 4.3（API级别18）引入了以低功耗蓝牙（BLE）为中心角色的内置平台支持，并提供应用程序可用于发现设备，查询服务和传输信息的API 常见用例包括以下内容： 在附近的设备之间传输少量的数据 与Google Beacons等接近传感器进行互动，为用户提供基于当前位置的定制体验。 传统蓝牙可以用于数据量比较大的传输，如语音，音乐，较高数据量传输等，但是比较耗电，低功耗蓝牙这样应用于实时性要求比较高，功耗比较低，但是数据速率比较低的产品，如遥控类的，如鼠标，键盘，遥控鼠标(Air Mouse)，传感设备的数据发送，如心跳带，血压计，温度传感器等。 关键术语（Key Terms）和 概念（Concepts） GATT图示1 GATT图示2 通用属性配置文件 Generic Attribute Profile（GATT）：GATT配置文件是通过BLE链接发送和接收被称为“属性”的短小数据的通用规范。目前所有的低能耗应用程序都基于GATT。 蓝牙SIG为低能耗设备定义了许多配置文件。 配置文件是设备如何在特定应用程序中工作的规范。 请注意，设备可以实现多个配置文件。 例如，一个设备可以包含一个心率监测器和一个电池电量检测器。 你可以把他看成xml来理解： 每个GATT由完成不同功能的Service组成； 每个Service由不同的Characteristic组成； 每个Characteristic由一个value和一个或者多个Descriptor组成； Service、Characteristic相当于标签（Service相当于他的类别，Characteristic相当于它的名字），而value才真正的包含数据，Descriptor是对这个value进行的说明和描述，当然我们可以从不同角度来描述和说明，因此可以有多个Descriptor. 举一个简单的例子进行说明： 常见的小米手环是一个BLE设备，（假设）它包含三个Service,分别是提供设备信息的Service、提供步数的Service、检测心率的Service;而设备信息的service中包含的characteristic包括厂商信息、硬件信息、版本信息等；而心率Service则包括心率characteristic等，而心率characteristic中的value则真正的包含心率的数据，而descriptor则是对该value的描述说明，比如value的单位啊，描述啊，权限啊等。 属性协议 Attribute Protocol（ATT）：GATT建立在属性协议（ATT）之上。 这也被称为GATT / ATT。 ATT经过优化，可在BLE设备上运行。 为此，它使用尽可能少的字节。 每个属性由一个通用唯一标识符（UUID）唯一标识，该标识符是用于唯一标识信息的字符串ID的标准化128位格式。 ATT传输的属性被格式化为特征和服务。 特性 Characteristic： 特性包含描述特性值的单个值和0-n个描述符。一个特征可以被认为是一个类，类似于一个阶级。是最小的数据逻辑单元。 描述符 Descriptor： 描述符是描述特征值的定义属性。 例如，一个描述符可以指定一个可读的描述，一个特征值的可接受范围，或者一个特征值特有的度量单位。value、descriptor中存储数据的解析由Server的工程师决定，并无规范，双发按照约定开发。 服务 Service： 服务是一个特征的集合。 例如，您可以拥有一个名为“心率监测器”的服务，其中包含“心率测量”等特性。 您可以在bluetooth.org上找到现有基于GATT的配置文件和服务的列表。Service/Characteristic均有一个唯一的UUID标识，UUID既有16位的也有128位的，我们需要了解的是16位的UUID是经过蓝牙组织认证的，是需要购买的，当然也有一些通用的16位UUID。例如Heart Rate服务的UUID就是0X180D,代码中表示为0X00001800-0000-1000-8000-00805f9b34fb,其他位为固定的。而128位的UUID则可以自定义。 角色（Roles）和责任（Responsibilities）以下是Android设备与BLE设备交互时适用的角色和职责： 中央（Central） 与 周边（Peripheral）。这适用于BLE连接本身。处于中心角色的设备扫描，寻找广告，并且在外围角色中的设备进行广告。 GATT服务器 与 GATT客户端。这决定了两台设备在建立连接后如何相互通话。 为了理解这个区别，假设你有一个Android手机和一个BLE设备的活动追踪器。 手机支持中心角色; 活动跟踪器支持外设角色（建立一个BLE连接，你需要每两个事物中只有一个支持外围设备的人不能彼此交谈，也不能只支持两个事物）。 一旦手机和活动追踪器建立了连接，他们就开始将GATT元数据转移到另一个。根据他们传输的数据的种类，其中一个或另一个可能充当服务器。例如，如果活动跟踪器想要将传感器数据报告给电话，则活动跟踪器可以充当服务器。如果活动跟踪器想要从手机接收更新，那么手机作为服务器可能是有意义的。 在本文档中使用的示例中，Android应用程序（在Android设备上运行）是GATT客户端。该应用程序从GATT服务器获取数据，GATT服务器是支持心率档案的BLE心率监测器。但你也可以设计你的Android应用程序来扮演GATT服务器的角色。有关更多信息，请参阅BluetoothGattServer。 BLE 权限（Permissions） 为了在您的应用程序中使用蓝牙功能，您必须声明（declare） 权限1：BLUETOOTH。您需要此权限才能执行（perform）任何 蓝牙通信 ，例如 请求连接，接受连接以及传输数据。 如果您希望您的应用启动设备发现或操纵（manipulate）蓝牙设置，则还必须声明 权限2：BLUETOOTH_ADMIN。 注意：如果您使用BLUETOOTH_ADMIN权限，则还必须具有BLUETOOTH权限。 在应用程序清单文件中声明蓝牙许可。例如： 12&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 如果您想声明您的应用仅适用于具有BLE功能的设备，请在应用的清单中包含以下内容： 1&lt;uses-feature android:name=&quot;android.hardware.bluetooth_le&quot; android:required=&quot;true&quot;/&gt; 但是，如果您想让您的应用可用于不支持BLE的设备，则应该在应用的清单中包含此元素，但设置required =“false”。 然后在运行时，您可以使用PackageManager.hasSystemFeature（）来确定BLE可用性： 123456// Use this check to determine whether BLE is supported on the device. Then// you can selectively disable BLE-related features.if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123; Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show(); finish();&#125; 注意：LE信标往往与位置有关。 为了在没有过滤器的情况下使用BluetoothLeScanner，您必须通过在应用的清单文件中声明 权限3：ACCESS_COARSE_LOCATION 或 权限3：ACCESS_FINE_LOCATION 权限来请求用户的许可。 没有这些权限，扫描将不会返回任何结果。 设置BLE在您的应用程序可以通过BLE进行通信之前，您需要验证设备是否支持BLE，如果是，请确保已启用BLE。请注意，只有在设置为false时才需要执行此项检查 如果不支持BLE，那么您应该禁用任何BLE功能。如果BLE支持，但被禁用，那么您可以请求用户启用蓝牙，而无需离开您的应用程序。 使用BluetoothAdapter，可以分两步完成此设置： 1. 获取 BluetoothAdapterBluetoothAdapter是任何和所有的蓝牙活动所必需的。 BluetoothAdapter代表设备自己的蓝牙适配器（蓝牙无线电）。整个系统有一个蓝牙适配器，您的应用程序可以使用这个对象与它进行交互。下面的代码展示了如何获取适配器。请注意，此方法使用getSystemService（）返回BluetoothManager的实例，然后用于获取适配器。 Android 4.3（API Level 18）介绍了BluetoothManager： 123456private BluetoothAdapter mBluetoothAdapter;...// Initializes Bluetooth adapter.final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);mBluetoothAdapter = bluetoothManager.getAdapter(); 2. 启用蓝牙接下来，您需要确保蓝牙已启用。调用isEnabled（）来检查当前是否启用了蓝牙。如果此方法返回false，则蓝牙被禁用。以下片段检查是否启用了蓝牙。如果不是，该片段会显示一个错误，提示用户转到设置以启用蓝牙： 123456// Ensures Bluetooth is available on the device and it is enabled. If not,// displays a dialog requesting user permission to enable Bluetooth.if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125; 注意：传递给 startActivityForResult（android.content.Intent，int）的REQUEST_ENABLE_BT常量是系统在onActivityResult（int，int，android.content）中返回给您的本地定义的整数（它必须大于0））实现作为requestCode参数。 查找BLE设备要查找BLE设备，请使用startLeScan（）方法。 此方法将BluetoothAdapter.LeScanCallback作为参数。 您必须实现此BluetoothAdapter.LeScanCallback，因为这是如何返回扫描结果。 由于扫描耗电量大，您应遵守以下准则: 一旦找到所需的设备，请停止扫描 切勿扫描循环，并在扫描上设置时间限制。以前可用的设备可能已移出范围，并继续扫描电池电量。 以下片段显示了如何启动和停止扫描： 123456789101112131415161718192021222324252627282930313233/** * Activity for scanning and displaying available BLE devices. */public class DeviceScanActivity extends ListActivity &#123; private BluetoothAdapter mBluetoothAdapter; private boolean mScanning; private Handler mHandler; // Stops scanning after 10 seconds. private static final long SCAN_PERIOD = 10000; ... private void scanLeDevice(final boolean enable) &#123; if (enable) &#123; // Stops scanning after a pre-defined scan period. mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; &#125;, SCAN_PERIOD); mScanning = true; mBluetoothAdapter.startLeScan(mLeScanCallback); &#125; else &#123; mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; ... &#125;...&#125; 如果只想扫描特定类型的外设，则改为调用startLeScan（UUID []，BluetoothAdapter.LeScanCallback），提供指定您的应用程序支持的GATT服务的UUID对象数组。 以下是BluetoothAdapter.LeScanCallback的一个实现，它是用于传递BLE扫描结果的接口🤔： 1234567891011121314151617private LeDeviceListAdapter mLeDeviceListAdapter;...// Device scan callback.private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mLeDeviceListAdapter.addDevice(device); mLeDeviceListAdapter.notifyDataSetChanged(); &#125; &#125;); &#125;&#125;; 注意：您只能扫描蓝牙LE设备或扫描经典蓝牙设备，如蓝牙中所述。您无法同时扫描Bluetooth LE和传统设备。 连接到GATT服务器（发送数据的BLE设备） 与BLE设备交互的第一步是连接到它，更具体地说，连接到设备上的GATT服务器。 要连接到BLE设备上的GATT服务器，请使用connectGatt（）方法。 此方法有三个参数：一个Context对象，autoConnect（布尔值，指示是否在BLE设备变为可用时自动连接）以及对BluetoothGattCallback的引用： 1mBluetoothGatt = device.connectGatt(this, false, mGattCallback); 这将连接到由BLE设备托管的GATT服务器，并返回一个BluetoothGatt实例，然后您可以使用该实例来执行GATT客户端操作。 调用者（Android应用程序）是GATT客户端。 BluetoothGattCallback用于向客户端传递结果，例如连接状态，以及任何其他GATT客户端操作 在这个例子中，BLE应用程序提供了一个Activity（DeviceControlActivity）来连接，显示数据，并显示设备支持的GATT服务和特性。 根据用户输入，此Activity与一个名为BluetoothLeService的服务进行通信，该服务通过Android BLE API与BLE设备进行交互： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// A service that interacts with the BLE device via the Android BLE API.public class BluetoothLeService extends Service &#123; private final static String TAG = BluetoothLeService.class.getSimpleName(); private BluetoothManager mBluetoothManager; private BluetoothAdapter mBluetoothAdapter; private String mBluetoothDeviceAddress; private BluetoothGatt mBluetoothGatt; private int mConnectionState = STATE_DISCONNECTED; private static final int STATE_DISCONNECTED = 0; private static final int STATE_CONNECTING = 1; private static final int STATE_CONNECTED = 2; public final static String ACTION_GATT_CONNECTED = &quot;com.example.bluetooth.le.ACTION_GATT_CONNECTED&quot;; public final static String ACTION_GATT_DISCONNECTED = &quot;com.example.bluetooth.le.ACTION_GATT_DISCONNECTED&quot;; public final static String ACTION_GATT_SERVICES_DISCOVERED = &quot;com.example.bluetooth.le.ACTION_GATT_SERVICES_DISCOVERED&quot;; public final static String ACTION_DATA_AVAILABLE = &quot;com.example.bluetooth.le.ACTION_DATA_AVAILABLE&quot;; public final static String EXTRA_DATA = &quot;com.example.bluetooth.le.EXTRA_DATA&quot;; public final static UUID UUID_HEART_RATE_MEASUREMENT = UUID.fromString(SampleGattAttributes.HEART_RATE_MEASUREMENT); // Various callback methods defined by the BLE API. private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; String intentAction; if (newState == BluetoothProfile.STATE_CONNECTED) &#123; intentAction = ACTION_GATT_CONNECTED; mConnectionState = STATE_CONNECTED; broadcastUpdate(intentAction); Log.i(TAG, &quot;Connected to GATT server.&quot;); Log.i(TAG, &quot;Attempting to start service discovery:&quot; + mBluetoothGatt.discoverServices()); &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123; intentAction = ACTION_GATT_DISCONNECTED; mConnectionState = STATE_DISCONNECTED; Log.i(TAG, &quot;Disconnected from GATT server.&quot;); broadcastUpdate(intentAction); &#125; &#125; @Override // New services discovered public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); &#125; else &#123; Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status); &#125; &#125; @Override // Result of a characteristic read operation public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); &#125; &#125; ... &#125;;...&#125; 当一个特定的回调被触发时，它会调用相应的broadcastUpdate（）辅助方法并传递一个动作。 请注意，本节中的数据解析是根据蓝牙心率测量配置文件规范执行的： 12345678910111213141516171819202122232425262728293031323334353637private void broadcastUpdate(final String action) &#123; final Intent intent = new Intent(action); sendBroadcast(intent);&#125;private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) &#123; final Intent intent = new Intent(action); // This is special handling for the Heart Rate Measurement profile. Data // parsing is carried out as per profile specifications. if (UUID_HEART_RATE_MEASUREMENT.equals(characteristic.getUuid())) &#123; int flag = characteristic.getProperties(); int format = -1; if ((flag &amp; 0x01) != 0) &#123; format = BluetoothGattCharacteristic.FORMAT_UINT16; Log.d(TAG, &quot;Heart rate format UINT16.&quot;); &#125; else &#123; format = BluetoothGattCharacteristic.FORMAT_UINT8; Log.d(TAG, &quot;Heart rate format UINT8.&quot;); &#125; final int heartRate = characteristic.getIntValue(format, 1); Log.d(TAG, String.format(&quot;Received heart rate: %d&quot;, heartRate)); intent.putExtra(EXTRA_DATA, String.valueOf(heartRate)); &#125; else &#123; // For all other profiles, writes the data formatted in HEX. final byte[] data = characteristic.getValue(); if (data != null &amp;&amp; data.length &gt; 0) &#123; final StringBuilder stringBuilder = new StringBuilder(data.length); for(byte byteChar : data) stringBuilder.append(String.format(&quot;%02X &quot;, byteChar)); intent.putExtra(EXTRA_DATA, new String(data) + &quot;\n&quot; + stringBuilder.toString()); &#125; &#125; sendBroadcast(intent);&#125; 回到DeviceControlActivity中，这些事件由BroadcastReceiver处理： 1234567891011121314151617181920212223242526272829// Handles various events fired by the Service.// ACTION_GATT_CONNECTED: connected to a GATT server.// ACTION_GATT_DISCONNECTED: disconnected from a GATT server.// ACTION_GATT_SERVICES_DISCOVERED: discovered GATT services.// ACTION_DATA_AVAILABLE: received data from the device. This can be a// result of read or notification operations.private final BroadcastReceiver mGattUpdateReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) &#123; mConnected = true; updateConnectionState(R.string.connected); invalidateOptionsMenu(); &#125; else if (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) &#123; mConnected = false; updateConnectionState(R.string.disconnected); invalidateOptionsMenu(); clearUI(); &#125; else if (BluetoothLeService. ACTION_GATT_SERVICES_DISCOVERED.equals(action)) &#123; // Show all the supported services and characteristics on the // user interface. displayGattServices(mBluetoothLeService.getSupportedGattServices()); &#125; else if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) &#123; displayData(intent.getStringExtra(BluetoothLeService.EXTRA_DATA)); &#125; &#125;&#125;; 读取BLE属性一旦你的Android应用程序连接到GATT服务器并发现服务，它就可以在支持的地方读取和写入属性。例如，这个代码片段遍历服务器的服务和特性，并在UI中显示它们： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class DeviceControlActivity extends Activity &#123; ... // （演示）Demonstrates how to （遍历）iterate through the supported GATT // Services/Characteristics. // In this sample, we （填充）populate the data structure that is bound to the // ExpandableListView on the UI. private void displayGattServices(List&lt;BluetoothGattService&gt; gattServices) &#123; if (gattServices == null) return; String uuid = null; String unknownServiceString = getResources(). getString(R.string.unknown_service); String unknownCharaString = getResources(). getString(R.string.unknown_characteristic); ArrayList&lt;HashMap&lt;String, String&gt;&gt; gattServiceData = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); ArrayList&lt;ArrayList&lt;HashMap&lt;String, String&gt;&gt;&gt; gattCharacteristicData = new ArrayList&lt;ArrayList&lt;HashMap&lt;String, String&gt;&gt;&gt;(); mGattCharacteristics = new ArrayList&lt;ArrayList&lt;BluetoothGattCharacteristic&gt;&gt;(); // Loops through available GATT Services. for (BluetoothGattService gattService : gattServices) &#123; HashMap&lt;String, String&gt; currentServiceData = new HashMap&lt;String, String&gt;(); uuid = gattService.getUuid().toString(); currentServiceData.put( LIST_NAME, SampleGattAttributes. lookup(uuid, unknownServiceString)); currentServiceData.put(LIST_UUID, uuid); gattServiceData.add(currentServiceData); ArrayList&lt;HashMap&lt;String, String&gt;&gt; gattCharacteristicGroupData = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = gattService.getCharacteristics(); ArrayList&lt;BluetoothGattCharacteristic&gt; charas = new ArrayList&lt;BluetoothGattCharacteristic&gt;(); // Loops through available Characteristics. for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) &#123; charas.add(gattCharacteristic); HashMap&lt;String, String&gt; currentCharaData = new HashMap&lt;String, String&gt;(); uuid = gattCharacteristic.getUuid().toString(); currentCharaData.put( LIST_NAME, SampleGattAttributes.lookup(uuid, unknownCharaString)); currentCharaData.put(LIST_UUID, uuid); gattCharacteristicGroupData.add(currentCharaData); &#125; mGattCharacteristics.add(charas); gattCharacteristicData.add(gattCharacteristicGroupData); &#125; ... &#125;...&#125; 接收GATT通知BLE应用程序在设备上发生特定特征变化时要求收到通知是很常见的。这段代码展示了如何使用setCharacteristicNotification（）方法为特性设置通知 12345678910private BluetoothGatt mBluetoothGatt;BluetoothGattCharacteristic characteristic;boolean enabled;...mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);...BluetoothGattDescriptor descriptor = characteristic.getDescriptor( UUID.fromString(SampleGattAttributes.CLIENT_CHARACTERISTIC_CONFIG));descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);mBluetoothGatt.writeDescriptor(descriptor); 一旦为特征启用了通知，如果特性在远程设备上发生变化，则会触发onCharacteristicChanged（）回调： 123456@Override// Characteristic notificationpublic void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);&#125; 关闭客户端App一旦您的应用程序使用BLE设备，应该调用close（），以便系统可以正确释放资源： 1234567public void close() &#123; if (mBluetoothGatt == null) &#123; return; &#125; mBluetoothGatt.close(); mBluetoothGatt = null;&#125; Android BLE APIBluetoothAdapter代表本地设备蓝牙适配器。 BluetoothAdapter允许您执行基本的蓝牙任务，例如启动设备发现，查询绑定（配对）设备列表，使用已知的MAC地址实例化BluetoothDevice，并创建BluetoothServerSocket以侦听来自其他设备的连接请求，并启动扫描蓝牙LE设备。 要获得代表本地蓝牙适配器的BluetoothAdapter，请在BluetoothManager上调用getAdapter（）函数。在JELLY_BEAN_MR1和下面，您将需要使用静态getDefaultAdapter（）方法。 从根本上说，这是所有蓝牙操作的起点。一旦你有了本地适配器，你就可以用getBondedDevices（）获得一组代表所有配对设备的BluetoothDevice对象。用startDiscovery（）启动设备发现;或者用listenUsingRfcommWithServiceRecord（String，UUID）创建一个BluetoothServerSocket监听传入的连接请求;或使用startLeScan（LeScanCallback）开始扫描蓝牙LE设备。 注：大多数方法需要BLUETOOTH权限，有些还需要BLUETOOTH_ADMIN权限。 BluetoothAdapter.LeScanCallback：用于提供LE扫描结果的回调接口。 BluetoothManager用于获取BluetoothAdapter的实例并进行整体蓝牙管理。使用带有BLUETOOTH_SERVICE的getSystemService（java.lang.String）来创建一个BluetoothManager，然后调用getAdapter（）来获得BluetoothAdapter BluetoothGatt蓝牙GATT配置文件的公共API。 本class提供蓝牙GATT功能，以实现与Bluetooth Smart或Smart Ready设备的通信。 要连接到远程外围设备，请创建一个BluetoothGattCallback并调用connectGatt（Context，boolean，BluetoothGattCallback）来获取此类的一个实例。 使用蓝牙设备发现或BLE扫描过程可以发现支持GATT的设备。 BluetoothGattCallback这个抽象类的作用是实现BluetoothGatt的回调。 BluetoothGattCharacteristic代表蓝牙GATT特性。GATT特性是用于构建GATT服务的基本数据元素，BluetoothGattService。 该特性包含一个值以及附加信息和可选的GATT描述符BluetoothGattDescriptor。 BluetoothGattService代表一个蓝牙GATT服务。Gatt服务包含一系列BluetoothGattCharacteristic以及引用的服务。 BluetoothGattDescriptor代表一个蓝牙GATT描述符.GATT描述符包含GATT特性的附加信息和属性，BluetoothGattCharacteristic。 它们可以用来描述特征的特征或控制特征的某些行为。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3-Scrapy爬取地址5级联动数据 - 初级]]></title>
    <url>%2FPython3-Scrapy%E7%88%AC%E5%8F%96%E5%9C%B0%E5%9D%805%E7%BA%A7%E8%81%94%E5%8A%A8%E6%95%B0%E6%8D%AE%20-%20%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Scrapy使用 - “区划代码和城乡划分代码”数据爬取 - 初级 1. 数据来源国家统计局： http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html 2. Scrapy框架、项目结构： 3. 原始数据3.1 第一级：省、直辖市 3.2 第二级：地级市 3.3 第三级：区、县、乡 3.4 第四级：街道、镇 3.5 第五级：社区、居委会、村 3.6 区域代码含义：37(省)07(市)84(区)118(镇)224(村) 3.7 城乡分类代码 100 城镇 110 城区 111 主城区 112 城乡结合区 120 镇区 121 镇中心区 122 镇乡结合区 123 特殊区域 200 乡村 210 乡中心区 220 村庄 4. 数据库结构4.1 整体结构 4.2 类似的表结构 5. 爬取数据结果5.1 第四级：镇数据获取log 5.2 第五级：村数据获取log 5.3 第四级：镇数据 数量 - 42866 5.4 第五级：村数据 数量 - 666655 6. 执行代码6.1 核心处理： 目的数据解析： 12node = sel.xpath('//tr[@class="provincetr"]/td/a/text()')node_href = sel.xpath('//tr[@class="provincetr"]/td/a/@href') 爬取嵌套URL： 12 cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + province_href[1:8]yield Request(url=cl, callback=self.parse_second, dont_filter=True) 向数据库填写数据： 1234567891011121314151617181920n = len(node_city) m = 0 while m &lt; n: code = json.dumps((node_city[m:m + 1]).extract(), ensure_ascii=False) name = json.dumps((node_city[m + 1:m + 2]).extract(), ensure_ascii=False) print(code[1:len(code) - 1]) print(name[1:len(name) - 1]) db = NorthernOpenSpacePipeline() sql = "insert into city_table (" + 'city_code,' + 'city_name,' + 'simple_city_code,' + 'grade' + ") VALUE (" + code[ 1:len( code) - 1] + "," + name[ 1:len( name) - 1] + "," + ( code[ 1:len( code) - 1])[ 1:5] + "," + "2" + ")" db.insertIntoTable(sql=sql) m = m + 2 6.2 代码版本展示Version 1 - 获取数据，通过Terminal显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222# coding=utf-8# 要在代码中使用"中文"注释，应该首先添加如上注释，说明是中文注释import jsonfrom scrapy import Spider, Selectorfrom scrapy.http.request import Requestimport reclass NOSSpider(Spider): name = "NOS" allowed_domains = ["www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm"] start_urls = ["http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"] # 第一级 url， 省级信息 一级 def parse(self, response): sel = Selector(response) items = [] node = sel.xpath('//tr[@class="provincetr"]/td/a/text()') node_href = sel.xpath('//tr[@class="provincetr"]/td/a/@href') for item_node in node: province_name = json.dumps(item_node.extract(), ensure_ascii=False) # 名称 ："山东省" # print(province_name) for item_node2 in node_href: province_href = json.dumps(item_node2.extract(), ensure_ascii=False) province_code = province_href[1:3] # Url ："37.html" # print(province_href) # 代码 ：37 # print(province_code) # 获取当前省级名称下的 地级市信息 二级 cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + province_href[1:8] yield Request(url=cl, callback=self.parse_second, dont_filter=True) def parse_second(self, response): second = Selector(response) # node_city = json.dumps(sell.xpath('//tr[@class="citytr"]/td/a/text()').extract(), ensure_ascii=False) node_city = second.xpath('//tr[@class="citytr"]/td/a/text()') node_city_href = second.xpath('//tr[@class="citytr"]/td/a/@href') # print(node_city) # 城市代码list city_codes = [] # 城市名称list city_name = [] # 城市href list city_href = [] for item in node_city: city = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if city[1:13].isdigit(): # 将字符串数据存至list类型数据中 city_codes.append(city) # print("代码：") # print(city) else: city_name.append(city) # print("名称：") # print(city) for href_item in node_city_href: city_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "城市href" 添加至 "list中" city_href.append(city_href_item) # 对得到的 "城市href" 做 "list去重" city_href = list(set(city_href)) city_codes = list(set(city_codes)) city_name = list(set(city_name)) for item in city_href: cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + item[1:13] # 第三级数据展示 yield Request(url=cl, callback=self.parse_thread, dont_filter=True) def parse_thread(self, response): thread = Selector(response) node_county = thread.xpath('//tr[@class="countytr"]/td/a/text()') node_county_href = thread.xpath('//tr[@class="countytr"]/td/a/@href') # 县区级 代码list county_codes = [] # 县区级 名称list county_name = [] # 县区级 href list county_href = [] for item in node_county: county = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if county[1:13].isdigit(): # 将字符串数据存至list类型数据中 county_codes.append(county) # print("代码：") # print(county) else: county_name.append(county) # print("名称：") # print(county) for href_item in node_county_href: county_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "县区级 href" 添加至 "list中" county_href.append(county_href_item) # 对得到的 "县区级 href" 做 "list去重" county_href = list(set(county_href)) county_codes = list(set(county_codes)) # print(county_codes) county_name = list(set(county_name)) for href, codes in zip(county_href, county_codes): # 57 68 cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + codes[1:3] + "/" + href[1:15] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # 第四级数据展示 yield Request(url=cl, callback=self.parse_fourth, dont_filter=True) def parse_fourth(self, response): thread = Selector(response) node_towntr = thread.xpath('//tr[@class="towntr"]/td/a/text()') node_towntr_href = thread.xpath('//tr[@class="towntr"]/td/a/@href') # 街道办 代码list towntr_codes = [] # 街道办 名称list towntr_name = [] # 街道办 href list towntr_href = [] for item in node_towntr: towntr = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if towntr[1:13].isdigit(): # 将字符串数据存至list类型数据中 towntr_codes.append(towntr) print("代码：") print(towntr) else: towntr_name.append(towntr) print("名称：") print(towntr) for href_item in node_towntr_href: towntr_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # print(towntr_href_item) # 将单个 "街道办 href" 添加至 "list中" towntr_href.append(towntr_href_item) # 对得到的 "街道办 href" 做 "list去重" towntr_href = list(set(towntr_href)) towntr_codes = list(set(towntr_codes)) towntr_name = list(set(towntr_name)) for href, code in zip(towntr_href, towntr_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + code[1:3] + "/" + code[3:5] + "/" + href[1:18] print(cl) # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/65/29/652927.html # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/21/211321001.html # code : 211321001000 # href : 21/211321001.html # 第五级数据展示 yield Request(url=cl, callback=self.parse_Five, dont_filter=True) def parse_Five(self, response): thread = Selector(response) node_village = thread.xpath('//tr[@class="villagetr"]/td/text()') # 社区 区划代码 list village_codes = [] # 社区 城乡分类代码 list village_categary = [] # 社区 名称 list village_name = [] for item in node_village: village = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if village[1:12].isdigit(): # 将字符串数据存至list类型数据中 village_codes.append(village) print("代码：") print(village) elif village[1:4].isdigit(): print("城乡分类代码：") village_categary.append(village) print(village) else: village_name.append(village) print("名称：") print(village) # 对得到的 "街道办 href" 做 "list去重" village_categary = list(set(village_categary)) village_codes = list(set(village_codes)) village_name = list(set(village_name)) Version 2 - 处理，简化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215# coding=utf-8# 要在代码中使用"中文"注释，应该首先添加如上注释，说明是中文注释import jsonfrom scrapy import Spider, Selectorfrom scrapy.http.request import Request"""从"国家统计局"官网爬取行政区域数据url:http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"""class NOSSpider(Spider): # 基础配置 - 唯一名称 name = "NOS" # 基础配置 - 允许访问的域名 allowed_domains = ["www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm"] # 基础配置 - 开发爬取的地址 start_urls = ["http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"] """第一级：省级、直辖市 数据爬取""" def parse(self, response): sel = Selector(response) node = sel.xpath('//tr[@class="provincetr"]/td/a/text()') node_href = sel.xpath('//tr[@class="provincetr"]/td/a/@href') for item_node, item_node2 in zip(node, node_href): # 名称 ："山东省" province_name = json.dumps(item_node.extract(), ensure_ascii=False) # 名称 ："37.html" province_href = json.dumps(item_node2.extract(), ensure_ascii=False) # 名称 ："37" province_code = province_href[1:3] # 拼接：地级市信息 二级 cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + province_href[1:8] yield Request(url=cl, callback=self.parse_second, dont_filter=True) """第二级：地级市 数据爬取""" def parse_second(self, response): second = Selector(response) node_city = second.xpath('//tr[@class="citytr"]/td/a/text()') node_city_href = second.xpath('//tr[@class="citytr"]/td/a/@href') # 城市代码list city_codes = [] # 城市名称list city_name = [] # 城市href list city_href = [] for item, href_item in zip(node_city, node_city_href): city = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if city[1:13].isdigit(): # 将字符串数据存至list类型数据中 city_codes.append(city) # print("代码：") else: city_name.append(city) # print("名称：") city_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "城市href" 添加至 "list中" city_href.append(city_href_item) # 做 "list去重" city_href = list(set(city_href)) city_codes = list(set(city_codes)) city_name = list(set(city_name)) for item in city_href: cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + item[1:13] # 第三级url拼接 yield Request(url=cl, callback=self.parse_thread, dont_filter=True) """第三级：区县乡级 数据爬取""" def parse_thread(self, response): thread = Selector(response) node_county = thread.xpath('//tr[@class="countytr"]/td/a/text()') node_county_href = thread.xpath('//tr[@class="countytr"]/td/a/@href') # 县区级 代码list county_codes = [] # 县区级 名称list county_name = [] # 县区级 href list county_href = [] for item, href_item in zip(node_county, node_county_href): county = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if county[1:13].isdigit(): # 将字符串数据存至list类型数据中 county_codes.append(county) # print("代码：") else: county_name.append(county) # print("名称：") county_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "县区级 href" 添加至 "list中" county_href.append(county_href_item) # 做 "list去重" county_href = list(set(county_href)) county_codes = list(set(county_codes)) county_name = list(set(county_name)) for href, codes in zip(county_href, county_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + codes[1:3] + "/" + href[1:15] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # 第四级url拼接 yield Request(url=cl, callback=self.parse_fourth, dont_filter=True) """第四级：街道、居委会级 数据爬取""" def parse_fourth(self, response): thread = Selector(response) node_towntr = thread.xpath('//tr[@class="towntr"]/td/a/text()') node_towntr_href = thread.xpath('//tr[@class="towntr"]/td/a/@href') # 街道办 代码list town_codes = [] # 街道办 名称list town_name = [] # 街道办 href list town_href = [] for item, href_item in zip(node_towntr, node_towntr_href): town = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if town[1:13].isdigit(): town_codes.append(town) # print("代码：") else: town_name.append(town) # print("名称：") towntr_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "街道办 href" 添加至 "list中" town_href.append(towntr_href_item) # 做 "list去重" town_href = list(set(town_href)) town_codes = list(set(town_codes)) town_name = list(set(town_name)) for href, code in zip(town_href, town_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + code[1:3] + "/" + code[3:5] + "/" + href[ 1:18] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/21/211321001.html # code : 211321001000 # href : 21/211321001.html # 第五级url拼接 yield Request(url=cl, callback=self.parse_Five, dont_filter=True) """第五级：社区级 数据爬取""" def parse_Five(self, response): thread = Selector(response) node_village = thread.xpath('//tr[@class="villagetr"]/td/text()') # 社区 区划代码 list village_codes = [] # 社区 城乡分类代码 list village_categary = [] # 社区 名称 list village_name = [] for item in node_village: village = json.dumps(item.extract(), ensure_ascii=False) if village[1:12].isdigit(): # 将字符串数据存至list类型数据中 village_codes.append(village) print("代码：") print(village) elif village[1:4].isdigit(): print("城乡分类代码：") village_categary.append(village) print(village) else: village_name.append(village) print("名称：") print(village) # 做 "list去重" village_categary = list(set(village_categary)) village_codes = list(set(village_codes)) village_name = list(set(village_name)) """ 最终结果： 代码： "610626001222" 城乡分类代码： "220" 名称： "陈砭村委会" """ Version 3 - 将数据写入到MySQL数据库0. 注意： 从本项目的一个文件中导入此文件中的某一个类时，需要导入一个完整的路劲。否则提示：ImportError: No module named items。在 settings文件中编写路径类时，同样需要编写带有路径的文件类，否则不认，同上错误 1. settings.py 1234567891011121314151617# 自动生成BOT_NAME = 'Northern_Open_Space'SPIDER_MODULES = ['Northern_Open_Space.spiders']NEWSPIDER_MODULE = 'Northern_Open_Space.spiders'ROBOTSTXT_OBEY = True# 设置请求头部，添加urlDEFAULT_REQUEST_HEADERS = &#123; "User-Agent": "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;", 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'&#125;# 手动添加FEED_EXPORT_ENCODING = 'utf-8'ITEM_PIPELINES = &#123; 'Northern_Open_Space.pipelines.NorthernOpenSpacePipeline': 300, # 保存到mysql数据库&#125; 2. pipelines.py 12345678910111213141516171819202122232425class NorthernOpenSpacePipeline(object): def insertIntoTable(self, sql): # 创建连接 conn = pymysql.connect( host='127.0.0.1', port=3306, user='root', passwd='0987', db='area_database', charset='utf8') # 要指定编码，否则中文可能乱码 # 创建游标 cursor = conn.cursor() # 执行查询语句 cursor.execute(sql) # 提交，不然无法保存新建或者修改的数据 conn.commit() # 关闭游标 cursor.close() # 关闭连接 conn.close() 3. XXXXpider.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244class NOSSpider(Spider): # 基础配置 - 唯一名称 name = "NOS" # 基础配置 - 允许访问的域名 allowed_domains = ["www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm"] # 基础配置 - 开发爬取的地址 start_urls = ["http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"] """第一级：省级、直辖市 数据爬取""" def parse(self, response): sel = Selector(response) node = sel.xpath('//tr[@class="provincetr"]/td/a/text()') node_href = sel.xpath('//tr[@class="provincetr"]/td/a/@href') for item_node, item_node2 in zip(node, node_href): # 名称 ："山东省" province_name = json.dumps(item_node.extract(), ensure_ascii=False) # 名称 ："37.html" province_href = json.dumps(item_node2.extract(), ensure_ascii=False) # 名称 ："37" province_code = province_href[1:3] # self.insertIntoProvince(province_code, province_name) cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + province_href[1:8] yield Request(url=cl, callback=self.parse_second, dont_filter=True) def insertIntoProvince(self, province_code, province_name): # 将获取的数据插入到数据库中 db = NorthernOpenSpacePipeline() sql = "insert into province_table (" + 'province_name,' + 'province_code,' + 'simple_province_code,' + 'grade' + ") VALUE (" + province_name + "," + province_code + '0000000000' + "," + province_code + "," + "1" + ")" db.insertIntoTable(sql=sql) """第二级：地级市 数据爬取""" def parse_second(self, response): second = Selector(response) node_city = second.xpath('//tr[@class="citytr"]/td/a/text()') # print(len(node_city)) # print(json.dumps(node_city.extract(), ensure_ascii=False)) node_city_href = second.xpath('//tr[@class="citytr"]/td/a/@href') # self.insertToCity(node_city) # 城市href list city_href = [] for href_item in node_city_href: city_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "城市href" 添加至 "list中" city_href.append(city_href_item) # 做 "list去重" city_href = list(set(city_href)) for item in city_href: cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + item[1:13] # 第三级url拼接 yield Request(url=cl, callback=self.parse_thread, dont_filter=True) def insertToCity(self, node_city): # 循环赋值 n = len(node_city) m = 0 while m &lt; n: code = json.dumps((node_city[m:m + 1]).extract(), ensure_ascii=False) name = json.dumps((node_city[m + 1:m + 2]).extract(), ensure_ascii=False) print(code[1:len(code) - 1]) print(name[1:len(name) - 1]) db = NorthernOpenSpacePipeline() sql = "insert into city_table (" + 'city_code,' + 'city_name,' + 'simple_city_code,' + 'grade' + ") VALUE (" + code[ 1:len( code) - 1] + "," + name[ 1:len( name) - 1] + "," + ( code[ 1:len( code) - 1])[ 1:5] + "," + "2" + ")" db.insertIntoTable(sql=sql) m = m + 2 """第三级：区县乡级 数据爬取""" def parse_thread(self, response): thread = Selector(response) node_county = thread.xpath('//tr[@class="countytr"]/td/a/text()') node_county_href = thread.xpath('//tr[@class="countytr"]/td/a/@href') # self.insertIntoCounty(node_county)# 县区级 代码list county_codes = [] # 县区级 名称list county_name = [] # 县区级 href list county_href = [] for item, href_item in zip(node_county, node_county_href): county = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if county[1:13].isdigit(): # 将字符串数据存至list类型数据中 county_codes.append(county) # print("代码：") else: county_name.append(county) # print("名称：") county_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "县区级 href" 添加至 "list中" county_href.append(county_href_item) # 做 "list去重" county_href = list(set(county_href)) county_codes = list(set(county_codes)) county_name = list(set(county_name)) for href, codes in zip(county_href, county_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + codes[1:3] + "/" + href[1:15] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/211321.html # 第四级url拼接 yield Request(url=cl, callback=self.parse_fourth, dont_filter=True) def insertIntoCounty(self, node_county): n = len(node_county) m = 0 while m &lt; n: code = json.dumps((node_county[m:m + 1]).extract(), ensure_ascii=False) name = json.dumps((node_county[m + 1:m + 2]).extract(), ensure_ascii=False) print(code[1:len(code) - 1]) print(name[1:len(name) - 1]) db = NorthernOpenSpacePipeline() sql = "insert into county_table (" + 'county_code,' + 'county_name,' + 'simple_county_code,' + 'grade' + ") VALUE (" + code[ 1:len( code) - 1] + "," + name[ 1:len( name) - 1] + "," + ( code[ 1:len( code) - 1])[ 1:7] + "," + "3" + ")" db.insertIntoTable(sql=sql) m = m + 2 """第四级：街道、居委会级 数据爬取""" def parse_fourth(self, response): thread = Selector(response) node_towntr = thread.xpath('//tr[@class="towntr"]/td/a/text()') node_towntr_href = thread.xpath('//tr[@class="towntr"]/td/a/@href') print(json.dumps(node_towntr.extract(), ensure_ascii=False)) # self.insertIntoTown(node_towntr)# 街道办 代码list town_codes = [] # 街道办 名称list town_name = [] # 街道办 href list town_href = [] for item, href_item in zip(node_towntr, node_towntr_href): town = json.dumps(item.extract(), ensure_ascii=False) # 检测当前字符串是否全部为 数字 ？ if town[1:13].isdigit(): town_codes.append(town) # print("代码：") else: town_name.append(town) # print("名称：") towntr_href_item = json.dumps(href_item.extract(), ensure_ascii=False) # 将单个 "街道办 href" 添加至 "list中" town_href.append(towntr_href_item) # 做 "list去重" town_href = list(set(town_href)) town_codes = list(set(town_codes)) town_name = list(set(town_name)) for href, code in zip(town_href, town_codes): cl = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/" + code[1:3] + "/" + code[3:5] + "/" + href[ 1:18] # http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/13/21/211321001.html # code : 211321001000 # href : 21/211321001.html # 第五级url拼接 yield Request(url=cl, callback=self.parse_Five, dont_filter=True) def insertIntoTown(self, node_towntr): n = len(node_towntr) m = 0 while m &lt; n: code = json.dumps((node_towntr[m:m + 1]).extract(), ensure_ascii=False) name = json.dumps((node_towntr[m + 1:m + 2]).extract(), ensure_ascii=False) # print(code[1:len(code) - 1]) # print(name[1:len(name) - 1]) db = NorthernOpenSpacePipeline() sql = "insert into town_table (" + 'town_code,' + 'town_name,' + 'simple_town_code,' + 'grade' + ") VALUE (" + code[ 1:len( code) - 1] + "," + name[ 1:len( name) - 1] + "," + ( code[ 1:len( code) - 1])[ 7:10] + "," + "4" + ")" db.insertIntoTable(sql=sql) m = m + 2 """第五级：社区级 数据爬取""" def parse_Five(self, response): thread = Selector(response) node_village = thread.xpath('//tr[@class="villagetr"]/td/text()') print(json.dumps(node_village.extract(), ensure_ascii=False)) n = len(node_village) m = 0 while m &lt; n: code = json.dumps((node_village[m:m + 1]).extract(), ensure_ascii=False) simple_code = json.dumps((node_village[m + 1:m + 2]).extract(), ensure_ascii=False) name = json.dumps((node_village[m + 2:m + 3]).extract(), ensure_ascii=False) print(code[1:len(code) - 1]) print(simple_code[1:len(simple_code) - 1]) print(name[1:len(name) - 1]) print((code[11:14])) db = NorthernOpenSpacePipeline() sql = "insert into village_table (" + \ 'village_code,' + 'village_name,' + 'simple_village_code,' + 'village_category_code,' + 'grade' + ") VALUE (" + \ code[1:len(code) - 1] + "," + name[1:len(name) - 1] + "," + code[11:14] + "," + simple_code[1:len(simple_code) - 1] + "," + "5" + ")" db.insertIntoTable(sql=sql) m = m + 3]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库-GreenDao]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E5%BA%93-GreenDao%2F</url>
    <content type="text"><![CDATA[GreenDao数据库使用 使用参考 greenDAO 是一个开源的 Android ORM，通过将 Java对象 映射到 数据库表（称为 ORM，“对象/关系映射”），解决编写SQL和解析查询结果非常繁琐且耗时的任务。 一. 添加依赖12345678910111213141516171819202122232425262728// In your root build.gradle file:buildscript &#123; repositories &#123; jcenter() mavenCentral() // add repository &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.1.1&apos; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin &#125;&#125; // In your app projects build.gradle file:apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin android &#123; ··· //greendao配置 greendao &#123; //版本号，升级时可配置 schemaVersion 1 &#125;&#125;dependencies &#123; implementation &apos;org.greenrobot:greendao:3.2.2&apos; // add library&#125; greenDAO核心类 DaoMaster： 使用greenDAO的切入点。DaoMaster保存数据库对象（SQLiteDatabase）并管理特定模式的 DAO类（而不是对象）。它有静态方法来创建表或删除它们。其内部类OpenHelper和DevOpenHelper是SQLiteOpenHelper实现，它们在SQLite数据库中创建模式。 DaoSession：管理特定模式的所有可用DAO对象，为开发人员提供了对基本实体操作和DAO的访问，以实现更完整的操作集。您可以使用其中一个getter方法获取该对象。DaoSession还提供了一些通用的持久性方法，如实体的：插入、加载、更新、刷新和删除。 DAO：数据访问持久存在的对象（DAO）并查询实体。 实体：可持久的对象。通常，实体是使用标准Java属性（如POJO或JavaBean）表示数据库行的对象。 实际使用 创建数据库并使用在 自定义的Application类 中进行初始化 1234DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, "notes-db", null);Database db = helper.getWritableDatabase();DaoMaster daoMaster = new DaoMaster(db);DaoSession daoSession = daoMaster.newSession(); Database是使用DaoMaster类提供的辅助类DevOpenHelper创建的 。它是DaoMaster中OpenHelper类的 一个实现 ，无需编写“CREATE TABLE”语句。 实体 和 DAO类 的创建1234567891011121314151617181920212223242526@Entitypublic class Student &#123; /** * 当前表中的学生数量的id值 */ @Id(autoincrement = true) private long id_num_stu; /** * 学生的学号 */ @Unique @NotNull private String id_stu; /** * 身份证号 */ @Unique @NotNull private String id_card_stu;&#125;``` **实体** 是持久存储在数据库中的 **类**，包含映射到数据库列的属性。在声明完 **Student** 这个实体之后，接下来就是要生成 **DAO类**，进行的操作是： 在Android Studio中使用：Build -&gt; Make project12得到的结果是： Student.java -&gt; StudentDao.java12345678## 获取一个DAO对象```JavaDaoSession daoSession = ((App) getApplication()).getDaoSession();studentDao = daoSession.getStudentDao(); DAO类的操作查询在greenDAO中，您可以使用原始SQL制定查询或者使用QueryBuilder 1QueryBuilder&lt;User&gt; qb = userDao.queryBuilder(); 在这这类中，包含了多条件查询中的各种查询，例如： where() or() and() join() oder() limit() offset() 注意： 在创建完“实体”后，记得要“build”一下，“build”之后就会生成相应的“StudentBaseDao”类文件，否则不能使用。供之后调用。 主键必须是long类型 注解说明： @Entity：告诉GreenDao该对象为实体，只有被@Entity注释的Bean类才能被dao类操作 @Id：对象的Id，使用Long类型作为EntityId，否则会报错。 @Property：可以自定义字段名，注意外键不能使用该属性 @NotNull：属性不能为空 @Transient：使用该注释的属性不会被存入数据库的字段中 @Unique：该属性值必须在数据库中是唯一值 @Generated：编译后自动生成的构造函数、方法等的注释，提示构造函数、方法等不能被修改 @ToOne：定义与另一个实体（一个实体对象）的关系（底下会有详解）.如： @ToMany：定义与多个实体对象的关系（底下会有详解） @OrderBy(date desc)：降序 关联： 参考：https://www.jianshu.com/p/dbec25bd575f 1对1 ：@ToOne(joinProperty = “userId”) ：通过外键来关联另一个实体。使用到的两个对象类为：（User，Picture） 123456789101112131415161718192021222324252627282930@Entitypublic class User &#123; @Id private Long UserId; private long pictureId; @Property(nameInDb = "NAME") private String name; @Property(nameInDb = "AGE") private String age; @Property(nameInDb = "SEX") private String sex; @ToOne(joinProperty = "pictureId")//pictureId是我们需要关联的外键 private Picture picture;&#125;@Entitypublic class Picture implements Serializable &#123; private static final long serialVersionUID = 11; @Id private Long pictureId; private long userId; @Property private String pictureName; @Property(nameInDb = "width") private String width; @Property(nameInDb = "height") private String height; @ToOne(joinProperty = "userId") private User user;&#125; 1对n： 注意：Intent传递对象需要用到：Serializable，必须把serialVersionUID 给带上，不然会报错。 12345@ToMany(referencedJoinProperty = "customerId")joinProperties这个参数是referencedJoinProperty 参数的升级版@ToMany(joinProperties = &#123; @JoinProperty(name = "id", referencedName = "customerId") &#125;) 1234567891011121314151617181920@Entitypublic class Customer &#123; @Id private Long id; @Property private String name; // @ToMany(referencedJoinProperty = "customerId") @ToMany(joinProperties = &#123;@JoinProperty(name = "id", referencedName = "customerId")&#125;) @OrderBy("date ASC") private List&lt;Order&gt; orders;&#125;@Entitypublic class Order &#123; @Id private Long id; @Property private Date date; private long customerId;&#125; m:n 多对多: 创建三个实体类，其中一个为关联类。 1234567891011121314151617181920212223242526272829@Entitypublic class Order &#123; @Id private Long id; @Property private Date date; private long customerId;&#125;@Entitypublic class Product &#123; @Id private Long id; @ToMany @JoinEntity( entity = JoinProductsWithOrders.class, sourceProperty = "productId", targetProperty = "orderId" ) private List&lt;Order&gt; ordersWithThisProduct;&#125;@Entitypublic class JoinProductsWithOrders &#123; @Id private Long id; private Long productId; private Long orderId;&#125; 2. 数据库的创建： 需要在自定义的“Application”类中进行声明。 12345678910111213141516171819202122232425262728293031323334353637public class App extends Application &#123; private static DaoSession daoSession; @Override public void onCreate() &#123; super.onCreate(); ··· //配置数据库 setupDatabase(); &#125; /** * 配置数据库 * * 1、DevOpenHelper：创建SQLite数据库的SQLiteOpenHelper的具体实现 * 2、DaoMaster：GreenDao的顶级对象，作为数据库对象、用于创建表和删除表 * 3、DaoSession：管理所有的Dao对象，Dao对象中存在着增删改查等API */ private void setupDatabase() &#123; // 创建数据库:49_class_info.db DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this,"jujia.db",null); // 获取可写数据库 SQLiteDatabase db = helper.getWritableDatabase(); // 获取数据库对象 DaoMaster daoMaster = new DaoMaster(db); // 获取Dao对象管理者 daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoInstant() &#123; return daoSession; &#125;&#125; 3. 最基本的CURD3.1 C ：增3.1 Read : 查 orderAsc：升序排序 orderDesc：降序排序 eq()： == noteq(): != gt(): &gt; t(): &lt; ge: &gt;= le: &lt;= like(): 包含 between: 两者之间 in: 在某个范围之内 notIn: 不在某个范围之内 limit(int): 限制查询的数量 - 分页 offset(int): 每次返回的数量 - 分页 unique(): 如果只想获取一个结果时 list(): 获取查询结果集合 - LazyList listLazy()懒查询：只有当调用list()中的实体对象时才会执行查询操作并且只缓存第一次被查询的结果，需要关闭 - LazyList listlazyUncached()懒查询：只有当调用list()中的实体对象时才会执行查询操作并且不缓存，需要关闭 - LazyList listIterator()：对查询结果进行遍历，不缓存，需要关闭 - LazyList 示例：123456789101112131415161718192021222324252627282930313233343536373839public class UserInfoCURD &#123; private static final String TAG = "UserInfoCURD"; /** * 增 * @param userInfoBean 实体对象 */ public static long insertToStudent(UserInfoBean userInfoBean)&#123; return App.getDaoInstant().getUserInfoBeanDao().insert(userInfoBean); &#125; /** * 删 * @param userInfoBean 实体对象 */ public static void deleteFromStudent(UserInfoBean userInfoBean)&#123; App.getDaoInstant().getUserInfoBeanDao().delete(userInfoBean); &#125; public static void deleteFromStudentAll()&#123; App.getDaoInstant().getUserInfoBeanDao().deleteAll(); &#125; /** * 改 * @param userInfoBean 实体对象 */ public static void updateToStudent(UserInfoBean userInfoBean)&#123; App.getDaoInstant().getUserInfoBeanDao().update(userInfoBean); &#125; /** * 查 - 全部 */ public static List&lt;UserInfoBean&gt; queryFromStudent()&#123; return App.getDaoInstant().getUserInfoBeanDao().loadAll(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的aseets中的文件读取]]></title>
    <url>%2FAndroid%E7%9A%84aseets%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[assets中文件的使用 1. Android资源文件大致可以分为两种： res目录下存放的可编译的资源文件：这种资源文件系统会在R.java里面自动生成该资源文件的ID，所以访问这种资源文件比较简单，通过R.XXX.ID即可； assets目录下存放的原生资源文件：系统在编译的时候不会编译assets下的资源文件。AssetManager提供对应用程序的原始资源文件进行访问；这个类提供了一个低级别的API，它允许你以简单的字节流的形式打开和读取和应用程序绑定在一起的原始资源文件。 2. AssetsManager类常量： ACCESS_UNKNOWN : 未指定具体的读取模式 ACCESS_RANDOM : 随机读取 ACCESS_STREAMING : 顺序读取 （默认） ACCESS_BUFFER : 缓存读取 方法： close(); 关闭asset manager String[] list(String path); 列出该目录下的下级文件和文件夹名称 InputStream open(String fileName); 以顺序读取模式打开文件，默认模式为ACCESS_STREAMING InputStream open(String fileName, int accessMode); 以指定模式打开文件 AssetFileDescriptor openFd (String fileName) 注意：Android中还有另外一个文件夹raw,和assets差不多,也不会被R文件编译,但是raw下不能在建文件夹,assets文件下是可以在建文件夹的,下面是获取raw文件夹下资源的方法: 1InputStream is = getResources().openRawResource(R.id.filename); 3. assets目录下主要存放四种文件： 文本文件 图像文件 网页文件（包括html中引用的js/ccs/jpg等资源 音频视频文件 4. 读取四种文件： 读取文本文件eg： 123456String fileName = "newFile.txt";InputStream is = getAssets().open(fileName); int lenght = is.available(); byte[] buffer = new byte[lenght]; is.read(buffer); String result = = new String(buffer, "utf8"); 读取图像文件： 123InputStream is = getAssets().open(fileName); bitmap = BitmapFactory.decodeStream(is); ivImg.setImageBitmap(bitmap); 读取网页文件： 1webView.loadUrl("file:///android_asset/html/index.htmll"); 读取音视频文件： 12345678910// 打开指定音乐文件,获取assets目录下指定文件的AssetFileDescriptor对象 AssetFileDescriptor afd = am.openFd(music); mPlayer.reset(); // 使用MediaPlayer加载指定的声音文件。 mPlayer.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()); // 准备声音 mPlayer.prepare(); // 播放 mPlayer.start(); 5. 将assets下的文件复制到SD卡中12345678910111213141516171819202122232425262728293031323334/** * 从assets目录中复制整个文件夹内容 * @param context Context 使用CopyFiles类的Activity * @param oldPath String 原文件路径 如：/aa * @param newPath String 复制后路径 如：xx:/bb/cc */ public void copyFilesFassets(Context context,String oldPath,String newPath) &#123; try &#123; String fileNames[] = context.getAssets().list(oldPath);//获取assets目录下的所有文件及目录名 if (fileNames.length &gt; 0) &#123;//如果是目录 File file = new File(newPath); file.mkdirs();//如果文件夹不存在，则递归 for (String fileName : fileNames) &#123; copyFilesFassets(context,oldPath + "/" + fileName,newPath+"/"+fileName); &#125; &#125; else &#123;//如果是文件 InputStream is = context.getAssets().open(oldPath); FileOutputStream fos = new FileOutputStream(new File(newPath)); byte[] buffer = new byte[1024]; int byteCount=0; while((byteCount=is.read(buffer))!=-1) &#123;//循环从输入流读取 buffer字节 fos.write(buffer, 0, byteCount);//将读取的输入流写入到输出流 &#125; fos.flush();//刷新缓冲区 is.close(); fos.close(); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); //如果捕捉到错误则通知UI线程 MainActivity.handler.sendEmptyMessage(COPY_FALSE); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EChart第三方JS库图表html文档示例]]></title>
    <url>%2FEChart%E7%AC%AC%E4%B8%89%E6%96%B9JS%E5%BA%93%E5%9B%BE%E8%A1%A8html%E6%96%87%E6%A1%A3%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[示例文档： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;&lt;div id="main" style="width: 100% ;height: 1000%; "&gt;&lt;/div&gt;&lt;!-- 编写JavaScript代码 --&gt;&lt;script type="text/javascript"&gt; // var arrName = []; // 高压 var arrDataH = []; // 低压 var arrDataL = []; // 心率 var arrDataM = []; //js调用Java function getEveryDay() &#123; return window.Fragment_Day.getDataByDay(); &#125; function getLocalTime(nS) &#123; return new Date(parseInt(nS) * 1000); &#125; function formatDate(now) &#123; var year = now.getFullYear(), month = now.getMonth() + 1, date = now.getDate(); return year + "-" + month + "-" + date; &#125; function topData() &#123; //var strData = getEveryDay(); var strData = [&#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;, &#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;, &#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;, &#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;, &#123; "addtime": 1515638273, "com_mark": "yongnuo", "h_pressure": 130, "id": 33, "idcode": "155023233265126", "l_pressure": 84, "pulse": 81 &#125;] console.log(strData); for (var i = 0; i &lt; strData.length; i++) &#123; arrName.push(formatDate(getLocalTime(strData[i].addtime))); console.log(formatDate(getLocalTime(strData[i].addtime))); arrDataH.push(strData[i].h_pressure); arrDataL.push(strData[i].l_pressure); arrDataM.push(strData[i].pulse); &#125; &#125; window.onload = function () &#123; topData(); var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; // 整体位置设置 grid: &#123; top: '10%', left: '10%', right: '4%', bottom: '15%' &#125;, // 图例设置 legend: &#123; //name=legend.data的时候才能显示图例 data: ['高压', '低压', '心率'], top: '2%', right: '10%', itemGap: 150, &#125;, // 字体大小设置 textStyle: &#123; fontSize: "150%" &#125;, // x轴设置 xAxis: &#123; type: 'category', boundaryGap: false, data: arrName, axisLabel: &#123; interval: 0, rotate: 45, formatter: '&#123;value&#125;', textStyle: &#123; fontSize: 24, &#125; &#125; &#125;, // y轴设置 yAxis: &#123; axisLabel: &#123; textStyle: &#123; fontSize: 24 &#125; &#125; &#125;, // 绘制折线 series: [ // 高压 &#123; /** * 图表样式 */ name: '高压', type: 'line', label: &#123; normal: &#123; show: true, position: 'top', fontSize: 24 &#125; &#125;, /** * 设置折线颜色 */ itemStyle: &#123; normal: &#123; color: "#cc3300", barBorderColor: "#cc3300", &#125; &#125;, /** * 设置y轴对应的具体数据 */ data: arrDataH, &#125;, // 低压 &#123; /** * 图表样式 */ name: '低压', type: 'line', label: &#123; normal: &#123; show: true, position: 'top', fontSize: 24 &#125; &#125;, /** * 设置折线颜色 */ itemStyle: &#123; normal: &#123; color: "#33aa00", barBorderColor: "#33aa00", &#125; &#125;, /** * 设置y轴对应的具体数据 */ data: arrDataL, &#125;, // 心率 &#123; /** * 图表样式 */ name: '心率', type: 'line', label: &#123; normal: &#123; show: true, position: 'top', fontSize: 24 &#125; &#125;, /** * 设置折线颜色 */ itemStyle: &#123; normal: &#123; color: "#388CD9", barBorderColor: "#388CD9", &#125; &#125;, /** * 设置y轴对应的具体数据 */ data: arrDataM, &#125;] &#125; window.onresize = myChart.resize; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终结果样式:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库-RxJava]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E5%BA%93-RxJava%2F</url>
    <content type="text"><![CDATA[参考：https://gank.io/post/560e15be2dca930e00da1083 一. 准备 Java泛型中&lt;？ extends E&gt;和&lt;？ super E&gt;的区别 参考：http://blog.csdn.net/u014513883/article/details/49820569 PECS法则 生产者（Producer）使用extends 如果你需要一个**提供**E类型元素的集合，使用泛型通配符&lt;? extends E&gt;。它好比一个生产者，可以提供数据。 消费者（Consumer）使用super 如果你需要一个只能**装入**E类型元素的集合，使用泛型通配符&lt;? super E&gt;。它好比一个消费者，可以消费你提供的数据。 既是生产者也是消费者既要存储又要读取，那就别使用泛型通配符 二. 使用方式（一）Observable中创造事件序列的方法1. create()1). Subscriber完整定义的回调123456789101112131415161718192021// Subscriber完整定义的回调Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("订阅者接收到----Hello"); subscriber.onNext("订阅者接收到----RxJava"); subscriber.onNext("订阅者接收到----Android"); subscriber.onCompleted(); &#125;&#125;).subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; onNext : " + s); &#125;&#125;); 2). Action1不完整定义的回调123456789101112131415// Action1不完整定义的回调Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("订阅者接收到----Hello"); subscriber.onNext("订阅者接收到----RxJava"); subscriber.onNext("订阅者接收到----Android"); subscriber.onCompleted(); &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + s); &#125;&#125;); Action1 和 Action0区别： Action0：是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。 Action1 ：也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。 2. just(T…) : 将传入的参数依次发送出来。12345678910111213141516171819202122232425262728293031// 使用单个StringObservable.just("just Hello", "just RxJava", "just Android").subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + s); &#125;&#125;);// 使用数组效果String[] strs = new String[]&#123;"just Hello", "just RxJava", "just Android"&#125;;Observable.just(strs).subscribe(new Action1&lt;String[]&gt;() &#123; @Override public void call(String[] strings) &#123; for (String item : strings) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + item); &#125; &#125;&#125;);// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted();/** * 结果： * just Hello * just RxJava * just Android */ 3. from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。12345678910111213141516171819202122232425// 一下两种方式产生的结果相同// 方式1String[] strs = &#123;"From Hello", "From RxJava", "From Android"&#125;;Observable.from(strs).subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; onNext haha : " + s); &#125; &#125;); // 方式2Observable.from(strs).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + s); &#125; &#125;); （二） 线程控制 ： Scheduler调度方法： subscribeOn() : 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn() ：指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 常用线程： Schedulers.immediate() : 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread() ：总是启用新线程，并在新线程执行操作。 Schedulers.io() : I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。顺序有变化。 Schedulers.computation() : 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。 AndroidSchedulers.mainThread() ：Android专用的 ，它指定的操作将在 Android 主线程运行。 示例： 123456789101112131415161718192021222324Observable.create(new Observable.OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getResources().getDrawable(R.mipmap.ic_launcher_round); subscriber.onNext(drawable); &#125;&#125;). subscribeOn(Schedulers.io()). observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onCompleted() &#123; Log.e(TAG, "aboutObservable_03 onCompleted"); &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, "aboutObservable_03 onError"); &#125; @Override public void onNext(Drawable drawable) &#123; mImage.setImageDrawable(drawable); &#125;&#125;); （三）变换将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 1. map() : 返回值为结果集。事件对象的直接变换，是一对一的转化，是 RxJava 最常用的变换。 释义 返回一个Observable，它将一个指定的函数应用于源Observable发出的每个项目，并发出这些函数应用程序的结果。 Func1()，包装的是有返回值的方法。 12345678910111213Observable.just("images/logo.png") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap &#125; &#125;) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap showBitmap(bitmap); &#125; &#125;); 2. flatMap() : 无顺序。嵌套操作。返回值为 Observable 对象。flat铺平。是一对多的转化。 释义 对Observable发射的数据都应用(apply)一个函数，这个函数返回一个Observable，然后合并这些Observables，并且发送（emit）合并的结果。 flatMap和map操作符很相像，flatMap发送的是合并后的Observables，map操作符发送的是应用函数后返回的结果集 原理： 嵌套 ：使用传入的事件对象创建一个 Observable 对象，此处嵌套Observable操作； 并不发送这个 Observable, 而是将它激活（Observable执行 “产生数据”的过程，此时，每一个事件产生若干个结果集合），但是不发送结果集合； 合并(merge)操作 —— 事件传入顺序 != 传出顺序 -&gt; 顺序混乱：每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件（结果集的集合）**统一**交给 Subscriber 的回调方法。 1234567891011121314151617181920212223242526272829303132333435363738List&lt;Course&gt; list1 = new ArrayList&lt;Course&gt;();list1.add(new Course("three - Android", 1));list1.add(new Course("three - JSP", 3));List&lt;Course&gt; list2 = new ArrayList&lt;Course&gt;();list2.add(new Course("three - Object-C", 1));list2.add(new Course("three - HTML 5", 2));StudentInCourse[] students = new StudentInCourse[]&#123; new StudentInCourse("张三", "男", 10, list1), new StudentInCourse("張小盒", "女", 20, list2),&#125;; Observable.from(students). flatMap(new Func1&lt;StudentInCourse, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(StudentInCourse studentInCourse) &#123; return Observable.from(studentInCourse.getList()); &#125; &#125;).subscribe(new Subscriber&lt;Course&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(Course course) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; onNext : " + course.toString()); &#125;&#125;);/** * Course&#123;name='three - Android', id=1&#125; * Course&#123;name='three - JSP', id=3&#125; * Course&#123;name='three - Object-C', id=1&#125; * Course&#123;name='three - HTML 5', id=2&#125; */ 详细说明：图片来自网络：https://www.jianshu.com/p/52cd2d514528 123由上图可以看出Student1、Student2经过flatMap后，按顺序依次经历了Observable1、Observable2，分别转化为Course。最后按顺序得到Course1、Course2、Course3、Course4、Course5、Course6，其中1-3由Student1得到，4-6由Student2得到。 我个人是在看到如上的配图+文字说明后，才恍然大悟的。 3. concatMap() ：有顺序性。同flatMap()相似 4.1 concat() : 多个数据源建立联系，one by one 参考：https://www.jianshu.com/p/94c433057440 官方图 网络图：多个数据源一个接一个的连接成为一个数据源 注意： 在使用此方法时，需要搭配onComplete() 或者 onError()。否则，最终返回的结果只能是第一个数据请求得到的结果。 使用场景： 4.1 需要同时处理多个数据请求，最终需要将其作为一个统一的数据进行返回。 4.2 依次检查memory、disk和network中是否存在数据，任何一步一旦发现数据后面的操作都不执行。 搭配使用： first() : 请求多数据源时，只要有一个请求到数据（满足需求），即停止其他请求，动作。 takeFirst() : 当请求多数据源时，所有的请求都没有数据时，为null时，不会报异常。 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 信息1Observable&lt;Object&gt; oneOb = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; String one = "商品信息1"; subscriber.onNext(one); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io());// 信息2Observable&lt;Object&gt; twoOb = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; String one = "这是艺术家的信息"; subscriber.onNext(one); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io());// 信息3Observable&lt;Object&gt; threeOb = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; Integer one = 123; subscriber.onNext(one); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io());// 信息汇总Observable.concat(oneOb, twoOb, threeOb).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object o) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + o.toString()); &#125;&#125;);/** * 商品信息1 * 这是艺术家的信息 * 123 */ // 只需要其中一个数据源有数据即可，即停止当前数据请求 Observable.concat(oneOb, twoOb, threeOb) // first()函数的使用 .first() .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object o) &#123; Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; call : " + o.toString()); &#125;&#125;);/** * 商品信息1 */ 4.2 merge() 合并 4.3 compose() 组合5. zip() : 合并多个数据流，然后发送最终合并的数据。 参考：http://blog.csdn.net/johnny901114/article/details/51614927 使用场景： 在很多app种都会有图片上传的功能，比如商品的评价，客户端允许用户拍照上传(可能多张)，把图片上传到服务器，然后获取图片的url，再把图片的信息（图片url，图片大小）发送给服务器。 参考代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 1,先把所有的图片上传到又拍云（比如3张图片） * 2,获取图片的url路径，图片大小等 * 3,最后把数据全部提交给服务器 *///需要上传的图片Picture[] ps = xxx;Observable.zip( Observable.from(ps), getUpYunAddress(ps.length),//获取上传的url new Func2&lt;Picture, UpYunAddress, Picture&gt;() &#123; @Override public Picture call(Picture picture, UpYunAddress upYunAddress) &#123; //如果该图片已经上传则不应该上传 if (TextUtils.isEmpty(picture.getSource())) &#123; try &#123; //使用又拍云提供的工具类，上传图片 String path = UpYunUtil.uploadImage(upYunAddress, picture.getLocalUrl()); //获取最终的url String finalUrl = upYunAddress.getPrefix() + path; picture.setSource(finalUrl); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return picture; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) //上传成功后获取图片大小 .flatMap(new Func1&lt;Picture, Observable&lt;Picture&gt;&gt;() &#123; @Override public Observable&lt;Picture&gt; call(Picture picture) &#123; if (TextUtils.isEmpty(picture.getHeight()) || TextUtils.isEmpty(picture.getWidth())) &#123; BitmapFactory.Options options; if (!TextUtils.isEmpty(picture.getLocalUrl())) &#123; options = ImageUtil.getBitmapOptions(picture.getLocalUrl()); picture.setLocalUrl(null); &#125; else &#123; options = ImageUtil.getBitmapOptions(picture.getSource()); &#125; picture.setWidth(String.valueOf(options.outWidth)); picture.setHeight(String.valueOf(options.outHeight)); &#125; return Observable.just(picture); &#125; &#125;); //最后处理最终的数据。 4. filter() ：集合进行过滤5. each() ：遍历集合6. take() ：取出集合中的前几个7. skip() ：跳过前几个元素]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View - 点击事件分发机制]]></title>
    <url>%2FAndroid%20View-%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[参考：https://developer.android.com/reference/android/view/MotionEvent.html 1. View描述1.1 基本描述View 是Android中 所有控件的基类，单个控件为 VIew，多个组合为 ViewGroup。View树 的结构类似于 Web 中的DOM树。 1.2 View位置参数 参数说明： 定位View的坐标：左（left）上（top）、右（right）下（bottom）； 获取 左上右下： left = getLeft(); top = getTop(); right = getRight(); bottom = getBottom(); x，y：相对于父容器，View左上角的坐标； translationX，translationY：View左上角相对于父容器的偏移量，默认为0； 参数换算关系： 1x = left + translationX; 2. View操作相关 MotionEvent：触摸事件的信息 TouchSlop：最小滑动距离 VelocityTracker：速度追踪类 GestureDetector：手势操作识别类 Scroller： 2.1 MotionEvent2.1.1 概念描述 动作代码 + 一组轴值 来描述运动。 动作代码 ：发生的状态变化，如指针向下或向上 一族轴值 ：描述位置和其他运动属性 例如，当用户第一次触摸屏幕时，系统View通过动作代码 ACTION_DOWN 和一组包含触摸的 X 和 Y 坐标的轴值以及关于触摸的压力，大小和方向的信息接触面积。 运动事件 与 指针 有些设备可以同时报告多个移动轨迹。多点触摸屏为每个手指发出一个运动轨迹。产生运动轨迹的各个手指或其他物体被称为指针。运动事件包含有关当前活动的所有指针的信息，即使其中一些指针自从上次事件发送以来尚未移动。除非手势被取消，否则指针的数目只会随着单个指针的上下而改变。 指针ID” 与 索引 每个指针都有一个唯一的标识，当它第一次出现时被分配（用 ACTION_DOWN 表示 ACTION_POINTER_DOWN）。指针ID保持有效，直到指针最终上升（由 ACTION_UP 或指示 ACTION_POINTER_UP）或手势被取消（由指示 ACTION_CANCEL）。 MotionEvent类 提供许多方法来查询位置和指针，如 getX(int)，getY(int)，getAxisValue(int)， getPointerId(int)，getToolType(int) 。大多数这些方法接受指针索引作为参数，而不是指针ID。事件中每个指针的指针索引的范围从0到1小于返回的值getPointerCount()。 单个指针在运动事件中出现的顺序是不确定的。因此，指针的指针索引可以从一个事件改变到下一个，但是只要指针保持活动状态，指针的指针ID就保证保持不变。使用该 getPointerId(int) 方法获取指针的 指针ID，以在手势中的所有后续运动事件中跟踪指针。然后对于连续运动事件，使用该findPointerIndex(int)方法获取该运动事件中给定指针标识的指针索引。 坐标 使用最新的指针坐标 ：使用getX(int)和可以getY(int)。使用较早坐标 ： 使用 getHistoricalX(int, int)和访问批次内的getHistoricalY(int, int)。坐标是“历史的”，只要它们比批中的当前坐标更早; 然而，它们仍然不同于之前的动作事件中报告的任何其他坐标。要按时间顺序处理批次中的所有坐标，请先消耗历史坐标，然后消耗当前坐标。 设备类型 MotionEvent内容的解释根据设备的源类别而有很大的不同。 2.1.2 事件类型123456789int action = MotionEventCompat.getActionMasked(event); switch(action) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: break; case MotionEvent.ACTION_UP: break; &#125; ACTION_MASK : 作为动作本身的动作代码部分的位掩码 常量 getActionMasked() 非触摸事件，所以它被传递给 onGenericMotionEvent(MotionEvent) ACTION_BUTTON_PRESS 按钮已被按下。常量值：11（0x0000000b） ACTION_BUTTON_RELEASE 一个按钮已被释放。常量值：12（0x0000000c） ACTION_HOVER_ENTER 指针未关闭，但已经进入窗口或视图的边界。常量值：9（0x00000009） ACTION_HOVER_EXIT 指针没有关闭，但已经退出了窗口或视图的边界。常量值：10（0x0000000a） ACTION_HOVER_MOVE 发生了改变，但指针没有下降（不像ACTION_MOVE）常量值：7（0x00000007） ACTION_SCROLL 运动事件包含相对垂直和/或水平滚动偏移。常量值：8（0x00000008） 常量 getActionMasked() 使用getButtonState()检索按钮状态 ACTION_DOWN 按下的手势已经开始，运动包含初始起始位置。常量值：0（0x00000000） ACTION_MOVE 在按下手势期间（在ACTION_DOWN和之间ACTION_UP）发生改变。常数值：2（0x00000002） ACTION_UP 按下的手势已经完成，常数值 : 1 (0x00000001) ACTION_CANCEL 当前手势已被中止。如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个ACTION_CANCEL事件。常数值 : 3 (0x00000003) ACTION_OUTSIDE 移动发生在UI元素的正常界限之外。注意：由于任何事件的位置都将超出视图层次结构的范围，因此默认情况下不会将其分派给ViewGroup的任何子项。因此，ACTION_OUTSIDE的移动应该以根View或适当的方式Window.Callback （例如Activity或Dialog）来处理。常量值：4（0x00000004） ACTION_POINTER_DOWN 非主指针已关闭 ACTION_POINTER_UP 非主指针已经上升。 ACTION_POINTER_INDEX_MASK 代表指针索引的动作代码中的位，与 ACTION_POINTER_DOWN和一起使用 ACTION_POINTER_UP。 非主指针已经上升。常量值：1（0x00000001） ACTION_POINTER_INDEX_SHIFT 按照定义，保存指针索引的动作位的位移ACTION_POINTER_INDEX_MASK 2.1.3 主要公共方法 公共方法 说明 getAction() 返回正在执行的操作。 getActionButton() 获取在按下或释放操作期间哪个按钮已被修改。 findPointerIndex(int pointerId) 给定一个指针标识符，在事件中找到它的数据索引 getActionIndex() 对于ACTION_POINTER_DOWN或ACTION_POINTER_UP 作为返回getActionMasked()，这将返回关联的指针索引。 getActionMasked() 返回正在执行的被屏蔽的操作，没有指针索引信息。 getDeviceId() 获取此事件来自的设备的ID。 getDownTime() 返回用户最初按下时启动位置事件流的时间（以毫秒为单位）。 getFlags() 获取运动事件标志。 getHistoricalEventTime(int pos) 返回在此事件和上一个事件之间发生历史移动的uptimeMillis()时间。 getHistoricalOrientation(int pointerIndex, int pos) 根据getOrientation(int)在此事件与给定指针的上一个事件之间发生的历史方向坐标返回历史方向坐标。 setSource(int source) 修改事件的来源。 setLocation(float x, float y) 设置这个事件的位置。 offsetLocation(float deltaX, float deltaY) 调整此事件的位置。 setAction(int action) 设置此事件的操作。 recycle() 回收MotionEvent，以供稍后调用者重新使用。 getYPrecision() 返回正在报告的Y坐标的精度。 getY(int pointerIndex) 返回给定指针索引的此事件的Y坐标 （用于getPointerId(int)查找此索引的指针标识符）。 getY() getY(int) 为第一个指针索引（可能是一个任意的指针标识符）。 getRawY() 返回此事件的原始Y坐标。 getPressure(int pointerIndex) 返回给定指针索引的此事件的当前压力 （用于getPointerId(int)查找此索引的指针标识符）。 getSize(int pointerIndex) 返回给定指针索引的近似大小的缩放值 （用于getPointerId(int)查找此索引的指针标识符）。 getPointerCount() 包含在这个事件中的数据指针的数量。 getOrientation(int pointerIndex) 返回给定指针索引（用于getPointerId(int)查找此索引的指针标识符）的触摸区域和工具区域的方向，从垂直方向顺时针旋转弧度。 getSource() 获取事件的来源。 2.1.4 事件坐标的含义 getX()和getY()：相对坐标值，相对于消费这个事件的视图的左上点的坐标。 getRawX()和getRawY(): 绝对坐标值，相对于屏幕。 2.1.5 Pointer概念为了可以表示多个触摸点的动作，MotionEvent中引入了Pointer的概念，一个pointer就代表一个触摸点，每个pointer都有自己的事件类型，也有自己的横轴坐标值。一个MotionEvent对象中可能会存储多个pointer的相关信息，每个pointer都会有一个自己的id和index。pointer的id在整个事件流中是不会发生变化的，但是index会发生变化。 MotionEvent类中的很多方法都是可以传入一个int值作为参数的，其实传入的就是pointer的index值。比如getX(pointerIndex)和getY(pointerIndex)，此时，它们返回的就是index所代表的触摸点相关事件坐标值。 由于pointer的index值在不同的MotionEvent对象中会发生变化，但是id值却不会变化。所以，当我们要记录一个触摸点的事件流时，就只需要保存其id,然后使用findPointerIndex(int)来获得其index值，然后再获得其他信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243private final static int INVALID_ID = -1; private int mActivePointerId = INVALID_ID; private int mSecondaryPointerId = INVALID_ID; private float mPrimaryLastX = -1; private float mPrimaryLastY = -1; private float mSecondaryLastX = -1; private float mSecondaryLastY = -1; public boolean onTouchEvent(MotionEvent event) &#123; int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; case MotionEvent.ACTION_DOWN: int index = event.getActionIndex(); mActivePointerId = event.getPointerId(index); mPrimaryLastX = MotionEventCompat.getX(event,index); mPrimaryLastY = MotionEventCompat.getY(event,index); break; case MotionEvent.ACTION_POINTER_DOWN: int index = event.getActionIndex(); mSecondaryPointerId = event.getPointerId(index); mSecondaryLastX = event.getX(index); mSecondaryLastY = event.getY(index); break; case MotionEvent.ACTION_MOVE: int index = event.findPointerIndex(mActivePointerId); int secondaryIndex = MotionEventCompat.findPointerIndex(event,mSecondaryPointerId); final float x = MotionEventCompat.getX(event,index); final float y = MotionEventCompat.getY(event,index); final float secondX = MotionEventCompat.getX(event,secondaryIndex); final float secondY = MotionEventCompat.getY(event,secondaryIndex); break; case MotionEvent.ACTION_POINTER_UP: xxxxxx(涉及pointer id的转换，之后的文章会讲解) break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mActivePointerId = INVALID_ID; mPrimaryLastX =-1; mPrimaryLastY = -1; break; &#125; return true; &#125; 除了pointer的概念，MotionEvent还引入了两个事件类型： ACTION_POINTER_DOWN:代表用户又使用一个手指触摸到屏幕上，也就是说，在已经有一个触摸点的情况下，有新出现了一个触摸点。 ACTION_POINTER_UP:代表用户的一个手指离开了触摸屏，但是还有其他手指还在触摸屏上。也就是说，在多个触摸点存在的情况下，其中一个触摸点消失了。它与ACTION_UP的区别就是，它是在多个触摸点中的一个触摸点消失时（此时，还有触摸点存在，也就是说用户还有手指触摸屏幕）产生，而ACTION_UP可以说是最后一个触摸点消失时产生。 那么，用户先两个手指先后接触屏幕，同时滑动，然后在先后离开这一套动作所产生的事件流是什么样的呢？它所产生的事件流如下： 先产生一个ACTION_DOWN事件，代表用户的第一个手指接触到了屏幕。 再产生一个ACTION_POINTER_DOWN事件，代表用户的第二个手指接触到了屏幕。很多的ACTION_MOVE事件，但是在这些MotionEvent对象中，都保存着两个触摸点滑动的信息 一个ACTION_POINTER_UP事件，代表用户的一个手指离开了屏幕。如果用户剩下的手指还在滑动时，就会产生很多ACTION_MOVE事件。 一个ACTION_UP事件，代表用户的最后一个手指离开了屏幕 2.2 VelocityTracker速度追踪。 追踪手指在滑动过程中水平或者垂直方向的速度。 使用步骤： 追踪当前事件：其应用在方法 onTouchEvent() 中 12VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 获取当前事件的滑动速度： 1234// 计算速度 velocityTracker.computerCurrentVelocity(1000);// 获取速度 int getXVT = velocityTracker.getXVelocity(); 回收 12velocityTracker.clear();velocityTracker.recycler(); 2.3 GestureDetector手势检测。 检测用户的单击、滑动、长按、双击等行为。 使用步骤： 创建 创建一个 GestureDetector 对象并实现 OnGestureListener 接口。 123GestureDetector gestureDetector = new GestureDetector(this);// 解决长按屏幕无法拖动的现象gestureDetector.setIsLongpressEnabled(false); 接管标View的 onTouchEvent() 在目标View的 onTouchEvent() 中实现如下操作： 12boolean consumer = gestureDetector.onTouchEvent(event);return consumer; 2.4 View滑动 2.5 TouchSlop最小滑动距离 3. View点击事件分发机制3.1 机制描述所谓的 点击事件分发 实际就是对 MotionEvent事件的分发 过程。即：将一个产生的 MotionEvent事件 传递给一个具体的View，这个传递的过程就是 点击事件分发。 onTouchEvent() 是真正用来进行业务逻辑处理 的地方，返回true表示已经将该事件消费，返回false表明事件继续传递。 onInterceptTouchEvent() 是用来进行 判断 是否需要对事件进行 拦截 从而阻止其继续往子组件传递的，返回false表示无需拦截，则递归的调用子组件的dispatchTouchEvent()方法；返回true表示需要拦截，则直接调用本组件的 onTouchEvent() 方法进行处理。 一般我们是在View的onTouchEvent()方法中处理MotionEvent对象的. 1public boolean onTouchEvent(MotionEvent event) 不同View组合，所持有的方法不同。 View.java 12public boolean dispatchTouchEvent(MotionEvent event)public boolean onTouchEvent(MotionEvent event) View 没有 onInterceptTouchEvent()。 ViewGroup.java 123public boolean dispatchTouchEvent(MotionEvent event)public boolean onTouchEvent(MotionEvent event) public boolean onInterceptTouchEvent(MotionEvent event) ViewGroup 默认不拦截任何事件， onInterceptTouchEvent() 方法默认值为 false。 3.2 对点击事件的分发3.2.1 事件由 Activity 分发至 ViewActivity类 中的 dispatchTouchEvent() 12345678910// line : 3396public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 代码中的 getWindow().superDispatchTouchEvent(ev) 就是 Window抽象类 中的 superDispatchTouchEvent(MotionEvent event) 抽象方法： 12// linne : 1635public abstract boolean superDispatchTouchEvent(MotionEvent event); Window抽象类 的具体实现类是 PhoneWindow类，对应的方法是：superDispatchTouchEvent(MotionEvent event) 12345// line : 1828@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 代码中的 mDecor.superDispatchTouchEvent(event); 指的就是 DecorView类 中的 superDispatchTouchEvent(MotionEvent event) 1234// line : 439public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; 而 DecorView类 继承 FrameLayout类，FrameLayout类 继承 ViewGroup类，ViewGroup类 继承 View类。所以此处调用的 dispatchTouchEvent(event) 就是 View类 中的方法。 到此为止，事件 已经从 Activity 传到了 View。一下将要进行的就是在 View 与 ViewGroup 中进行事件的传递。 3.2.2 事件在 VIew 与 ViewGroup 中分发View类 中的 dispatchTouchEvent(MotionEvent event) ： 12345678910111213141516171819202122232425// line : 12478public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; …… if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; return result;&#125; 由于 View 只有自己本身，所以没有 onInterceptTouchEvent(MotionEvent event) 方法。在这个方法中，如果事件被处理，那么就执行 onTouchEvent(event, 0)；若是事件没有被处理，那么执行 onUnhandledEvent(event, 0); ViewGroup类 中的 dispatchTouchEvent(MotionEvent event) 1234567891011121314151617181920212223242526272829303132333435363738394041// line : 2541@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; // 执行事件消耗： onTouchEvent(); if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; …… // 执行 拦截 判断：onInterceptTouchEvent(ev) boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; …… // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; intercepted = true; &#125; &#125; // 未能处理事件 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; // 返回值 return handled;&#125; 在这个处理过程中需要一个 InputEventConsistencyVerifier类（public final class InputEventConsistencyVerifier{}），这个类的作用是： 1检查输入事件序列是否自洽。记录检测到的每个问题的描述。检测到问题时，事件会受到污染。 此机制可防止多次报告同一错误。 而 dispatchTouchEvent(MotionEvent ev) 方法中用到的 onInterceptTouchEvent(MotionEvent event) 、onTouchEvent(ev, 1) 与 onUnhandledEvent(ev, 1) 都属于 InputEventConsistencyVerifier类。 InputEventConsistencyVerifier类 中的 onInterceptTouchEvent(MotionEvent event) 12345678910// line : 3192public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123; return true; &#125; return false;&#125; InputEventConsistencyVerifier类 中的 onTouchEvent(MotionEvent event, int nestingLevel) 1234567891011121314151617181920212223// line : 322public void onTouchEvent(MotionEvent event, int nestingLevel) &#123; if (!startEvent(event, nestingLevel, EVENT_TYPE_TOUCH)) &#123; return; &#125; final int action = event.getAction(); final boolean newStream = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_OUTSIDE; if (newStream &amp;&amp; (mTouchEventStreamIsTainted || mTouchEventStreamUnhandled)) &#123; mTouchEventStreamIsTainted = false; mTouchEventStreamUnhandled = false; mTouchEventStreamPointers = 0; &#125; if (mTouchEventStreamIsTainted) &#123; event.setTainted(true); &#125; …… // 结束事件 finishEvent();&#125; InputEventConsistencyVerifier类 中的 onUnhandledEvent(InputEvent event, int nestingLevel) `通知验证者给定事件未处理，并且应忽略事件的其余跟踪。只有在事先由一致性验证程序使用{@link #onInputEvent}和其他方法检查事件时，才应调用此方法。 * @param事件该事件。 * @param nestingLevel嵌套级别：如果从基类调用，则为0，或者从子类调用1。 如果此一致性验证程序已在更高的嵌套级别检查了该事件，则不会再次检查该事件。 用于处理子类调度方法委托给其超类的调度方法并且两个调度方法调用一致性验证程序的情况。` 123456789101112131415161718192021222324252627282930// line : 582public void onUnhandledEvent(InputEvent event, int nestingLevel) &#123; if (nestingLevel != mLastNestingLevel) &#123; return; &#125; if (mRecentEventsUnhandled != null) &#123; mRecentEventsUnhandled[mMostRecentEventIndex] = true; &#125; if (event instanceof KeyEvent) &#123; final KeyEvent keyEvent = (KeyEvent)event; final int deviceId = keyEvent.getDeviceId(); final int source = keyEvent.getSource(); final int keyCode = keyEvent.getKeyCode(); final KeyState state = findKeyState(deviceId, source, keyCode, /*remove*/ false); if (state != null) &#123; state.unhandled = true; &#125; &#125; else &#123; final MotionEvent motionEvent = (MotionEvent)event; if (motionEvent.isTouchEvent()) &#123; mTouchEventStreamUnhandled = true; &#125; else if ((motionEvent.getSource() &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123; if (mTrackballDown) &#123; mTrackballUnhandled = true; &#125; &#125; &#125;&#125; 4 滑动冲突解决滑动冲突的重点：根据业务实际需要，分析问题原因。 入手点基本是通过 滑动方向 差异这个问题入手的，在 父View中操作的是 onInterceptTouchEvent() 方法中的 MotionEvent 对象。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 使用频率较少的控件]]></title>
    <url>%2FAndroid%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87%E8%BE%83%E5%B0%91%E7%9A%84%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[控件了解 控件1.CheckedTextView - 列表文字选择 参考：http://blog.csdn.net/zouchengxufei/article/details/51029489 2.QuickContactBadge - 联系人快捷标识3.Space - 用于填充View组件中的间隙 4.SearchView - 原生的搜索框控件 参考：http://blog.csdn.net/airsaid/article/details/51087226参考： https://www.cnblogs.com/LT5505/p/5534357.html 5.ExpandableListView - 显示二级节点的ListView 参考：https://www.cnblogs.com/hebao0514/p/4760939.html 6.Chronometer - 一个计时器,用来记录用户进行某项操作所消耗的时间 参考：https://www.cnblogs.com/xianfeng-zhang/p/8110053.html参考：http://blog.csdn.net/mengweiqi33/article/details/76903986 6.1 CountDownTimer - 倒计时 https://www.jianshu.com/p/3c10432a4726 7.TextClock - 显示时间 参考：http://blog.csdn.net/EthanCo/article/details/72829656 8.ImageSwitcher - 图像切换器 参考：http://blog.csdn.net/android_gjw/article/details/51759499参考：https://www.cnblogs.com/scetopcsa/p/3695272.html 9.AdapterViewFlipper - 显示上一个、下一个view 参考：http://blog.csdn.net/yan8024/article/details/46879867 10.StackView - 卡片堆叠 参考：http://blog.csdn.net/qq_16628781/article/details/49308355参考：http://blog.csdn.net/Small_Lee/article/details/51544975 11.TextSwitcher - 文字切换 参考：http://blog.csdn.net/bsmmaoshenbo/article/details/61198996参考：http://blog.csdn.net/u011418943/article/details/51871482 12.ViewAnimator - View视图切换 参考：http://www.jizhuomi.com/android/course/312.html参考：http://blog.csdn.net/lgy64422575/article/details/50255657 13.ViewFlipper - 循环滚动的效果 参考：http://blog.csdn.net/u011150924/article/details/60867499参考：http://blog.csdn.net/qq_31715429/article/details/50972357 14.include、merge 、ViewStub - 布局优化 参考：http://blog.csdn.net/xyz_lmn/article/details/14524567 15.SurfaceView与TextureView 参考：http://blog.csdn.net/hejjunlin/article/details/58582919 16.NumberPicker - 数字选择器 参考：https://www.cnblogs.com/xiaofeixiang/p/4125560.html参考：https://www.2cto.com/kf/201407/320686.html 17.TextInputLayout - TextView容器 参考：http://blog.csdn.net/q4878802/article/details/49780691参考：https://segmentfault.com/a/1190000009282096 18.GridView - 宫格布局 http://blog.csdn.net/sinat_25926481/article/details/70880047 18.GridLayout - 网格布局，平均分布 参考：http://blog.csdn.net/sunsteam/article/details/69486658行划分：http://blog.csdn.net/huangxiaominglipeng/article/details/17448045 具体示例：http://blog.csdn.net/yisizhu/article/details/51753003主体、cell元素：http://blog.csdn.net/k316378085/article/details/52316633 区分 GridView 与 GridLayout 参考：http://blog.csdn.net/studyboyjlu4/article/details/18192677 GridView是一种适配器布局,它的继承关系是ViewGroup–&gt;AdapterView–&gt;AbsListView–&gt;GridView，他是从一个adapter中取出内容填充到GridView中的每一个子View。 GridLayout是一个布局，它大大简化了对复杂布局的处理，提高了性能。他直接继承自ViewGroup，和LinearLayout这种是类似的。 区分 GridView 与 GridLayout 与 TableLayout 参考：http://blog.csdn.net/shareus/article/details/52063761]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kit]]></title>
    <url>%2FKit%2F</url>
    <content type="text"><![CDATA[工具 常用总结0. Android屏幕适配 参考：https://www.jianshu.com/p/ec5a1a30694b 1. String 类的replace方法替换字符串“无效”、“不起作用”原因l 参考： http://blog.csdn.net/huqingpeng321/article/details/52915324 没有特殊字符的话，则返回的是同一个对象的引用；若出现特殊字符，则new一个新的对象,替换之前的对象。 实际使用：1234567891011121314151617// 存储待遍历img地址List&lt;String&gt; array = MatchHtmlValue.match(tempHtml,&quot;img&quot;, &quot;src&quot;);StringBuilder builder = new StringBuilder();// 执行遍历for (int i = 0; i &lt; array.size(); i++) &#123; String oldHtmlVal = array.get(i); String newHtmlVal = MyCommon.URL_BASE_IMG + array.get(i); // ！！！ 此处执行替换时必须重新生成一个新的String串 builder.append(tempHtml.replace(oldHtmlVal,newHtmlVal));&#125;// 字符串拼接html.append(&quot;联系电话为：&quot; + tel);html.append(builder); *//*html.append(getServerInfo.getData().getDesc().replace(&quot;/public/upload/20171213/31d2fd1460e2471bd0fbbb59689c9c50.png&quot;,&quot;http://192.168.31.178:8088/public/upload/20171213/31d2fd1460e2471bd0fbbb59689c9c50.png&quot;));*//*Log.e(TAG, &quot;ヽ(｀Д´)ﾉ -&gt; onSuccess tel : &quot; + tel + &quot;; \n html : &quot; + html);htmlStr = html.toString();CommonWebViewSets.setHtmlCode(mServerWebView,htmlStr); 2. 通过正则表达式获取html标签中的指定属性值 参考：http://blog.csdn.net/andybbc/article/details/50556668 1234567891011121314151617181920212223242526public class MatchHtmlElementAttrValue &#123; /** * 获取指定HTML标签的指定属性的值 * @param source 要匹配的源文本 * @param element 标签名称 * @param attr 标签的属性名称 * @return 属性值列表 */ public static List&lt;String&gt; match(String source, String element, String attr) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); String reg = &quot;&lt;&quot; + element + &quot;[^&lt;&gt;]*?\\s&quot; + attr + &quot;=[&apos;\&quot;]?(.*?)[&apos;\&quot;]?\\s.*?&gt;&quot;; Matcher m = Pattern.compile(reg).matcher(source); while (m.find()) &#123; String r = m.group(1); result.add(r); &#125; return result; &#125; public static void main(String[] args) &#123; String source = &quot;&lt;a title=中国体育报 href=&apos;&apos;&gt;aaa&lt;/a&gt;&lt;a title=&apos;北京日报&apos; href=&apos;&apos;&gt;bbb&lt;/a&gt;&quot;; List&lt;String&gt; list = match(source, &quot;a&quot;, &quot;title&quot;); System.out.println(list); &#125; &#125; 3.Android 输入框与键盘之间的关系为了不让键盘阻挡输入框，添加此配置 123&lt;activity android:name="..." android:windowSoftInputMode="adjustResize" /&gt; 4. TextView跑马灯效果 在java文件中作出的修改 获取当前控件，将当前控件设置为： 12// 不设置这个属性,字体不会开始滚动tv.setSelected(true); 在xml文件中作出的修改 1234567891011121314&lt;TextView android:id="@+id/myTextView" android:layout_width="50dp" android:layout_height="wrap_content" android:layout_centerInParent="true" android:ellipsize="marquee" android:focusable="true" android:marqueeRepeatLimit="marquee_forever" android:singleLine="true" android:text="文本区域" android:textColor="@android:color/black" &gt; &lt;/TextView&gt; 5. 账户相关属性正则表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * 账户相关属性验证工具 * */public class AccountValidatorUtil &#123; /** * 正则表达式：验证用户名 */ public static final String REGEX_USERNAME = "^[a-zA-Z]\\w&#123;5,20&#125;$"; /** * 正则表达式：验证密码 */ public static final String REGEX_PASSWORD = "^[a-zA-Z0-9]&#123;6,20&#125;$"; /** * 正则表达式：验证手机号 */ public static final String REGEX_MOBILE = "^((17[0-9])|(14[0-9])|(13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d&#123;8&#125;$"; /** * 正则表达式：验证邮箱 */ public static final String REGEX_EMAIL = "^([a-z0-9A-Z]+[-|\\.]?)+[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\.)+[a-zA-Z]&#123;2,&#125;$"; /** * 正则表达式：验证汉字 */ public static final String REGEX_CHINESE = "^[\u4e00-\u9fa5],&#123;0,&#125;$"; /** * 正则表达式：验证身份证 */ public static final String REGEX_ID_CARD = "(^\\d&#123;18&#125;$)|(^\\d&#123;15&#125;$)"; /** * 正则表达式：验证URL */ public static final String REGEX_URL = "http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?"; /** * 正则表达式：验证IP地址 */ public static final String REGEX_IP_ADDR = "(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d)"; /** * 校验用户名 * * @param username * @return 校验通过返回true，否则返回false */ public static boolean isUsername(String username) &#123; return Pattern.matches(REGEX_USERNAME, username); &#125; /** * 校验密码 * * @param password * @return 校验通过返回true，否则返回false */ public static boolean isPassword(String password) &#123; return Pattern.matches(REGEX_PASSWORD, password); &#125; /** * 校验手机号 * * @param mobile * @return 校验通过返回true，否则返回false */ public static boolean isMobile(String mobile) &#123; return Pattern.matches(REGEX_MOBILE, mobile); &#125; /** * 校验邮箱 * * @param email * @return 校验通过返回true，否则返回false */ public static boolean isEmail(String email) &#123; return Pattern.matches(REGEX_EMAIL, email); &#125; /** * 校验汉字 * * @param chinese * @return 校验通过返回true，否则返回false */ public static boolean isChinese(String chinese) &#123; return Pattern.matches(REGEX_CHINESE, chinese); &#125; /** * 校验身份证 * * @param idCard * @return 校验通过返回true，否则返回false */ public static boolean isIDCard(String idCard) &#123; return Pattern.matches(REGEX_ID_CARD, idCard); &#125; /** * 校验URL * * @param url * @return 校验通过返回true，否则返回false */ public static boolean isUrl(String url) &#123; return Pattern.matches(REGEX_URL, url); &#125; /** * 校验IP地址 * * @param ipAddr * @return */ public static boolean isIPAddr(String ipAddr) &#123; return Pattern.matches(REGEX_IP_ADDR, ipAddr); &#125;&#125; 6. 将多次Toast弹出改为一次弹出1234567891011121314151617public class Util &#123; private static Toast toast; public static void showToast(Context context, String content) &#123; if (toast == null) &#123; toast = Toast.makeText(context, content, Toast.LENGTH_SHORT); &#125; else &#123; toast.setText(content); &#125; toast.show(); &#125;&#125; 调用的： 1Util.showToast(context, "things happened"); 7. 数据 转 json123//生成Json对象Gson gson = new Gson();String valueDateJson = gson.toJson(dataBean.getData()); 7. 关于 时间 与 时间戳7.1 js中时间戳转换为时间 参考：https://www.cnblogs.com/sufei/archive/2012/12/03/2799480.html参考：https://www.cnblogs.com/mr-wuxiansheng/p/6296646.html 12345678910111213function getLocalTime(nS) &#123; return new Date(parseInt(nS) * 1000);&#125;function formatDate(now) &#123; var year = now.getFullYear(), month = now.getMonth() + 1, date = now.getDate(); return year + "-" + month + "-" + date;&#125;console.log(formatDate(getLocalTime(strData[i].addtime))); 原始时间戳（示例）：1516165200转换为时间（示例）：2018-01-17 7.2 处理后的时间转换为时间戳12345678strNew[0] = year + "-" + month + "-" + day;Date date = null;try &#123; date = new SimpleDateFormat("yyyy-MM-dd").parse(strNew[0]);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125;unixTimestamp = date.getTime() / 1000; 关键： parse() 得到的时间：2018-01-17处理后的时间戳1：Wed Jan 17 00:00:00 GMT-05:00 2018处理后的时间戳2：1516165200 7.3 java中时间戳与时间格式的转换1234567891011/* * 将时间转换为时间戳 */ public static String dateToStamp(String s) throws ParseException&#123; String res; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = simpleDateFormat.parse(s); long ts = date.getTime(); res = String.valueOf(ts); return res;&#125; 1234567891011/* * 将时间戳转换为时间 */public static String stampToDate(String s)&#123; String res; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); long lt = new Long(s); Date date = new Date(lt); res = simpleDateFormat.format(date); return res;&#125; 8. Java - Collections 集合操作的静态多态方法，是一个工具类。 参考：http://blog.csdn.net/qq924862077/article/details/48022135 9. String／StringBuffer／StringBuilder它们之间的区别 参考：http://mp.weixin.qq.com/s/U1aIOERz7hqeC8JUH-fI6A 为什么要引入其它两种字符串处理类?提高字符串连接效率。在大部分情况下，字符串的拼接速度为：StringBuilder &gt; StringBuffer &gt; String String 不可变。因此每次对其操作改变其变量值，其实是生成一个新的对象，然后将变量引用指向新对象，因此速度慢。 线程安全。 存放在常量池，在编译期已经被确定了。new String()不是字符串常量，它有自己的地址空间，存放在堆空间 StringBuffer 可变。对其操作即直接操作对象指向的引用，无需产生新对象，速度很快； 线程安全。在维护多线程的同步等也会消耗一点性能。 堆空间 StringBuilder 可变。是jdk5之后新增的，其用法与StringBuffer完全一致， 非线程安全。在单线程中最佳，因为其不需要维护线程的安全，因此是最快的。 堆空间 10. AS 编译时提示error please select android sdk出现问题的界面： 解决方法：在File-&gt; Project Structure-&gt;app的属性中设置Compile Sdk Version即可。 11. 打开应用时出现“你的手机上未安装应用程序”–实际上该应用已经安装123456&lt;activity ··· android:exported=&quot;false&quot; &gt; ···&lt;/activity&gt; 问题就是出在：android:exported=&quot;false&quot;。该属性的意思 “是否允许activity被其它程序调用”，默认为 true。 12. Git 提示fatal: remote origin already exists 错误解决办法参考：http://blog.csdn.net/top_code/article/details/50381432 解决办法： 1、先删除远程 Git 仓库 $ git remote rm origin 2、再添加远程 Git 仓库 $ git remote add origin xxx 13. Http结构图 14. Activity生命周期图官方： 15. 修改App的包名http://blog.csdn.net/mr_zdd/article/details/78739485 16. App基本UI框架UI项目主框架： TabLayout + ViewPager效果图 0. 变量 12345TabLayout mTabLayout;private List&lt;String&gt; titles = new ArrayList&lt;&gt;();private List&lt;Fragment&gt; mFragmentList = new ArrayList&lt;&gt;();private FragmentAdapter mFragmentAdapter; 1. 自定义TabLayout的TabItem布局文件：item_tab_layout_layout 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.zhy.autolayout.AutoLinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="129px" android:orientation="vertical"&gt; &lt;ImageView android:id="@+id/img" android:layout_width="47px" android:layout_height="47px" android:layout_gravity="center" android:layout_marginTop="24px"/&gt; &lt;TextView android:id="@+id/text_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="10px" android:gravity="center|top" android:text="通知公告" android:textColor="@color/bottom_text_color_selector" android:textSize="@dimen/text_content_text_size"/&gt;&lt;/com.zhy.autolayout.AutoLinearLayout&gt; 2. 主界面xml布局文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.zhy.autolayout.AutoRelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/container" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" android:orientation="vertical"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/main_view_pager" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_above="@+id/line_main"/&gt; &lt;View android:layout_above="@+id/navigation_01" android:id="@+id/line_main" android:layout_width="match_parent" android:layout_height="1px" android:background="#cacaca"/&gt; &lt;android.support.design.widget.TabLayout android:layout_alignParentBottom="true" android:id="@+id/navigation_01" android:layout_width="match_parent" android:layout_height="129px"/&gt;&lt;/com.zhy.autolayout.AutoRelativeLayout&gt; 3. 选中样式配置 xml文件 3.1 选中字体样式配置： bottom_text_color_selector 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:color="@color/colorPrimary" android:state_selected="true"/&gt; &lt;item android:color="@color/textColor" android:state_selected="false"/&gt;&lt;/selector&gt; 3.2 选中图片样式配置： notice_checked_selector 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_selected="true" android:drawable="@drawable/bottom_notice_check"/&gt; &lt;item android:state_selected="false" android:drawable="@drawable/bottom_notice_uncheck"/&gt;&lt;/selector&gt;xx 4. 适配器：FragmentAdapter 1234567891011121314151617181920212223242526public class FragmentAdapter extends FragmentStatePagerAdapter &#123; private List&lt;String&gt; mStringList ; private List&lt;Fragment&gt; mFragmentList ; public FragmentAdapter(FragmentManager fm, List&lt;String&gt; mStrings, List&lt;Fragment&gt; mFragments) &#123; super(fm); this.mStringList = mStrings; this.mFragmentList = mFragments; &#125; @Override public Fragment getItem(int position) &#123; return mFragmentList.get(position); &#125; @Override public int getCount() &#123; return mFragmentList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mStringList.get(position); &#125;&#125; 5. Activity中UI控件配置 123456789101112131415161718192021222324252627282930313233private void initAdapter() &#123; titles.add("通知公告"); titles.add("临时任务"); titles.add("日常巡检"); titles.add("设置"); mFragmentList.add(new NoticeFragment()); mFragmentList.add(new TempTaskFragment()); mFragmentList.add(new CheckUsuallyFragment()); mFragmentList.add(new SettingFragment()); int[] imgs = new int[]&#123;R.drawable.notice_checked_selector,R.drawable.task_checked_selector,R.drawable.check_checked_selector,R.drawable.setting_checked_selector&#125;; mFragmentAdapter = new FragmentAdapter(getSupportFragmentManager(),titles,mFragmentList); mMainViewPager.setAdapter(mFragmentAdapter); mTabLayout.setupWithViewPager(mMainViewPager); mTabLayout.setSelectedTabIndicatorHeight(0); for (int i = 0; i &lt; titles.size(); i++) &#123; //获得到对应位置的Tab TabLayout.Tab itemTab = mTabLayout.getTabAt(i); if (itemTab != null) &#123; //设置自定义的标题 itemTab.setCustomView(R.layout.item_tab_layout_layout); TextView textView = (TextView) itemTab.getCustomView().findViewById(R.id.text_title); textView.setText(titles.get(i)); ImageView imageView= (ImageView) itemTab.getCustomView().findViewById(R.id.img); imageView.setImageResource(imgs[i]); &#125; &#125; mTabLayout.getTabAt(0).getCustomView().setSelected(true);&#125; 17. 转义字符\n 回车换行\t 横向跳到下一制表位置 \v 竖向跳格\b 退格\r 回车\f 走纸换页\ 反斜线符”\”\’ 单引号符\ddd 1～3位八进制数所代表的字符\xhh 1～2位十六进制数所代表的字符 空格的ASC是32，转换为16进制是x20，使用转义字符为 \x20 18. 安装apk时INSTALL_FAILED_NO_MATCHING_ABIS 参考：https://stackoverflow.com/questions/24572052/install-failed-no-matching-abis-when-install-apk 这个错误是由于使用了native libraries 。该native libraries 不支持当前的cpu的体系结构。 解决方式，在app的build.gradle文件中： 12345678splits &#123; abi &#123; enable true reset() include &apos;x86&apos;, &apos;armeabi-v7a&apos; universalApk true &#125;&#125; 修改依据： 19. 线性表、链表、哈希表数组、链表、树（二叉树、平衡树）、哈希表被称为通用数据结构。之所以称之为通用数据结构是因为它们通过关键字的值来存储、查找数据。 具体使用哪一种数据结构，可以参考下图： 上体育课的时候，老师说：你们站一队，每个人记住自己是第几个，我喊到几，那个人就举手，这就是数组。 老是说，你们每个人记住自己前面的人和后面的人，然后老师只知道第一人是谁。 然后你们各自由活动，老是要找某一个人，是不是每次都是从第一个开始往自己身后的人开始传达？这就是链表。 老师说： 大家1，2，3，4报数，凡是报1，为1队，凡是报2的为2队。。。。 而这个4就相当于预定义好的桶的个数。这就是散列（哈希）。 程序中，存放指定的数据最常用的数据结构有两种：数组和链表。 数组和链表的区别：： 数组是将元素在内存中连续存放。链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。 数组必须事先定义固定的长度，不能适应数据动态的增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费； 链表动态地进行存储分配，可以适应数据动态地增减的情况。 （静态）数组从栈中分配空间，对于程序员方便快速，但是自由度小； 链表从堆中分配空间，自由度大但是申请管理比较麻烦。 但是数组和链表在存储数据方面到底谁好？根据数组和链表的特性，分两种情况讨论： 1，当进行数据查询时，数组可以直接通过下标迅速访问数组中的元素。而链表则需要从第一个元素开始一直找到需要的元素位置，显然，数组的查询效率会比链表的高。 2，当进行增加或删除元素时，在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样，如果想删除一个元素，需要移动大量去填掉被移动的元素，而链表只需改动元素中的指针即可实现增加或删除元素。 那么哈希表，是既能具备数组的快速查询的优点，又能融合链表方便快捷的增加删除元素的优势。 哈希表 参考：https://blog.csdn.net/xiaoxik/article/details/74926090参考：https://www.cnblogs.com/s-b-b/p/6208565.html Hash table是指针的数组或者说向量表。哈希表(Hash Table)也叫散列表，是根据关键码值（Key Value）而直接进行访问的数据结构。它通过把关键码值映射到哈希表中的一个位置来访问记录，以加快查找的速度。这个映射函数就做散列函数，存放记录的数组叫做散列表。 一张图类比描述哈希表： 最典型的的例子就是字典，如果我想要获取“按”字详细信息，我肯定会去根据拼音an去查找 拼音索引（当然也可以是偏旁索引），我们首先去查an在字典的位置，查了一下得到安，结果如下。这过程就是键码映射，在公式里面，就是通过key去查找f(key)。其中，按就是关键字（key），f（）就是字典索引，也就是哈希函数，查到的页码4就是哈希值。 20. Java中常见数据结构：list与map 20.1. Collection（单列集合）20.1.1 （有序、可重复）List ArrayList：底层数据结构是数组,查询快,增删慢；线程不安全,效率高 Vector：底层数据结构是数组,查询快,增删慢；线程安全,效率低 LinkedList：底层数据结构是链表,查询慢,增删快结构是链表,查询慢,增删快；线程不安全,效率高 20.1.12 (无序,唯一)Set HashSet 底层数据结构是哈希表。 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 最终：自动生成hashCode()和equals()即可 LinkedHashSet： 底层数据结构由**链表**和**哈希表**组成。 由链表保证元素有序。 由哈希表保证元素唯一。 TreeSet 底层数据结构是红黑树。(是一种自平衡的二叉树) 20.2 Map(双列集合) Map集合的数据结构仅仅针对键有效，与值无关。 存储的是键值对形式的元素，键唯一，值可重复。 HashMap 底层数据结构是哈希表。线程不安全，效率高 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 LinkedHashMap 底层数据结构由链表和哈希表组成。 由链表保证元素有序。 由哈希表保证元素唯一。 21. Java中的 强引用、软引用、弱引用、虚引用 引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 在内存不足时 对象缓存 内存不足时终止 弱引用 在垃圾回收时 对象缓存 gc运行后终止 虚引用 Unknown Unknown Unknown 1、强引用（StrongReference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下： Object o=new Object(); // 强引用 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。 12345678private transient Object[] elementData; public void clear() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。 2、软引用（SoftReference） 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 12String str=new String(&quot;abc&quot;); // 强引用 SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str); // 软引用 当内存不足时，等价于： 1234If(JVM.内存不足()) &#123; str = null; // 转换为软引用 System.gc(); // 垃圾回收器进行回收 &#125; 如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。这时候就可以使用软引用 12345678Browser prev = new Browser(); // 获取页面进行浏览 SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用 if(sr.get()!=null)&#123; rev = (Browser) sr.get(); // 还没有被回收器回收，直接获取 &#125;else&#123; prev = new Browser(); // 由于内存吃紧，所以对软引用的对象回收了 sr = new SoftReference(prev); // 重新构建 &#125; 3、弱引用（WeakReference） 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。 123String str=new String(&quot;abc&quot;); WeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str); str=null; 下面的代码会让str再次变为一个强引用： 1String abc = abcWeakRef.get(); 4、虚引用（PhantomReference）与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 22. int、Integer有什么区别Java是面向对象的编程语言，一切都是对象，但是为了编程的方便还是引入了基本数据类型，为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型。 12原始类型：boolean，char，byte，short，int，long，float，double包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double int：属于简单类型，不存在“引用”这个概念；其数据是存储在栈空间中Integer：属于继承自Object的类，是按照java存储对象的内存模型来存储的；引用存储在栈中，对象数据存储在堆中；基于这个原理不同，所以在进行参数传递的时候，int是值传递，其在栈中的数据不可变； 而Integer类型是引用传递，引用指向的内存地址中的数据是可以变化的，但是栈中的引用是不变的。 int的初始化值是0 ，Integer初始化的值是null。，你不能把null值赋给int。 泛型支持Integer，并不支持int 。如： ArrayList list = new ArrayList()你不能在泛型中写int; 行为不一样 12int a =10; Integer b= new Integer(10); 在方法调用中：a是基本类型，并没有什么方法可言；因为方法是类的特性。b有很多方法，因为方法是对象中定义的；一些转换操作，如转为字符串等 23 Java中的 位运算符 详解与（ &amp; ）、非（ ~ ）、或（ | ）、异或（ ^ ） 参考：https://blog.csdn.net/vebasan/article/details/6193916 位运算符 主要针对 二进制 ，它包括了：“与”、“非”、“或”、“异或”。从表面上看似乎有点像逻辑运算符，但 逻辑运算符 是 针对两个关系运算符 来进行逻辑运算，而位运算符主要针对 两个二进制数 的位进行逻辑运算。 1. 与 （ &amp; ）运算符两个操作数中 位都为1，结果才为1，否则结果为0 如 ：129 &amp; 128，结果为 : 128 129转换成二进制就是10000001，128转换成二进制就是10000000。 根据与运算符的运算规律，只有两个位都是1，结果才是1，可以知道结果就是10000000，即128. 2. 或 （ | ） 运算符两个位 只要有一个为1，那么结果就是1，否则就为0 如：128 | 129 ，结果是：129 129转换成二进制就是10000001，128转换成二进制就是10000000。 根据或运算符的运算规律，只有两个位有一个是1，结果才是1，可以知道结果就是10000001，即129。 3. 非 （ ~ ） 运算符如果位为0，结果是1，如果位为1，结果是0 4. 异或 （ ^ ） 运算符两个操作数的位中，相同则结果为0，不同则结果为1。 如：15 ^ 2 , 结果是：13 15转换成二进制为 1111，2转换成二进制为0010，根据异或的运算规律，可以得出其结果为1101 即 13。 24 String的不变性如： 12String s = &quot;abcd&quot;;s = s.concat(&quot;ef&quot;); 25 targetSdkVersiontargetSdkVersion 是 Android 系统提供向前兼容的主要手段。随着 Android 系统的升级，某个系统的 API 或者模块的行为可能会发生改变，但是为了保证老 APK 的行为还是和以前兼容。只要 APK 的 targetSdkVersion 不变，即使这个 APK 安装在新 Android 系统上，其行为还是保持老的系统上的行为，这样就保证了系统对老应用的前向兼容性。 26 刘海屏幕适配参考 刘海屏”主要分成两类： 标准的 Android P Api 厂商在 Android P 以下的系统，做的特殊适配。 华为的处理方案 Google方案 1类3模式 1类：用DisplayCutout这个类找出刘海(cutout)的位置和形状，调用getDisplayCutout()这个方法可以获取刘海(cutout)的位置和区域。例如： 3模式： LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT：仅仅当系统提供的bar完全包含了刘海区时才允许window扩展到刘海区,否则window不会和刘海区重叠 LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES：允许window扩展到刘海区(原文说的是短边的刘海区, 目前有刘海的手机都在短边,所以就不纠结了) LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER：不允许window扩展到刘海区。 27 Android关于网络的操作类 TrafficStats 提供网络流量统计的类。这些统计信息包括发送和接收的字节数，以及通过移动接口在每个UID基础上通过所有接口发送和接收的网络数据包。这些统计数据可能并非在所有平台上都可用。如果此设备不支持统计信息，则会返回{@link #UNSUPPORTED}。请注意，此类返回的统计信息将重置，并在每次重新启动后从零开始。 NetworkStatsManager 访问更强大的历史网络统计数据 28 Gradle依赖相关操作28-1 查看依赖关系方式1：命令行，在terminal中 1./gradlew :XXX:dependencies 其中 XXX 可换成你想要看依赖树的 module 的名称。这个命令将debugApk、debugCompile、releaseApk、releaseCompile、compile 等全部打印出来,耗费时间长不说,最后的结果集也是一大片,不例于查看。或者： 1./gradlew -q :app:dependencies 或者，只想看compile相关的依赖，使用如下命令： 1./gradlew -q :app:dependencies --configuration implementation 其中 configuration implementation中的 implementation（此处可根据自己Android studio版本的新旧替换为implementation、api或compile等命令）表示只需要打印出 编译环境下的依赖项就可以了。 28-2 依赖重复：Program type already present: XXX排查方式：通过 双击shift键 后，输入 XXX ，查看是哪些第三方中引用了 XXX。 28-3 依赖子项排除产生原因：不同的第三方依赖中包含了相同的包或者相同的依赖，重点是他们的版本还不一样，有的版本高，有的版本低。 排查方式： 通过 28-1 查看依赖关系，列出所有依赖关系 com + f 输入重复引用的依赖名称 29 android 打包 v1,v2问题参考：https://www.cnblogs.com/liangxy/p/9059683.html 一定可行的方案： 只使用 v1 方案 不一定可行的方案：同时使用 v1 和 v2 方案 对 7.0 以下一定不行的方案：只使用 v2 方案 V1：可对签名后的文件，作适当修改，并重新压缩。 V2：不能对签名后的 APK作任何修改，包括 zipalign。因为它是针对字节进行的签名，所以任何改动都会影响最终结果。 Signature Versions不能只选择 V2(Full APK Signature)，应该选择V1(Jar Signature)，或者选择 V1和 V2。 30 关于软键盘 显示键盘 12345public void showInput() &#123; edMoneyInput.requestFocus(); InputMethodManager imm = (InputMethodManager) mAcitivity.getSystemService(INPUT_METHOD_SERVICE); imm.showSoftInput(edMoneyInput, 0);&#125; 隐藏键盘 123456protected void hideInput() &#123; InputMethodManager imm = (InputMethodManager) mAcitivity.getSystemService(Context.INPUT_METHOD_SERVICE); if (imm != null) &#123; imm.hideSoftInputFromWindow(view.getWindowToken(), 0); &#125;&#125; 默认设置：不需要自动弹出软键盘 方式1：在manifest文件的Activity标签设置属性android:windowSoftInputMode=&quot;stateAlwaysHidden&quot; （或者stateHidden|adjustResize）。 方式2： 1getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE | WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN); 避免软键盘弹出会覆盖底部控件 在布局文件根布局加上一个属性： 1android:fitsSystemWindows=&quot;true&quot; 31 BottomSheetDialogFragment 各种高度、滑动设置123456789101112131415161718public Dialog onCreateDialog(Bundle savedInstanceState) &#123; view = View.inflate(getContext(), R.layout.md_activity_setting_default_currency, null); dialog = (BottomSheetDialog) super.onCreateDialog(savedInstanceState); dialog.setContentView(view); dialog.setCanceledOnTouchOutside(false); FrameLayout bottomSheet = dialog.getDelegate().findViewById(android.support.design.R.id.design_bottom_sheet); if (bottomSheet != null) &#123; behavior = BottomSheetBehavior.from(bottomSheet); // 重要 ：各种高度、禁止滑动设置 behavior.setHideable(false); bottomSheet.getLayoutParams().height = getHeight();/*ViewGroup.LayoutParams.MATCH_PARENT*/; behavior.setPeekHeight(getHeight()); &#125; initView(); initData(); initListener(); return dialog; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView的使用]]></title>
    <url>%2FAndroid%20WebView%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WebView的设置 Web相关代码块1. WebVIew的 Setting 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191/** * CommonWebViewSets WebView设置工具类 * * @author wenjia.Cheng cwj1714@163.com * @date 2017/12/29 */public class CommonWebViewSets &#123; /** * 设置URL * * @param webView 控件 * @param url url地址 */ public static void setUrl(WebView webView, String url,ProgressBar mProgressBar) &#123; initWeb(webView,mProgressBar); webView.loadUrl(url); &#125; /** * 设置html源代码，无base Url * * @param webView 控件 * @param html html源代码 */ public static void setHtmlCode(WebView webView, String html,ProgressBar mProgressBar) &#123; initWeb(webView,mProgressBar); webView.loadDataWithBaseURL("我的服务商", html, "text/html", "utf-8", null); &#125; /** * 设置html源代码，有base Url * * @param webView 控件 * @param baseUrl baseUrl * @param html html源代码 */ public static void setHtmlCodeBaseUrl(WebView webView, String baseUrl, String html,ProgressBar mProgressBar) &#123; initWeb(webView,mProgressBar); webView.loadDataWithBaseURL(baseUrl, html, "text/html", "utf-8", null); &#125; /** * @param webView 控件 */ @SuppressLint("SetJavaScriptEnabled") public static void initWeb(WebView webView, final ProgressBar mProgressBar) &#123; // 获取webview设置属性 WebSettings settings = webView.getSettings(); // 设置编码格式 settings.setDefaultTextEncodingName("utf-8"); // 进行屏幕适配设置 settings.setUseWideViewPort(true); settings.setLoadWithOverviewMode(true); // 设置支持JavaScript settings.setJavaScriptEnabled(true); // 这个是给图片设置点击监听的，如果你项目需要webview中图片，点击查看大图功能，可以这么添加 // webView.addJavascriptInterface(new JavaScriptInterface(this), "imagelistner"); settings.setAllowContentAccess(false); settings.setAllowFileAccessFromFileURLs(false); settings.setAllowUniversalAccessFromFileURLs(false); settings.setAllowFileAccess(false); // 把html中的内容放大webview等宽的一列中 settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN); //settings.setDefaultFontSize(44); // 设置可以支持缩放 //webView.getSettings().setSupportZoom(true); // 设置出现缩放工具 //webView.getSettings().setBuiltInZoomControls(true); //webView.getSettings().setDisplayZoomControls(true); //如果不设置WebViewClient，请求会跳转系统浏览器 webView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; //该方法在Build.VERSION_CODES.LOLLIPOP以前有效，从Build.VERSION_CODES.LOLLIPOP起，建议使用shouldOverrideUrlLoading(WebView, WebResourceRequest)&#125; instead //返回false，意味着请求过程里，不管有多少次的跳转请求（即新的请求地址），均交给webView自己处理，这也是此方法的默认处理 //返回true，说明你自己想根据url，做新的跳转，比如在判断url符合条件的情况下，我想让webView加载http://ask.csdn.net/questions/178242 /*if (url.toString().contains("sina.cn"))&#123; view.loadUrl("http://ask.csdn.net/questions/178242"); return true; &#125;*/ return false; &#125; @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; //返回false，意味着请求过程里，不管有多少次的跳转请求（即新的请求地址），均交给webView自己处理，这也是此方法的默认处理 //返回true，说明你自己想根据url，做新的跳转，比如在判断url符合条件的情况下，我想让webView加载http://ask.csdn.net/questions/178242 /*if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; if (request.getUrl().toString().contains("sina.cn"))&#123; view.loadUrl("http://ask.csdn.net/questions/178242"); return true; &#125; &#125;*/ return false; &#125; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); //imgReset(view);//重置webview中img标签的图片大小 // html加载完成之后，添加监听图片的点击js函数 //addImageClickListner(view); &#125; &#125;); if (mProgressBar == null) &#123; &#125; else &#123; webView.setWebChromeClient(new WebChromeClient()&#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; // TODO 自动生成的方法存根 if(newProgress==100)&#123; mProgressBar.setVisibility(View.GONE);//加载完网页进度条消失 &#125; else&#123; mProgressBar.setVisibility(View.VISIBLE);//开始加载网页时显示进度条 mProgressBar.setProgress(newProgress);//设置进度值 &#125; &#125; &#125;); &#125; &#125; /** * 这段js函数的功能就是，遍历所有的img节点，并添加onclick函数，函数的功能是在图片点击的时候调用本地java接口并传递url过去 * * @param view view */ private static void addImageClickListner(WebView view) &#123; view.loadUrl("javascript:(function()&#123;" + "var objs = document.getElementsByTagName(\"img\"); " + "for(var i=0;i&lt;objs.length;i++) " + "&#123;" + " objs[i].onclick=function() " + " &#123; " + " window.imagelistner.openImage(this.src); " + " &#125; " + "&#125;" + "&#125;)()"); &#125; /** * 对图片进行重置大小，宽度就是手机屏幕宽度，高度根据宽度比便自动缩放 **/ private static void imgReset(WebView view) &#123; view.loadUrl("javascript:(function()&#123;" + "var objs = document.getElementsByTagName(\"img\"); " + "for(var i=0;i&lt;objs.length;i++) " + "&#123;" + "var img = objs[i]; " + " img.style.maxWidth = '100%'; img.style.height = 'auto'; " + "&#125;" + "&#125;)()"); &#125; private static class JavaScriptInterface &#123; private Context context; public JavaScriptInterface(Context context) &#123; this.context = context; &#125; //点击图片回调方法 //必须添加注解,否则无法响应 @JavascriptInterface public void openImage(String img) &#123; Log.i("TAG", "响应点击事件!"); Intent intent = new Intent(); intent.putExtra("image", img); // BigImageActivity查看大图的类，自己定义就好 // intent.setClass(context, BigImageActivity.class); context.startActivity(intent); &#125; &#125;&#125; 2. WebView 不仅可以通过 URL 装载网页，也可以直接装载 HTML 代码，WebView 类有两个方法可以装载 HTML 代码:1loadData(String data, String mimeType, String encoding) 此方法在装载包含中文的 HTML 代码时会有乱码 与 1loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl) 此方法不会有乱码 参数： baseUrl: 获得相对路径的根 URL, 如果设为null, 默认值为 about:blank historyUrl: 如果HTML代码装载失败或为 null, WebView 组件会装载这个参数指定的URL. data : HTML代码 mimeType: Mime类型， 一般为 text/html encoding: HTML代码的编码， 例如： GBK, uft-8 3. 在HTML文档中设置自适应屏幕（文字）1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 4. 在Android的WebView中点击“返回按钮”时的操作123456789101112131415161718192021/** * webView监听返回按钮 * * @param keyCode 按钮码 * @param event 事件 * @return 。 */@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KeyEvent.KEYCODE_BACK)) &#123; if (web_act_view.canGoBack()) &#123; //goBack()表示返回WebView的上一页面 web_act_view.goBack(); return true; &#125; else &#123; finish(); return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 8.0/8.1 Notification的使用]]></title>
    <url>%2FAndroid%208.0%3A8.1%20Notification%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/rentee/article/details/78303532非常全面的参考：https://www.jianshu.com/p/d2051a785309 起因 - 设置“Notification”后，状态栏并没有任何提示最近项目中需要使用到“Notification”，这个原本在android中非常简单就能实现的功能，如今我却怎么设置都不成功，这让我颇为郁闷。 然后开始查看别人是怎么写的，但是同样并没有任何效果。然后我意识到我的系统版本时Android 8.1。设置方式已经变了。 一个前版本的例子： 1234567891011Notification.Builder builder = new Notification.Builder(this); Intent intent = new Intent(this, TraceActivity.class); Bitmap icon = BitmapFactory.decodeResource(this.getResources(), R.drawable.ic_person_pin_circle_cyan_700_24dp); //设置pendingIntent builder.setContentIntent(PendingIntent.getActivity(this, 0, intent, 0)) .setLargeIcon(icon) .setContentTitle(&quot;领队定位&quot;) .setSmallIcon(R.drawable.ic_person_pin_circle_white_18dp) .setContentText(&quot;定位服务正在运行中……&quot;); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.notify(1, builder.build()); 这样的写法运行在Android 8.0之上是没有任何效果的。 Android 8.0 Notification注意： 代码中添加了：NotificationChannel这个类。这是Android O新增的通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。 NotificationChannel是Android O新增的特性，为了兼容老代码，如果channelId为null的话，Android O会把通知归到“Other Channel”上。PS：将targetSdkVersion提到26以上的话，就必须设置channel了，不能为null。 使用到的类1. NotificationChannel官方解释为：适用于类似主题通知的集合的设置的表示形式。使用方式为： 123456// 创建自己的的NotificationChannel 参数1：id：channeId；参数2：name：自定义类别的名字，在&quot;设置界面&quot;的类别栏下回显示 name；参数3：重要等级NotificationChannel channel = new NotificationChannel(&quot;10&quot;,&quot;普通通知&quot;,NotificationManager.IMPORTANCE_DEFAULT);// NotificationManager管理器NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);// 使用channel对象mNotifyMgr.createNotificationChannel(channel); 2. NotificationManager官方解释为：通知用户发生事件的类。 这是如何告诉用户在后台发生了什么事情。 123NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);// 发出通知mNotifyMgr.notify(10, notification); 3. Notification.Builder官方解释：一个类，它表示如何使用一个持久化通知呈现给用户 初步使用实例的图解较为完整的通知示例图解 通知频道的名称：new NotificationChannel(“10”,”普通通知”,NotificationManager.IMPORTANCE_DEFAULT); 未设置颜色的样式： 添加自定义提醒12345678910111213// 添加自定义声音提醒builder.setSound(Uri.parse("path/to/sound"));// 添加自定义震动提醒// 延迟200ms后震动300ms，再延迟400ms后震动500mslong[] pattern = new long[]&#123;200,300,400,500&#125;; builder.setVibrate(pattern);// 添加自定义呼吸灯提醒，自动添加FLAG_SHOW_LIGHTSint argb = 0xffff0000; // led灯光颜色int onMs = 300; // led亮灯持续时间int offMs = 100; // led熄灯持续时间builder.setLights(argb, onMs, offMs); 一个完整的Notification 初步使用 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * android 8.0 新的Notification */@RequiresApi(api = Build.VERSION_CODES.O)private void initNotification() &#123; Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_map_cyan_700_48dp); // 创建自己的的NotificationChannel 参数1：id：channeId；参数2：name：自定义类别的名字，在&quot;设置界面&quot;的类别栏下回显示 name；参数3：重要等级 NotificationChannel channel = new NotificationChannel(&quot;10&quot;,&quot;普通通知&quot;,NotificationManager.IMPORTANCE_DEFAULT); channel.enableLights(true); channel.setLightColor(Color.RED); channel.setShowBadge(true); channel.setDescription(&quot;description&quot;); // NotificationManager管理器 NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); // 使用channel对象 mNotifyMgr.createNotificationChannel(channel); // 点击通知之后的意图 PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, TraceActivity.class), 0); PendingIntent pendingIntent2 = PendingIntent.getActivity(this, 0, new Intent(this, ChangePwdActivity.class), 0); Notification notification = new Notification.Builder(this,&quot;10&quot;) // 设置通知 右侧 大图标 .setLargeIcon(bitmap) // 设置通知的图标、app文字名称，若不设置则整个通知均为黑灰色 .setColor(getResources().getColor(R.color.Deep_Orange_700)) // 无障碍服务所需文字 .setTicker(&quot;这是什么玩意？- 国旅&quot;) // 小图标 .setSmallIcon(R.drawable.ic_person_pin_circle_cyan_700_24dp) // 标题文本 .setContentTitle(&quot;Notification Title&quot;) // 解释内容 - 子文本 .setContentText(&quot;Text &amp; Text&quot;) // 在项目app名称右侧显示的内容文字 .setSubText(&quot;Sub_tex&quot;) // 设置通知的动作数组 .setActions(new Notification.Action[]&#123;new Notification.Action(R.drawable.contact_me,&quot;进入Map&quot;,pendingIntent),new Notification.Action(R.drawable.contact_me,&quot;修改密码&quot;,pendingIntent2)&#125;) // 设置单个动作 //.setActions(new Notification.Action(R.drawable.contact_me,&quot;修改密码&quot;,pendingIntent2)) // 仅当 配合&quot;setContentIntent(pendingIntent)&quot;使用时，点击通知会自动消失 .setAutoCancel(true) // 为通知设置意图 //.setContentIntent(pendingIntent) // 同时实现：铃声/振动/灯呼吸 三种提醒方式 .setDefaults(Notification.DEFAULT_ALL) .setWhen(0) .setNumber(3) .build(); // getNotification() deprecated in API level 16 // 发出通知 mNotifyMgr.notify(10, notification);&#125; 说明 如果该通知只是起到 “通知”的作用，不希望用户点击后有相应的跳转，那么，intent、pendingIntent这几行代码可以不写，可以创建延时操作，当通知被成功 notify 后，一段时间后调用manager.cancel(notificationID)，将通知清除，此时builder.setAutoCancel()方法不写也可以。 如果通知栏下拉后，希望用户点击并有相应的跳转事件。那么，要注意跳转后，通知是否有必要继续存在。如果点击后通知消失，两种方法： 设置setAutoCancel 参数设置为 true，默认是false， 在intent事件中的如本例中的MainActivity的onCreate()方法调用 manager.cancel(notificationID)取消该通知，此ID要和创建通知的ID一致，否则通知不消失。 如果点击不消失，将setAutoCancel 参数设置为 false即可。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>版本新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库-SwipeToLoadLayout]]></title>
    <url>%2F%E5%BC%80%E6%BA%90%E5%BA%93-SwipeToLoadLayout%2F</url>
    <content type="text"><![CDATA[总结 1. SwipeToLoadLayout滑动加载布局，可以实现下拉刷新与上拉加载更多。该库支持对ListView，GridView，RecyclerView，WebView，ScrollView等滑动视图的下载刷新与上拉加载更多。 1.1 配置 首先在工程的build.gradle上面添加JitPack仓库 123456allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 在模块的build.gradle上面添加依赖 123dependencies &#123; compile &apos;com.github.Aspsine:SwipeToLoadLayout:1.0.3&apos;&#125; 1.2 基本使用SwipeToLoadLayout下面定义三个子视图: SwipeRefreshHeaderLayout : 代表下拉刷新的头部 RecyclerView: 代表滑动视图主体 SwipeLoadMoreFooterLayout: 代表上拉加载更多的尾部 1234567891011121314151617181920212223&lt;com.aspsine.swipetoloadlayout.SwipeToLoadLayout android:id=&quot;@+id/swipeToLoadLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.aspsine.swipetoloadlayout.SwipeRefreshHeaderLayout android:id=&quot;@id/swipe_refresh_header&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:gravity=&quot;center&quot;/&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/swipe_target&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;com.aspsine.swipetoloadlayout.SwipeLoadMoreFooterLayout android:id=&quot;@id/swipe_load_more_footer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:gravity=&quot;center&quot; /&gt;&lt;/com.aspsine.swipetoloadlayout.SwipeToLoadLayout&gt; 这三个子视图的id必须是上面所写的，否则会出错 1.3 常用属性 app:refresh_enabled：设置是否可以下拉刷新 app:load_more_enabled：设置是否可以上拉加载更多 app:swipe_style：设置下拉刷新与上拉加载的样式，其值为classic，above，blew或scale app:refresh_trigger_offset：触发下拉刷新的偏移量，默认值是下拉刷新头部的高度 app:load_more_trigger_offset：触发上拉加载更多的偏移量，默认值是上拉加载更多的高度 app:refresh_final_drag_offset：下拉刷新最大可以拖动的偏移量 app:load_more_final_drag_offset：上拉加载更多最大可以拖动的偏移量 app:release_to_refreshing_scrolling_duration：释放下拉刷新持续滚动的时间 app:release_to_loading_more_scrolling_duration：释放上拉加载更多持续滚动的时间 app:refresh_complete_delay_duration：下拉刷新完成延迟的持续时间 app:load_more_complete_delay_duration：上拉加载更多完成延迟的持续时间 app:refresh_complete_to_default_scrolling_duration：默认完成下拉刷新持续滚动时间 app:load_more_complete_to_default_scrolling_duration： 默认完成上拉加载更多持续滚动时间 app:default_to_refreshing_scrolling_duration：默认下拉刷新滚动时间 app:default_to_loading_more_scrolling_duration：默认上拉加载更多滚动时间 1.4 自定义下拉刷新头部与上拉加载更多尾部 定义下拉刷新头部视图只需要实现SwipeRefreshTrigger, SwipeTrigger两个接口就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class RefreshHeaderView extends TextView implements SwipeRefreshTrigger, SwipeTrigger &#123; public RefreshHeaderView(Context context) &#123; super(context); &#125; public RefreshHeaderView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void onRefresh() &#123; setText("REFRESHING"); &#125; @Override public void onPrepare() &#123; setText(""); &#125; @Override public void onMove(int yScrolled, boolean isComplete, boolean automatic) &#123; if (!isComplete) &#123; if (yScrolled &gt;= getHeight()) &#123; setText("RELEASE TO REFRESH"); &#125; else &#123; setText("SWIPE TO REFRESH"); &#125; &#125; else &#123; setText("REFRESH RETURNING"); &#125; &#125; @Override public void onRelease() &#123; &#125; @Override public void onComplete() &#123; setText("COMPLETE"); &#125; @Override public void onReset() &#123; setText(""); &#125;&#125; 定义上拉加载更多尾部视图只需要实现SwipeLoadMoreTrigger, SwipeTrigger两个接口就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LoadMoreFooterView extends TextView implements SwipeTrigger, SwipeLoadMoreTrigger &#123; public LoadMoreFooterView(Context context) &#123; super(context); &#125; public LoadMoreFooterView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void onLoadMore() &#123; setText("LOADING MORE"); &#125; @Override public void onPrepare() &#123; setText(""); &#125; @Override public void onMove(int yScrolled, boolean isComplete, boolean automatic) &#123; if (!isComplete) &#123; if (yScrolled &lt;= -getHeight()) &#123; setText("RELEASE TO LOAD MORE"); &#125; else &#123; setText("SWIPE TO LOAD MORE"); &#125; &#125; else &#123; setText("LOAD MORE RETURNING"); &#125; &#125; @Override public void onRelease() &#123; setText("LOADING MORE"); &#125; @Override public void onComplete() &#123; setText("COMPLETE"); &#125; @Override public void onReset() &#123; setText(""); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下在Androidstudio中获取数字签名证书的SHA1值]]></title>
    <url>%2FMac%E4%B8%8B%E5%9C%A8Androidstudio%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E7%9A%84SHA1%E5%80%BC%2F</url>
    <content type="text"><![CDATA[总结 获取步骤 AndroidStudio切换到Terminal 输入命令：cd ~/.android 输入命令：keytool -list -v -keystore debug.keystore 输入密钥库口令: android 或者 回车 得到的结果为： 1234567891011121314151617181920212223242526272829***************** WARNING WARNING WARNING ****************** 存储在您的密钥库中的信息的完整性 ** 尚未经过验证! 为了验证其完整性, ** 必须提供密钥库口令。 ****************** WARNING WARNING WARNING *****************密钥库类型: JKS密钥库提供方: SUN您的密钥库包含 1 个条目别名: androiddebugkey创建日期: 2017-6-24条目类型: PrivateKeyEntry证书链长度: 1证书[1]:所有者: C=US, O=Android, CN=Android Debug发布者: C=US, O=Android, CN=Android Debug序列号: 1有效期开始日期: Sat Jun 24 22:49:12 CST 2017, 截止日期: Mon Jun 17 22:49:12 CST 2047证书指纹: MD5: …… SHA1: …… SHA256: …… 签名算法名称: SHA1withRSA 版本: 1*******************************************]]></content>
      <categories>
        <category>Kit</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图开发-鹰眼轨迹]]></title>
    <url>%2FAndroid%20%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91-%E9%B9%B0%E7%9C%BC%E8%BD%A8%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/29ccac3e1e42 存在问题1. 后台service是否存活2. 电量与流量提示3. 坐标系说明 需求概览 围栏：到达指定位置之后通知 鹰眼轨迹：根据行踪绘制轨迹 位置提醒：到达指定位置后提醒。 一、定位方式gps定位、wifi定位、基站（SIM卡）定位 特点：1. gps定位：卫星定位，利用手机gps硬件定位，实现简单，手机本地就能实现定位，不需要和服务端进行交互。在室内或者有遮蔽物的地点无法接收到gps信号。此时利用wifi定位。 gps定位精度很高，几米到十几米，但是耗电严重。 2. wifi定位：在室外既能接收gps信号，也能接收wifi信号。wifi定位的原理是，我们在室外的时候，手机能接收到gps位置信息，也能扫描到WiFi，当手机把gps位置和WiFi传到后端服务器，WiFi和gps位置就建立了映射关系，当手机在室内无法接收到gps时，却能扫描WiFi，手机把WiFi传到服务器查询出对应的gps位置，然后进行计算可以得到位置结果（经纬度），其中映射和计算是很复杂的过程。 WiFi定位精度相对于gps差一点，但是也能到十几米、几十米，也有上百米的误差的，低耗电。 3. 基站定位：当手机无法扫描到WiFi时，只要装了sim卡，就能连接移动或联通等基站，即可用基站定位，定位原理和WiFi大致相同。基站定位需要装了sim卡，并且手机能上网。 wifi定位与基站定位统称为网络定位。 基站定位精度很差，一般都有几百米，上千米的误差。 误差其实和wifi、基站的信号覆盖半径有关，wifi覆盖半径大概100m左右，而基站的覆盖半径就到km级别了。 二、百度地图鹰眼认证认证与不认证： 权限及配额说明： http://lbsyun.baidu.com/index.php?title=android-yingyan/guide/quota 三、百度地图 鹰眼轨迹服务 的使用 参考：http://lbsyun.baidu.com/index.php?title=android-yingyan/guide/buildproject 0. 准备条件01. 获取 账号秘钥账号秘钥 ： http://lbsyun.baidu.com/apiconsole/key 02. 创建 鹰眼服务服务鹰眼服务 ：http://lbsyun.baidu.com/trace/admin/service 1. 下载相关文件http://lbsyun.baidu.com/index.php?title=android-yingyan/sdkandev-download 2. 导入库文件 倒库参考：https://www.cnblogs.com/jiy-for-you/p/6093199.html 注意：使用AndroidStudio 路径 将jar文件拷贝到工程的libs目录下，若使用鹰眼的图像存储功能，需导入bos-android-sdk-1.0.2.jar。 注意：百度鹰眼包中有okhttp，而我的本地项目中也有okhttp，所以冲突，无法构建。此处注意保留一处即可。 导入so文件方式： 1. 将so文件导入到src/main/jniLibs目录下。 2. 将so文件导入到libs目录下。，然后在build.gradle文件中添加： 12345sourceSets &#123; main &#123; jniLibs.srcDir &apos;libs&apos; &#125;&#125; jar包添加完毕之后，需要在gradle文件中进行添加： 3. 配置AndroidManifest.xml文件3.1 声明使用权限1234567891011121314151617181920212223242526&lt;!-- 这个权限用于进行网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;!-- 用于加快GPS首次定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS"/&gt; &lt;!-- 这个权限用于访问GPS定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;!-- 用于读取手机当前的状态--&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; &lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入对象存储BOS数据--&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;!-- 访问网络，网络定位需要上网--&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;!-- SD卡读取权限，用于写入对象存储BOS数据--&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt; &lt;uses-permission android:name="android.permission.READ_LOGS"/&gt; &lt;uses-permission android:name="android.permission.VIBRATE"/&gt; &lt;uses-permission android:name="android.permission.WAKE_LOCK"/&gt; &lt;uses-permission android:name="android.permission.WRITE_SETTINGS"/&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; &lt;!-- 用于Android M及以上系统，申请加入忽略电池优化白名单--&gt; &lt;uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS"/&gt; 3.2 声明&lt;service&gt;组件12345&lt;service android:name="com.baidu.trace.LBSTraceService" android:enabled="true" android:exported="true" android:process=":remote" /&gt; 3.3 设置 AccessKey1234567&lt;application …… &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;AK&quot; /&gt; //key:开发者申请的Key]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对已有文字处理]]></title>
    <url>%2FAndroid%20SpannableString%20%E5%AF%B9%E5%B7%B2%E6%9C%89%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考：http://blog.csdn.net/fan7983377/article/details/51776782参考：http://www.jianshu.com/p/84067ad289d2 关键类：SpannableString 一、一个实例1. 更改颜色12345SpannableString mSpanStartTitle = new SpannableString("点击红色按钮开始录音");//处理 提示文字的 颜色 样式ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor("#C62828"));mSpanStartTitle.setSpan(colorSpan, 2, 4, Spanned.SPAN_INCLUSIVE_INCLUSIVE);mNoticeStartTitle.setText(mSpanStartTitle); 样式结果 2. 更改字体大小123456789//代操作……SpannableString mSpanNoticeTitle = new SpannableString("正在录音中……" + "\n" + "点击停止录音");//处理 提示文字的 大小 样式RelativeSizeSpan sizeSpan01 = new RelativeSizeSpan(0.7f);mSpanNoticeTitle.setSpan(sizeSpan01,7,mSpanNoticeTitle.length(),Spanned.SPAN_INCLUSIVE_INCLUSIVE);//处理 提示文字的 下标 样式SubscriptSpan subscriptSpan = new SubscriptSpan();mSpanNoticeTitle.setSpan(subscriptSpan, 7, mSpanNoticeTitle.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mNoticeRecordingTitle.setText(mSpanNoticeTitle); 样式结果 二、SpannableStringSpannableString和String一样，都是一种字符串类型，同样TextView也可以直接设置SpannableString作为显示文本，不同的是SpannableString可以通过使用其方法setSpan()方法实现字符串各种形式风格的显示,重要的是可以指定设置的区间，也就是为字符串指定下标区间内的子字符串设置格式。 三、SpannableStringBuilder应该有不少开发的小伙伴知道StringBuilder，可以使用append()方法实现字符串拼接，非常方便。同样，SpannableString中也有SpannableStringBuilder，顾名思义，就是实现对，SpannableString的一个拼接效果，同样是append()方法，可以实现各种风格效果的SpannableString拼接，非常实用。 四、重要方法 - setSpan()1setSpan(Object what, int start, int end, int flags) what ：设置的格式是什么，可以是前景色、背景色也可以是可点击的文本等等；start表示需要设置格式的子字符串的起始下标end表示终了下标flags属性就有意思了，共有四种属性： Spanned.SPAN_INCLUSIVE_EXCLUSIVE 从起始下标到终了下标，包括起始下标 Spanned.SPAN_INCLUSIVE_INCLUSIVE 从起始下标到终了下标，同时包括起始下标和终了下标 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 从起始下标到终了下标，但都不包括起始下标和终了下标 Spanned.SPAN_EXCLUSIVE_INCLUSIVE 从起始下标到终了下标，包括终了下标 五、Span常用格式1. ForegroundColorSpan，为文本设置前景色，效果和TextView的setTextColor()类似2. BackgroundColorSpan，为文本设置背景色，效果和TextView的setBackground()类3. RelativeSizeSpan，设置文字相对大小，在TextView原有的文字大小的基础上，相对设置文字大小1234SpannableString spannableString = new SpannableString("万丈高楼平地起");RelativeSizeSpan sizeSpan04 = new RelativeSizeSpan(1.8f);spannableString.setSpan(sizeSpan04, 3, 4, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 4. StrikethroughSpan，为文本设置中划线，也就是常说的删除线1234SpannableString spannableString = new SpannableString("为文字设置删除线");StrikethroughSpan strikethroughSpan = new StrikethroughSpan();spannableString.setSpan(strikethroughSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 5. UnderlineSpan，为文本设置下划线，具体实现方法如下：1234SpannableString spannableString = new SpannableString("为文字设置下划线");UnderlineSpan underlineSpan = new UnderlineSpan();spannableString.setSpan(underlineSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 6. SuperscriptSpan，设置上标，具体实现方法如下：1234SpannableString spannableString = new SpannableString("为文字设置上标");SuperscriptSpan superscriptSpan = new SuperscriptSpan();spannableString.setSpan(superscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 7. SubscriptSpan，设置下标，具体实现方法如下：1234SpannableString spannableString = new SpannableString("为文字设置下标");SubscriptSpan subscriptSpan = new SubscriptSpan();spannableString.setSpan(subscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 8. SpannableString spannableString = new SpannableString(“为文字设置粗体、斜体风格”);123456StyleSpan styleSpan_B = new StyleSpan(Typeface.BOLD);StyleSpan styleSpan_I = new StyleSpan(Typeface.ITALIC);spannableString.setSpan(styleSpan_B, 5, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(styleSpan_I, 8, 10, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setHighlightColor(Color.parseColor("#36969696"));textView.setText(spannableString); 9. ImageSpan，设置文本图片123456SpannableString spannableString = new SpannableString("在文本中添加表情（表情）");Drawable drawable = getResources().getDrawable(R.mipmap.a9c);drawable.setBounds(0, 0, 42, 42);ImageSpan imageSpan = new ImageSpan(drawable);spannableString.setSpan(imageSpan, 6, 8, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 10. ClickableSpan，设置可点击的文本，设置这个属性的文本可以相应用户点击事件，至于点击事件用户可以自定义注意： 使用ClickableSpan的文本如果想真正实现点击作用，必须为TextView设置setMovementMethod()方法，否则没有点击相应，至于setHighlightColor方法则是控制点击是的背景色。 123456789101112131415161718192021222324252627282930SpannableString spannableString = new SpannableString("为文字设置点击事件");MyClickableSpan clickableSpan = new MyClickableSpan("http://www.jianshu.com/users/dbae9ac95c78");spannableString.setSpan(clickableSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor("#36969696")); textView.setText(spannableString); // 自定义点击事件class MyClickableSpan extends ClickableSpan &#123; private String content; public MyClickableSpan(String content) &#123; this.content = content; &#125; @Override public void updateDrawState(TextPaint ds) &#123; ds.setUnderlineText(false); &#125; @Override public void onClick(View widget) &#123; Intent intent = new Intent(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString("content", content); intent.putExtra("bundle", bundle); startActivity(intent); &#125;&#125; 11. URLSpan，设置超链接文本URLSpan就是继承自ClickableSpan，就是重写了父类的onClick事件，用系统自带浏览器打开链接。 123456SpannableString spannableString = new SpannableString("为文字设置超链接");URLSpan urlSpan = new URLSpan("http://www.jianshu.com/users/dbae9ac95c78");spannableString.setSpan(urlSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor("#36969696"));textView.setText(spannableString);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>文字处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考：《Head First 设计模式》 1. 定义：讲一个复杂对象的构建与他的表示分离，使得不同的构建过程可以创建不同的表示。 2. 建造者模式要点: 在目标类中有一个静态内部类Builder 目标类与静态内部类Builder拥有同样的成员变量 静态内部类Builder提供一个build()或者create()用于创建对应的外部类。该方法内部调用了外部类的一个私有构造方法，该私有构造方法的参数就是静态内部类Builder。 使用特点：链式调用 3. 骨架1234567891011121314151617181920212223242526272829303132333435363738public class Person &#123; /* 声明变量 */ String name; String address; int age; int sex; String job; int phoneNumber; int QQNumber; /** * 构造函数私有化 */ private Person()&#123; &#125; /** * 声明一个 静态类 Builder */ public static class Builder &#123; /* 声明同 person类 一样的变量 */ String name; String address; int age; int sex; String job; int phoneNumber; int QQNumber; &#125;&#125; 4. 一个完整含有建造者（Builder）模式的类此模式的主要实现是在”骨架”的基础上进行填充。 4.1 实现关键 - 1 ：类的私有构建方法1234private Person(Builder builder)&#123; //··· this.sex = builder.sex; &#125; 4.2 实现关键 - 2 ：静态类Builder中的方法返回值 + build()方法。1234567public static class Builder &#123; //··· public Person build()&#123; return new Person(this); &#125;&#125; 4.3 完整的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public class Person &#123; /* 声明变量 */ String name; String address; int age; int sex; String job; int phoneNumber; int QQNumber; /** * 构造函数私有化，通过这一点确保使用 Builder 实现动态构建（组合实现）当前类的实例化。 */ private Person(Builder builder)&#123; this.address = builder.address; this.age = builder.age; this.job = builder.job; this.name = builder.name; this.phoneNumber = builder.phoneNumber; this.QQNumber = builder.QQNumber; this.sex = builder.sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public int getPhoneNumber() &#123; return phoneNumber; &#125; public void setPhoneNumber(int phoneNumber) &#123; this.phoneNumber = phoneNumber; &#125; public int getQQNumber() &#123; return QQNumber; &#125; public void setQQNumber(int QQNumber) &#123; this.QQNumber = QQNumber; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", address='" + address + '\'' + ", age=" + age + ", sex=" + sex + ", job='" + job + '\'' + ", phoneNumber=" + phoneNumber + ", QQNumber=" + QQNumber + '&#125;'; &#125; /** * 声明一个 静态类 Builder * * 通过这个Builder类，动态的构建（组合实现）当前对象的各个属性。 * 特点： * 不需要编写多个构造函数。 */ public static class Builder &#123; /* 声明同 person类 一样的变量 */ String name; String address; int age; int sex; String job; int phoneNumber; int QQNumber; public Builder name(String name)&#123; this.name = name; return this; &#125; public Builder address(String address)&#123; this.address = address; return this; &#125; public Builder age(int age)&#123; this.age = age; return this; &#125; public Builder sex(int sex)&#123; this.sex = sex; return this; &#125; public Builder job(String job)&#123; this.job = job; return this; &#125; public Builder phoneNumber(int phoneNumber)&#123; this.phoneNumber = phoneNumber; return this; &#125; public Builder QQNumber(int QQNumber)&#123; this.QQNumber = QQNumber; return this; &#125; /** * 返回本类的实例化对象，此方法也真正实现当前类的实例化。 * @return 当前对象 */ public Person build()&#123; return new Person(this); &#125; &#125;&#125; 5. 使用建造者（Builder）模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainPerson &#123; public static void main(String[] aegs)&#123; // 构造方式1 Person person = new Person.Builder() .name("张三") .sex(1) .age(24) .build(); System.out.println(person.toString()); // 构造方式2 Person person2 = new Person.Builder() .name("旺旺") .sex(1) .age(12) .address("广东") .phoneNumber(122343423) .build(); System.out.println(person2.toString()); // 构造方式3 Person person3 = new Person.Builder() .name("刘贤") .sex(0) .age(72) .address("HK") .phoneNumber(8989345) .QQNumber(11112232) .job("司机") .build(); System.out.println(person3.toString()); // 构造方式4 Person person4 = new Person.Builder() .name("张倩") .sex(0) .age(22) .address("JP") .phoneNumber(0220330) .QQNumber(1233424) .job("Student") .build(); System.out.println(person4.toString()); &#125; /** * Person&#123;name='张三', address='null', age=24, sex=1, job='null', phoneNumber=0, QQNumber=0&#125; Person&#123;name='旺旺', address='广东', age=12, sex=1, job='null', phoneNumber=122343423, QQNumber=0&#125; Person&#123;name='刘贤', address='HK', age=72, sex=0, job='司机', phoneNumber=8989345, QQNumber=11112232&#125; Person&#123;name='张倩', address='JP', age=22, sex=0, job='Student', phoneNumber=73944, QQNumber=1233424&#125; */&#125; 6. 在Android中的应用 AlertDialog 图片加载库：Picasso]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- TypedArray]]></title>
    <url>%2FAndroid%20View-%E8%87%AA%E5%AE%9A%E4%B9%89%20-%20TypedArray%2F</url>
    <content type="text"><![CDATA[自定义View中的 attrs.xml 文件设置 1. 文件位置： 2. 文件内容（仅供参考）：1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="MyViewGroup"&gt; &lt;attr name="textOneTitle" format="string"/&gt; &lt;attr name="textOneSize" format="integer"/&gt; &lt;attr name="imageSrc" format="reference"/&gt; &lt;attr name="textTwoTitle" format="string"/&gt; &lt;attr name="textTwoSize" format="integer"/&gt; &lt;attr name="textOneVisible" format="boolean"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 3. 属性文件中参数属性的分类： 4. attrs.xml 文件中 format 取值类型1. reference：参考某一资源ID。 属性的定义 1&lt;attr name="imageSrc" format="reference"/&gt; 属性的使用 1cwj:imageSrc="@drawable/maps" 在java中获取数值（2种方式） 12345Drawable imgSrc = array.getDrawable(R.styleable.MyViewGroup_imageSrc);mImageView.setBackground(imgSrc);int imgSrc = array.getResourceId(R.styleable.MyViewGroup_imageSrc,R.drawable.ic_launcher_background);mImageView.setBackgroundResource(imgSrc); 2. color：颜色值。 属性的定义 1&lt;attr name="textOneColor" format="color"/&gt; 属性的使用 1cwj:textOneColor="#ff0000" 在java中获取 123int textOneColor = array.getColor(R.styleable.MyViewGroup_textOneColor, Color.BLACK);mTextView2.setTextColor(textOneColor); 3. boolean：布尔值。 属性的定义 1&lt;attr name="textOneVisible" format="boolean"/&gt; 属性的使用 1cwj:textOneVisible="false" 在java中获取 1234567boolean oneIsShow = array.getBoolean(R.styleable.MyViewGroup_textOneVisible,true);if (oneIsShow) &#123; mTextView1.setVisibility(VISIBLE);&#125; else &#123; mTextView1.setVisibility(INVISIBLE);&#125; 4. dimension：尺寸值。 属性的定义 1&lt;attr name="textOneSize" format="dimension"/&gt; 属性的使用 1cwj:textTwoSize="@dimen/textOneSize2" 在java中获取 123float textOneSize = array.getDimension(R.styleable.MyViewGroup_textOneSize,10);mTextView1.setTextSize(textOneSize); 5. float：浮点值。 属性的定义 1&lt;attr name = "fromAlpha" format = "float" /&gt; 属性的使用 1android:fromAlpha = "1.0" 6. integer：整型值。 属性的定义 1&lt;attr name = "frameDuration" format="integer" /&gt; 属性的使用 1android:frameDuration = "100" 7. string：字符串。 属性的定义 1&lt;attr name="textOneTitle" format="string"/&gt; 属性的使用 1cwj:textOneTitle="大标题" 在java中使用 123String textOneTitle = array.getString(R.styleable.MyViewGroup_textOneTitle);mTextView1.setText(textOneTitle); 8. fraction：百分数。 属性的定义 1&lt;attr name = "pivotY" format = "fraction" /&gt; 属性的使用 1android:pivotY = "300%" 9. enum：枚举值。 属性的定义 1234&lt;attr name="textTwoGravity"&gt; &lt;enum name="top" value="1"/&gt; &lt;enum name="center" value="2"/&gt;&lt;/attr&gt; 属性的使用 1cwj:textTwoGravity="top" 在java中获取 1234567int gracityIndex = array.getInt(R.styleable.MyViewGroup_textTwoGravity, Gravity.CENTER);if (gracityIndex == 1) &#123; mTextView2.setGravity(Gravity.TOP);&#125; else if (gracityIndex == 2) &#123; mTextView2.setGravity(Gravity.CENTER);&#125; 10. flag：位或运算。 属性的定义 123456789101112&lt;attr name="windowSoftInputMode"&gt; &lt;flag name = "stateUnspecified" value = "0" /&gt; &lt;flag name = "stateUnchanged" value = "1" /&gt; &lt;flag name = "stateHidden" value = "2" /&gt; &lt;flag name = "stateAlwaysHidden" value = "3" /&gt; &lt;flag name = "stateVisible" value = "4" /&gt; &lt;flag name = "stateAlwaysVisible" value = "5" /&gt; &lt;flag name = "adjustUnspecified" value = "0x00" /&gt; &lt;flag name = "adjustResize" value = "0x10" /&gt; &lt;flag name = "adjustPan" value = "0x20" /&gt; &lt;flag name = "adjustNothing" value = "0x30" /&gt; &lt;/attr&gt; 属性的使用 1android:windowSoftInputMode = "stateUnspecified | stateUnchanged | stateHidden" 其他 - 组合属性设置： 属性的定义 1&lt;attr name = "background" format = "reference|color" /&gt; 属性的使用 1android:background = "@drawable/图片ID|#00FF00"]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- 组合View]]></title>
    <url>%2FAndroid%20View-%E8%87%AA%E5%AE%9A%E4%B9%89-%20%E7%BB%84%E5%90%88View%2F</url>
    <content type="text"><![CDATA[这次描述的是自定义ViewGroup，这其中既包括完全自定义ViewGroup和组合ViewGroup。 自定义组合ViewGroup1. 创建一个自定义ViewGroup的xml文件1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.zhy.autolayout.AutoRelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/item_single_view" android:layout_width="match_parent" android:layout_height="210px" android:background="@color/login_txt" android:gravity="center"&gt; &lt;ImageView android:id="@+id/item_single_iv" android:layout_width="50px" android:layout_height="50px" android:layout_centerHorizontal="true" android:layout_marginTop="6px" android:src="@drawable/ic_launcher"/&gt; &lt;TextView android:id="@+id/item_single_tv_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@+id/item_single_iv" android:layout_marginTop="16px" android:gravity="center_horizontal" android:text="信息" android:textColor="@color/button_text_color"/&gt; &lt;TextView android:id="@+id/item_single_tv_val" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/item_single_tv_title" android:layout_marginTop="10px" android:gravity="center_horizontal" android:text="1223" android:textColor="@color/button_text_color"/&gt;&lt;/com.zhy.autolayout.AutoRelativeLayout&gt; 2. 创建一个继承自ViewGroup的自定义类。2.1 一个原始的自定义类：123456789101112131415public class MyViewGroup extends LinearLayout &#123; public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125;&#125; 2.2 对自定义组合控件中的子控件进行属性设置使用到的类： TypedArray 使用的文件： attrs.xml 文件 注意： 属性的初始化应该放在相应的构造函数中，例如本自定义ViewGroup中的构造过程应该写在第二个构造函数中，写在第三个构造函数中在使用时则不会显示。 在获取Layout布局文件时，注意参数的设置： View view = LayoutInflater.from(context).inflate(R.layout.my_view_group_layout,this,true); 有时，此处参数设置出错，自定义view的控件将不会显示。 此步编写的步骤为： 获取Layout布局文件 声明 Layout布局文件中的子控件 通过 TypedArray 获取 子控件 中的属性值 为各个子控件设置参数值 实例为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class MyViewGroup extends LinearLayout &#123; private static final String TAG = "MyViewGroup"; /* 2- 声明 xml文件用到的 控件 */ TextView mTextView1,mTextView2; ImageView mImageView; public MyViewGroup(Context context) &#123; super(context); &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); // 1 - 获取自定义的 xml文件 View view = LayoutInflater.from(context).inflate(R.layout.my_view_group_layout,this,true); // 3 - findViewById mTextView1 = view.findViewById(R.id.one_tv); mTextView2 = view.findViewById(R.id.two_tv); mImageView = view.findViewById(R.id.image); // 4 - 通过 TypedArray 获取 attrs文件中的属性值 @SuppressLint("Recycle") TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.MyViewGroup); if (array != null) &#123; String textOneTitle = array.getString(R.styleable.MyViewGroup_textOneTitle); float textOneSize = array.getDimension(R.styleable.MyViewGroup_textOneSize,10); String textTwoTitle = array.getString(R.styleable.MyViewGroup_textTwoTitle); float textTwoSize = array.getDimension(R.styleable.MyViewGroup_textTwoSize,10); //两种方式均可 Drawable imgSrc = array.getDrawable(R.styleable.MyViewGroup_imageSrc); //int imgSrc = array.getResourceId(R.styleable.MyViewGroup_imageSrc,R.drawable.ic_launcher_background); boolean oneIsShow = array.getBoolean(R.styleable.MyViewGroup_textOneVisible,true); int textOneColor = array.getColor(R.styleable.MyViewGroup_textOneColor, Color.BLACK); int gracityIndex = array.getInt(R.styleable.MyViewGroup_textTwoGravity, Gravity.CENTER); array.recycle(); Log.e(TAG, "ヽ(｀Д´)ﾉ -&gt; MyViewGroup textOneTitle : " + textOneTitle + ", textOneSize : "+ textOneSize + ", textTwoTitle : " + textTwoTitle + ", textTwoSize : " + textTwoSize); // 5 - 为控件中的各个控件设置参数值 mTextView1.setText(textOneTitle); mTextView2.setText(textTwoTitle); mTextView1.setTextSize(textOneSize); mTextView2.setTextSize(textTwoSize); mTextView2.setTextColor(textOneColor); //控制子控件的显隐性 if (oneIsShow) &#123; mTextView1.setVisibility(VISIBLE); &#125; else &#123; mTextView1.setVisibility(INVISIBLE); &#125; //设置自定义图片的两种方式 mImageView.setBackground(imgSrc); //mImageView.setBackgroundResource(imgSrc); if (gracityIndex == 1) &#123; mTextView2.setGravity(Gravity.TOP); &#125; else if (gracityIndex == 2) &#123; mTextView2.setGravity(Gravity.CENTER); &#125; &#125; &#125; public MyViewGroup(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public void setImageView(Drawable imageViewId) &#123; mImageView.setBackground(imageViewId); &#125; public void setTextView1(String textView1Title) &#123; mTextView1.setText(textView1Title); &#125; public void setTextView2(String textView2Title) &#123; mTextView2.setText(textView2Title); &#125; public void setTextView1Size(int textView1Val) &#123; mTextView1.setTextSize(textView1Val); &#125; public void setTextView2Size(int textView2Val) &#123; mTextView2.setTextSize(textView2Val); &#125; public void setTextView2Gravity(String gravity) &#123; if ("top".equals(gravity)) &#123; mTextView2.setGravity(Gravity.TOP); &#125; else if ("center".equals(gravity)) &#123; mTextView2.setGravity(Gravity.CENTER); &#125; &#125;&#125; 3. 布局文件3.1 在相应的xml文件中调用自定义的ViewGroup类，实现对此类的调用。在这一步中，要想使用自定义view的属性进行数值的设置，首先要声明命名空间： xmlns:cwj=&quot;http://schemas.android.com/apk/res-auto&quot; 实际例子： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:cwj="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.yannischeng.custom_view.view_group.MyViewGroupActivity" android:orientation="vertical"&gt; &lt;com.yannischeng.custom_view.view_group.MyViewGroup cwj:textOneSize="@dimen/textOneSize1" cwj:textOneTitle="大标题" cwj:textTwoSize="@dimen/textOneSize2" cwj:textTwoTitle="具体的详细信息" cwj:imageSrc="@drawable/maps" android:layout_width="match_parent" android:layout_height="56dp"/&gt;&lt;/LinearLayout&gt; 3.2 修改之后布局文件123456789101112&lt;com.yannischeng.custom_view.view_group.MyViewGroup android:id="@+id/my_view_group" cwj:textOneSize="@dimen/textOneSize1" cwj:textOneTitle="大标题" cwj:textTwoSize="@dimen/textOneSize2" cwj:textTwoTitle="具体的详细信息" cwj:imageSrc="@drawable/maps" cwj:textOneVisible="false" cwj:textOneColor="#ff0000" cwj:textTwoGravity="top" android:layout_width="match_parent" android:layout_height="56dp"/&gt; 运行结果为： 4. 在相应的类中像使用其他控件一样使用自定义ViewGroup类的属性。1234567891011121314@BindView(R.id.my_view_group)MyViewGroup mMyViewGroup;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_view_group); ButterKnife.bind(this); mMyViewGroup.setTextView1("标题"); mMyViewGroup.setTextView1Size(14); mMyViewGroup.setTextView2("小标题"); mMyViewGroup.setTextView2Size(10);&#125; 5. 为自定义控件添加响应事件声明一个回调事件接口： 123456public interface ClickListener &#123; void textOneClickListener(View view); void textTwoClickListener(View view);&#125; 在自定义控件中使用： 12345678910111213141516171819202122232425262728293031323334/* 点击事件接口 */ClickListener mClickListener = null;/* 构造方法 */public MyViewGroup(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); //... mTextView1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mClickListener.textOneClickListener(v); &#125; &#125;); mTextView2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mClickListener.textTwoClickListener(v); &#125; &#125;); &#125;/** * 点击方法声明 */public void setClickListener(ClickListener listener)&#123; mClickListener = listener;&#125; 在Activity中使用 1234567891011mMyViewGroup.setClickListener(new ClickListener() &#123; @Override public void textOneClickListener(View view) &#123; Toast.makeText(MyViewGroupActivity.this, "this is textOneClickListener!", Toast.LENGTH_SHORT).show(); &#125; @Override public void textTwoClickListener(View view) &#123; Toast.makeText(MyViewGroupActivity.this, "this is textTwoClickListener!", Toast.LENGTH_SHORT).show(); &#125;&#125;); 点击左侧写有“标题”的按钮：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权限-FileProvider]]></title>
    <url>%2FAndroid%20%E6%9D%83%E9%99%90-FileProvider%2F</url>
    <content type="text"><![CDATA[问题总结 问题起因：E/FileSource: Failed to open file &apos;/storage/emulated/0/DCIM/Camera/VID_20171121_203344.mp4&apos;. (Permission denied) 这是因为7.0的新的文件权限导致的。文件共享要采用FileProvicer的形式，不能使用之前的file路径来简单表示。 3步解决问题1. file_paths 文件在res/下创建xml/文件夹，然后创建：file_paths文件。 12345&lt;resources xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-files-path name="root_path" path="."/&gt;&lt;/resources&gt; 注意：&lt;paths&gt;元素可包含多个元素。 具体元素的含义： &lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /data/user/0/com.yannischeng.simplemediaplayer/files Context.getFilesDir() + /path/ &lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /data/user/0/com.yannischeng.simplemediaplayer/cache Context.getCacheDir() + /path/ &lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0 Environment.getExternalStorageDirectory() + /path/ &lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0/Android/data/com.yannischeng.simplemediaplayer/files Context.getExternalFilesDir(String) + /path/ &lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于 ： // /storage/emulated/0/Android/data/com.yannischeng.simplemediaplayer/cache Context.getExternalCacheDir() + /path/ &lt;root-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 相当于外置SD卡路径。 // /system Environment.getRootDirectory().getAbsolutePath(); 2. 注册FileProvider在AndroidManifest.xml里面注册FileProvider 123456789101112&lt;application ... &lt;provider android:name="android.support.v4.content.FileProvider" &lt;!-- 共享文件的文件根目录，名字可以自定义 --&gt; android:authorities="media.player" &lt;!-- 自定义的权限 --&gt; android:exported="false" &lt;!-- 是否设置为独立进程 --&gt; android:grantUriPermissions="true"&gt; &lt;!-- 是否拥有共享文件的临时权限 --&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt; &lt;/provider&gt; &lt;/application&gt; 3. 使用在java代码中： 1Uri fileURI = FileProvider.getUriForFile(mContext,"media.player",file);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android视频]]></title>
    <url>%2FAndroid%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/10e357946447 基础知识 一、基本概念写在前面：如果在很多专有名字，概念都不熟悉的情况下，想要去阅读播放器源码会是相当困难的事情。 1. Codec编码（encode） 和 解码(decode)。Codec就是一种程序，这种程序可以对视频文件进行编码和解码。 A video codec is an electronic circuit or software that compresses（编码，压缩） or decompresses（解码，解压） digital video. It converts raw (uncompressed) digital video to a compressed format or vice versa. In the context of video compression, “codec” is a concatenation of “encoder” and “decoder”—a device that only compresses is typically called an encoder, and one that only decompresses is a decoder. 视频文件的本质其实就是图片的集合，当一段连续的图片不断的出现在人眼前(一般一个连贯的电影或者动画至少要求一秒24帧，也就是一秒内连续出现24张图片)，肉眼就会“欺骗性”的告诉大脑我们在看一个视频，而不是幻灯片。 图片大小计算：720P 1280 * 720 * 3byte = 2.7M Android在xml中定义颜色格式：#ffffff，三原色：3X4X2 = 24位二进制位 24/8 = 3。 仅仅是60s（1分钟）就有这么大，一部电影岂不……？ 所以通过：Codec程序对这些连续的图片通过一定的算法压缩成体积更小的文件格式 - 编码，压缩。在屏幕上进行播放时，需要显示图片，所以要将图片进行还原 - 解码，解压缩。Codec解码的编解码是分别针对：视频（图片）、音频（声波）。 视频的编解码是一个非常复杂的过程，但是现在有很多的工具及规范： H.265/H.264/H.263 2. Container format file（视频容器文件） - 结构化的文件视频容器文件即：mp4、rmvb、avi。容器：包括了视频(video)数据、(audio)音频数据、文字(Text)数据。结构化：音频、视频、文字数据必须按照一定的规范，放在指定的地方（方便解析）。 元数据 -&gt; Codec程序 -&gt; 视频容器文件 一个典型的“MP4”视频容器文件 Track(轨道)，这是一个专业术语，用来区分不同的音视频/文字数据。最重要的却是这个MetaData（头文件），它包含了很多关于视频的原始数据，比如视频的大小，视频的时长，还有一个索引表，这个索引表包含了不同轨道的起始位置(以字节为单位)，又因为每个轨道会被分成若干块sample(采样，每一块采样都是可以单独被播放器播放的一段数据，以微妙为单位)，metadata也会维护一个细粒度更小的索引表，记录了每一块sample的大小，起始位置，对应视频的时间是多少(以字节为单位)等等的信息。 3. 视频处理流程 原片(Raw Data) -Encode-&gt; 容器文件(container) -process-&gt; 不同分辨率 -服务器-&gt; 客户端使用 二、MP4 解析1. Mp4格式文件的构成MP4是一种格式的规范，是被ISO机构认证的，只要你通过Codec生成了一个mp4文件，那么这个文件的格式必须是按照ISO机构的规矩来。这个规范很好理解，它定义了一个MP4文件里面，哪些数据应该放在什么位置(以字节为单位)，哪些数据的长度是多少。 MP4格式定义：http://xhelmboyx.tripod.com/formats/mp4-layout.txt 任何容器，包括mp4都是类似的结构化文件，只不过不同的格式文件ISO对其有严格的要求，数据的摆放顺序、排列等等不同而已。 2. MP4头文件构成在Meta Data里面，每一个Header，头文件，我们都叫他们Atom Header(不知道咋翻译)。Atom Header分为Leaf Atom 和 Container Atom。前者代表一个连接着字符串信息的头文件，后者是一个包含了若干个子Atom的头文件，他们互相之间是有层级关系的(参考上图)。每次播放器获取了movie atom之后(moov)，会根据层级关系，向下，或者向下读取相关的其他信息。每一个头文件都会对它的子头文件保存位置的引用，所以只要根据mp4文件的规范获取了最顶级的头文件moov,就可以顺势往下读取其他头文件 苹果MP4文档：https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706 mp4的头文件结构： 最重要的信息是采样索引表(Sample Table Atoms).对应图中“stbl ”这个atom header。这个索引表保存了mp4文件所有的采样(sample)与视频时间的对应关系(一般以微秒为单位)，还有包括每个采样的大小，在mp4文件中的起始位置(以自己为单位)。 3. 标准播放器的启动流程3.1 播放器构成： 数据源（source） 读取器（extractor） 加载控制器（load control） 渲染器（trackRenderer） 3.1 播放器播放流程：在播放器可以把数据提交给渲染器之前，播放器需要把必需的头文件全部解析并存入内存，比如之前说的采样索引表。一般播放器在解析完毕后，会构建三个表： 一个存放时间对应采样索引 一个存放采样索引对应在mp4文件中的起始位置(以字节为单位) 一个存放采样索引对应大小(以字节为单位)。 通过表1，我们知道该微秒对应第1个采样（sample），从第一个和第二个表我们知道，第1个采样的数据范围(在mp4文件内)是从第0字节到300（0+300）字节，那么播放器就会去读取这个范围的数据并且放入渲染器中进行渲染。 同时，加载器会基于当前已经缓存的数据，决定是否还需要不停的读取数据进入内存。一般来说每个播放器都有默认的缓存值，也会有一个基准线，只有当缓存足够数据才能放进渲染器进行渲染。 最后同理，当我们拖动滑动控制器(SeekBar)想快进的时候，我们和第一步一样，通过我们想滑动的时间获取采样的索引，再重新开始读取数据。 综上所述，播放器在正式播放视频文件之前，必须要把头文件全部读取并解析(这会是一段非常耗时的程序)，这也是在线视频播放的等待时间的瓶颈。在接下来的章节我会介绍自适应视频播放(Adaptive Streaming)，这个技术的发明使得了分段式mp4文件(Fragmented Mp4)技术得以诞生，大大的减少了在线视频播放的等待时间。 4. 在线视频播放的技术基础(online video streaming)在线视频的播放其实和播放本地视频的区别就是Extractor读取的Source，数据源不一样。 在线播放需要下载数据到内存，再交由Extractor读取分析。但是既然是在线视频播放，我们肯定不能把整个容器文件下载到内存或者硬盘再开始解析播放。我们希望能控制下载的进度，比如我当前在看第10s的视频内容，所以我只想缓存/下载视频内容到第20s的位置。 我们俗称的渐进式下载(Progressive Downloading)就解决了这一难题。 在HTTP请求里面加一个叫RANGE的header，放入起始字节和结束字节，就可以只下载对应部分的数据，这一header的支持也是各种下载软件实现断点下载的基础。每次断网的时候记录下来已经下载的数据的字节数，下次再下载的时候从字节数+1处重新下载并且写入原有文件就可以了。 三、 Android的Media API1. Android平台视频播放历史自带播放器缺点： 很多格式的容器文件不支持，也不支持自适应视频播放(Adaptive Streaming) 应用开发者很难debug播放器，MediaPlayer的代码很多都是Native Method。并不在Java层。 很难做自定义的拓展和设置，比如缓冲的大小，下载进度等等。 安卓4.3之后 release 新的 Media Codec API组，把API组件设计的面向视频播放的更底层概念。 从结构图里看出，原来的MediaPlayer把Extractor，和Codec API全部封锁在了Framework层，应用层完全接触不到。在新的API设计里面，这些都挪到了应用层(其实虽然MediaCodec API，就是编解码API还在Framework，但是应用层可以调用他们) 2. Android Codec API的使用在全新的Media API里面，最最最重要的就是MediaExtractor和MediaCodec这两个类，第一个可以对容器文件进行读取控制，第二个就是对数据进行编解码的API。 MediaExtractor可以从一个URL，获取容器文件的轨道数量、轨道信息(Track)。在确定了轨道信息之后，可以选择想要解码的轨道(只能选择一个，所以音轨和视频轨道需要两个不同MediaExtractor给两个不同MediaCodec解码)，再从该轨道不停的读取数据放入MediaCodec API进行解码。 MediaCodec API则是创建的时候就需要选择Codec的类型。然后编码的时候需要安卓平台显示视频的Surface 一个MediaCodec在创建之后会在内部维护两个对列(Queue),一个是InputQueue，一个是OutputQueue。类似生产者消费者的模式，MediaCodec会不停的从InputQueue获取数据(InputQueue的数据又是又MediaExtractor提供)，解码，再把解码之后的数据放入OutputQueue，再提供给Surface让其视频内容。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2FAndroid%20%E5%8A%A8%E7%94%BB%20-%20%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[总结：基本动画 与 属性动画 一、概览： Animator : 这是为动画提供基本支持的类的超类，这些动画可以被启动、结束、并添加AnimatorListeners。 Animator的子类 Evaluator. 二、 注意事项两个方法，避免内存泄漏 onAttachedToWindow()：当含有此View的Activity启动时，View的此方法会被调用。 onDetachedFromWindow()：包含此View的Activity在退出或者View被remove时，View的此方法会被调用。 OOM问题避使用帧动画中，因为当图片数量较多且图片较大时，在此种动画中易出现此问题。 View动画问题View动画是对View的影像做动画，并不是真正的改变View的状态，因此有时候会出现动画完成后无法隐藏的情况，调用setVisibility(View.GONE)也没有作用，此时调用：view.clearAnimation()即可清除View动画。 开启硬件加速——动画更流畅1view.setLayerType(View.LAYER_TYPE_SOFTWARE, null); 三、动画分类0. 复杂属性动画 使用 PropertyValuesHolder 来对多个属性同时做动画； 使用 AnimatorSet 来同时管理调配多个动画； PropertyValuesHolder 的进阶使用：使用 PropertyValuesHolder.ofKeyframe() 来把一个属性拆分成多段，执行更加精细的属性动画。 1. 最早的两种 逐帧动画(frame-by-frame animation) 补间动画(tweened animation) 2. 属性动画 ：ValueAnimator（Android3.0） - 某一属性（值）动画属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的，即：ValueAnimator只不过是对值进行了一个平滑的动画过渡。 它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等 补间动画是只能对View对象进行动画操作的。而属性动画就不再受这个限制，它可以对任意对象进行动画操作。 这个类提供了一个简单的计时引擎，用于运行计算动画值的动画并将其设置在目标对象上。所有动画都有一个定时脉冲。它在自定义处理程序中运行，以确保在UI线程上发生属性更改。默认情况下，ValueAnimator使用非线性时间插值，通过AccelerateDecelerateInterpolator类来加速和减速动画。这种行为可以通过调用{@link ValueAnimator＃setInterpolator（TimeInterpolator）}来改变。动画师可以从代码或资源文件创建。这里是一个ValueAnimator资源文件的例子： {@sample development / samples / ApiDemos / res / anim / animator.xml ValueAnimatorResources} 也可以使用{@link PropertyValuesHolder}和 {@link Keyframe}资源标签来创建一个多步骤的动画。 请注意，您可以XMind为每个关键帧指定显式小数值（从0到1），以确定动画在整个持续时间内何时到达该值。或者，您可以关闭分数，关键帧将在总时长内平均分配：{@sample development / samples / ApiDemos / res / anim / value_animator_pvh_kf.xml ValueAnimatorKeyframeResources} （1）ObjectAnimator - ValueAnimator 子类ValueAnimator的这个子类ObjectAnimator为动画目标对象上的属性提供了支持。这个类的构造函数使用参数来定义将被动画的目标对象以及将被动画的属性名称。然后在内部确定适当的设置/获取函数，动画将根据需要调用这些函数来动画属性。 简单使用方式: 1234ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(mTextView01,"rotation",0f,360f);mObjectAnimator.setDuration(2000);mObjectAnimator.setInterpolator(mInterpolator);mObjectAnimator.start(); 1.1 基本使用12345ObjectAnimator animator = ObjectAnimator.ofFloat(view,"progress",0,100);// 2. 用 start() 执行动画animator.setDuration(3000);animator.setInterpolator(new LinearOutSlowInInterpolator());animator.start(); 在自定义View中使用objectAnimator的“属性”：添加setter()/getter()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class CameraFlipBoard extends View &#123; Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); Camera mCamera = new Camera(); Bitmap mBitmap; int degree; ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); public CameraFlipBoard(Context context) &#123; super(context); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //设置自定义动画 &#123; mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.maps); mAnimator.setDuration(2000); mAnimator.setInterpolator(new FastOutLinearInInterpolator()); //无限重复 mAnimator.setRepeatCount(ValueAnimator.INFINITE); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start(); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end(); &#125; //unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问 @SuppressWarnings("unused") public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate(); &#125; public int getDegree() &#123; return degree; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float centerX = getWidth() / 2; float centerY = getHeight() / 2; float cbx = centerX - mBitmap.getWidth() / 2; float cby = centerY - mBitmap.getHeight() / 2; /* 本次要实现的是由图片的中间开始，上半部分不动，下半部分由上往下翻180度。 所以，一张图片要被分成2部分： 上半部分绘制完成之后不动 下半部分则是反向转动180度 */ //上半部分 canvas.save(); canvas.clipRect(0,0,getWidth(),centerY); canvas.drawBitmap(mBitmap, cbx,cby, mPaint); canvas.restore(); /* 未经移动的canvas坐标原点即为camera的坐标原点。 移动的距离要看 具体的bitmap所在的具体位置： 若bitmap在view的坐标原点，则移动bitmap的width/2和height/2即可。 若bitmap不在view的坐标原点，则要根据他们的相对位置进行计算后移动。 */ //下半部分 canvas.save(); if (degree &lt; 90) &#123; canvas.clipRect(0,centerY,getWidth(),getHeight()); &#125; else &#123; canvas.clipRect(0,0,getWidth(),centerY); &#125; mCamera.save(); canvas.translate(centerX,centerY); mCamera.rotateX(degree); mCamera.applyToCanvas(canvas); canvas.translate(-centerX,-centerY); mCamera.restore(); canvas.drawBitmap(mBitmap,cbx,cby,mPaint); canvas.restore(); &#125;&#125; 1.2 组合动画（一个接一个的动画）：AnimatorSet实现组合动画功能主要需要借助AnimatorSet这个类，这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法： after(Animator anim) 将现有动画插入到传入的动画之后执行 after(long delay) 将现有动画延迟指定毫秒后执行 before(Animator anim) 将现有动画插入到传入的动画之前执行 with(Animator anim) 将现有动画和传入的动画同时执行 1234567ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f); ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f); ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(rotate).with(fadeInOut).after(moveIn); animSet.setDuration(5000); animSet.start(); 1234567891011121314151617181920ObjectAnimator animator1 = ObjectAnimator.ofFloat(...); animator1.setInterpolator(new LinearInterpolator()); ObjectAnimator animator2 = ObjectAnimator.ofInt(...); animator2.setInterpolator(new DecelerateInterpolator());AnimatorSet animatorSet = new AnimatorSet(); // 两个动画依次执行,使用 playSequentially()，就可以让两个动画依次播放，而不用为它们设置监听器来手动为他们监管协作。animatorSet.playSequentially(animator1, animator2); animatorSet.start(); // 两个动画同时执行animatorSet.playTogether(animator1, animator2); animatorSet.start();// 使用 AnimatorSet.play(animatorA).with/before/after(animatorB)// 的方式来精确配置各个 Animator 之间的关系animatorSet.play(animator1).with(animator2); animatorSet.play(animator1).before(animator2); animatorSet.play(animator1).after(animator2); animatorSet.start(); 1.3 同一个动画中改变多个属性： PropertyValuesHolder12345PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat("scaleX", 1);PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat("scaleY", 1); PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat("alpha", 1);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3) animator.start(); 1.4 把同一个属性拆分：PropertyValuesHolders.ofKeyframe()12345678910// 在 0% 处开始Keyframe keyframe1 = Keyframe.ofFloat(0, 0); // 时间经过 50% 的时候，动画完成度 100%Keyframe keyframe2 = Keyframe.ofFloat(0.5f, 100); // 时间见过 100% 的时候，动画完成度倒退到 80%，即反弹 20%Keyframe keyframe3 = Keyframe.ofFloat(1, 80); PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe("progress", keyframe1, keyframe2, keyframe3);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder); animator.start(); （2）ViewPropertyAnimator（Android3.1） 该类可以在View对象上自动优化动画选择属性。 如果View对象上只有一个或两个属性被设置为动画，推荐使用ObjectAnimator。由ObjectAnimator调用的属性设置器能够正确地设置属性并使视图无效。 但是，如果同时对多个属性进行动画处理，或者只是想要更方便的语法来为特定的属性设置动画，则ViewPropertyAnimator可能更适合执行此任务。 这个类可以为几个同时动画提供更好的性能，因为它将优化无效调用，只发生一次对于多个属性，而不是每个动画属性独立地导致它自己的失效。而且，使用这个类的语法可能更容易使用，因为调用者只需要告诉View对象哪个属性需要动画。 这个类不是由调用者构造的，而是由View的属性来动画的。调用View.animate()将返回对该视图的相应ViewPropertyAnimator对象的引用。 imageView.animate()中的animate(): 1234567891011public ViewPropertyAnimator animate() &#123; if (mAnimator == null) &#123; mAnimator = new ViewPropertyAnimator(this); &#125; return mAnimator;&#125; ViewPropertyAnimator(View view) &#123; mView = view; view.ensureTransformationInfo();&#125; 2.1 基本功能： rotation scale translation alpha 2.2 使用到的其他相关接口： Animator ： 动画提供基本支持的类的超类 Animator.AnimatorListener ：动画侦听器从动画接收通知。 ValueAnimator.AnimatorUpdateListener ： TimeInterpolator ViewPropertyAnimatorRT 2.3 除了动画之外的价格set方法: ViewPropertyAnimator setDuration(long duration) ViewPropertyAnimator setInterpolator(TimeInterpolator interpolator) ViewPropertyAnimator setListener(Animator.AnimatorListener listener) ViewPropertyAnimator setStartDelay(long startDelay) ViewPropertyAnimator setUpdateListener(ValueAnimator.AnimatorUpdateListener listener) 2.4 ViewPropertyAnimator基本使用，（同一个动画中改变多个属性）1234567imageView.animate().translationX(500f). alpha(0.2f). scaleX(1.5f). scaleY(1.5f). rotation(720). setInterpolator(new AnticipateOvershootInterpolator()). setDuration(3000); 三、 Animator监听器给动画设置监听器，可以在关键时刻得到反馈，从而及时做出合适的操作，例如在动画的属性更新时同步更新其他数据，或者在动画结束后回收资源等 ViewPropertyAnimator ObjectAnimator setListener() addListener() setUpdateListener() addUpdateListener() set[Update]Listener() remove[Update]Listener() addPauseListener() removePauseListener() withStartAction()一次性动画 withEndAction() Animator类当中提供了一个addListener()方法，这个方法接收一个AnimatorListener，我们只需要去实现这个AnimatorListener就可以监听动画的各种事件了。 四、 其他组件1. 插值器 - Interpolator1.1 Interpolator的作用内插器定义动画的变化率。 这可以使基本的动画效果（alpha，缩放，平移，旋转）加速，减速，重复等。 1.2 Interpolator的继承关系 1.3 系统自带效果 Interpolator class Resource ID AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator AccelerateInterpolator @android:anim/accelerate_interpolator AnticipateInterpolator @android:anim/anticipate_interpolator AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator BounceInterpolator @android:anim/bounce_interpolator CycleInterpolator @android:anim/cycle_interpolator DecelerateInterpolator @android:anim/decelerate_interpolator LinearInterpolator @android:anim/linear_interpolator OvershootInterpolator @android:anim/overshoot_interpolator Interpolator class decription AccelerateDecelerateInterpolator 开始和结束缓慢，中间加速 AccelerateInterpolator 开始的时候缓慢，之后开始加速 AnticipateInterpolator 开始的时候向后甩一下，然后向前 AnticipateOvershootInterpolator 开始的时候向后甩一下，然后加速向前甩过终点一点后回到原点 BounceInterpolator 动画结束的时候小距离的时候在终点处弹起 CycleInterpolator 将重复周期的指定数目的动画。变化率遵循正弦模式 DecelerateInterpolator 开始的时候快，结束的时候慢 FastOutLinearInInterpolator 加速运动 FastOutSlowInInterpolator 先加速再减速 LinearInterpolator 以常量速率变化 LinearOutSlowInInterpolator 持续减速 OvershootInterpolator 运动到终点后，冲过终点后再回弹 PathInterpolator 自定义动画完成度 / 时间完成度曲线 2. 计算器 - TypeEvaluator 参考：http://hencoder.com/ui-1-7/ 告诉动画系统如何从初始值过度到结束值 用于ValueAnimator.setEvaluator（TypeEvaluator）函数的接口。 评估者允许开发人员通过允许他们为动画系统不能自动理解和使用的类型提供自定义评估器来为任意属性类型创建动画。 12345678910111213141516public interface TypeEvaluator&lt;T&gt; &#123; /** * 该函数返回对开始和结束值进行线性插值的结果 * 表示开始和结束值之间的比例的“分数”。 计算是一个简单的参数计算：result = x0 + t *（x1 - x0） * 其中 x0 是 startValue ，x1 是 endValue ， t 是 分数 。 * * @参数分数从开始到结束值的分数 * @param startValue起始值。 * @param endValue最终值。 * @return给定的开始值和结束值之间的线性插值 * fraction ：参数fraction非常重要，这个参数用于表示动画的完成度的，我们应该根据它来计算当前动画的值应该是多少。 */ public T evaluate(float fraction, T startValue, T endValue);&#125; 2.1 一个IntEvaluator类代码：123456789/** * 此评估程序可用于在 int 值之间执行类型插值。 */public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 2.2 使用自定义一个Evaluator 1234567891011public class AZEvaluator implements TypeEvaluator&lt;Character&gt; &#123; @Override public Character evaluate(float fraction, Character startValue, Character endValue) &#123; int startInt = (int)startValue; int endInt = (int)endValue; int curInt = (int)(startInt + (fraction *(endInt - startInt))); char result = (char)curInt; return result; &#125;&#125; 1234567891011121314ValueAnimator valueAnimator = ValueAnimator.ofObject(new AZEvaluator(),Character.valueOf('A'),Character.valueOf('Z'));valueAnimator.setDuration(3000);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; char currentChar = (char) animation.getAnimatedValue(); Log.e(TAG, "onAnimationUpdate: " + currentChar ); showChar.setText(String.valueOf(currentChar)); &#125;&#125;);//valueAnimator.setInterpolator(new LinearInterpolator());valueAnimator.setRepeatCount(ValueAnimator.INFINITE);valueAnimator.setRepeatMode(ValueAnimator.REVERSE);valueAnimator.start(); 硬件加速 参考：http://hencoder.com/ui-1-8/ 硬件加速能够让绘制变快，主要有三个原因 本来由 CPU 自己来做的事，分摊给了 GPU 一部分，自然可以提高效率； 相对于 CPU 来说，GPU 自身的设计本来就对于很多常见类型内容的计算（例如简单的圆形、简单的方形）具有优势； 由于绘制流程的不同，硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免了一些重复操作，从而大幅提升绘制效率。 原理在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。大致就像这样： 而在硬件加速开启时，Canvas 的工作方式改变了：它只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。大致是这样： 限制]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画 - Canvas处理与Camera三维变换]]></title>
    <url>%2FAndroid%20%E5%8A%A8%E7%94%BB%20-%20Canvas%2F</url>
    <content type="text"><![CDATA[总结 1. Canvas与Camera中不可忽略的两个方法：Canvas对同一个图片对象进行处理时，需要时时注意的两个方法。 save() : 保存 - 处理之前的状态 restore() ：恢复 至 save()状态 2. 动画处理的顺序问题：当 Camera 对素材进行处理时，Canvas 的顺序是 反的。即：两者对于一个图片进行多项操作处理时候，实际处理代码的顺序是 由下向上 的。 3. 裁剪 ClipCanvas中与Clip有关的方法： 共有2类：Path和Rect 3.1 Rect裁剪 - 形状、坐标裁剪canvas.clipRect(left,top,left + 130,top + 150); canvas.drawBitmap(bitmap, left, top, paint); 3.2 Path裁剪 - 路径裁剪//圆形抠图 canvas.save(); canvas.translate(250,500); Path path = new Path(); path.addCircle(100,200,100, Path.Direction.CW); canvas.clipPath(path); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); //心形挖空 canvas.save(); canvas.translate(600,500); Path path1 = new Path(); path1.setFillType(Path.FillType.INVERSE_WINDING); path1.arcTo(50,100,150,200,135,225,false); path1.arcTo(150,100,250,200,180,225,false); path1.lineTo(150,300); path1.close(); canvas.clipPath(path1); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); //心形抠图 canvas.save(); canvas.translate(1000,500); Path path2 = new Path(); path2.setFillType(Path.FillType.EVEN_ODD); path2.arcTo(50,100,150,200,135,225,false); path2.arcTo(150,100,250,200,180,225,false); path2.lineTo(150,300); path2.close(); canvas.clipPath(path2); canvas.drawBitmap(bitmap,0,0,paint); canvas.restore(); 4. 变换 Canvas，Matrix，Camera4.1 Canvas变换共有4类： scale - 缩放 translate - 平移 skew - 歪曲 rotate - 旋转 他们的使用方式相同，唯一就是参数类型不同。 skew的使用 123456789101112131415161718192021/** * 斜切 */ canvas.save(); canvas.translate(0,200); /** * @param sx在X中歪斜的数量 * @param sy在Y中倾斜的数量 */ canvas.skew(0f,0.5f); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); canvas.save(); canvas.translate(700,400); /** * @param sx在X中歪斜的数量 * @param sy在Y中倾斜的数量 */ canvas.skew(-0.5f,0f); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 4.2 Matrix变换大致使用 Matrix matrix = new Matrix(); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.save(); matrix.postTranslate(0,300); canvas.concat(matrix); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); canvas.translate(0,-300); canvas.save(); matrix.preTranslate(0,-300); canvas.concat(matrix); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 4.3 Camera变换中的使用Canvas和Matrix仅能对图像实现二维效果的是实现，而Camera所在的是空间三维坐标系，能够实现空间变换效果。 4.3.1 初次实现变换123456789101112131415161718Camera camera = new Camera();canvas.translate(100,200);canvas.save();camera.save();camera.rotateX(30);camera.applyToCanvas(canvas);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore();canvas.translate(100,-200);canvas.save();camera.save();camera.rotateY(30);camera.applyToCanvas(canvas);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 很明显可以看到，在空间坐标系中进行camera变换后，得到的效果已经失真。 Android的Camera中的轴是一个控件三维轴：X、Y、Z，3个轴，camera所对应的原点并不是图像的原点，而是三维坐标轴的原点。 所以图像如果想在camera下沿各个轴做&quot;平面（不失真）&quot;的旋转，就要以图像的中心为轴心进行旋转，但是camera不支持设置轴心，所以要通过Canvas进行轴心的再设置。 通过Canvas将图像的中心移动到轴的中心。待旋转结束之后再将图形的轴心移动回之前的位置。 所以，在camera下将图像进行旋转实际的操作步骤是： 1）将图像中心移动至空间坐标系的轴心 2）执行图像的变换 3）恢复图像原来的轴心位置。 通过移动图像的坐标原点后，对图像的X、Y、Z轴分别旋转30度后，三个图像是重合在一起的。即： 他们的轴心是同一个点。 4.3.2 Camera的空间坐标轴注意：和Camera坐标有关的图片均来自“扔物线”的个人视频截图，此处特此声明。 Camera的空间坐标系的旋转方向： 4.3.3 修正之后123456789101112131415161718192021222324252627282930313233343536373839404142//对X轴进行30度旋转//保存变更前的状态camera.save();canvas.save();//通过canva将三维坐标系的轴心移动至图像的原点，恢复到之前的空间状态。canvas.translate(center1X, center1Y);//在camera下将图像沿着x轴旋转30度camera.rotateX(30);//获得在camera下图像的旋转结果，并将结果应用到canvas中.camera.applyToCanvas(canvas);//通过canva将图像的原点移动至三维坐标系的轴心canvas.translate(-center1X, -center1Y);//camera处理结束后，恢复到之前的sava状态camera.restore();//将得到的图像的结果进行绘制。canvas.drawBitmap(bitmap, point1.x, point1.y, paint);//canvas处理结束后，恢复到之前的sava状态canvas.restore();//对Y轴进行30度旋转canvas.translate(400, 0);camera.save();canvas.save();canvas.translate(center1X, center1Y);camera.rotateY(30);camera.applyToCanvas(canvas);canvas.translate(-center1X, -center1Y);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore();//对Z轴进行30度旋转canvas.translate(400, 0);camera.save();canvas.save();canvas.translate(center1X, center1Y);camera.rotateZ(30);camera.applyToCanvas(canvas);canvas.translate(-center1X, -center1Y);camera.restore();canvas.drawBitmap(bitmap, point1.x, point1.y, paint);canvas.restore(); 实际执行过程 在空间坐标轴中的移动过程大致为： 先将图的原点移动到空间坐标系的原点。即代码： canvas.translate(-center1X, -center1Y); 然后执行具体的变换操作，代码：camera.rotateZ(30); 获取变换后的投影 得到投影结果后，再将图像的原点移动到之前的位置。 运行结果 设置虚拟Camera的位置 123DisplayMetrics displayMetrics = getResources().getDisplayMetrics();float newZ = - displayMetrics.density * 6;camera.setLocation(0, 0, newZ); 5. 为自定义中的图像添加 动画5.1 步骤（1）声明ObjectAnimator对象并进行初始化。12int degree;ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); （2）对ObjectAnimator对象进行具体设置123456//设置时长mAnimator.setDuration(2000);//设置插值器mAnimator.setInterpolator(new FastOutLinearInInterpolator());//无限重复mAnimator.setRepeatCount(ValueAnimator.INFINITE); （3）重写相应的方法设置动画的开始和结束1234567891011@Overrideprotected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start();&#125;@Overrideprotected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end();&#125; （4）设置含有degree属性的方法1234567//unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问@SuppressWarnings("unused")public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate();&#125; （5）使用参数1mCamera.rotateX(degree); 5.2 一个完整的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class CameraFlipBoard extends View &#123; Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); Camera mCamera = new Camera(); Bitmap mBitmap; int degree; ObjectAnimator mAnimator = ObjectAnimator.ofInt(this,"degree",180,0); public CameraFlipBoard(Context context) &#123; super(context); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public CameraFlipBoard(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //设置自定义动画 &#123; mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.maps); mAnimator.setDuration(2000); mAnimator.setInterpolator(new FastOutLinearInInterpolator()); //无限重复 mAnimator.setRepeatCount(ValueAnimator.INFINITE); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); mAnimator.start(); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mAnimator.end(); &#125; //unused这个参数是屏蔽：定义的变量在代码中并未使用且无法访问 @SuppressWarnings("unused") public void setDegree(int degree)&#123; this.degree = degree; //执行重绘 invalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float centerX = getWidth() / 2; float centerY = getHeight() / 2; float cbx = centerX - mBitmap.getWidth() / 2; float cby = centerY - mBitmap.getHeight() / 2; /* 本次要实现的是由图片的中间开始，上半部分不动，下半部分由上往下翻180度。 所以，一张图片要被分成2部分： 上半部分绘制完成之后不动 下半部分则是反向转动180度 */ //上半部分 canvas.save(); canvas.clipRect(0,0,getWidth(),centerY); canvas.drawBitmap(mBitmap, cbx,cby, mPaint); canvas.restore(); /* 未经移动的canvas坐标原点即为camera的坐标原点。 移动的距离要看 具体的bitmap所在的具体位置： 若bitmap在view的坐标原点，则移动bitmap的width/2和height/2即可。 若bitmap不在view的坐标原点，则要根据他们的相对位置进行计算后移动。 */ //下半部分 canvas.save(); if (degree &lt; 90) &#123; canvas.clipRect(0,centerY,getWidth(),getHeight()); &#125; else &#123; canvas.clipRect(0,0,getWidth(),centerY); &#125; mCamera.save(); canvas.translate(centerX,centerY); mCamera.rotateX(degree); mCamera.applyToCanvas(canvas); canvas.translate(-centerX,-centerY); mCamera.restore(); canvas.drawBitmap(mBitmap,cbx,cby,mPaint); canvas.restore(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android7.0新特性-Shortcuts]]></title>
    <url>%2FAndroid7.0%E6%96%B0%E7%89%B9%E6%80%A7-Shortcuts%2F</url>
    <content type="text"><![CDATA[总结 说明如果你的App targets android7.1（API level25）或者更高，你就可以在你的app中定义快捷方式来支持特殊的actions。这些快捷方式可以显示在启动图标上，快捷方式可以在你的app内让用户快速开始使用命令或者推荐任务。Shortcuts是Android7.0的新特性，它的功能就像是类似iphone的3D Touch，选中其中的一条Shortcut后，点击是打开对应的app界面，长按则是将此条Shortcut添加至桌面。 以网易云音乐为例进行展示。 长按带有shorcuts功能的app时，该有的样式。 单个shortcut固定到桌面时的样式。其中大的背景icon是在shortcuts中自己设置的，右下角小的背景icon是app的icon。 实现你也可以在你的app中发布两个不同类型的快捷方式 静态快捷方式被定义在一个资源文件中。因此，你必须等到直到你的app更新后，才能改变“静态快捷方式”中的详情。 动态快捷方式是通过在运行时使用ShortcutManager API来发布的，在运行时，你的app可以发布、更新、和移除。 在你的app中同一时间至多可以发布5个快捷方式（静态和动态结合）。然而不必显示你所创建的每一个。 动态使用到的类 ShortcutManager，ShortcutInfo。其中，ShortcutManager用于管理ShortcutInfo，而ShortcutInfo则是执行具体的创建。 简单的初级实现：manager = getSystemService(ShortcutManager.class); //第一步：ShortcutInfo 对象 ShortcutInfo info = new ShortcutInfo.Builder(this,&quot;id1&quot;) //此条shortcut的icon .setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). //固定到桌面时显示的文字 setShortLabel(&quot;Trinea&quot;). //按住app的icon后此条shortcut在显示时的位置 setRank(1). //按住app的icon后此条shortcut显示的文字 setLongLabel(&quot;打开Trinea主页&quot;). //此条shortcut执行的功能 setIntents(intents). build(); //ShortcutInfo 对象 ShortcutInfo info2 = new ShortcutInfo.Builder(this,&quot;id2&quot;). setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). setShortLabel(&quot;百度&quot;). setRank(2). setLongLabel(&quot;百度一下&quot;). setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.baidu.com/&quot;))). build(); //ShortcutInfo 对象 ShortcutInfo info3 = new ShortcutInfo.Builder(this,&quot;id0&quot;). setIcon(Icon.createWithResource(MainActivity.this,R.mipmap.ic_launcher_round)). setShortLabel(&quot;SecondActivity&quot;). setDisabledMessage(&quot;此快捷方式已经被禁用&quot;). setRank(3). setLongLabel(&quot;打开 SecondActivity&quot;). setIntents(intents2). build(); //第二步：整理shortcut对象 dynamicShortcuts.add(info); dynamicShortcuts.add(info2); dynamicShortcuts.add(info3); //第三步：通过manager设置shortcut //manager.addDynamicShortcuts(Arrays.asList(info)); manager.setDynamicShortcuts(dynamicShortcuts); 静态需要的文件AndroidManifest.xml。 在触发Shortcuts的Activity的activity标签配置中，添加meta-data标签。具体为： &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.shortcuts&quot; android:resource=&quot;@xml/my_shortcut&quot;/&gt; &lt;/activity&gt; 其中android:resource指向定义了 shortcuts 的资源文件。 创建一个资源文件，在res/xml/目录下，文件的名字同meta-data自己编写的my_shortcut： 在这个资源文件中使用shortcuts作为根元素，它包含多个shortcut标签列表，每一个shortcut 就是一个`静态快捷方式`。 一个shortcut的具体为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;shortcut android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:shortcutDisabledMessage=&quot;@string/message&quot; android:shortcutId=&quot;static&quot; android:shortcutLongLabel=&quot;@string/longlaber&quot; android:shortcutShortLabel=&quot;@string/shortlaber&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetClass=&quot;com.example.shortcutsmy.SecondActivity&quot; android:targetPackage=&quot;com.example.shortcutsmy&quot; /&gt; &lt;/shortcut&gt; &lt;/shortcuts&gt; 说明 shortcutId表示 shortcut 唯一标识符，相同的 shortcutId 会被覆盖。必须字段。 shortcutShortLabel为将 shortcut 拖动到桌面时显示的名字，官方建议不超过 10 个字符，必须字段。 shortcutLongLabel为 shortcut 列表中每个 shortcut 的名字，不宜过长，如果过长或未设置默认会显示 ShortLabel，官方建议不超过 25 个字符。可选字段。 icon为 shortcut 的 icon，在列表展示和拖动到桌面时显示需要，可选字段。 enabled表示 shortcut 是否可用，false 表示禁用。xml 中这个属性几乎没有被设置为 false 的实际场景，具体原因可见6.7 如何更好的删除(废弃)老的 Shortcut中介绍。 shortcutDisabledMessage为已固定在桌面的 shortcut 被 Disabled 后点击时的 Toast 提示内容。可选字段。 intent为点击 shortcut 时响应的 intent，必须字段。可以添加多个 intent，但点击时不会启动所有 intent，而是启动最后一个 intent，在这个 intent 回退时会启动它前面一个 intent，相当于自动将所有 intent 添加到了堆栈。 intent可设置属性包括：android:action、android:data、android:mimeType、android:targetClass、android:targetPackage，其中android:action为必须属性。至此，一个静态的Shortcut创建结束了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>版本新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- Paint使用详解]]></title>
    <url>%2FAndroid%20View-%E8%87%AA%E5%AE%9A%E4%B9%89-%20Paint%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[参考：http://hencoder.com/ui-1-2/ Paint类的4个enum画笔填充样式 Style123456public static enum Style&#123; FILL(), FILL_AND_STROKE(), STROKE();&#125; 画笔线头样式 Cap123456public static enum Cap&#123; BUTT(), ROUND(), SQUARE();&#125; 两条直线相交后的样式 Join123456public static enum Join&#123; BEVEL(), MITER(), ROUND();&#125; 文字对齐方式 Align123456public static enum Align&#123; CENTER(), LEFT(), RIGHT();&#125; Paint的功能 颜色 效果 绘制文本 初始化 1. 颜色1.1 基本颜色绘制 基本颜色绘制表示：基础颜色的设置，分类的标准就是根据不同颜色设置方式。 Paint 设置颜色的方法：Paint.setColor/ARGB 来设置颜色123paint.setColor(Color.parseColor("#009688")); paint.setColor(Color.BLACK);paint.setARGB(100, 255, 0, 0); Shader 来指定着色方案Shader 中文名是“着色器”。 注意：在设置了 Shader 的情况下， Paint.setColor/ARGB 所设置的颜色就不再起作用。 在Android中并不是直接使用“Shader类”，而是使用它的子类： LinearGradient（线性渐变） RadialGradient（辐射渐变） SweepGradient（扫描渐变） BitmapShader（Bitmap着色） ComposeShader（组合着色） 其中前三者：LinearGradient（线性渐变）, RadialGradient（辐射渐变）, SweepGradient（扫描渐变）同xml绘制图形中有形同的样式。Shader作为一个基类，包含有一个enum类： 12345678910111213141516171819public enum TileMode &#123; /** * 如果着色器在其原始边界之外绘制，则复制边缘颜色 */ CLAMP (0), /** * 重复着色器的图像水平和垂直 */ REPEAT (1), /** * 复着色器的图像水平和垂直，交替镜像 */ MIRROR (2); TileMode(int nativeInt) &#123; this.nativeInt = nativeInt; &#125; final int nativeInt;&#125; 1 LinearGradient 线性渐变使用： 123Shader shader = new LinearGradient(100, 100, 500, 500, Color.parseColor("#E91E63"), Color.parseColor("#2196F3"), Shader.TileMode.CLAMP);paint.setShader(shader); 此类的构造器 123456789101112131415/** * Create a shader that draws a linear gradient along a line. * * @param x0 The x-coordinate for the start of the gradient line * @param y0 The y-coordinate for the start of the gradient line * @param x1 The x-coordinate for the end of the gradient line * @param y1 The y-coordinate for the end of the gradient line * @param colors The colors to be distributed along the gradient line * @param positions May be null. The relative positions [0..1] of * each corresponding color in the colors array. If this is null, * the the colors are distributed evenly along the gradient line. * @param tile The Shader tiling mode*/ LinearGradient(float x0, float y0, float x1, float y1, @NonNull @ColorInt int colors[], @Nullable float positions[], @NonNull TileMode tile) 参数： x0 y0 x1 y1：渐变的两个端点的位置 color0 color1“ 是端点的颜色 tile：端点范围之外的着色规则，类型是 TileMode 2 RadialGradient 辐射渐变使用： 123Shader shader = new RadialGradient(300, 300, 200, Color.parseColor("#E91E63"), Color.parseColor("#2196F3"), Shader.TileMode.CLAMP);paint.setShader(shader); 构造方法： 1RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, TileMode tileMode)。 参数： centerX centerY：辐射中心的坐标 radius：辐射半径 centerColor：辐射中心的颜色 edgeColor：辐射边缘的颜色 tileMode：辐射范围之外的着色模式。 3 SweepGradient 扫描渐变使用： 123Shader shader = new SweepGradient(300, 300, Color.parseColor("#E91E63"), Color.parseColor("#2196F3"));paint.setShader(shader); 构造方法： 1SweepGradient(float cx, float cy, int color0, int color1) 参数： cx cy ：扫描的中心 color0：扫描的起始颜色 color1：扫描的终止颜色 4 BitmapShader Bitmap 来着色使用： 123Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.batman); Shader shader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); paint.setShader(shader); 通过使用：drawCircle() + BitmapShader就可以绘制圆形的 Bitmap，不用 drawBitmap() 了（其他形状同理）。 构造方法： 1BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY) 参数： bitmap：用来做模板的 Bitmap 对象 tileX：横向的 TileMode tileY：纵向的 TileMode。 5 ComposeShader 混合着色器（两个 Shader 一起使用）使用 1234567891011// 第一个 Shader：头像的 BitmapBitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.batman); Shader shader1 = new BitmapShader(bitmap1, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 第二个 Shader：从上到下的线性渐变（由透明到黑色）Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.batman_logo); Shader shader2 = new BitmapShader(bitmap2, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // ComposeShader：结合两个 ShaderShader shader = new ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER); paint.setShader(shader); ComposeShader() 在硬件加速下是不支持两个相同类型的 Shader 的，所以这里也需要关闭硬件加速才能看到效果。如何 关闭硬件加速 ? 构造方法： 1ComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode) 参数： shaderA, shaderB：两个相继使用的 Shader mode: 两个 Shader 的叠加模式，即 shaderA 和 shaderB 应该怎样共同绘制。它的类型是 PorterDuff.Mode 。 PorterDuff.Mode 一共有 17 个，可以分为： Alpha 合成 (Alpha Compositing) 混合 (Blending) 具体使用参考：http://hencoder.com/ui-1-2/ 1.2 setColorFilter(ColorFilter colorFilter) 颜色过滤对每个像素的颜色进行过滤 在设置了对象的基础颜色之后，再对颜色进行设置就是针对“基础颜色”进行设置，不再是停留在对“对象颜色的填充”方面。Paint通过setColorFilter(ColorFilter filter) 方法设置 ColorFilter。 但是 ColorFilter 并不直接使用，而是使用它的子类： LightingColorFilter：模拟简单的光照效果 使用 12ColorFilter lightingColorFilter = new LightingColorFilter(0x00ffff, 0x000000); paint.setColorFilter(lightingColorFilter); PorterDuffColorFilter ColorMatrixColorFilter 1.3 setXfermode(Xfermode xfermode)指的是你要绘制的内容和 Canvas 的目标位置的内容应该怎样结合计算出最终的颜色，就是要你以绘制的内容作为源图像，以 View 中已有的内容作为目标图像，选取一个 PorterDuff.Mode 作为绘制内容的颜色处理方案。 注意事项 使用离屏缓冲（Off-screen Buffer） 在绘制之前保存，绘制之后恢复： 123456int saved = canvas.saveLayer(null, null, Canvas.ALL_SAVE_FLAG);canvas.drawBitmap(rectBitmap, 0, 0, paint); // 画方paint.setXfermode(xfermode); // 设置 Xfermodecanvas.drawBitmap(circleBitmap, 0, 0, paint); // 画圆paint.setXfermode(null); // 用完及时清除 Xfermodecanvas.restoreToCount(saved); 控制好透明区域 2. 效果2.1 setAntiAlias (boolean aa) 抗锯齿效果抗锯齿默认是关闭的，如果需要抗锯齿，需要显式地打开。打开抗锯齿还有一个更方便的方式，可以在初始化的时候就开启抗锯齿： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);``` ## 2.2 `setStyle(Paint.Style style)` 线条填充效果设置图形是线条风格还是填充风格的，也可以二者并用。## 2.3 线条样式效果线条形状的一共有 4 个方法：- **setStrokeWidth(float width)** ：设置线条宽度- **setStrokeCap(Paint.Cap cap)** ：设置线头的形状。 - BUTT 平头 - ROUND 圆头 - SQUARE 方头默认为 BUTT。![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/006tNc79ly1fig74qv8rij30ct05rglp.jpg)- **setStrokeJoin(Paint.Join join)** : 设置拐角的形状。 - MITER 尖角 - BEVEL 平角 - ROUND 圆角 默认为 MITER![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/006tNc79ly1fig75e27w6j30cp05ewem.jpg)- **setStrokeMiter(float miter)** : 是对于 setStrokeJoin() 的补充，设置 MITER 型拐角的延长线的最大值.![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/006tNc79ly1fig7ak3kqgj30cs0cq74j.jpg)## 2.4 色彩优化效果- **setDither(boolean dither)** ：设置图像的抖动。抖动更多的作用是在图像降低色彩深度绘制时，避免出现大片的色带与色块 ```Javapaint.setDither(true); ``` ![](https://yannischeng-img-1258109292.cos.ap-beijing.myqcloud.com/006tNc79ly1fig7d34s0jj30lf07t75x.jpg) - **setFilterBitmap(boolean filter)** ：双线性过滤来绘制 Bitmap。图像在放大绘制的时候会出现马赛克现象，如果开启了双线性过滤，就可以让结果图像显得更加平滑 ```Javapaint.setFilterBitmap(true); 2.5 setPathEffect(PathEffect effect) 设置轮廓效果使用 12PathEffect pathEffect = new DashPathEffect(new float[]&#123;10, 5&#125;, 10); paint.setPathEffect(pathEffect); 共有6 种 PathEffect： (1) CornerPathEffect – 圆角 (2) DashPathEffect – 虚线效果 (3) DiscretePathEffect – 离散路径效果 (4) PathDashPathEffect – 印章路径效果 (5) ComposePathEffect合并两个特效是有先后顺序的，它会先将第二个参数的PathEffect innerpe的特效作用于路径上，然后再在此加了特效的路径上作用第二个特效。 (6) SumPathEffect是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。 1. CornerPathEffect ：把所有拐角变成圆角 12PathEffect pathEffect = new CornerPathEffect(20); paint.setPathEffect(pathEffect); 构造方法 1CornerPathEffect(float radius) 的参数 radius 是圆角的半径。 使用: 12345678910111213141516171819202122232425262728//第1组 拐角弧度Path path = new Path();path.moveTo(100,200);path.lineTo(400,50);path.lineTo(700,200);path.lineTo(1000,70);canvas.drawPath(path,paintStyle(Color.GREEN,0,null,0));//画布下移canvas.translate(0,50);canvas.drawPath(path,paintStyle(Color.WHITE,50,null,0));canvas.translate(0,50);canvas.drawPath(path,paintStyle(Color.YELLOW,100,null,0));canvas.translate(0,200); private Paint paintStyle(int color, int corner, float[] floats, int phase) &#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); //设置拐角度数 paint.setPathEffect(new CornerPathEffect(corner)); //设置间断线 if (floats != null) &#123; paint.setPathEffect(new DashPathEffect(floats,phase)); &#125; paint.setStyle(Paint.Style.STROKE); return paint;&#125; 2. DiscretePathEffect ：离散路径效果 12PathEffect pathEffect = new DiscretePathEffect(20, 5); paint.setPathEffect(pathEffect); 构造方法 1DiscretePathEffect(float segmentLength, float deviation) 的两个参数中， segmentLength 是用来拼接的每个线段的长度， deviation 是偏离量。使用 123456789101112131415161718192021//第3组离散canvas.translate(0,50);canvas.drawPath(path,paintStyle(Color.GREEN,2,14));canvas.translate(0,50);canvas.drawPath(path,paintStyle(Color.WHITE,4,8));canvas.translate(0,50);canvas.drawPath(path,paintStyle(Color.YELLOW,8,4)); private Paint paintStyle(int color,float someLength, float deviation) &#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); /** * segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为2的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。 deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。 */ paint.setPathEffect(new DiscretePathEffect(someLength,deviation)); paint.setStyle(Paint.Style.STROKE); return paint;&#125; 3. DashPathEffect ：虚线效果 12PathEffect pathEffect = new DiscretePathEffect(20, 5); paint.setPathEffect(pathEffect); 使用 1234567891011121314151617181920212223242526272829303132//第2组 间隔线float[] floats = new float[]&#123;30,10&#125;;float[] floats2 = new float[]&#123;100,30&#125;;float[] floats3 = new float[]&#123;10,30,90,20&#125;;/** * 对于intervals[]数组的有两个限定： 长度必须大于等于2；因为必须有一个实线段和一个空线段来组成虚线。 个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。 对于phase：开始绘制的偏移值 */canvas.translate(0,50);canvas.drawPath(path,paintStyle(Color.GREEN,0,floats,0));canvas.translate(0,50);canvas.drawPath(path,paintStyle(Color.WHITE,50,floats2,50));canvas.translate(0,50);canvas.drawPath(path,paintStyle(Color.YELLOW,100,floats3,100));canvas.translate(0,200); private Paint paintStyle(int color, int corner, float[] floats, int phase) &#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); //设置拐角度数 paint.setPathEffect(new CornerPathEffect(corner)); //设置间断线 if (floats != null) &#123; paint.setPathEffect(new DashPathEffect(floats,phase)); &#125; paint.setStyle(Paint.Style.STROKE); return paint;&#125; 4. PathDashPathEffect ：印章路径效果 1234Path dashPath = ...; // 使用一个三角形来做 dash PathEffect pathEffect = new PathDashPathEffect(dashPath, 40, 0, PathDashPathEffectStyle.TRANSLATE);paint.setPathEffect(pathEffect); 构造方法 1PathDashPathEffect(Path shape, float advance, float phase, PathDashPathEffect.Style style) shape ： 参数是用来绘制的 Path ； advance ：是两个相邻的 shape 段之间的间隔，不过注意，这个间隔是两个 shape 段的起点的间隔，而不是前一个的终点和后一个的起点的距离； phase “和 DashPathEffect 中一样，是虚线的偏移； style ：是用来指定拐弯改变的时候 shape 的转换方式。style 的类型为 PathDashPathEffect.Style ，是一个 enum ，具体有三个值： TRANSLATE：位移 ROTATE：旋转 MORPH：变体 使用 1234567891011121314151617181920212223242526272829303132333435363738394041Path mPath = new Path();mPath.moveTo(0,20);mPath.lineTo(10,0);mPath.lineTo(20,20);mPath.close();/***向路径添加一个闭圆轮廓* Direction:方向 cw:顺时针, ccw:逆时针旋转* @param x要添加到路径的圆的中心的x坐标* @param y要添加到路径的圆的中心的y坐标* @param radius要添加到路径的圆的半径* @param dir滚动圆圈轮廓的方向*/mPath.addCircle(0,0,3, Path.Direction.CCW);mPath.addCircle(20,0,3, Path.Direction.CW);canvas.translate(0,80);//通过变形印章来过渡转角canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,30,12,PathDashPathEffect.Style.MORPH));canvas.translate(0,80);//通过旋转印章来过渡转角canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,40,12,PathDashPathEffect.Style.ROTATE));canvas.translate(0,80);//通过位移来过渡转角canvas.drawPath(path,paintStylePashDush(Color.GREEN,mPath,80,12,PathDashPathEffect.Style.TRANSLATE)); private Paint paintStylePashDush(int color, Path shape, float advance, float phase, PathDashPathEffect.Style style) &#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(5); paint.setColor(color); /** Path shape:表示印章路径，比如我们下面示例中的三角形加右上角一个点； float advance：表示两个印章路径间的距离,很容易理解，印章间距离越大，间距就越大。 float phase：路径绘制偏移距离，与上面DashPathEffect中的float phase参数意义相同 Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE; Style.ROTATE表示通过旋转印章来过渡转角； Style.MORPH表示通过变形印章来过渡转角； Style.TRANSLATE表示通过位移来过渡转角。 */ paint.setPathEffect(new PathDashPathEffect(shape,advance,phase,style)); paint.setStyle(Paint.Style.STROKE); return paint;&#125; 5. SumPathEffect ：分别按照两种 PathEffect 分别对目标进行绘制。 123PathEffect dashEffect = new DashPathEffect(new float[]&#123;20, 10&#125;, 0); PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new SumPathEffect(dashEffect, discreteEffect); 6. ComposePathEffect ：也是一个组合效果类的 PathEffect 先对目标 Path 使用一个 PathEffect，然后再对这个改变后的 Path 使用另一个 PathEffect。 123PathEffect dashEffect = new DashPathEffect(new float[]&#123;20, 10&#125;, 0); PathEffect discreteEffect = new DiscretePathEffect(20, 5); pathEffect = new ComposePathEffect(dashEffect, discreteEffect); 两者曲别： 第 5 种效果是分别将2种效果都绘制出来，2者都可见。第 6 种效果是县绘制第一种效果，然后在第一种效果上再绘制第二种效果，最终呈现的是：在第一种效果上的第二种效果 使用 123456789101112131415161718192021222324252627282930canvas.translate(0,250);//通过变形印章来过渡转角PathDashPathEffect dashPathEffect = new PathDashPathEffect(mPath,40,0,PathDashPathEffect.Style.TRANSLATE);DiscretePathEffect discretePathEffect = new DiscretePathEffect(20,2);canvas.drawPath(path,paintStyleEffectCompose(Color.GREEN,discretePathEffect,dashPathEffect));canvas.translate(0,140);//通过旋转印章来过渡转角canvas.drawPath(path,paintStyleEffectSum(Color.GREEN,dashPathEffect,discretePathEffect)); //设置合并两个路径特效效果private Paint paintStyleEffectCompose(int color, PathEffect effect1, PathEffect effect2) &#123;Paint paint = new Paint();paint.setAntiAlias(true);paint.setStrokeWidth(5);paint.setColor(color);paint.setPathEffect(new ComposePathEffect(effect1,effect2));paint.setStyle(Paint.Style.STROKE);return paint;&#125;//设置合并两个路径特效效果private Paint paintStyleEffectSum(int color, PathEffect effect1, PathEffect effect2) &#123;Paint paint = new Paint();paint.setAntiAlias(true);paint.setStrokeWidth(5);paint.setColor(color);paint.setPathEffect(new SumPathEffect(effect1,effect2));paint.setStyle(Paint.Style.STROKE);return paint;&#125; 注意：PathEffect 在有些情况下不支持硬件加速，需要关闭硬件加速才能正常使用： Canvas.drawLine() 和 Canvas.drawLines() 方法画直线时，setPathEffect() 是不支持硬件加速的； PathDashPathEffect 对硬件加速的支持也有问题，所以当使用 PathDashPathEffect 的时候，最好也把硬件加速关了。 2.6 setShadowLayer(float radius, float dx, float dy, int shadowColor) 在之后的绘制内容下面加一层阴影如果要清除阴影层，使用 clearShadowLayer() 。 注意：在硬件加速开启的情况下， setShadowLayer() 只支持文字的绘制，文字之外的绘制必须关闭硬件加速才能正常绘制阴影。如果 shadowColor 是半透明的，阴影的透明度就使用 shadowColor 自己的透明度；而如果 shadowColor 是不透明的，阴影的透明度就使用 paint 的透明度。 2.7 setMaskFilter(MaskFilter maskfilter)基于整个画面来进行过滤 BlurMaskFilter ：模糊效果 1paint.setMaskFilter(new BlurMaskFilter(50, BlurMaskFilter.Blur.NORMAL)); 构造方法 1BlurMaskFilter(float radius, BlurMaskFilter.Blur style) radius： 参数是模糊的范围 style： 是模糊的类型，共有四种： NORMAL: 内外都模糊绘制 SOLID: 内部正常绘制，外部模糊 INNER: 内部模糊，外部不绘制 OUTER: 内部不绘制，外部模糊 EmbossMaskFilter ：浮雕效果 2.8 获取绘制的 Path根据 paint 的设置，计算出绘制 Path 或文字时的 实际 Path。实际 Path ，指的就是 drawPath() 的绘制内容的轮廓，要算上线条宽度和设置的 PathEffect。 1getFillPath(src, dst) 会计算出实际 Path，然后把结果保存在 dst 里。 12getTextPath(String text, int start, int end, float x, float y, Path path)getTextPath(char[] text, int index, int count, float x, float y, Path path) 文字的绘制虽然使用 Canvas.drawText() 方法，但其实在下层，文字信息全是被转化成图形，对图形进行绘制的。 getTextPath() 方法，获取的就是目标文字所对应的 Path 。这两个方法， getFillPath() 和 getTextPath() ，就是获取绘制的 Path 的方法。之所以把它们归类到「效果」类方法，是因为它们主要是用于图形和文字的装饰效果的位置计算。 3 绘制文本实例公共方法1234567891011121314151617181920212223242526272829303132333435363738394041424344private Paint paintStyle(int color, Paint.Style style)&#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); //设置文字对齐方式，取值：align.CENTER、align.LEFT或align.RIGHT paint.setTextAlign(Paint.Align.LEFT); //设置是否为粗体文字 paint.setFakeBoldText(false); //设置下划线 paint.setUnderlineText(false); //设置字体水平倾斜度，普通斜体字是-0.25 paint.setTextSkewX(/*(float) -0.25*/0f); //设置带有删除线效果 paint.setStrikeThruText(false); //只会将水平方向拉伸，高度不会变 paint.setTextScaleX(0); return paint;&#125;private Paint paintStyleType(int color, Paint.Style style, Typeface typeface)&#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); paint.setTypeface(typeface); return paint;&#125;private Paint paintStyleAlign(int color, Paint.Style style, Paint.Align align)&#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setStrokeWidth(2); paint.setStyle(style); paint.setColor(color); paint.setTextSize(60); paint.setTextAlign(align); return paint;&#125; 基础的文字绘制12345678910111213141516171819202122232425//基线坐标(100,100)//第1个 基线坐标(100,100)canvas.drawText(strs,100,100,paintStyleAlign(Color.BLACK,Paint.Style.FILL, Paint.Align.LEFT));//绘制基线Y轴canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE));//绘制基线X轴canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE));//第2个canvas.translate(0,150);canvas.drawText(strs,600,100,paintStyleAlign(Color.BLACK,Paint.Style.FILL, Paint.Align.CENTER));canvas.drawLine(600,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE));canvas.drawLine(600,0,600,100,paintStyle(Color.RED,Paint.Style.STROKE));//第3个canvas.translate(0,100);canvas.drawText(strs,100,100,paintStyleAlign(Color.BLACK,Paint.Style.STROKE, Paint.Align.LEFT));canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE));canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE));//第4个canvas.translate(0,100);canvas.drawText(strs,600,100,paintStyleAlign(Color.BLACK,Paint.Style.STROKE, Paint.Align.RIGHT));canvas.drawLine(600,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE));canvas.drawLine(600,0,600,100,paintStyle(Color.RED,Paint.Style.STROKE)); FontMetrics 字体的各种度量的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 描述给定文本大小字体的各种度量的类。 请记住，Y值增加下降，所以这些值将是正的，测量距离上升的值将是负的 * 注意:在使用FontMetrics时必须为同一个Paint对象,否则,无法获取文字正确的位置关系 */Paint paint12 = new Paint();paint12.setAntiAlias(true);paint12.setStrokeWidth(2);paint12.setStyle(Paint.Style.STROKE);paint12.setColor(Color.BLACK);paint12.setTextSize(180);Paint.FontMetrics fontMetrics = paint12.getFontMetrics();//可绘制的最高高度所在线float top;//可绘制的最低高度所在线float bottom;//系统建议的，绘制单个字符时，字符应当的最高高度所在线float ascent;//系统建议的，绘制单个字符时，字符应当的最低高度所在线float descent;/** * 建议在文本行之间添加的额外空格。 *///fontMetrics.leading;top = 100 + fontMetrics.top;bottom = 100 + fontMetrics.bottom;ascent = 100 + fontMetrics.ascent;descent = 100 + fontMetrics.descent;canvas.translate(-90,300);canvas.drawText(strs,100,100,paint12);//绘制的文字基线paint12.setStrokeWidth(2);canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE));//可绘制的最高高度所在线paint12.setColor(Color.RED);paint12.setStrokeWidth(4);canvas.drawLine(100,top,1080,top,paint12);//可绘制的最低高度所在线paint12.setColor(Color.GREEN);paint12.setStrokeWidth(4);canvas.drawLine(100,bottom,1080,bottom,paint12);//系统建议的，绘制单个字符时，字符应当的最高高度所在线paint12.setColor(Color.YELLOW);paint12.setStrokeWidth(2);canvas.drawLine(100,ascent,1080,ascent,paint12);//系统建议的，绘制单个字符时，字符应当的最低高度所在线paint12.setColor(Color.BLACK);paint12.setStrokeWidth(2);canvas.drawLine(100,descent,1080,descent,paint12);//文字所占宽度float width = paint12.measureText(strs);//文字所占高度float height = bottom - top;Log.e(TAG, "onDraw width: " + width + ", height : " + height);//绘制文字所占区域的边框Path pathRect = new Path();RectF rectF2 = new RectF(100,top,width+100,bottom);paint12.setColor(Color.BLUE);paint12.setStrokeWidth(1);pathRect.addRect(rectF2, Path.Direction.CW);canvas.drawRect(rectF2,paint12); 根据路径绘制文字123456789101112131415161718192021222324252627PathMeasure measure = new PathMeasure(pathRect,false);int length = (int) measure.getLength();paint12.setTextSize(40);paint12.setColor(Color.RED); canvas.drawText(String.valueOf(length),width,bottom,paint12);//根据路径绘制文字paint12.setColor(Color.BLACK);paint12.setTextSize(90);canvas.translate(0,200);Path rectPath = new Path();RectF rectF = new RectF(400,200,1000,800);//顺时针rectPath.addRect(rectF, Path.Direction.CW);canvas.drawPath(rectPath,paintStyle(Color.RED,Paint.Style.STROKE));/** * @param hOffset 要添加到文本开始位置的路径上的距离 * @param vOffset（ - ）或以下的距离（+）定位文本的路径 */paint12.setStyle(Paint.Style.FILL_AND_STROKE);canvas.drawTextOnPath(strs,rectPath,0,0,paint12);paint12.setStyle(Paint.Style.STROKE);canvas.drawTextOnPath(strs,rectPath,20,20,paint12);paint12.setStyle(Paint.Style.STROKE);paint12.setColor(Color.BLUE);canvas.drawTextOnPath(strs,rectPath,-20,-20,paint12); 顺时针 逆时针 4 初始化类这一类方法是用来初始化 Paint 对象，或者是批量设置 Paint 的多个属性的方法。 4.1 reset()重置 Paint 的所有属性为默认值。相当于重新 new 一个，不过性能当然高一些啦。 4.2 set(Paint src)把 src 的所有属性全部复制过来。相当于调用 src 所有的 get 方法，然后调用这个 Paint 的对应的 set 方法来设置它们。 4.3 setFlags(int flags)批量设置 flags。相当于依次调用它们的 set 方法。例如：  1paint.setFlags(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG); 这行代码，和下面这两行是等价的： 12paint.setAntiAlias(true); paint.setDither(true);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义-绘制图表]]></title>
    <url>%2FAndroid%20View-%E8%87%AA%E5%AE%9A%E4%B9%89-%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[总结 步骤分析数据的表现形式 坐标系 饼状图 数据准备，获取图表的： 标题 各个数据项的名称 各个数据项的数值 将数据进行封装 在设定item尺寸范围时，需要设定： 规定好起始位置（X轴或Y轴的startValue） 坐标系确定好原点（0，0） 饼状图确定好圆心 各个item之间的间隔（space） 单个item的宽度或高度（比值） 直方图、折线图时平均分配item的高度、宽度； 饼状图时各个数据所占的扇形面积的大小（当前数据所占比例*360）。 有无特殊要求？具体实现标记重点：在自定义图表的实现过程中，尽量使用“对象获取”、“比例化”的数据。 两个图使用的同一个数据类：PhoneData1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class PhoneData &#123; String phoneName; float phoneValue; int phoneColor; public PhoneData(String phoneName, float phoneValue, int phoneColor) &#123; this.phoneName = phoneName; this.phoneValue = phoneValue; this.phoneColor = phoneColor; &#125; public String getPhoneName() &#123; return phoneName; &#125; public void setPhoneName(String phoneName) &#123; this.phoneName = phoneName; &#125; public float getPhoneValue() &#123; return phoneValue; &#125; public void setPhoneValue(float phoneValue) &#123; this.phoneValue = phoneValue; &#125; public int getPhoneColor() &#123; return phoneColor; &#125; public void setPhoneColor(int phoneColor) &#123; this.phoneColor = phoneColor; &#125; @Override public String toString() &#123; return "PhoneData&#123;" + "phoneName='" + phoneName + '\'' + ", phoneValue=" + phoneValue + ", phoneColor=" + phoneColor + '&#125;'; &#125;&#125; 坐标系的实现：一个完整的类，包括注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213/** * 直角坐标系 * * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class Histogram extends View &#123; private static final String TAG = "Histogram"; private String titleName = "直角坐标系"; private List&lt;PhoneData&gt; mPhoneData = null; private float maxVal = 0f; private float totalVal = 0f; private Paint mPaint = null; private DecimalFormat mDecimalFormat; public Histogram(Context context) &#123; super(context); &#125; public Histogram(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public Histogram(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void initData() &#123; mPhoneData = new ArrayList&lt;&gt;(); mPhoneData.add(new PhoneData("HuaWei", 38f, Color.RED)); mPhoneData.add(new PhoneData("Vivo", 23f, Color.BLUE)); mPhoneData.add(new PhoneData("Samsung", 33f, Color.GREEN)); mPhoneData.add(new PhoneData("Oppo", 12f, Color.YELLOW)); mPhoneData.add(new PhoneData("Apple", 41f, Color.MAGENTA)); mPhoneData.add(new PhoneData("XiaoMi", 17f, Color.LTGRAY)); mPhoneData.add(new PhoneData("Pixel2", 6f, Color.DKGRAY)); mPhoneData.add(new PhoneData("HTC", 11f, Color.MAGENTA)); mPhoneData.add(new PhoneData("MOTO", 9f, Color.CYAN)); for (PhoneData item : mPhoneData) &#123; maxVal = Math.max(maxVal, item.getPhoneValue()); totalVal = totalVal + item.getPhoneValue(); &#125; dealMaxVal(maxVal); Log.d(TAG, "(&gt;^ω^&lt;) -&gt; initData maxVal is : " + maxVal + ", totalVal is : " + totalVal); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); mPaint.setColor(Color.BLACK); mDecimalFormat = new DecimalFormat(".00"); &#125; private void dealMaxVal(float maxVal) &#123; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); initData(); mPaint.setStrokeWidth(1); mPaint.setTextSize(56); canvas.drawText(titleName, canvas.getWidth() / 2 - mPaint.measureText(titleName) / 2, canvas.getHeight() * 0.07f, mPaint); mPaint.setColor(Color.BLACK); canvas.translate(canvas.getWidth() * 0.1f, canvas.getHeight() * 0.9f); mPaint.setStrokeWidth(5); //方式：2,两者均可实现绘制 canvas.drawLine(0f, 0f, canvas.getWidth() * 0.8f, 0f, mPaint); canvas.drawLine(0f, 0f, 0f, -canvas.getHeight() * 0.8f, mPaint); //item的宽度和间隔 float itemWidth = canvas.getWidth() * 0.8f / mPhoneData.size() * 0.8f; float itemSpace = canvas.getWidth() * 0.8f / mPhoneData.size() * 0.2f; //绘制直方图 drawRect(canvas, itemSpace, itemWidth, maxVal); //绘制数值文字 drawTextValue(canvas, itemSpace, itemWidth, maxVal); //绘制折线 drawLines(canvas, itemSpace, itemWidth, maxVal); //绘制点 drawPoint(canvas, itemSpace, itemWidth, maxVal); //绘制最高数值参考线 drawKindOfValLine(canvas, itemSpace, itemWidth); &#125; private void drawKindOfValLine(Canvas canvas, float itemSpace, float itemWidth) &#123; int maxValIndex = 0; mPaint.setColor(Color.BLUE); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStrokeWidth(2); float aveVal = totalVal / mPhoneData.size(); for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; if (maxVal == mPhoneData.get(i).getPhoneValue()) &#123; maxValIndex = i; &#125; &#125; //最大值的表示 float valueYMax = -maxVal / maxVal * canvas.getHeight() * 0.7f; String maxStr = mDecimalFormat.format(mPhoneData.get(maxValIndex).getPhoneValue()); canvas.drawLine(0f, valueYMax, maxValIndex * (itemSpace + itemWidth) + (itemSpace + itemWidth / 2), valueYMax, mPaint); canvas.drawText(maxStr, -mPaint.measureText(maxStr) - 10f, valueYMax, mPaint); //平均值的表示 float valueYAve = -aveVal / maxVal * canvas.getHeight() * 0.7f; String aveStr = mDecimalFormat.format(aveVal); canvas.drawLine(0f, valueYAve, canvas.getWidth() * 0.8f, valueYAve, mPaint); canvas.drawText(aveStr, -mPaint.measureText(aveStr) - 10f, valueYAve, mPaint); &#125; private void drawRect(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; float startXY = 0f; mPaint.setTextSize(36); mPaint.setStrokeWidth(1); for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); //绘制X轴文字 - 横向 canvas.drawText(item.getPhoneName(), startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2, 60, mPaint); //绘制X轴文字 - 有一定角度 /* Path path = new Path(); path.moveTo(startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2, 30); path.lineTo(startXY + itemSpace + (itemWidth - mPaint.measureText(item.getPhoneName())) / 2 + 30, 30 + mPaint.measureText(item.getPhoneName())); canvas.drawTextOnPath(item.getPhoneName(),path,0,0,mPaint);*/ //绘制直方图 canvas.drawRect(startXY + itemSpace, -item.getPhoneValue() / maxVal * canvas.getHeight() * 0.7f, startXY + itemSpace + itemWidth, 0, mPaint); //重新绘制item的起始点 startXY += itemSpace + itemWidth; &#125; &#125; private void drawTextValue(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; float startXY = 0f; mPaint.setTextSize(36); mPaint.setStrokeWidth(1); for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); //绘制直方图上方的数值文字 canvas.drawText(String.valueOf(item.getPhoneValue()), startXY + itemSpace + (itemWidth - mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2, -item.getPhoneValue() / maxVal * canvas.getHeight() * 0.7f - 20f, mPaint); //重新绘制item的起始点 startXY += itemSpace + itemWidth; &#125; &#125; private void drawPoint(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(20); mPaint.setStrokeCap(Paint.Cap.ROUND); float startX = itemSpace + itemWidth / 2; float startY = 0f; for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; canvas.drawPoint(startX, startY, mPaint); startX = startX + itemSpace + itemWidth; &#125; &#125; private void drawLines(Canvas canvas, float itemSpace, float itemWidth, float maxVal) &#123; mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(5); float startX = itemSpace + itemWidth / 2; float startY = 0f; float endX = 0f; for (int i = 0; i &lt; mPhoneData.size(); i++) &#123; if (i == 0) &#123; startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; canvas.drawPoint(startX, startY, mPaint); &#125; else &#123; endX = startX + itemSpace + itemWidth; canvas.drawLine(startX, startY, endX, -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f, mPaint); startY = -mPhoneData.get(i).getPhoneValue() / maxVal * canvas.getHeight() * 0.7f; startX = endX; &#125; &#125; &#125;&#125; /* 绘制x，y轴 方式：1 canvas.drawLine(canvas.getWidth() * 0.1f, canvas.getHeight() * 0.9f,canvas.getWidth() * 0.9f,canvas.getHeight() * 0.9f,mPaint); canvas.drawLine(canvas.getWidth() * 0.1f,canvas.getHeight() * 0.9f,canvas.getWidth() * 0.1f,canvas.getHeight() * 0.1f,mPaint); */ 饼状图的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * PieChart 饼状图 * * @author wenjia.Cheng cwj1714@163.com * @date 2017/11/13 */public class PieChart extends View &#123; private static final String TAG = "PieChart"; private String titleName = "饼状图"; private List&lt;PhoneData&gt; mPhoneData = null; private float maxVal = 0f; private float totalVal = 0f; private Paint mPaint = null; /** * 起始角度 */ private float startAngle; /** * 划过角度 */ private float swepAngle; /** * 划过角度的一半 */ private float halfSwepAngle; /** * 指示文字的标线 X 轴起始点。 */ private float lineStartX; private float lineStartY; private float lineEndX; private float lineEndY; private float radius = 0f; private float divideStart = 90; private float divideEnd = 270; private DecimalFormat decimalFormat; public PieChart(Context context) &#123; super(context); &#125; public PieChart(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public PieChart(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void initData()&#123; mPhoneData = new ArrayList&lt;&gt;(); mPhoneData.add(new PhoneData("HuaWei",38f, Color.RED)); mPhoneData.add(new PhoneData("Vivo",23f,Color.BLUE)); mPhoneData.add(new PhoneData("Samsung",33f,Color.GREEN)); mPhoneData.add(new PhoneData("Oppo",12f,Color.YELLOW)); mPhoneData.add(new PhoneData("Apple",41f,Color.MAGENTA)); mPhoneData.add(new PhoneData("XiaoMi",17f,Color.LTGRAY)); mPhoneData.add(new PhoneData("Pixel2",6f,Color.DKGRAY)); for (PhoneData item : mPhoneData) &#123; maxVal = Math.max(maxVal,item.getPhoneValue()); totalVal = totalVal + item.getPhoneValue(); &#125; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); mPaint.setStrokeWidth(1); mPaint.setColor(Color.BLACK); //构造方法的字符格式这里如果小数不足2位,会以0补足. decimalFormat=new DecimalFormat("######0.00"); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); /* 圆点坐标：(x0,y0) 半径：r 角度：a0 则圆上任一点为：（x1,y1） x1 = x0 + r * cos(ao * 3.14 /180 ) y1 = y0 + r * sin(ao * 3.14 /180 ) */ initData(); mPaint.setTextSize(56); canvas.drawText(titleName,canvas.getWidth()/2 - mPaint.measureText(titleName)/2, canvas.getHeight() * 0.07f,mPaint); //移动画布的原点 canvas.translate(canvas.getWidth() / 2,canvas.getWidth() / 2 - 100f); float length = canvas.getWidth() * 0.25f; RectF rectF = new RectF(-length, -length,length,length); mPaint.setStrokeWidth(5); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStyle(Paint.Style.FILL); mPaint.setTextSize(36); radius = length; for (PhoneData item : mPhoneData) &#123; mPaint.setColor(item.getPhoneColor()); swepAngle = item.getPhoneValue() / totalVal * 360f; halfSwepAngle = startAngle + swepAngle / 2; /* * 角度=弧度*180/Math.PI 圆点坐标：(x0,y0) 半径：r 角度：a0 则圆上任一点为：（x1,y1） x1 = x0 + r * cos(ao * 3.14 /180 ) y1 = y0 + r * sin(ao * 3.14 /180 ) */ lineStartX = (float) (radius * Math.cos(halfSwepAngle * Math.PI / 180)); lineStartY = (float) (radius * Math.sin(halfSwepAngle * Math.PI / 180)); lineEndX = (float) ((radius + 50) * Math.cos(halfSwepAngle * Math.PI / 180)); lineEndY = (float) ((radius + 50) * Math.sin(halfSwepAngle * Math.PI / 180)); if (maxVal == item.getPhoneValue()) &#123; //注意先保存当前canvas canvas.save(); canvas.translate(lineStartX * 0.1f, lineStartY * 0.1f); canvas.drawArc(rectF, startAngle, swepAngle - 2f, true, mPaint); canvas.drawLine(lineStartX,lineStartY,lineEndX,lineEndY,mPaint); //绘制各个区域的文字 diffLineLength(canvas, item); //绘制各个区域的数值 diffLineVal(canvas, item); //绘制百分比 //diffPercentage(canvas,item); &#125; else &#123; canvas.drawArc(rectF,startAngle,swepAngle - 2f,true,mPaint); canvas.drawLine(lineStartX,lineStartY,lineEndX,lineEndY,mPaint); diffLineLength(canvas, item); diffLineVal(canvas, item); //diffPercentage(canvas,item); &#125; if (maxVal == item.getPhoneValue()) &#123; // 特殊工作做完之后，再回复之前保存的canvas canvas.restore(); &#125; startAngle += swepAngle; &#125; &#125; private void diffLineLength(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; canvas.drawLine(lineEndX, lineEndY, lineEndX - 100, lineEndY, mPaint); canvas.drawText(item.getPhoneName(), lineEndX - 120 - mPaint.measureText(item.getPhoneName()), lineEndY, mPaint); &#125; else &#123; canvas.drawLine(lineEndX,lineEndY,lineEndX + 100,lineEndY,mPaint); canvas.drawText(item.getPhoneName(),lineEndX + 120,lineEndY,mPaint); &#125; &#125; private void diffLineVal(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; mPaint.setColor(Color.WHITE); canvas.drawText(String.valueOf(item.getPhoneValue()),(lineEndX - (mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2) * 0.5f,(lineEndY) * 0.5f, mPaint); &#125; else &#123; mPaint.setColor(Color.WHITE); canvas.drawText(String.valueOf(item.getPhoneValue()),(lineEndX + (mPaint.measureText(String.valueOf(item.getPhoneValue()))) / 2) * 0.5f,(lineEndY) * 0.5f, mPaint); &#125; &#125; private void diffPercentage(Canvas canvas, PhoneData item) &#123; if (halfSwepAngle &gt; divideStart &amp;&amp; halfSwepAngle &lt;= divideEnd) &#123; mPaint.setColor(Color.WHITE); canvas.drawText(decimalFormat.format(item.getPhoneValue() / totalVal *100) + "%",(lineEndX - mPaint.measureText(decimalFormat.format(item.getPhoneValue()))) / 2,(lineEndY) * 0.5f, mPaint); &#125; else &#123; mPaint.setColor(Color.WHITE); canvas.drawText(decimalFormat.format(item.getPhoneValue() / totalVal *100) + "%" ,(lineEndX - mPaint.measureText(decimalFormat.format(item.getPhoneValue()))) / 2,(lineEndY) * 0.5f, mPaint); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《Head First 设计模式》 设计原则：依赖倒置原则要依赖抽象，不要依赖具体类。 这个原则比起“针对接口编程，不针对实现编程”更加强调的是“抽象”。不让高层组件依赖底层组件，而且不论“高层”还是“底层”，两者都依赖“抽象”。 这个模式的学习，首先通过一个自己以前最常见的编码开始（自己在学校编写小项目时曾经真的这么写过 ，好囧啊 ﾍ(;´Д｀ﾍ) ）。 引出问题 这样看可能并不会特别直观，但是只要转换为图形…… 通过这个图形的，我们已经很直观的能看到问题的所在：有点“牵一发而动全身”的意思。这样的编写违背了面向接口编程的原则，而且耦合程度高：一个类与众多的类之间保持着依赖关系。 进行倒置 依赖倒置原则中的“倒置”究竟“倒”在哪里？“倒置”指的是和一般的OO设计思想方式相反，倒置你针对问题进行设计时的思维方式。 如何避免违反依赖倒置原则： 变量不可以持有具体类的引用。 在此例中，使用工厂方法来避免new 不要让类派生自具体的类。 不要覆盖基类中已实现的方法 抽象工厂模式的定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。抽象工厂的任务是定义创建一组产品的接口，接口内的每个方法负责创建一个具体的产品，同时我们利用实现抽象工厂子类来实现这个创建方法。抽象工厂中利用工厂方法实现生产方法是相当自然的做法。 停止于： 2017-11-08 15:10:25 专向：Android高级进阶]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StarUML的使用]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%20StarUML%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[StarUML使用参考：http://blog.csdn.net/eyckwu/article/details/53871841UML学 : http://www.uml.org.cn/oobject/201104212.asp各种图（流程图，思维导图，UML，拓扑图，ER图）简介 ：http://www.cnblogs.com/jiqing9006/p/3344221.html 码云拾遗 明星效应。很简单，在一个领域保持顶尖水平，比在一两个领域保持领先水平和五六个领域保持一般水准都要更有价值、并且收益更好。 有悖常识的真相：让未来更开放的方式，正是专注的去做好一件事情。这个世界上最成功的人，他们在某一领域获得成功之后，可通过经营杠杆进入任何他们想要涉足的领域。而这都得依赖于他们曾极致的专注在做好一件事情上。 正文StarUML是一个韩国人用DELPHI写的UML工具，支持UML2.0。 UML： 静态建模：系统基础和系统固定框架结构，这些图形往往是“静态”的。 类图(Class Diagram)：常用来分析业务概念 用例图(Use Case Diagram)：由参与者、用例以及它们之间的关系构成的 使用参考：https://www.2cto.com/os/201502/377091.html 参与者：是指存在于系统外部并直接与系统交互的人、系统或设备等。 用例：是系统为参与者提供的功能。 用例命名：取一个简单、概括性的名称，一般是带有动作性的名称。 用例表示：用椭圆表示，椭圆下面附有用例的名称、实线箭头，在用例图中用于连接参与者与用例，用例方向指向用例。 用例与用例之间的三种关系： 1. 泛化（generalization）代表一般与特殊的关系 2. 包含（include）关系 3. 扩展（extend）关系 对象图(Object Diagram) 构件图(Component Diagram)：表示组件之间的关系 部署图(Deployment Diagram)：部署软件应用的物理设备信息 2. 动态建模：描述的是某种行为，是“动态”的。 活动图(Activity Diagram)：类似流程图 状态机图(State Machine Diagram) 时序图(Sequence Diagram)：捕捉一段时间范围内多个对象之间的交互信息， 强调信息交互的时间顺序。 通讯图(Communication Diagram) 时间图(Timing Diagram) StarUML使用Mode的选择选择更为具体的图 添加更为丰富的元素 类图的画法概览 如上图是一个类图，下面对每一个图标的内容进行解释（从左到右，从从上到下）。左侧： 标识Class的可见性（默认public） 添加note，进行对类的说明 右侧： 增加类的属性 增加类的行为 添加reception 添加子类 添加父类 添加已有的接口 添加需要的接口 添加关联 添加聚合 添加组合 添加端口 添加组件 具体1. 类图包括：类名 + 属性 + 方法 2. 类图之间的关系1. 泛化（Generalization）： 就是面向对象中的继承，奔驰、宝马、奥迪都继承自汽车类 表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节，直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 2. 实现（interface Realization）：圆圈代表接口 一般接口实现的画法及表示：在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。 3. 依赖（Dependency）： 对象之间最弱的一种关联方式，是临时性的关联，代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。 一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。 在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。 StarUML的使用同下图 4. 关联4.1 一般关联(Association) : 对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。 在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 4.2 聚合关联(Aggregation) : 表示has-a的关系，是一种不稳定的包含关系。 较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。 在类图使用空心的菱形表示，菱形从局部指向整体。 4.3 组合(Composition) : 表示contains-a的关系，是一种强烈的包含关系。 组合类负责被组合类的生命周期，是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。 在类图使用实心的菱形表示，菱形从局部指向整体。 5. 多重性(Multiplicity) :通常在关联、聚合、组合中使用。就是代表有多少个关联对象存在。使用数字..星号（数字）表示。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 Scrapy爬虫框架使用]]></title>
    <url>%2FPython3%20Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Scrapy框架使用指南：http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.htmlScrapy零基础使用：http://www.jb51.net/article/57183.htm 开题问：把网站装进爬虫需要几步？答：四步。 1. 新建项目2. 明确目标3. 制作爬虫4. 存储内容 注意：# coding=utf-8 使用Scrapy爬虫框架时应该添加此条语句表明注释是中文注释 1. 新建项目使用命令新建一个scrapy项目 scrapy startproject projectName 建立项目的文件目录 scrapyproject ├── scrapy.cfg └── scrapyproject ├── __init__.py ├── items.py ├── middlewares.py ├── pipelines.py ├── settings.py └── spiders └── __init__.py 2 directories, 7 files 各个文件的作用： scrapy.cfg ：项目的配置文件 scrapyproject/ ：项目的Python模块，将会从这里引用代码 scrapyproject/items.py ：项目的items文件 scrapyproject/pipelines.py ：项目的pipelines文件 scrapyproject/settings.py ：项目的设置文件 scrapyproject/spiders/ ：具体执行爬虫的目录 2. 明确目标在Scrapy中，items是用来管理抓取内容的容器，有点像Python中的Dict，但是提供了一些额外的保护减少错误。 一般来说，item可以用scrapy.item.Item类来创建，并且用scrapy.item.Field对象来定义属性（可以理解成类似于ORM映射关系，类似于java bean）。 编写Item：修改scrapyproject目录下的items.py4文件，在原本的class后面添加我们自己的class。 import scrapy class PyScrapy1601Item(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() pass class DmozItem(scrapy.Item): node = scrapy.Field() 3. 爬虫实现先爬后取 3.1 爬要建立一个Spider，你必须用scrapy.spider.BaseSpider创建一个子类，并确定三个强制属性： name ：爬虫的识别名称，必须是唯一的。 start_urls ：爬取的URL列表。爬虫从这里开始抓取数据。 parse() ：解析的方法，调用的时候传入从每一个URL传回的Response对象作为唯一参数，负责解析并匹配抓取的数据(解析为item)。 allow_domains ：allow_domains是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页。一个模板： from scrapy.spider import Spider from scrapy.selector import Selector from py_scrapy_16_01.py_scrapy_16_01.items import DmozItem class DmozSpider(Spider): name = &quot;dmoz&quot; allowed_domains = [&quot;dmoztools.net&quot;] start_urls = [ &quot;http://dmoztools.net/Computers/Programming/Languages/Python/&quot;, ] def parse(self, response): sel = Selector(response) sites = sel.xpath(&apos;//div[@class=&quot;browse-node&quot;]/text()&apos;) items2 = [] for node in sites: item = DmozItem() item[&apos;href&apos;] = node.extract() items2.append(item) return items2 进入到 /scrapyproject/scrapyproject下 运行 scrapy crawl dmoz 执行了这条命令发生了啥？首先，Scrapy为爬虫的 start_urls 属性中的每个URL创建了一个scrapy.http.Request 对象 ，并将爬虫的parse() 方法指定为回调函数。然后，这些 Request 被调度并执行，之后通过parse()方法返回 scrapy.http.Response 对象，并反馈给爬虫。 3.2 取爬取整个网页完毕，接下来的就是的取过程了。在基础的爬虫里，这一步可以用正则表达式来抓。在Scrapy里，使用一种叫做 XPath selectors的机制，它基于 XPath表达式。 例子：/html/head/title : 选择HTML文档元素下面的&lt;title&gt;标签。/html/head/title/text() : 选择前面提到的&lt;title&gt; 元素下面的文本内容//td: 选择所有 &lt;td&gt; 元素//div[@class=”mine”] : 选择所有包含 class=&quot;mine&quot; 属性的div标签元素 xpath路径表达式： 表达式 描述 / 从根节点选取 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 更多使用参考 W3C-XPath ：http://www.w3school.com.cn/xpath/index.asp 为了方便使用XPaths，Scrapy提供XPathSelector 类，有2种可以选择: HtmlXPathSelector (HTML数据解析) XmlXPathSelector (XML数据解析) 必须通过一个 Response 对象对他们进行实例化操作，如： sel = Selector(response) Selector对象展示了文档的节点结构。因此，第一个实例化的selector必与根节点或者是整个目录有关 。在Scrapy里面，Selectors 有4种基础的方法： xpath() ：返回一系列的selectors，每一个select表示一个xpath参数表达式选择的节点。 css() ：返回一系列的selectors，每一个select表示一个css参数表达式选择的节点。 extract() ：返回一个unicode字符串，即选中的数据。 re() ：返回一串一个unicode字符串，即使用正则表达式抓取出来的内容。 3.3 xpath()测试在终端输入： scrapy shell http://dmoztools.net/Computers/Programming/Languages/Python/ 在没有报错的情况下，输入 response.headers 得到： 在没有报错的情况下，输入 response.body 得到： 4. 存储内容保存信息的最简单的方法是通过Feed exports，主要有4种：JSON，JSON lines，CSV，XML。我们将结果用最常用的JSON导出，命令如下： scrapy crawl dmoz -o items.json -t json 其中，-o 后面是导出文件名，-t 后面是导出类型。 5. Pycharm中运行爬虫程序错误1. NameError: global name ‘DmozItem’ is not definedFile &quot;/Users/yannischeng/PycharmProjects/First_Python_Project/spiderone/spiderone/spiders/dmoe_spider.py&quot;, line 20, in parse item = DmozItem() NameError: global name &apos;DmozItem&apos; is not defined 解决方案：使用相对导入 from ..items import DmozItem 第一个点(.) 表示当前目录，第二个点表示上一级父目录。这样做还有一个额外的好处就是你可以随意修改你的包的名称，松耦合。 2. Scrapy爬取中文，显示ascii码，如何转变成utf-8正常编码？ 参考：http://www.jianshu.com/p/c03d968ef68b 将爬取到的中文信息存储为json格式的文件时，文字显示就会出现问题，存储为xml时就不会有问题。本要求应该显示的是：摘要，而实际显示的内容为：\&quot;\u6458\u8981 解决方案：使用json包中的json.dumps(dictname,ensure_ascii=False)具体案例使用： item[&apos;node&apos;] = json.dumps(node.extract(), ensure_ascii=False) print(item[&apos;node&apos;]) 摘要: 把系统换到了fedora,记录几个相关的配置 3. scrapy` 的 parse() return 值必须是Request, BaseItem, dict or None，如果返回str报错[scrapy.core.scraper] ERROR: Spider must return Request, BaseItem, dict or None, got &apos;str&apos; in &lt;GET http://www.cnblogs.com/aLittleBitCool/&gt; 4. scrapy爬虫得到的json文件是ascii码问题 参考：http://bbs.fishc.com/thread-85672-1-1.html import json #记得添加这两个库 import codecs class XXXPipeline(object): #XXX就是你建立scrapy工程的名称 def __init__(self): #添加一下初始化方法 self.file = codecs.open(&apos;item.json&apos;, &apos;wb&apos;, encoding=&apos;utf-8&apos;) #item.json指的是你要保存的json格式文件的名称，编码格式一般都是&apos;utf-8&apos; def process_item(self, item, spider): line = json.dumps(dict(item),ensure_ascii=False) + &apos;\n&apos; #这一句会将你每次返回的字典抓取出来,“ensure_ascii=False”这一句话很重要，如果是True的话就是我们保存的\u4e2d\u56fd这种格式了 self.file.write(line) #写入到文件中 return item 将以上内容插入pipelines.py,同时在settings.py中加入 ITEM_PIPELINES = { &apos;panda.pipelines.PandaPipeline&apos;: 300 }]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境下MySQL的安装与使用]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[平台：Mac环境 mysql操作命令参考：http://www.runoob.com/mysql/mysql-tutorial.html 安装 官网下载地址 https://dev.mysql.com/downloads/file/?id=473576 默认安装目录 /usr/local/ 安装时弹出的默认密码，在第一次登录时需要用到： A temporary password is generated for root@localhost: gkct&gt;2Wajv5W 安装完成 登录mysql （连接远程数据库，默认端口号：3306） 远程连接 mysql -h主机地址 -u用户名 －p用户密码 登录mysql （连接本地数据库） mysql -u root -p 输入密码 登录后，修改密码 SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;新密码&apos;); 开启/关闭 - 手动 `系统偏好设置` -&gt; `mysql` 修改mysql编码 查看编码 默认设置： mysql&gt; show variables like &apos;%char%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.01 sec) 修改 在目录：/usr/local/mysql/support-files下找里面有没有my-default.cnf或my.cnf文件. 如果有则直接打开添加: 在[client]在下面添加 default-character-set=utf8 默认字符集为utf8 在[mysqld] 添加 default-character-set=utf8 默认字符集为utf8 设定连接mysql数据库时使用utf8编码，以让mysql数据库为utf8运行 init_connect=&apos;SET NAMES utf8&apos; 若是没有在/etc下新建my.cnf。执行命令： $ cd /etc $ sudo vim my.cnf 将 本文 附录内容粘贴到文件中后，保存退出即可。注意：修改完编码后要 退出之后再次进入 才能生效修改之后的编码设置 mysql&gt; show variables like &apos;%char%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.00 sec) 卸载MySQLsudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* vim /etc/hostconfig (and removed the line MYSQLCOM=-YES-) rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* MySQL操作命令 命令操作参考：http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html命令操作参考：http://blog.csdn.net/qi49125/article/details/77887100 数据库操作 查看版本号 select version(); 查询所有数据库 show database; 使用数据库 use 数据库名称 创建数据库 create database 数据库名 删除数据库 drop database 数据库名 备份数据库外部数据库 导入 登录 mysql -u root -p; 选择数据库 use databaseName; 将外部的.sql文件拖入终端中 source 命令后面，然后回车 source 拖如.sql文件; 内部数据库 导出 在终端中，要进入存储文件的目录，然后再执行导出操作 cd 待存文件的目录 导出MySQL中的所有数据库（结构+数据） mysqldump -u root -p --all-databases &gt; dafadf00.sql; 导出MySQL中的单个数据库（结构+数据） mysqldump -u root -p database_name &gt; sql_name.sql 导出单个数据库中的单张表，导出命令中加了一个表名（结构+数据） mysqldump -u root -p database_name table_name &gt; sql_name.sql 导出数据库的结构 （仅结构） mysqldump -u root -p --add-drop-table temp &gt; /Users/yannischeng/Desktop/outfile_name.sql 导出查询数据结果到指定文件 参考：http://blog.csdn.net/u011677147/article/details/64129606 在做mysql导出数据的时候，遇到的问题如下： ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement mysql 默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。解决方法： 查询mysql 的secure_file_priv配置，使用命令行： show global variables like &apos;%secure%&apos;; 查询结果 secure_file_prive=null -- 限制mysqld 不允许导入导出 secure_file_priv=/tmp/ -- 限制mysqld的导入导出只能发生在/tmp/目录下 secure_file_priv=&apos; &apos; -- 不对mysqld 的导入 导出做限制 更改secure_file_pri的值： /usr/local/mysql/support-files中的my-default.cnf配置文件，就把它复制到/private/etc中，重命名为“my.cnf”，并加入secure_file_priv=&apos;&apos;，重启mysql服务器即可。 使用 into outfile 开始导出： select * from table_name into outfile &apos;/Users/yannischeng/Desktop/NewFile.txt&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\n&apos;; 因为导出的数据会出现一些乱码或者特殊字符，所以使用以上关键字进行转义。 出现问题 ERROR 1 (HY000): Can&apos;t create/write to file &apos;/Users/yannischeng/Desktop/NewFile.txt&apos; (Errcode: 13 - Permission denied 表操作 use 数据库名; 删除表 drop table 表名; 删除表中数据 delete from 表名,……，…… where 表达式; 显示当前数据库的表 show tables; 显示表的数据结构 describe 表名; 或者 desc 表名; 或者 show columns from 表名; 创建表 mysql&gt; create table student( -&gt; id int(4) not null primary key auto_increment, -&gt; name char(20) not null, -&gt; age int(4) not null, -&gt; address char(100), -&gt; other varchar(100) default &quot;null&quot;); rename 修改表名 alter table 旧表名 rename 新表名; 或者 rename table 原表名 新表名; 修改表结构：增（add）、删（drop）、改（modify）、重命名（change）: 可通过after 字段名、first精确控制添加的位置。 add 增加字段 alter table 表名 add 字段名 字段设置 字段位置; modify 修改字段 alter table 表名 modify 字段名 字段设置 字段位置; change 重命名字段 alter table 表名 change 旧字段名 新字段名 字段设置; drop 删除字段 alter table 表名 drop 字段名; 数据操作 增 单条数据 insert into student (,&apos;yannis&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;); 多条数据 insert into student values (13,&apos;tom&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;),(21,&apos;jack&apos;, 25, &apos;tianjin&apos;, &apos;good&apos;); 指定字段插入数据 insert into 表名 (字段名) values (&apos;数值&apos;); 删 delete from 表名 where 条件; 改 update 表名 set name=&apos;marry&apos; where id=13; 查 查询数据完整语法 select [distinct][统计函数] 字段名/* from 数据源 [where 条件子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]; distinct ：去重复 统计函数 ： Count()： 统计分组后的记录数，每一相同的组有多少行记录 Max()： 统计每组最大的值 Min()： 统计每组最小的值 Avg()： 统计每组的平均值 Sum()： 统计每组的和 where ：条件 group by 字段 ：分组。根据某个字段进行分组，相同的放一组，不同的分到不同的组。统计的是数据，不是记录。 having 子句 ：与where子句一样进行条件判断，为什么是group by……having…… 而不是group by……where? 因为：进行数据统计时，是数据进入内存之后，会进行分组 -&gt; 统计 -&gt; having条件判断。而where是针对从磁盘读取数据时进行判断，此刻还没分组，进行统计就判断了。所以错误！ order by 子句 ：order by根据某个字段进行升序或降序排序，基本语法： order by 字段名 [asc/desc]; asc升序 可不写 desc降序 limit 子句 ：是一种限制结果的语句。 1）用来限制数量 2) 限制起始位置 limit 起始位置，长度。分页常用。 内连接，外连接，自然连接，交叉连接 内连接：从左表中取出每一条记录，和右表中所有的记录进行匹配，匹配必须是左表中与右表中某个条件相同，最终会保留结果，否则不保留。基本语法： 左表 [inner] join 右表 on 左表.字段 = 右表.字段; select * from my_student inner join my_class on my_student.C_id = mu_class.id; 左外连接：左表为主，然后每条记录与右表进行连接，不管能不能匹配的上，左表都会保留。能匹配，右表某条记录保留，不能匹配，某条记录置为NULL，最终记录数至少不少于左表已有的记录。基本语法： 左表 left join 右表 on 左表.字段 = 右表.字段; 当前时间： select now(); 附录# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the &quot;--help&quot; option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 init_connect=&apos;SET NAMES utf8 port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect=&apos;SET NAMES utf8&apos; # Don&apos;t listen on a TCP/IP port at all. This can be a security enhancement, # if all processes that need to connect to mysqld run on the same host. # All interaction with mysqld must be made via Unix sockets or named pipes. # Note that using this option without enabling named pipes on Windows # (via the &quot;enable-named-pipe&quot; option) will render mysqld useless! # #skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master&apos;s port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST=&apos;125.564.12.1&apos;, MASTER_PORT=3306, # MASTER_USER=&apos;joe&apos;, MASTER_PASSWORD=&apos;secret&apos;; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables&apos; values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout]]></content>
      <categories>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 16-安装爬虫工具Scrapy]]></title>
    <url>%2FPython3%20%2016-%E5%AE%89%E8%A3%85%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7Scrapy%2F</url>
    <content type="text"><![CDATA[人生苦短，我用python。 安装Scrapy需要使用到：pip（python2）、pip3（python3），由于之前已经安装，此处忽略。 平台：Macpython2 pippython3 pip3 使用pip进行安装注意：安装过程还是比较曲折的 (〒︿〒) sudo pip install scrapy 错误 - 1 ： Found existing installation: six 1.4.1 DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project. Uninstalling six-1.4.1: ... OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-89wTP6-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info&apos; 根据网上得出的解决方案： 重启电脑，按住 option 键，–&gt; 再按 command + r 进入 Recovery模式 –&gt; 工具选择终端输入： csrutil disable 然后 reboot 再次执行 sudo pip install Scrapy 进行安装，结果依然出错。错误 - 2 ： Found existing installation: six 1.4.1 DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project. Uninstalling six-1.4.1: Successfully uninstalled six-1.4.1 Running setup.py install for PyDispatcher ... done Running setup.py install for Twisted ... done 注意： Running setup.py install for PyDispatcher ... done Running setup.py install for Twisted ... done 因为未安装 以上两个，导致 Scrapy未能安装成功。错误描述为： AttributeError: &apos;module&apos; object has no attribute &apos;OP_NO_TLSv1_1&apos; 安装 twisted $ pip install twisted==15.4.0 仍然报错 - 3 ： AttributeError: &apos;module&apos; object has no attribute &apos;OP_NO_TLSv1_1&apos; 更新pyOpenSSl sudo pip install --upgrade pyOpenSSl 最终出现： Successfully uninstalled pyOpenSSL-0.13.1 Successfully installed asn1crypto-0.23.0 cffi-1.11.2 cryptography-2.1.2 enum34-1.1.6 idna-2.6 ipaddress-1.0.18 pyOpenSSl-17.3.0 pycparser-2.18 然后输入： scrapy version 出现结果： Scrapy 1.4.0 安装成功！ 使用pip3进行安装 参考：http://www.jianshu.com/p/d00a19f6c4ed 提示：在使用 pip3 进行安装时，首先应该执行以下步骤： sudo -s pip3 install --ignore-installed six 否则报错： PermissionError: [Errno 13] Permission denied: &apos;/usr/local/Cellar/python3/3.6.1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/six.py&apos; 然后执行： sudo -s pip3 install scrapy 结果： Installing collected packages: cssselect, queuelib, w3lib, PyDispatcher, lxml, parsel, idna, pycparser, cffi, asn1crypto, cryptography, pyOpenSSL, pyasn1, attrs, pyasn1-modules, service-identity, hyperlink, incremental, zope.interface, Automat, constantly, Twisted, scrapy Successfully installed Automat-0.6.0 PyDispatcher-2.0.5 Twisted-17.9.0 asn1crypto-0.23.0 attrs-17.2.0 cffi-1.11.2 constantly-15.1.0 cryptography-2.1.2 cssselect-1.0.1 hyperlink-17.3.1 idna-2.6 incremental-17.5.0 lxml-4.1.0 parsel-1.2.0 pyOpenSSL-17.3.0 pyasn1-0.3.7 pyasn1-modules-0.1.5 pycparser-2.18 queuelib-1.4.2 scrapy-1.4.0 service-identity-17.0.0 w3lib-1.18.0 zope.interface-4.4.3 验证： YannisCheng:source yannischeng$ python3 Python 3.6.1 (default, Apr 4 2017, 09:40:21) [GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.38)] on darwin Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; import scrapy &gt;&gt;&gt; 安装成功]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 使用快人一步2 快捷键]]></title>
    <url>%2FAndroid%20Studio%E4%BD%BF%E7%94%A8%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A52%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[键盘快捷键 快捷键参考：https://developer.android.google.cn/studio/intro/keyboard-shortcuts.htmlAndroid Studio使用指南：https://developer.android.google.cn/studio/projects/android-library.html 常规 说明 Windows/Linux Mac 全部保存 Control + S Command + S 同步 Control + Alt + Y Command + Option + Y 最大化/最小化编辑器 Control + Shift + F12 Control + Command + F12 添加到收藏夹 Alt + Shift + F Option + Shift + F 使用当前配置文件检查当前文件 Alt + Shift + I Option + Shift + I 快速切换模式 Control + （反引号） Control + `（反引号） 打开设置对话框 Control + Alt + S Command + ,（英文逗号） 打开项目结构对话框 Control + Alt + Shift + S Command + ;（英文分号） 在标签和工具窗口之间切换 Control + Tab Control + Tab 在 Studio 内导航和搜索 说明 Windows/Linux Mac 搜索全部内容（包括代码和菜单） 按两次 Shift 按两次 Shift 查找 Control + F Command + F 查找下一个 F3 Command + G 查找上一个 Shift + F3 Command + Shift + G 替换 Control + R Command + R 查找操作 Control + Shift + A Command + Shift + A 按符号名称搜索 Control + Alt + Shift + N Command + Option + O 查找类 Control + N Command + O 查找文件（而不是类） Control + Shift + N Command + Shift + O 在路径中查找 Control + Shift + F Command + Shift + F 打开文件结构弹出式菜单 Control + F12 Command + F12 在打开的编辑器标签之前导航 Alt + 向右/向左箭头 Control + 向右/向左箭头 跳到源代码 F4 / Control + Enter F4 / Command + 向下箭头 在新窗口中打开当前编辑器标签 Shift + F4 Shift + F4 最近打开的文件弹出式菜单 Control + E Command + E 最近编辑的文件弹出式菜单 Control + Shift + E Command + Shift + E 转到上一个编辑位置 Control + Shift + 退格键 Command + Shift + 退格键 关闭活动编辑器标签 Control + F4 Command + W 从工具窗口返回到编辑器窗口 Esc Esc 隐藏活动或上一个活动工具窗口 Shift + Esc Shift + Esc 转到行 Control + G Command + L 打开类型层次结构 Control + H Control + H 打开方法层次结构 Control + Shift + H Command + Shift + H 打开调用层次结构 Control + Alt + H Control + Option + H s 编写代码 说明 Windows/Linux Mac 生成代码（getter、setter、构造函数、hashCode/equals、toString、新文件、新类） Alt + Insert Command + N 替换方法 Control + O Control + O 实现方法 Control + I Control + I 控制语句 (if…else / try…catch / etc.) Control + Alt + T Command + Option + T 删除插入符处的行 Control + Y Command + 退格键 折叠/展开当前代码块 Control + 减号/加号 Command + 减号/加号 折叠/展开所有代码块 Control + Shift + 减号/加号 Command + Shift + 减号/加号 复制当前行或选择 Control + D Command + D 基本代码自动完成 Control + 空格键 Control + 空格键 智能代码自动完成（按预期类型过滤方法和变量列表） Control + Shift + 空格键 Control + Shift + 空格键 完成语句 Control + Shift + Enter Command + Shift + Enter 快速文档查找 Control + Q Control + J 显示选定方法的参数 Control + P Command + P 转到声明（直接） Control + B 或 Control + 点击 Command + B 或 Command + 点击 转到实现 Control + Alt + B Command + Alt + B 转到超类方法/超类 Control + U Command + U 打开快速定义查找 Control + Shift + I Command + Y 切换项目工具窗口的可见性 Alt + 1 Command + 1 切换书签 F11 F3 通过助记切换书签 Control + F11 Option + F3 通过行注释添加注释/取消注释 Control + / Command + / 通过块注释添加注释/取消注释 Control + Shift + / Command + Shift + / 选择连续增加的代码块 Control + W Option + Up 将当前选择退回到上一个状态 Control + Shift + W Option + Down 移动到代码块起始位置 Control + [ Option + Command + [ 移动到代码块结束位置 Control + ] Option + Command + ] 从当前位置选择到代码块起始位置 Control + Shift + [ Option + Command + Shift + [ 从当前位置选择到代码块结束位置 Control + Shift + ] Option + Command + Shift + ] 从当前位置删除到单词结尾 Control + Delete Option + Delete 从当前位置删除到单词开头 Control + 退格键 Option + 退格键 优化导入 Control + Alt + O Control + Option + O 项目快速修复（显示意图操作和快速修复） Alt + Enter Option + Enter 重新格式化代码 Control + Alt + L Command + Option + L 自动缩进行 Control + Alt + I Control + Option + I 缩进/取消缩进行 Tab/Shift + Tab Tab/Shift + Tab 智能行合并 Control + Shift + J Control + Shift + J 智能行拆分 Control + Enter Command + Enter 开始新行 Shift + Enter Shift + Enter 下一个/上一个突出显示的错误 F2 / Shift + F2 F2 / Shift + F2 构建并运行 说明 Windows/Linux Mac 构建 Control + F9 Command + F9 构建并运行 Shift + F10 Control + R 调试 说明 Windows/Linux Mac 调试 Shift + F9 Control + D 跳过 F8 F8 逐步执行 F7 F7 智能逐步执行 Shift + F7 Shift + F7 跳出 Shift + F8 Shift + F8 运行到光标位置 Alt + F9 Option + F9 评估表达式 Alt + F8 Option + F8 继续运行程序 F9 Command + Option + R 切换断点 Control + F8 Command + F8 查看断点 Control + Shift + F8 Command + Shift + F8 重构 说明 Windows/Linux Mac 复制 F5 F5 移动 F6 F6 安全删除 Alt + Delete Command + Delete 重命名 Shift + F6 Shift + F6 更改签名 Control + F6 Command + F6 内联 Control + Alt + N Command + Option + N 提取方法 Control + Alt + M Command + Option + M 提取变量 Control + Alt + V Command + Option + V 提取字段 Control + Alt + F Command + Option + F 提取常量 Control + Alt + C Command + Option + C 提取参数 Control + Alt + P Command + Option + P 版本控制/本地历史记录 说明 Windows/Linux MacOS 将项目提交到 VCS Control + K Command + K 从 VCS 更新项目 Control + T Command + T 查看最近变更 Alt + Shift + C Option + Shift + C 打开 VCS 弹出式菜单 Alt + `（反引号） Control + V]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android资源文件-color]]></title>
    <url>%2FAndroid%20%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6-color%2F</url>
    <content type="text"><![CDATA[官方参考：https://material.io/guidelines/style/color.html#color-color-palette 16进制透明度 100%-0%123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101100% — FF99% — FC98% — FA97% — F796% — F595% — F294% — F093% — ED92% — EB91% — E890% — E689% — E388% — E087% — DE86% — DB85% — D984% — D683% — D482% — D181% — CF80% — CC79% — C978% — C777% — C476% — C275% — BF74% — BD73% — BA72% — B871% — B570% — B369% — B068% — AD67% — AB66% — A865% — A664% — A363% — A162% — 9E61% — 9C60% — 9959% — 9658% — 9457% — 9156% — 8F55% — 8C54% — 8A53% — 8752% — 8551% — 8250% — 8049% — 7D48% — 7A47% — 7846% — 7545% — 7344% — 7043% — 6E42% — 6B41% — 6940% — 6639% — 6338% — 6137% — 5E36% — 5C35% — 5934% — 5733% — 5432% — 5231% — 4F30% — 4D29% — 4A28% — 4727% — 4526% — 4225% — 4024% — 3D23% — 3B22% — 3821% — 3620% — 3319% — 3018% — 2E17% — 2B16% — 2915% — 2614% — 2413% — 2112% — 1F11% — 1C10% — 1A9% — 178% — 147% — 126% — 0F5% — 0D4% — 0A3% — 082% — 051% — 030% — 00 部分16进制透明度12345678910111213141516171819202122不透明度 16进制值100% FF95% F290% E685% D980% CC75% BF70% B365% A660% 9955% 8C50% 8045% 7340% 6635% 5930% 4D25% 4020% 3315% 2610% 1A5% 0D0% 00 Android Material Design 字体颜色透明度1234567100%: FF87%: DE70%: B354%: 8A50%: 8038%: 6112%: 1F 各个颜色数值黑白1234&lt;!-- 0 Black 黑色 --&gt;&lt;color name="Black"&gt;#000000&lt;/color&gt;&lt;!-- 0 White 白色 --&gt;&lt;color name="White"&gt;#FFFFFF&lt;/color&gt; 灰色1234567891011&lt;!-- 1 Grey 灰色 --&gt;&lt;color name="Grey_50"&gt;#FAFAFA&lt;/color&gt;&lt;color name="Grey_100"&gt;#F5F5F5&lt;/color&gt;&lt;color name="Grey_200"&gt;#EEEEEE&lt;/color&gt;&lt;color name="Grey_300"&gt;#E0E0E0&lt;/color&gt;&lt;color name="Grey_400"&gt;#BDBDBD&lt;/color&gt;&lt;color name="Grey_500_bar"&gt;#9E9E9E&lt;/color&gt;&lt;color name="Grey_600"&gt;#757575&lt;/color&gt;&lt;color name="Grey_700"&gt;#616161&lt;/color&gt;&lt;color name="Grey_800"&gt;#424242&lt;/color&gt;&lt;color name="Grey_900"&gt;#212121&lt;/color&gt; 蓝灰色1234567891011&lt;!-- 2 Blue Grey 蓝灰色--&gt;&lt;color name="Blue_Grey_50"&gt;#FAFAFA&lt;/color&gt;&lt;color name="Blue_Grey_100"&gt;#CFD8DC&lt;/color&gt;&lt;color name="Blue_Grey_200"&gt;#B0BEC5&lt;/color&gt;&lt;color name="Blue_Grey_300"&gt;#90A4AE&lt;/color&gt;&lt;color name="Blue_Grey_400"&gt;#78909C&lt;/color&gt;&lt;color name="Blue_Grey_500_bar"&gt;#607D8B&lt;/color&gt;&lt;color name="Blue_Grey_600"&gt;#546E7A&lt;/color&gt;&lt;color name="Blue_Grey_700"&gt;#455A64&lt;/color&gt;&lt;color name="Blue_Grey_800"&gt;#37474F&lt;/color&gt;&lt;color name="Blue_Grey_900"&gt;#263238&lt;/color&gt; 红色123456789101112131415&lt;!-- 3 Red 红色--&gt;&lt;color name="r_50"&gt;#FFEBEE&lt;/color&gt;&lt;color name="r_100"&gt;#FFCDD2&lt;/color&gt;&lt;color name="r_200"&gt;#EF9A9A&lt;/color&gt;&lt;color name="r_300"&gt;#E57373&lt;/color&gt;&lt;color name="r_400"&gt;#EF5350&lt;/color&gt;&lt;color name="r_500_bar"&gt;#F44336&lt;/color&gt;&lt;color name="r_600"&gt;#E53935&lt;/color&gt;&lt;color name="r_700"&gt;#D32F2F&lt;/color&gt;&lt;color name="r_800"&gt;#C62828&lt;/color&gt;&lt;color name="r_900"&gt;#B71C1C&lt;/color&gt;&lt;color name="r_a100"&gt;#FF8A80&lt;/color&gt;&lt;color name="r_a200"&gt;#FF5252&lt;/color&gt;&lt;color name="r_a400"&gt;#FF1744&lt;/color&gt;&lt;color name="r_a700"&gt;#D50000&lt;/color&gt; 粉色123456789101112131415&lt;!-- 4 Pink 粉色--&gt;&lt;color name="p_50"&gt;#FCE4EC&lt;/color&gt;&lt;color name="p_100"&gt;#F8BBD0&lt;/color&gt;&lt;color name="p_200"&gt;#F48FB1&lt;/color&gt;&lt;color name="p_300"&gt;#F06292&lt;/color&gt;&lt;color name="p_400"&gt;#EC407A&lt;/color&gt;&lt;color name="p_500_bar"&gt;#E91E63&lt;/color&gt;&lt;color name="p_600"&gt;#D81B60&lt;/color&gt;&lt;color name="p_700"&gt;#C2185B&lt;/color&gt;&lt;color name="p_800"&gt;#AD1457&lt;/color&gt;&lt;color name="p_900"&gt;#880E4F&lt;/color&gt;&lt;color name="p_a100"&gt;#FF80AB&lt;/color&gt;&lt;color name="p_a200"&gt;#FF4081&lt;/color&gt;&lt;color name="p_a400"&gt;#F50057&lt;/color&gt;&lt;color name="p_a700"&gt;#C51162&lt;/color&gt; 紫色123456789101112131415&lt;!-- 5 Purple 紫色--&gt;&lt;color name="pur_50"&gt;#F3E5F5&lt;/color&gt;&lt;color name="pur_100"&gt;#E1BEE7&lt;/color&gt;&lt;color name="pur_200"&gt;#CE93D8&lt;/color&gt;&lt;color name="pur_300"&gt;#BA68C8&lt;/color&gt;&lt;color name="pur_400"&gt;#AB47BC&lt;/color&gt;&lt;color name="pur_500_bar"&gt;#9C27B0&lt;/color&gt;&lt;color name="pur_600"&gt;#8E24AA&lt;/color&gt;&lt;color name="pur_700"&gt;#7B1FA2&lt;/color&gt;&lt;color name="pur_800"&gt;#6A1B9A&lt;/color&gt;&lt;color name="pur_900"&gt;#4A148C&lt;/color&gt;&lt;color name="pur_a100"&gt;#EA80FC&lt;/color&gt;&lt;color name="pur_a200"&gt;#E040FB&lt;/color&gt;&lt;color name="pur_a400"&gt;#D500F9&lt;/color&gt;&lt;color name="pur_a700"&gt;#AA00FF&lt;/color&gt; 深紫色123456789101112131415&lt;!-- 6 Deep Purple 深紫色--&gt;&lt;color name="deep_pur_50"&gt;#EDE7F6&lt;/color&gt;&lt;color name="deep_pur_100"&gt;#D1C4E9&lt;/color&gt;&lt;color name="deep_pur_200"&gt;#B39DDB&lt;/color&gt;&lt;color name="deep_pur_300"&gt;#9575CD&lt;/color&gt;&lt;color name="deep_pur_400"&gt;#7E57C2&lt;/color&gt;&lt;color name="deep_pur_500_bar"&gt;#673AB7&lt;/color&gt;&lt;color name="deep_pur_600"&gt;#5E35B1&lt;/color&gt;&lt;color name="deep_pur_700"&gt;#512DA8&lt;/color&gt;&lt;color name="deep_pur_800"&gt;#4527A0&lt;/color&gt;&lt;color name="deep_pur_900"&gt;#311B92&lt;/color&gt;&lt;color name="deep_pur_a100"&gt;#B388FF&lt;/color&gt;&lt;color name="deep_pur_a200"&gt;#7C4DFF&lt;/color&gt;&lt;color name="deep_pur_a400"&gt;#651FFF&lt;/color&gt;&lt;color name="deep_pur_a700"&gt;#6200EA&lt;/color&gt; 靛蓝色123456789101112131415&lt;!-- 7 Indigo 靛蓝色 --&gt;&lt;color name="Indigo_50"&gt;#E8EAF6&lt;/color&gt;&lt;color name="Indigo_100"&gt;#C5CAE9&lt;/color&gt;&lt;color name="Indigo_200"&gt;#9FA8DA&lt;/color&gt;&lt;color name="Indigo_300"&gt;#7986CB&lt;/color&gt;&lt;color name="Indigo_400"&gt;#5C6BC0&lt;/color&gt;&lt;color name="Indigo_500_bar"&gt;#3F51B5&lt;/color&gt;&lt;color name="Indigo_600"&gt;#3949AB&lt;/color&gt;&lt;color name="Indigo_700"&gt;#303F9F&lt;/color&gt;&lt;color name="Indigo_800"&gt;#283593&lt;/color&gt;&lt;color name="Indigo_900"&gt;#1A237E&lt;/color&gt;&lt;color name="Indigo_a100"&gt;#8C9EFF&lt;/color&gt;&lt;color name="Indigo_a200"&gt;#536DFE&lt;/color&gt;&lt;color name="Indigo_a400"&gt;#3D5AFE&lt;/color&gt;&lt;color name="Indigo_a700"&gt;#304FFE&lt;/color&gt; 蓝色123456789101112131415&lt;!-- 8 Blue 蓝色 --&gt;&lt;color name="Blue_50"&gt;#E3F2FD&lt;/color&gt;&lt;color name="Blue_100"&gt;#BBDEFB&lt;/color&gt;&lt;color name="Blue_200"&gt;#90CAF9&lt;/color&gt;&lt;color name="Blue_300"&gt;#64B5F6&lt;/color&gt;&lt;color name="Blue_400"&gt;#42A5F5&lt;/color&gt;&lt;color name="Blue_500_bar"&gt;#2196F3&lt;/color&gt;&lt;color name="Blue_600"&gt;#1E88E5&lt;/color&gt;&lt;color name="Blue_700"&gt;#1976D2&lt;/color&gt;&lt;color name="Blue_800"&gt;#1565C0&lt;/color&gt;&lt;color name="Blue_900"&gt;#0D47A1&lt;/color&gt;&lt;color name="Blue_a100"&gt;#82B1FF&lt;/color&gt;&lt;color name="Blue_a200"&gt;#448AFF&lt;/color&gt;&lt;color name="Blue_a400"&gt;#2979FF&lt;/color&gt;&lt;color name="Blue_a700"&gt;#2962FF&lt;/color&gt; 亮蓝色123456789101112131415&lt;!-- 9 Light Blue 亮蓝色--&gt;&lt;color name="Light_Blue_50"&gt;#E1F5FE&lt;/color&gt;&lt;color name="Light_Blue_100"&gt;#B3E5FC&lt;/color&gt;&lt;color name="Light_Blue_200"&gt;#81D4FA&lt;/color&gt;&lt;color name="Light_Blue_300"&gt;#4FC3F7&lt;/color&gt;&lt;color name="Light_Blue_400"&gt;#29B6F6&lt;/color&gt;&lt;color name="Light_Blue_500_bar"&gt;#03A9F4&lt;/color&gt;&lt;color name="Light_Blue_600"&gt;#039BE5&lt;/color&gt;&lt;color name="Light_Blue_700"&gt;#0288D1&lt;/color&gt;&lt;color name="Light_Blue_800"&gt;#0277BD&lt;/color&gt;&lt;color name="Light_Blue_900"&gt;#01579B&lt;/color&gt;&lt;color name="Light_Blue_a100"&gt;#80D8FF&lt;/color&gt;&lt;color name="Light_Blue_a200"&gt;#40C4FF&lt;/color&gt;&lt;color name="Light_Blue_a400"&gt;#00B0FF&lt;/color&gt;&lt;color name="Light_Blue_a700"&gt;#0091EA&lt;/color&gt; 青色123456789101112131415&lt;!-- 10 Cyan 青色 --&gt;&lt;color name="Cyan_50"&gt;#E0F7FA&lt;/color&gt;&lt;color name="Cyan_100"&gt;#B2EBF2&lt;/color&gt;&lt;color name="Cyan_200"&gt;#80DEEA&lt;/color&gt;&lt;color name="Cyan_300"&gt;#4DD0E1&lt;/color&gt;&lt;color name="Cyan_400"&gt;#26C6DA&lt;/color&gt;&lt;color name="Cyan_500_bar"&gt;#00BCD4&lt;/color&gt;&lt;color name="Cyan_600"&gt;#00ACC1&lt;/color&gt;&lt;color name="Cyan_700"&gt;#0097A7&lt;/color&gt;&lt;color name="Cyan_800"&gt;#00838F&lt;/color&gt;&lt;color name="Cyan_900"&gt;#006064&lt;/color&gt;&lt;color name="Cyan_a100"&gt;#84FFFF&lt;/color&gt;&lt;color name="Cyan_a200"&gt;#18FFFF&lt;/color&gt;&lt;color name="Cyan_a400"&gt;#00E5FF&lt;/color&gt;&lt;color name="Cyan_a700"&gt;#00B8D4&lt;/color&gt; 蓝绿色123456789101112131415&lt;!-- 11 Teal 蓝绿色 --&gt;&lt;color name="Teal_50"&gt;#E0F2F1&lt;/color&gt;&lt;color name="Teal_100"&gt;#B2DFDB&lt;/color&gt;&lt;color name="Teal_200"&gt;#80CBC4&lt;/color&gt;&lt;color name="Teal_300"&gt;#4DB6AC&lt;/color&gt;&lt;color name="Teal_400"&gt;#26A69A&lt;/color&gt;&lt;color name="Teal_500_bar"&gt;#009688&lt;/color&gt;&lt;color name="Teal_600"&gt;#00897B&lt;/color&gt;&lt;color name="Teal_700"&gt;#00796B&lt;/color&gt;&lt;color name="Teal_800"&gt;#00695C&lt;/color&gt;&lt;color name="Teal_900"&gt;#004D40&lt;/color&gt;&lt;color name="Teal_a100"&gt;#A7FFEB&lt;/color&gt;&lt;color name="Teal_a200"&gt;#64FFDA&lt;/color&gt;&lt;color name="Teal_a400"&gt;#1DE9B6&lt;/color&gt;&lt;color name="Teal_a700"&gt;#00BFA5&lt;/color&gt; 绿色123456789101112131415&lt;!-- 12 Green 绿色 --&gt;&lt;color name="Green_50"&gt;#E8F5E9&lt;/color&gt;&lt;color name="Green_100"&gt;#C8E6C9&lt;/color&gt;&lt;color name="Green_200"&gt;#A5D6A7&lt;/color&gt;&lt;color name="Green_300"&gt;#81C784&lt;/color&gt;&lt;color name="Green_400"&gt;#66BB6A&lt;/color&gt;&lt;color name="Green_500_bar"&gt;#4CAF50&lt;/color&gt;&lt;color name="Green_600"&gt;#43A047&lt;/color&gt;&lt;color name="Green_700"&gt;#388E3C&lt;/color&gt;&lt;color name="Green_800"&gt;#2E7D32&lt;/color&gt;&lt;color name="Green_900"&gt;#1B5E20&lt;/color&gt;&lt;color name="Green_a100"&gt;#B9F6CA&lt;/color&gt;&lt;color name="Green_a200"&gt;#69F0AE&lt;/color&gt;&lt;color name="Green_a400"&gt;#00E676&lt;/color&gt;&lt;color name="Green_a700"&gt;#00C853&lt;/color&gt; 亮绿色123456789101112131415&lt;!-- 13 Light Green 亮绿色--&gt;&lt;color name="Light_Green_50"&gt;#F1F8E9&lt;/color&gt;&lt;color name="Light_Green_100"&gt;#DCEDC8&lt;/color&gt;&lt;color name="Light_Green_200"&gt;#C5E1A5&lt;/color&gt;&lt;color name="Light_Green_300"&gt;#AED581&lt;/color&gt;&lt;color name="Light_Green_400"&gt;#9CCC65&lt;/color&gt;&lt;color name="Light_Green_500_bar"&gt;#8BC34A&lt;/color&gt;&lt;color name="Light_Green_600"&gt;#7CB342&lt;/color&gt;&lt;color name="Light_Green_700"&gt;#689F38&lt;/color&gt;&lt;color name="Light_Green_800"&gt;#558B2F&lt;/color&gt;&lt;color name="Light_Green_900"&gt;#33691E&lt;/color&gt;&lt;color name="Light_Green_a100"&gt;#CCFF90&lt;/color&gt;&lt;color name="Light_Green_a200"&gt;#B2FF59&lt;/color&gt;&lt;color name="Light_Green_a400"&gt;#76FF03&lt;/color&gt;&lt;color name="Light_Green_a700"&gt;#64DD17&lt;/color&gt; 酸橙汁饮料123456789101112131415&lt;!-- 14 Lime 酸橙汁饮料 --&gt;&lt;color name="Lime_50"&gt;#F9FBE7&lt;/color&gt;&lt;color name="Lime_100"&gt;#F0F4C3&lt;/color&gt;&lt;color name="Lime_200"&gt;#E6EE9C&lt;/color&gt;&lt;color name="Lime_300"&gt;#DCE775&lt;/color&gt;&lt;color name="Lime_400"&gt;#D4E157&lt;/color&gt;&lt;color name="Lime_500_bar"&gt;#CDDC39&lt;/color&gt;&lt;color name="Lime_600"&gt;#C0CA33&lt;/color&gt;&lt;color name="Lime_700"&gt;#AFB42B&lt;/color&gt;&lt;color name="Lime_800"&gt;#9E9D24&lt;/color&gt;&lt;color name="Lime_900"&gt;#827717&lt;/color&gt;&lt;color name="Lime_a100"&gt;#F4FF81&lt;/color&gt;&lt;color name="Lime_a200"&gt;#EEFF41&lt;/color&gt;&lt;color name="Lime_a400"&gt;#C6FF00&lt;/color&gt;&lt;color name="Lime_a700"&gt;#AEEA00&lt;/color&gt; 黄色123456789101112131415 &lt;!-- 15 Yellow 黄色 --&gt;&lt;color name="Yellow_50"&gt;#FFFDE7&lt;/color&gt;&lt;color name="Yellow_100"&gt;#FFF9C4&lt;/color&gt;&lt;color name="Yellow_200"&gt;#FFF59D&lt;/color&gt;&lt;color name="Yellow_300"&gt;#FFF176&lt;/color&gt;&lt;color name="Yellow_400"&gt;#FFEE58&lt;/color&gt;&lt;color name="Yellow_500_bar"&gt;#FFEB3B&lt;/color&gt;&lt;color name="Yellow_600"&gt;#FDD835&lt;/color&gt;&lt;color name="Yellow_700"&gt;#FBC02D&lt;/color&gt;&lt;color name="Yellow_800"&gt;#F9A825&lt;/color&gt;&lt;color name="Yellow_900"&gt;#F57F17&lt;/color&gt;&lt;color name="Yellow_a100"&gt;#FFFF8D&lt;/color&gt;&lt;color name="Yellow_a200"&gt;#FFFF00&lt;/color&gt;&lt;color name="Yellow_a400"&gt;#FFEA00&lt;/color&gt;&lt;color name="Yellow_a700"&gt;#FFD600&lt;/color&gt; 琥珀色123456789101112131415&lt;!-- 16 Amber 琥珀色--&gt;&lt;color name="Amber_50"&gt;#FFF8E1&lt;/color&gt;&lt;color name="Amber_100"&gt;#FFECB3&lt;/color&gt;&lt;color name="Amber_200"&gt;#FFE082&lt;/color&gt;&lt;color name="Amber_300"&gt;#FFD54F&lt;/color&gt;&lt;color name="Amber_400"&gt;#FFCA28&lt;/color&gt;&lt;color name="Amber500_bar"&gt;#FFC107&lt;/color&gt;&lt;color name="Amber_600"&gt;#FFB300&lt;/color&gt;&lt;color name="Amber_700"&gt;#FFA000&lt;/color&gt;&lt;color name="Amber_800"&gt;#FF8F00&lt;/color&gt;&lt;color name="Amber_900"&gt;#FF6F00&lt;/color&gt;&lt;color name="Amber_a100"&gt;#FFE57F&lt;/color&gt;&lt;color name="Amber_a200"&gt;#FFD740&lt;/color&gt;&lt;color name="Amber_a400"&gt;#FFC400&lt;/color&gt;&lt;color name="Amber_a700"&gt;#FFAB00&lt;/color&gt; 橘黄色123456789101112131415&lt;!-- 17 Orange 橘黄色--&gt;&lt;color name="Orange_50"&gt;#FFF3E0&lt;/color&gt;&lt;color name="Orange_100"&gt;#FFE0B2&lt;/color&gt;&lt;color name="Orange_200"&gt;#FFCC80&lt;/color&gt;&lt;color name="Orange_300"&gt;#FFB74D&lt;/color&gt;&lt;color name="Orange_400"&gt;#FFA726&lt;/color&gt;&lt;color name="Orange_500_bar"&gt;#FF9800&lt;/color&gt;&lt;color name="Orange_600"&gt;#FB8C00&lt;/color&gt;&lt;color name="Orange_700"&gt;#F57C00&lt;/color&gt;&lt;color name="Orange_800"&gt;#EF6C00&lt;/color&gt;&lt;color name="Orange_900"&gt;#E65100&lt;/color&gt;&lt;color name="Orange_a100"&gt;#FFD180&lt;/color&gt;&lt;color name="Orange_a200"&gt;#FFAB40&lt;/color&gt;&lt;color name="Orange_a400"&gt;#FF9100&lt;/color&gt;&lt;color name="Orange_a700"&gt;#FF6D00&lt;/color&gt; 深橘黄色123456789101112131415&lt;!-- 18 Deep Orange 深橘黄色--&gt;&lt;color name="Deep_Orange_50"&gt;#FBE9E7&lt;/color&gt;&lt;color name="Deep_Orange_100"&gt;#FFCCBC&lt;/color&gt;&lt;color name="Deep_Orange_200"&gt;#FFAB91&lt;/color&gt;&lt;color name="Deep_Orange_300"&gt;#FF8A65&lt;/color&gt;&lt;color name="Deep_Orange_400"&gt;#FF7043&lt;/color&gt;&lt;color name="Deep_Orange_500_bar"&gt;#FF5722&lt;/color&gt;&lt;color name="Deep_Orange_600"&gt;#F4511E&lt;/color&gt;&lt;color name="Deep_Orange_700"&gt;#E64A19&lt;/color&gt;&lt;color name="Deep_Orange_800"&gt;#D84315&lt;/color&gt;&lt;color name="Deep_Orange_900"&gt;#BF360C&lt;/color&gt;&lt;color name="Deep_Orange_a100"&gt;#FF9E80&lt;/color&gt;&lt;color name="Deep_Orange_a200"&gt;#FF6E40&lt;/color&gt;&lt;color name="Deep_Orange_a400"&gt;#FF3D00&lt;/color&gt;&lt;color name="Deep_Orange_a700"&gt;#DD2C00&lt;/color&gt; 棕色1234567891011&lt;!-- 19 Brown 棕色--&gt;&lt;color name="Brown_50"&gt;#EFEBE9&lt;/color&gt;&lt;color name="Brown_100"&gt;#D7CCC8&lt;/color&gt;&lt;color name="Brown_200"&gt;#BCAAA4&lt;/color&gt;&lt;color name="Brown_300"&gt;#A1887F&lt;/color&gt;&lt;color name="Brown_400"&gt;#8D6E63&lt;/color&gt;&lt;color name="Brown_500_bar"&gt;#795548&lt;/color&gt;&lt;color name="Brown_600"&gt;#6D4C41&lt;/color&gt;&lt;color name="Brown_700"&gt;#5D4037&lt;/color&gt;&lt;color name="Brown_800"&gt;#4E342E&lt;/color&gt;&lt;color name="Brown_900"&gt;#3E2723&lt;/color&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Sutdio 使用快人一步1 插件配置]]></title>
    <url>%2FAndroid%20Studio%E4%BD%BF%E7%94%A8%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A51%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[今日感悟，写在前面： 放手无关紧要，精于攻坚克难。 Android studio 使用参考；http://www.open-open.com/lib/view/open1466732917214.html http://www.open-open.com/lib/view/open1458715872710.html 一、Android Studio 3.0 - Android Profiler分析器 参考：http://blog.csdn.net/niubitianping/article/details/72617864Android Studio 3.0 新特性：http://blog.csdn.net/niubitianping/article/details/72600923 二、Android Studio 官方用户指南 https://developer.android.google.cn/studio/intro/index.html 三、使用频率最高的3个快捷键： ⌘ + n：各种自动生成。 （control）⌃ + t ： （shift）⇧ + （control）⌃ + （enter） ⏎ 补充快捷键 四、插件插件安装位置：Android Studio -&gt; Preferences -&gt; Plugins。快捷键：⌘ + ,敲出⌘：⌃ + ⌘ + space，之后进行选择 1. 代码规范 - Alibaba Java Coding Guidelines阿里巴巴Java开发规约的插件。安装后在Android Studio显示为：可选择实时监测，也可以关闭检测。 2. 真机无线调试 - Android WiFi ADB通过WIFI连接手机和电脑。数据线插入你的手机，然后点击Connect，显示State = Connect后拔掉数据线即可。 3. 布局文件分组的插件 - folding-plugin图片来自网络 4. View注解绑定 - Android ButterKnife ZeleznyButterKnife是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。快捷键：⌘ + n使用时必须要将光标悬浮于 activity_main之上才能有效。 4.1 控件的点击事件异常时 只是在Java代码中写明了方法，但是并没有在XML代码中使用onClick=&quot;&quot;来描述此方法 在Java代码中只是声明了方法，当时并没有在方法中声明参数：(View view)。如果不写此参数，将会导致在调用方法时，找不到View中的 指定id 值。 4.2 空指针异常： Android Studio3.0之前 在 app模块 的 gradle 编译文件 build.gradle 加入下列代码： apply plugin: &apos;com.neenbedankt.android-apt&apos; 在 app模块 的 gradle 编译文件 build.gradle 中的 dependencies中加入 apt &apos;com.jakewharton:butterknife-compiler:8.0.1&apos; compile &apos;com.jakewharton:butfe:8.0.1&apos; 在 项目 的 gradle 编译文件 build.gradle 文件，在 dependencies 中加入 classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; Android Studio3.0 在 app模块 的 gradle 中的 dependencies中加入 compile &apos;com.jakewharton:butterknife:8.8.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos; 5. 资源文件状态生成 - SelectorChapek for Android通过资源文件命名自动生成Selector文件。 6. ViewHolder代码自动生成 - AndroidCodeGenerator在 res/layout/文件夹下选择你适配器的item layout的布局文件，然后右键，如图所示： 选择其中一项之后，会弹出一个窗口，在这个窗口已经根据item布局文件默认生成了一个适配器类，你所要做的就是根据自己的实际需求进行修改。 7. 自动findViewById() - Prettify据Layout自动生成findViewById。使用方式同ButterKnife快捷键：⌘ + n 后选择 View Variables 或者 View Fields区别： 前者View Variables生成的是私有变量 后者 View Fields生成的是成员变量 8. 自动生成style代码 - Android Styler快捷键：⇧ + ⌘ + d效果如图： 9. 生命周期方法位置排序 - Lifecycle Sorter根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序。快捷键 ⌘ + ⌥ + K 10. 关于Json数据10.1 Json数据 -&gt; java对象 ：GsonFormatGsonFormat是一个快速格式化json数据，自动生成实体类参数的插件。快捷键：⌘ + n 后选择 GsonFormat。 10.2 Java对象 -&gt; json格式数据 ：Java库：Gson 参考：http://blog.csdn.net/oQiHaoGongYuan/article/details/50944755 添加gson库： 首先，在自己的android studio的项目中把gson库添加进来，右键 app 选择 open module settings 选择当前 Module，然后点击 Dependencies,在点击3步中的Library dependency（依赖的库） 在1所指的弹出的收索框中收索gson，然后点击2 所指的收索，然后下面就会出现最新的gson库，点击OK 点击上图OK后，gson库就出现在了dependency中了，这个时候还得点击 2所指的OK（确认）按钮。 最后查看build.gradle中看看gson库有没有添加成功，如下图2所指的地方，现在可以看到google官方的gson库就添加到了项目中来。 使用gson把Java对象转化为Json格式 12Gson gson = new Gson();gson.toJson(对象); 11. Parcelable自动生成 - ParcelableGenerator自动生成Parcelable接口所需的代码。 Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。 而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。 Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。 Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据。 快捷键：⌘ + n 12. Android Material Design 风格图标全集 - Android Material Design Icon Generator通过此库可以获取MD风格的所有图标，更让人惊喜的是：选中的图标会自动生成各种 drawable 文件夹的图标，而且可以自定义颜色，绝对让人惊喜。快捷键：⌥ + ⌘ + m 选择指定图标以及自定义颜色。 13. Android本地数据/数据库浏览器查询、修改第三方库引入：在module的gradle中 debugCompile &apos;com.amitshekhar.android:debug-db:1.0.0&apos; 使用： mac下按住⌘ + 单击即可在浏览器中看到当前App的数据。 14. 色彩管理器 - color-manager这个管理器是一个插件，只要在 Android Studio 安装此插件即可。使用参考：https://github.com/shiraji/color-manager 安装之后的样式： 过滤 功能： 选中此功能后：不显示系统提供的颜色； 未选中时：显示 系统+自定义 颜色。 15. Builder生成器 - innerbuilder这个管理器是一个插件，只要在 Android Studio 安装此插件即可。使用参考：https://github.com/analytically/innerbuilder 官网截图： 16. FindBugs-IDEAhttps://blog.csdn.net/fancy_xty/article/details/51718687 17. statistic https://blog.csdn.net/dreamlivemeng/article/details/67637789/ 五、组合指令1. 自定义组指令快捷键：⌘ + , 后选择 Live TemPlates，如下所示： 单击上图中的+可以添加自定义的组合键选择其中的AndroidLog即可进行自定义设置： 参数具体修改界面： 2. 已存在组合指令2.1 Log输出自定义 logt private static final String TAG = &quot;MainActivity &quot;; loge logi logd 2.2 循环 单独使用：foreach for (:) {} fori for (int i = 0; i &lt; ; i++) {} itar (array) for (int i = 0; i &lt; array.length; i++) { = array[i]; } iten (enum) while (enumeration.hasMoreElements()) { Object nextElement = enumeration.nextElement(); } itit (iterator) while (iterator.hasNext()) { Object next = iterator.next(); } itli (List) for (int i = 0; i &lt; list.size(); i++) { Object o = list.get(i); } 组合使用： tagList.for 123for (String s : tagList) &#123; &#125; tagList.fori 123for (int i = 0; i &lt; tagList.size(); i++) &#123; &#125; tagList.forr 123for (int i = tagList.size() - 1; i &gt;= 0; i--) &#123; &#125; 2.3 判定 ifn if (savedInstanceState == null) {} inn if (savedInstanceState != null) {} lazy if (savedInstanceState == null) { savedInstanceState = new Bundle(); } lnst if (savedInstanceState instanceof Object) { Object instanceState = (Object) savedInstanceState; } 2.4 View相关 gone .setVisibility(View.GONE); visible Toast Toast.makeText(this, &quot;&quot;, Toast.LENGTH_SHORT).show(); fbc () findViewById(R.id.); fixme // FIXME: 2017/10/26 todo lhm lhw 2.5 全局 static final 变量 psf public static final psfi public static final int psfs St 六 常用快捷整理 查看当前module所有断点：Com + shift + F8 全局搜索变量：Com + shift + f 搜索类：双击 shift 变量大写：Com + shift + u switch to task ：shift + option + t 快速修改：Com + option + f 书签设置：F3（普通书签样式）；option + F3（数字书签样式）；com + F3（显示所有书签） 折叠/展开代码块：com + “-“ / “+” 查找操作：Cmd +Shift + A 回到上一个工具窗口：F12 上一个编辑位置：Cmd + Shift + Delete 定位到嵌套文件(在一个项目中有多个相同名称的文件存在，同过此命令调出搜索窗口，通过先输入路径进行文件定位)：Shift + Cmd + O 查看一个方法在项目多个文件中的用法（Usage of XXX in Project Files）：option+F7 定位到当前类所在的父类（直接跳转）：com + u 在外部打开文件：com + 单击Tab 快速查看定义：Cmd + Y 最近修改的文件：Cmd + Shift + E 返回到编辑器：Esc：该操作仅仅把光标移回编辑器。Shift + Esc：该操作会关闭当前面板，然后把光标移回到编辑器。 上、下移动当前行：com + shift + 方向键 扩大/缩小选中范围：option + 方向键 选中快捷键：option + 光标 文件结构弹窗：com + F12 复制行：com + d 提取方法：com + option + m 提取参数：com + option + p 提取变量：com + option + v 内置（提取反向操作）：com + option + n 合并文本行：ctrl + shift + j 动态模板：com + j 行上下移动，不需要复制粘贴就可以上下移动行了：option + Shift + Up/Down 方法移动：com + option + up/dowm 重构：shift + F6 为当前变量添加额外判定条件：option + com + t 七-生成签名文件1keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 参数说明 1234567-genkey 在用户主目录中创建一个key.jks文件-v 显示密钥库中的证书详细信息-alias 产生别名-keyalg 指定密钥的算法 -keystore 指定密钥库的名称(产生的各类信息将不在.jks文件中-validity 指定创建的证书有效期多少天-keysize 指定密钥长度]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境下Hexo-GitHub-MWeb搭建个人博客]]></title>
    <url>%2FMac%E7%8E%AF%E5%A2%83%E4%B8%8BHexo-GitHub-MWeb%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[需要的工具：Node.js、Git、Hexo、Coding（自选）、MWeb（自选） 安装Git非重点，自行安装 Node.js非重点，自行安装 Hexo按照此命令进行安装Hexo$ sudo npm install -g hexo 初始化Hexo其中Blog_Hexo为自己建立的目标文件夹。只要是建立自己的任意一个博客，都可使用一下步骤。 $ hexo init Blog_Hexo 在“blog”文件夹中安装npm $ npm install 执行一下命令，查看是否安装成功 $ hexo s 在浏览器中打开：http://localhost:4000 能看到“Hexo”页面表示安装成功： 关联GitHub登录你的Github帐号，新建仓库，名为：用户名.github.io ，此为固定写法。创建之后为： 创建的Hexo文件夹为： cd到Blog_Hexo文件夹下，编辑_config.yml。 注意：_config.yml 文件中的 ：后面要加一个空格 1）若是只将博客上传至GItHub中，编写 deploy: type: git repository: https://github.com/gonghonglou/gonghonglou.github.io.git branch: master 2）若是将博客同时上传至GItHub和Coding中，编写： deploy: type: git repo: github: git@github.com:YannisCheng/YannisCheng.github.io.git,master coding: git@git.coding.net:yannischeng/blog.git,master 在Blog_Hexo文件夹目录下执行生成静态页面命令： $ hexo g 此时若出现如下报错： ERROR Local hexo not found in ~/blog ERROR Try runing: &apos;npm install hexo --save&apos; 则执行命令： npm install hexo --save 若无报错，自行忽略此步骤。再执行配置命令： $ hexo d 执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命： $ npm install hexo-deployer-git --save 若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即 Username for &apos;https:// .github.com&apos;: Password for &apos;https:// .github.com&apos;: hexo deploy命令执行成功后，浏览器中打开网址http:// .github.io 能看到和打开 http://localhost:4000 时一样的页面。 发布cd到Blog_Hexo中，执行如下命令新建文章 hexo new &quot;hello-world&quot; 新的文件建立之后的位置为 编辑之后，在 Blog_Hexo 文件夹中执行如下命令 hexo generate //生成静态页面 hexo deploy //将文章部署到Github 至此，安装环节结束，可以进行基本的使用了。 安装主题NexT主题在Blog_Hexo目录下执行： git clone https://github.com/iissnan/hexo-theme-next themes/next 安装之后的文件位置为： 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 theme: next 修改主题为主题增加标签：hexo new page tags 为主题修改背景：在 \themes\next\layout\_layout.swig文件的&lt;/body&gt;上面添加 &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/ca 具体详细设置参考：https://github.com/hustcc/canvas-nest.js/blob/master/README-zh.md 问题杂集主题相关hexo next5.0主题不显示副标题打开themes/next/source/css/_schemes/Mist/_logo.styl 你会看见.site-subtitle { display: none; }删去或改成你想要的即可 为主题 添加字数统计、阅读时长、友情链接开启设置NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件Blog\themes\next_config.yml中打开wordcount统计功能即可 # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true 若只是打开开关，部署之后会发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等字样。 参考：http://blog.csdn.net/wangxw725/article/details/71602256?utm_source=itdadao&amp;utm_medium=referral 找到Blog\themes\next\layout\_macro\post.swig 文件注意： 在此文中出现 字数统计的配置英文字样时会报错！ 安装统计插件如果没有安装 hexo-wordcount 插件，先安装该插件： npm i --save hexo-wordcount Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下： npm install hexo-wordcount@2 --save 安装完成后，重新执行启动服务预览就可以了。 Hexo相关添加分类、标签云、关于等页面以添加分类页面为例，在站点目录下，打开git bash，输入 hexo new page &quot;categories&quot; 之后在站点目录下的source文件夹下，会新增一个categories的文件夹，里面有一个index.md文件，打开如下 --- title: categories date: 2015-12-04 15:37:22 type: &quot;categories&quot; comments: false --- 其中，comments可以设置为false，含义是打开分类页面、评论插件不显示；如要显示则改为true。tags, about页面的创建类似，输入 hexo new page &quot;tags&quot; hexo new page &quot;about&quot; 标签的使用 + 文章模板--- title: Mac环境下Hexo-GitHub-MWeb搭建个人博客 date: 2017-10-22 23:48:37 tags: [Mac,博客] categories: 博客 --- hexo草稿模式 参考：http://blog.csdn.net/wizardforcel/article/details/40684575 草稿模式中的文件不会公开显示，适用于：有些文档非常重要但是又不想公开、又不想删除，此时使用hexo模式最合适。使用 hexo new draft &quot;Android热修复&quot; 执行此命令之后，会在相应目录下生成相关文件：~/HexoBLog/source/_drafts/Android热修复.md。图示： 强行预览草稿更爱配置文件： render _drafts: true 通过服务预览： hexo server --drafts 将草稿转变为正式文章： hexo publish [layout] &lt;filename&gt; 问题总结Module Error系列问题描述: 123&#123; Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;&#125;&#123; Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos; &#125;&#123; Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos; 解决办法： 按照以下顺序： 卸载 1npm uninstall hexo-cli -g 安装 1npm install hexo-cli -g 执行到这一步，问题仅仅剩下： 1&#123; Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;&#125; 再安装一次 1npm install hexo --no-optional]]></content>
      <categories>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的menu文件]]></title>
    <url>%2FAndroid%E7%9A%84menu%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[总结 在Activity中使用menu/** * toolbar menu 的图标点初始化 * @param menu * @return */ @Override public boolean onCreateOptionsMenu(Menu menu) { super.onCreateOptionsMenu(menu); getMenuInflater().inflate(R.menu.tool_bar, menu); return true; } 一个menu文件示例包括：单个item menu，组item menu &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;item android:id=&quot;@+id/choose_day&quot; android:icon=&quot;@drawable/date_choose_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;选择时间范围&quot; app:showAsAction=&quot;always&quot;&gt; &lt;!-- item包含menu表示该menu是item下的子菜单 --&gt; &lt;!--&lt;menu&gt; &amp;lt;!&amp;ndash; 将group中的菜单项放于一个组里面 &amp;ndash;&amp;gt; &lt;group android:id=&quot;@+id/group&quot; android:menuCategory=&quot;secondary&quot; android:visible=&quot;true&quot;&gt; &lt;item android:id=&quot;@+id/today&quot; android:icon=&quot;@drawable/menu_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;今天&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/week&quot; android:icon=&quot;@drawable/menu_bg&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;本周&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;/group&gt; &lt;/menu&gt;--&gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/recorder_voice&quot; android:icon=&quot;@drawable/recoder_selector&quot; android:orderInCategory=&quot;80&quot; android:title=&quot;点击录音&quot; app:showAsAction=&quot;always&quot;&gt; &lt;/item&gt; &lt;/menu&gt; 方法的使用在建立actionbar或是toolbar的时候，都会默认的实现两个方法： onCreateOptionsMenu ： 建立菜单，只在页面加载的时候，运行一次，其后就不在运行了，想改变Menu在这里是不可能的。 onOptionsItemSelected ：对选中的菜单进行操作 Android提供了一个方法叫onPrepareOptionsMenu，它的功能是在每次点击一个Menu的时候，它就改变一次，所以你想要改变Menu的值，就得在这里运行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>menu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义 - Drawable]]></title>
    <url>%2FAndroid%20View-%E8%87%AA%E5%AE%9A%E4%B9%89%20-%20Drawable%2F</url>
    <content type="text"><![CDATA[Android动画参考 ：http://blog.csdn.net/harvic880925/article/details/39996643/各个形状介绍 ：http://blog.csdn.net/yangyahuiguo/article/details/52131658 DrawableDrawable 表示的是一种可以在 Canvas 上进行绘制的抽象的概念。其子类有很多，最常见的颜色和图片都是一种 Drawable。一般使用 XML文件 来描述 Drawable，简单、解耦。 Drawable 特点 子类繁多； 掌握种类繁多的 Drawable 可以作出一些特殊效果的UI。 Drawable 优点 相比自定义View，简单的多； 非图片类型的 Drawable 占用内存较少。 BitmapDrawable 对应：XML文件 中的 &lt;bitmap&gt; 标签 表示的就是一张图片，通过在 XML文件 中进行属性配置，产生不同的效果。 ShapeDrawable 对应：XML文件 中的 &lt;shape&gt; 标签 通过颜色、形状构造图形 示例1. oval：椭圆gradient:表示渐变属性 type 表示渐变的样式 123456789101112131415161718&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -》 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;gradient android:angle="180" android:endColor="@color/Amber_900" android:startColor="@color/Orange_100"/&gt; &lt;!-- 当使用此属性时，过度颜色的背景将被遮盖，只显示当前属性的颜色 --&gt; &lt;!--&lt;solid android:color="@color/Deep_Orange_a700"/&gt;--&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; gradientRadius:和镜像属性结合使用，也是必须要设定的属性。表示镜像半径的大小 1234567891011121314151617&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- sweep 属性正常使用，无需其他条件--&gt; &lt;!-- radial 属性使用需要搭配：gradientRadius属性 ： 效果： 由内而外的扩散--&gt; &lt;gradient android:endColor="@color/Amber_900" android:gradientRadius="100px" android:startColor="@color/Orange_100" android:type="radial"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 12345678910111213141516171819&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -》 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;gradient android:angle="180" android:centerColor="@color/white" android:endColor="@color/Amber_900" android:gradientRadius="200px" android:startColor="@color/Orange_100" android:type="radial"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 1234567891011121314151617181920&lt;!-- 绘制圆形 --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" android:useLevel="false"&gt; &lt;!-- 当只使用此属性时，此圆的背景色为此属性的颜色 --&gt; &lt;!-- 默认过度颜色：从右 -&gt; 左--&gt; &lt;!-- 默认过度效果为：linear --&gt; &lt;!-- android:centerY float。渐变中心的相对Y坐标，在0到1.0之间。 --&gt; &lt;!-- x,y 表示开始颜色 开始的位置--&gt; &lt;gradient android:type="radial" android:gradientRadius="100px" android:centerX="0.3" android:centerY="0.3" android:endColor="@color/Amber_900" android:startColor="@color/Orange_100"/&gt; &lt;!-- 此颜色总是显示 --&gt; &lt;stroke android:width="5px" android:color="@color/Blue_600"/&gt;&lt;/shape&gt; 示例2. ring ：圆环 12345678910111213141516171819&lt;!-- 绘制圆环 --&gt;&lt;!--innerRadius : 内环的半径。一个尺寸值（dip等等）或者一个尺寸资源 --&gt;&lt;!--innerRadiusRatio : Float类型。这个值表示内部环的比例，例如,如果android:innerRadiusRatio = " 5 ",那么内部的半径等于环的宽度除以5。这个值会被android:innerRadius重写。 默认值是9。( innerRaiusRatio=view的宽度/半径) --&gt;&lt;!-- thickness : 环的厚度，是一个尺寸值或尺寸的资源。--&gt;&lt;!-- thicknessRatio : Float类型。厚度的比例。例如,如果android:thicknessRatio= " 2 ",然后厚度等于环的宽度除以2。这个值是被android:innerRadius重写， 默认值是3。(thickenessRatio=View的宽度/环厚度）--&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:innerRadius="120px" android:innerRadiusRatio="9" android:shape="ring" android:thickness="20px" android:thicknessRatio="3" android:useLevel="false"&gt; &lt;gradient android:endColor="#00000000" android:startColor="#ff0000" android:type="sweep"/&gt;&lt;/shape&gt; &lt;shape&gt;标签 中各个属性的介绍1. 形状分类 矩形rectangle 椭圆形oval 线性形状line 环形ring 水波纹ripple 2. ring专有属性android:innerRadius 尺寸，内环的半径。android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的半径，例如，如果:android:innerRadiusRatio=”5”，表示内环半径等于环的宽度除以5，这个值是可以被覆盖的，默认为9. android:thickness 尺寸，环的厚度android:thicknessRatio浮点型，以环的宽度比率来表示环的厚度，例如，如果android:thicknessRatio=”2”，那么环的厚度就等于环的宽度除以2。这个值是可以被android:thickness覆盖的，默认值是3.android:useLevel boolean值，如果当做是LevelListDrawable使用时值为true，否则为false. 3. 一个xml文件 6个元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!-- 1- 圆角 android:radius 整型 半径 android:topLeftRadius 整型 左上角半径 android:topRightRadius 整型 右上角半径 android:bottomLeftRadius 整型 左下角半径 android:bottomRightRadius 整型 右下角半径 --&gt; &lt;corners android:radius="8dp" android:topLeftRadius="5dp" android:topRightRadius="15dp" android:bottomLeftRadius="20dp" android:bottomRightRadius="25dp" /&gt; &lt;!-- 2- 渐变色 android:startColor 颜色值 起始颜色 android:endColor 颜色值 结束颜色 android:centerColor 整型 渐变中间颜色，即开始颜色与结束颜色之间的颜色 android:angle 整型 渐变角度(PS：当angle=0时，渐变色是从左向右。 然后逆时针方向转，当angle=90时为从下往上。angle必须为45的整数倍) android:type ["linear" | "radial" | "sweep"] 渐变类型(取值：linear、radial、sweep) linear 线性渐变，这是默认设置 radial 放射性渐变，以开始色为中心。 sweep 扫描线式的渐变。 android:useLevel ["true" | "false"] 如果要使用LevelListDrawable对象，就要设置为true。设置为true无渐变。false有渐变色 android:gradientRadius 整型 渐变色半径.当 android:type="radial" 时才使用。单独使用 android:type="radial"会报错。 android:centerX 整型 渐变中心X点坐标的相对位置 android:centerY 整型 渐变中心Y点坐标的相对位置 --&gt; &lt;gradient android:startColor="#FFFF0000" android:endColor="#80FF00FF" android:angle="45" /&gt; &lt;!-- 3- 内”边距"，即内容与边的距离 android:left 整型 左内边距 android:top 整型 上内边距 android:right 整型 右内边距 android:bottom 整型 下内边距 --&gt; &lt;padding android:left="10dp" android:top="10dp" android:right="10dp" android:bottom="10dp" /&gt; &lt;!-- 4- ”大小" android:width 整型 宽度 android:height 整型 高度 --&gt; &lt;size android:width="600dp" /&gt; &lt;!-- 5- ”内部填充" android:color 颜色值 填充颜色 --&gt; &lt;solid android:color="#ffff9d77" /&gt; &lt;!-- 6- ”描边" android:width 整型 描边的宽度 android:color 颜色值 描边的颜色 android:dashWidth 整型 表示描边的样式是虚线的宽度， 值为0时，表示为实线。值大于0则为虚线。 android:dashGap 整型 表示描边为虚线时，虚线之间的间隔 即“ - - - - ” --&gt; &lt;stroke android:width="2dp" android:color="#dcdcdc" /&gt;&lt;/shape&gt; LayerDrawable 层次绘制 参考：http://blog.csdn.net/lihenair/article/details/50111231 对应： &lt;layer-list&gt;标签 表示一种层次化的 Drawable 集合，类似 PS 软件中的 图层 概念，下面的图层遮挡上面的图层。 原理图解 &lt;layer_list&gt; : 将多个“图片”或 多种效果的shape 按照顺序层叠起来 示例01 1234567891011121314151617181920212223242526&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;!-- 底层--&gt;&lt;!-- 此处的位置数值表示：相对于顶层的位置偏移--&gt; &lt;item android:top="10px" android:left="10px"&gt; &lt;shape&gt; &lt;solid android:color="#bbb" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width="1px" android:color="#ccc" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 顶层--&gt; &lt;!-- 此处的位置数值表示：相对于底层的位置偏移--&gt; &lt;item android:bottom="10px" android:right="10px"&gt; &lt;shape&gt; &lt;solid android:color="#ffffff" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width="0.3px" android:color="#ddd" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; 示例02：在我们的例子中，当按钮被按下时，我们取消了阴影来产生反馈效果。 123456789101112131415161718192021222324252627282930313233&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;layer-list&gt; &lt;item android:left="4dp" android:top="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#ff58bb52" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;!-- SHADOW LAYER --&gt; &lt;item android:left="4dp" android:top="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#66000000" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- CONTENT LAYER --&gt; &lt;item android:bottom="4dp" android:right="4dp"&gt; &lt;shape&gt; &lt;solid android:color="#ff58bb52" /&gt; &lt;corners android:radius="30dip"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; StateListDrawable这个类所达到的效果其实就是，我们常用的：在 res/drawable/目录下编写的 各种 xxx_selector xml文件。 对应：&lt;selector&gt; 标签 表示的也是 Drawable 的集合，是不同事件状态的下的 Drawable 集合]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 15-I/O]]></title>
    <url>%2FPython3%20%2015-I%3AO%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 关于Open()源码文档打开文件并返回流。失败时提高IOError。 文件是一个文本或字节串，给出要打开的文件的名称（如果文件不在当前工作目录中的路径）或要包装的文件的整数文件描述符。 （如果给出了一个文件描述符，则当返回的I / O对象关闭时，它将被关闭，除非closefd设置为False。）mode是一个可选字符串，用于指定文件打开的方式。它默认为&apos;r&apos;，这意味着在文本模式下打开阅读。其他常见的值是“w”用于写入（截断文件已存在），“x”用于创建和写入新文件，“a”用于附加（在某些Unix系统上，这意味着所有写入都附加到无论当前查找位置如何，文件的结尾）。在文本模式下，如果未指定编码，则使用的编码与平台相关：调用locale.getpreferredencoding（False）以获取当前语言环境编码。 （用于读取和写入原始字节使用二进制模式并保留编码未指定。）可用的模式有： &apos;r&apos;开放阅读（默认） &apos;w&apos;打开写入，首先截断文件 &apos;x&apos;创建一个新文件并将其打开以进行写入 &apos;a&apos;开放写作，如果文件存在，则附加到文件末尾 &apos;b&apos;二进制模式 &apos;t&apos;文字模式（默认） &apos;+&apos;打开一个磁盘文件进行更新（读写） &apos;U&apos;通用换行模式（弃用） 默认模式为“rt”（打开阅读文本）。对于二进制随机访问，模式&apos;w + b&apos;打开并将文件截断为0字节，而&apos;r + b&apos;打开文件而不截断。如果文件已经存在，&apos;x&apos;模式意味着&apos;w&apos;并引发一个`FileExistsError`。 Python区分以二进制和文本模式打开的文件，即使底层操作系统没有。文件以二进制模式打开（将&apos;b&apos;追加到模式参数）返回内容作为字节对象而不进行任何解码。在文本模式（默认情况下，或在模式参数附加了&apos;t&apos;）时，文件的内容将返回为字符串，首先使用平台相关编码对字节进行了解码，如果给出，则使用指定的编码。 &apos;U&apos;模式已被弃用，并会在将来的Python版本中引发异常。它对Python 3没有影响。使用换行来控制通用换行符模式。缓冲是用于设置缓冲策略的可选整数。通过0以切换缓冲（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），整数&gt; 1表示固定大小的块缓冲区的大小。当没有给出缓冲参数时，默认缓冲策略的工作原理如下： *二进制文件以固定大小的块进行缓冲;使用启发式方法来选择缓冲区的大小，试图确定底层设备的“块大小”并落回到“io.DEFAULT_BUFFER_SIZE”上。在许多系统上，缓冲区通常为4096或8192字节长。 *“交互式”文本文件（其中isatty（）返回True的文件）使用行缓冲。其他文本文件使用上述针对二进制文件的策略。 encoding是用于对文件进行解码或编码的编码名称。这只能在文本模式下使用。默认编码是平台依赖的，但是Python可以支持任何编码。有关支持的编码列表，请参阅编解码器模块。 errors是一个可选的字符串，指定如何处理编码错误 - 此参数不应在二进制模式下使用。如果存在编码错误（默认值为None）具有相同的效果，则通过&apos;strict&apos;来引发ValueError异常，或者通过&apos;ignore&apos;忽略错误。 （请注意，忽略编码错误可能导致数据丢失。）有关编码错误字符串的列表，请参阅codecs.register的文档或运行&apos;help（codecs.Codec）&apos;。 换行符控制通用换行符的工作原理（仅适用于文本模式）。它可以是无，&apos;&apos;，&apos;\ n&apos;，&apos;\ r&apos;和&apos;\ r \ n&apos;。它的工作原理如下： *输入时，如果换行符为None，则启用通用换行符模式。输入中的行可以&apos;\ n&apos;，&apos;\ r&apos;或&apos;\ r \ n&apos;结尾，并将它们转换为&apos;\ n&apos;，然后返回给调用者。如果是&apos;&apos;，则启用通用换行模式，但是行结束将返回给未经翻译的调用者。如果它具有任何其他合法值，则输入行仅由给定终止 2017年07月21日09:44:52 暂停]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 14-调试]]></title>
    <url>%2FPython3%20%2014-%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 几个方法说明 .print()打印用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。 assert断言凡是用print()来辅助查看的地方，都可以用断言assert来替代。代码示例： 1234567def foo(s): n = int(s) assert n != 0, 'n is zero!' return 10 / ndef main(): foo('0') 在程序中使用assert和print()相比也好不到哪去。但是：启动Python解释器时可以用-O参数来关闭assert 1$ python3 -O err.py 关闭后，你可以把所有的assert语句当成pass来看。 logging日志把print()替换为logging是第3种方式，和assert比，logging不但会抛出错误，而且可以输出到文件。注意：导入logging包之后，应在添加配置语句logging.basicConfig(level=logging.INFO)代码示例 1234567891011121314151617181920212223242526272829303132333435363738import logging# logging.basicConfig(level=logging.INFO)# 配置日志信息logging.basicConfig(level=logging.DEBUG, format='%(asctime)-8s %(name)-8s %(levelname)-8s %(message)s - [%(filename)s:%(lineno)s]', datefmt='%Y-%m-%d %H:%M:%S', filename='myapp.log', filemode='w')# 定义一个Handler打印INFO及以上级别的日志到sys.stderrconsole = logging.StreamHandler()console.setLevel(logging.DEBUG)# 设置控制台日志打印格式formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')console.setFormatter(formatter)# 将定义好的console日志handler添加到root loggerlogging.getLogger('').addHandler(console)"""测试logging"""s = '0'n = int(s)logging.info('n = %d' % n)print(10 / n)'''结果输出INFO:root:n = 0Traceback (most recent call last): File "/Users/yannischeng/PycharmProjects/First_Python_Project/py_obj_end_12/TestObj.py", line 69, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero''''''输出到文件中的信息：2017-07-20 09:57:51 root INFO n = 0 - [LogSet.py:27]''' 优点 允许你指定记录信息的级别，有debug，info，warning，error等几个级别。 通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。 参考 logging的配置参考：http://blog.csdn.net/naiveloafer/article/details/7630903 Format编写 Format Description %(name)s Name of the logger (logging channel). %(levelno)s |Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).%(levelname)s |Text logging level for the message (‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’).%(pathname)s |Full pathname of the source file where the logging call was issued (if available).%(filename)s | Filename portion of pathname.%(module)s | Module (name portion of filename).%(funcName)s | Name of function containing the logging call.%(lineno)d | Source line number where the logging call was issued (if available).%(created)f | Time when the LogRecord was created (as returned by time.time()).%(relativeCreated)d | Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.%(asctime)s |Human-readable time when the LogRecord was created. By default this is of the form “2003-07-08 16:49:45,896” (the numbers after the comma are millisecond portion of the time).%(msecs)d | Millisecond portion of the time when the LogRecord was created.%(thread)d | Thread ID (if available).%(threadName)s | Thread name (if available).%(process)d | Process ID (if available).%(message)s | The logged message, computed as msg % args. basicConfig()编写 对日志记录系统进行基本配置： 如果根记录器已经具有处理程序，则此函数不起作用配置。这是一个方便的方法，供简单的脚本使用做一次性配置的日志记录包。 默认行为是创建一个写入的StreamHandler sys.stderr，使用BASIC_FORMAT格式字符串设置格式化程序，和将处理程序添加到根记录器。 可以指定一些可选的关键字参数，这可以改变默认行为。 Optional Keyword Description filename 指定使用指定的FileHandler进行创建文件名，而不是一个StreamHandler。 filemode | 指定打开文件的方式，如果指定了filename（如果filemode未指定，则默认为&apos;a&apos;）。 format | 为处理程序使用指定的格式字符串。 datefmt | 使用指定的日期/时间格式。 style | 如果指定了格式字符串，请使用此字符串指定格式字符串的类型（可能的值&apos;％&apos;，&apos;{&apos;，&apos;$&apos;，for ％-formatting，：meth：`str.format`和：class：`string.Template` - 默认为&apos;％&apos;）。 level | 将根记录器级别设置为指定级别。 stream | 使用指定的流来初始化StreamHandler。注意该参数与“filename”不兼容 - 如果同时使用存在，“流”被忽略。 handlers | 如果指定，这应该是已经创建的迭代处理程序，将被添加到根处理程序。任何处理程序在没有格式化程序分配的列表中分配在此函数中创建的格式化程序。 请注意： 可以指定使用open（filename，mode）创建的流而不是传递文件名和模式。但是应该记住StreamHandler并不关闭它的流（因为它可能使用sys.stdout或sys.stderr），而FileHandler关闭其流当处理程序关闭时。 .调试器pdb – 有了PyCharm目前不考虑此种方式启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 14-单元测试]]></title>
    <url>%2FPython3%20%2014-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python “测试驱动开发”（TDD：Test-Driven Development）– 单元测试 是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 在pycharm中创建单元测试 创建参考：http://blog.csdn.net/u013088062/article/details/50183789一个案例：http://www.cnblogs.com/iamjqy/p/7155315.html 具体创建过程参考python文件夹的.png图片。 选中待要编写测试代码的类名 –&gt; 右键 选择 Go To –&gt; Test Object 单元测试实现待测试类代码12345678910111213141516class MyDict(dict): def __init__(self, **kwargs): super().__init__(**kwargs) def __getattr__(self, item): try: return self[item] except KeyError: raise AttributeError(r"'MyDict' object has no attribute '%s'" % item) def __setattr__(self, key, value): self[key] = value def add(self, m, n): print("%d + %d = %d" % (m, n, (m+n))) 单元测试类代码123456789101112131415161718192021222324from unittest import TestCasefrom py_unittext_14.MyDict import MyDictclass TestMyDict(TestCase): # setUp与tearDown # 这两个方法会分别在每调用一个测试方法的前后分别被执行。 # setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码 def setUp(self): print('setUp...') def tearDown(self): print('tearDown...') def test_add(self): d = MyDict(name='程文佳', age='24', city='Tianjin') self.assertEqual(d.name, '程文佳') self.assertEqual(d['name'], '程文佳') print(d.name) def test_add2(self): d = MyDict(name='程文佳', age='24', city='Tianjin') d.add(3, 4) 测试结果1234567891011setUp...程文佳tearDown...setUp...3 + 4 = 7tearDown...Ran 2 tests in 0.002sOK 小结 单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。 单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。 单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。 单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 13-错误+测试+调试]]></title>
    <url>%2FPython3%20%2013-%E9%94%99%E8%AF%AF%2B%E6%B5%8B%E8%AF%95%2B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 错误12345678try: """ 可能出错的代码块 """except ZeroDivisionError as e: print('except:', e)finally: print('finally...') 错误特点 Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。 使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，即：不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。比如函数main()调用foo()，foo()调用bar()，结果bar()出错了。这时，只要main()捕获到了就可以处理bar()中的错误。 记录错误 捕获错误，把错误堆栈打印出来，分析错误原因，同时，让程序继续执行下去而不是使得程序被结束。 使用方法 12345678import logging# 同样是出错，但程序打印完错误信息后会继续执行，并正常退出.# 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。try: bar('0')except Exception as e: logging.exception(e) 抛出错误 因为错误是class。捕获一个错误就是捕获到该class的一个实例。 既可以使用python的内置函数抛出错误，也可以自己编写函数抛出错误。 使用关键字raise抛出一个错误实例 代码示例 1234567891011121314151617181920# 编写自定义异常类class FooError(ValueError): passdef foo(s): n = int(s) if n==0: raise FooError('invalid value: %s' % s) return 10 / n# 调用自定义的异常类foo('0')# 报的错误Traceback (most recent call last): File "err_throw.py", line 11, in &lt;module&gt; foo('0') File "err_throw.py", line 8, in foo raise FooError('invalid value: %s' % s)__main__.FooError: invalid value: 0]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 11-面向对象+枚举]]></title>
    <url>%2FPython3%20%2011-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python Python中Enum枚举的实现：http://www.cnblogs.com/codingmylife/archive/2013/05/31/3110656.html 定义常量的一般方法：定义变量推荐的方法为：将枚举类型定义一个class类型。每个常量都是class的唯一实例python提供了Enum来实现枚举功能 12345678910111213141516171819202122232425262728293031323334353637# 实现方式1from enum import EnumWeek = Enum('WeekInfo', ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'))# 实现方式2from enum import Enum, unique# @unique装饰器检查保证没有重复值@uniqueclass MyEnum02(Enum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sta = 6# 遍历Enumfor name, value in Week.__members__.items(): print(name, value, m.value)print(Week.Mon.value) # 1"""Mon WeekInfo.Mon 1Tue WeekInfo.Tue 2Wed WeekInfo.Wed 3Thu WeekInfo.Thu 4Fri WeekInfo.Fri 5Sat WeekInfo.Sat 6Sun WeekInfo.Sun 7"""# 使用MyEnum02print(MyEnum02(1)) # MyEnum02.Mon]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 12-面向对象+元类]]></title>
    <url>%2FPython3%20%2012-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 静态语言和动态语言最大的不同，就是函数和类的定义。不是编译时定义的，而是运行时动态编译的。 关键字：type(), metaclass 一般的class创建123456789101112131415class Hello(object): def hello(self): print('Hello World !')from py_obj_end_12.Hello import Hello"""导入Hello类后的测试"""h = Hello()print(h.hello()) # Hello World !# 查看实例h所属的类型，是class Helloprint(type(h)) # &lt;class 'py_obj_end_12.Hello.Hello'&gt;# 查看Hello所属的类型，是 type 类型print(type(Hello)) # &lt;class 'type'&gt; 使用type()来动态创建类type 是什么？为什么 Hello 会是 type 类型的？ 因为Python是动态语言，所以class的定义是运行时动态创建的，而创建class使用的就是type()函数 type()函数既可以返回一个对象的类型，又可以创建出新的类型。 通过type()创建class和直接写class是完全一样的。 因为python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 正常情况下，我们使用class Xxx创建一个类。但是，因为type()函数允许我们动态的将类创建出来。 动态语言本身支持处于运行期的程序动态创建一个类。这和Java的静态语言不同。 type()使用：http://www.cnblogs.com/ccorz/p/6120783.html type(name, bases, dict) 返回一个新的type对象. 基本上是 class 语句的动态形式. 参数: name , 字符串, 制定要构造类的名字, 赋给新对象的 __name__ 属性; bases，一个tuple，指定新类型的所有基类，赋给新对象的__bases__ 属性; dict， 字典类型，作为新类的名字空间，赋给新对象的__dict__ 属性 12345678910111213141516171819# 用type()函数创建Hello类# 1.定义一个函数。即：类的方法def say(self): print('Hello, World 2!')# 2.创建一个class Hello2。type()函数中传入的参数：# 1）class类名，2）继承的父类集合，3）class的方法名与函数的绑定，此处即：将函数say()绑定至方法名hello上# 其实class定义一个类主要也是这3个主要组成部分：类名、继承类、方法# Hello2是一个以名为"Hello22"的类的引用。这个名为"Hello22"的类以object为基类,类中有一个say()函数Hello2 = type('Hello22', (object,), dict(say=say))# 3.为类绑定一个变量Hello2.name = 'cwj'# 测试h2 = Hello2()print(h2.say()) # Hello, World 2!print(h2.name) # cwj metaclass使用metaclass来控制类的创建行为]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 10-面向对象+定制对象]]></title>
    <url>%2FPython3%20%2010-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E5%AE%9A%E5%88%B6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 在编写一个基础类的基础上，为其重写某些魔法方法。 python其他内置魔法方法： https://docs.python.org/3/reference/datamodel.html#special-method-nameshttp://www.cnblogs.com/simayixin/archive/2011/05/04/2036295.htmlpython常用魔法方法的实现：http://www.cnblogs.com/scolia/p/5690210.html 魔法方法有：-1.__new__()：对象的创建，是一个静态方法，第一个参数是cls。(不可能是self，因为对象还没创建，哪来的self)—提示单例模式与此有关。0.__init__()：对象的初始化， 是一个实例方法，第一个参数是self。1.__slots__()：约束要绑定的临时变量2.__len__()：让类作用于len()3.__str__()：类似于java中的toString()，返回用户看到的字符串4.__repe__()：返回开发者看到的字符串5.__iter__()：将一个类被用于for...in循环中，返回一个迭代对象6.__getitem__()：像list那样按照下标取出元素，要在其中处理slice切片、step步长7.__getattr__()：当调用不存在的属性时，Python解释器会试图调用__getattr__(self, &#39;attr&#39;)来尝试获得属性。只有在没有找到属性的情况下，才调用__getattr__，已有的属性将不会在__getattr__中查找。而且，实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。8.__call__() __iter__() 配合 __next__()使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person(object): # 构造方法 def __init__(self, name): self._name = name self.a, self.sum = 1, 0 # 使本类可以迭代 def __iter__(self): return self # 具体的迭代方法，此方法的实现是关键 def __next__(self): self.sum = self.sum + self.a if self.sum &gt; 10: raise StopIteration return self.sum # 重写 toString()方法 def __str__(self): return 'Person name is ' + self._name __repr__ = __str__ '''测试'''person = Person("cwj")# 重写 __str__() 之后的效果print(Person("cwj")) # Person name is cwjprint(person) # Person name is cwjprint(isinstance(person, Iterator)) # Trueprint(isinstance(person, Iterable)) # Truel = []# 遍历Person序列，此时Person是一个Iteratorfor n in person: l.append(n) print(n)# 将一个类遍历后得到的结果赋值给l序列print(l) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'''12345678910''' __getitme__()配合__setitme__()使用12345678910111213141516171819class DictDemo(object): def __init__(self): self.dict = &#123;&#125; def __getitem__(self, item): if item in self.dict: return self.dict[item] else: return '不存在' def __setitem__(self, key, value): self.dict[key] = value '''测试'''dictD = DictDemo()dictD['1'] = 'cwj'dictD.__setitem__('1','234')print(dictD.__getitem__('1')) # 234print(dictD['2']) # 不存在 一个实现迭代、容器的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112'''Animal类 自定义魔法函数'''from pip._vendor.requests.packages.urllib3.connectionpool import xrange'''创建一个模拟字典的类，这个类的内部维护了两个列表，key 负责储存键，value 负责储存值，两个列表通过索引的一一对应，从而达到模拟字典的目的'''class Animal(object): def __init__(self, key, value): self.key = [] self.value = [] self.key.append(key) self.value.append(value) self.__index = 0 # __len__方法，按照协议，这个方法应该返回容器的长度 def __len__(self): return len(self.key) # __getitem__方法。这个方法会在a['scolia']时，调用a.__getitem__('scolia')。 # 也就是说这个方法定义了元素的获取. # 先找到 key 列表中建的索引，然后用索引去 value 列表中找对应的元素，然后将其返回 def __getitem__(self, item): if item in self.key: return self.value[self.key.index(item)] else: return '不存在' # __setitem__(self, key, value)方法定义了 a['scolia'] = 'good' 这种操作时的行为， # 此时将会调用a.__setitem__('scolia', 'good') 因为是绑定方法，所以self是自动传递的 def __setitem__(self, key, value): if key not in self.key: self.key.append(key) self.value.append(value) else: __index = self.key.index(key) self.value[__index] = value # __delitem__(self, key)方法定义了del a['scolia'] 这类操作时候的行为， # 里面的‘scolia’就作为参数传进去 def __delitem__(self, key): if key in self.key: __index = self.key.index(key) del self.key[__index] del self.value[__index] else: return "key值不存在" '''只有实现里以上四个方法，就可以当做可变容器来使用了。''' # __str__ 是对应于 str() 函数，在类的表示中会继续讨论，这里是为了 print 语句好看才加进去的， # 因为print语句默认就是调用str()函数 def __str__(self): l = [] for index in xrange(len(self.key)): __key = self.key[index] __value = self.value[index] result = __key,__value l.append(result) return str(l) # 实现一个__iter__方法，这个方法负责返回一个迭代器 def __iter__(self): return self # 内部实现了next（python3.x为__next__）方法，真正负责迭代的实现。 # 当迭代器内的元素用尽之后，任何的进一步调用都之后触发 StopIteration 异常 # 一般会在一个类里同时实现这两种方法（即是可迭代对象又是迭代器），此时__iter__方法只要返回self就足够的了 def __next__(self): if self.__index == len(self.key): self.__index = 0 raise StopIteration() else: __key = self.key[self.__index] __value = self.value[self.__index] result = __key, __value self.__index += 1 return result # __contains__实现了成员判断，这里我们更关心value列表中的数据，所以判断的是value列表。 # 该方法要求返回布尔值。 def __contains__(self, item): if item in self.value: return True else: return False # __reversed__(self)方法返回一个倒序后的副本，这里体现了有序性 def __reversed__(self): __result = self.value __result.reverse() return __result'''实际测试'''m = Animal('1', 'cwj')print(m) # [('1', 'cwj')]print(m.__len__()) # 1m['2'] = 'ddd'm['3'] = 'qwe'm['2'] = 'lkj'print(m) # [('1', 'cwj'), ('2', 'lkj'), ('3', 'qwe')]print(m.__len__()) # 3del m['3']print(m) # [('1', 'cwj'), ('2', 'lkj')]print(m.__len__()) # 2print(reversed(m)) # ['lkj', 'cwj']print('cwj' in m) # True 类的切片操作 参考：http://www.cnblogs.com/scolia/p/5690210.html 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Slices(object): def __init__(self, x): self._x = x self._index = -1 ''' # __getitem__()实现支持for循环 def __getitem__(self, item): if isinstance(self._x, list): self._index += 1 return self._x[self._index] else: raise '参数类型错误' ''' def __getitem__(self, item): # print(item.start, item.stop, item.step) # 1 2 1 # return item # slice(1, 2, 1) if isinstance(item, slice): return self._x[item.start:item.stop:item.step]'''测试Slices类''''''s = Slices([1, 2, 3, 4])for n in s: print(n)'''1234'''s2 = Slices('1234')for n in s2: print(n)'''s3 = Slices([1, 2, 3, 4, 5])# 当直接返回item参数时的结果# print(s3[1:4:1]) # slice(1, 2, 1)print(s3[1:4:1]) # [2, 3, 4]print(s3[-4:-2]) # [2, 3]print(s3[-3:-1]) # [3, 4]print(s3[-5:]) # [1, 2, 3, 4, 5]print(s3[:]) # [1, 2, 3, 4, 5]print(s3[-1::-1]) # [5, 4, 3, 2, 1]print(s3[-1:]) # [5]``` ## `__getattr__()`正常情况下，当我们调用类的`方法`或`属性`时，如果不存在，就会报错。如：```pythonAttributeError: 'Student' object has no attribute 'score' 要避免这个错误，Python有一个机制：写一个__getattr__()方法，动态返回一个属性。当调用不存在的属性时，比如color，Python解释器会试图调用__getattr__(self, &#39;color&#39;)来尝试获得属性，这样我们就有机会返回color的值 123456789101112131415# 返回不存在的属性与函数# 作用：可以针对完全动态的情况作调用def __getattr__(self, item): # 返回未定义的属性 if item == 'color': return '您真是 666 啊 ~ 这个属性都鞥猜到' elif item == 'address': return '哈哈哈' # 返回未定义的函数 elif item == 'add': return lambda: 100 else: # 注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None # 要让class只响应特定的几个属性,要按照约定，抛出AttributeError错误 raise AttributeError('\'Student\' object has no attribute \'%s\'' % item) __call__()与__getattr__()组合实现URL中的链式(chain)调用在python中，函数其实是一个对象。如： 12345&gt;&gt;&gt; f = abs&gt;&gt;&gt; f.__name__'abs'&gt;&gt;&gt; f(-123)123 由于 f 可以被调用，所以，f 被称为可调用对象。所有的函数都是可调用对象。一个类的实例对象想要变成一个可调用的对象，只需要实现一个魔法方法__call__()。 可调用对象与一般对象 可调用对象：obj.name(‘source’).age。即：既可以使用.调用属性或方法，也可以使用obj()以一种函数样式使用此对象。此时调用obj(arg1,arg2,....)就等价于obj.__call__(self,arg1,arg2,...) 一般对象：obj.name。即：只能使用.调用属性或方法。 因为__call__()魔法方法的加入，因此python的函数与对象之间的概念被模糊了 URL中的链式调用，这样无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变，代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344'''URLChain类'''class URLChain(object): def __init__(self, path = ''): self.__path = path def __getattr__(self, item): # 实现参考：https://zhidao.baidu.com/question/1865282935722979707.html # 返回一个 URLChain 对象，这个时候里面的path就是''+'/'+'api'='/api'，此时self = /api print('\'self.__path is\' :' + self.__path + ' , \'item is\' : ' + item + ' ， 之前self为：', self) # 即：上一个 '%s/%s' 的数值代替：构造函数中 path = ''中 '' 的具体数值，相当于重新构造了一个对象， # 在即将的调用的返回值中表示参数self.__path的值, 新传入的参数赋值给item return URLChain('%s/%s' % (self.__path, item)) def __str__(self): return self.__path __repr__ = __str__ # 将此类的实例对象变成一个可调用的对象 def __call__(self, path): print('__call__ 之前self is : ', self) print('__call__ path is : ' + path) return URLChain('%s/%s' % (self.__path, path))'''调用URLChian类'''chain = URLChain()print(chain.api.server.user.friends)''''self.__path is' : , 'item is' : api ， 之前self为： 'self.__path is' :/api , 'item is' : server ， 之前self为： /api'self.__path is' :/api/server , 'item is' : user ， 之前self为： /api/server'self.__path is' :/api/server/user , 'item is' : friends ， 之前self为： /api/server/user/api/server/user/friends'''# 当执行 ('cwj') 这一个参数时调用的是 URLChian的 __call__()print(chain.api.server('cwj').friends)''''self.__path is' : , 'item is' : api ， 之前self为： 'self.__path is' :/api , 'item is' : server ， 之前self为： /api__call__ 之前self is : /api/server__call__ path is : cwj'self.__path is' :/api/server/cwj , 'item is' : friends ， 之前self为： /api/server/cwj/api/server/cwj/friends''' callable()的使用：判断一个变量是函数还是对象代码示例 1234# 判断一个对象是否能被调用，能被调用的对象就是一个Callable对象,函数和自定义的带有__call__()的类实例对象返回值是True：print(callable(chain)) # True URLChian实现了__call__()魔法方法print(callable(dictD)) # Falseprint(callable(abs)) # True]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 09-面向对象]]></title>
    <url>%2FPython3%20%2009-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 类的模板123456789101112131415161718192021222324252627'''类模板'''class Student(object): def __init__(self, name, age, city): self.name = name self.age = age self.__city = city def print_info(self): print('self is : ', self) # self is : &lt;py_class.Student.Student object at 0x10c92c400&gt; # print(student) 得到的结果为：&lt;py_class.Student.Student object at 0x10c92c400&gt; print('class is : ', self.__class__) # class is : &lt;class 'py_class.Student.Student'&gt; print('%s, %d, %s' % (self.name, self.age, self.__city)) def get_age(self): if self.age == 20: print('age is ', self.age) elif self.age &gt; 20: print('too old') else: print('too young') def get_city(self): return self.__city def set_city(self, city): self.__city = city 属性 1.类属性：像是Student类中的name就是类属性 2.实例属性：像是下文中的student.__city就是实例属性 类中变量及函数的命名规范 以__开始，并以__ 双下划线 结束的是python中的特殊变量，特殊变量是可以直接访问的，不是private变量 class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的.通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类 __init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去 在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。 self指向的类的实力对象。由： 12print('self is : ', self) # self is : &lt;py_class.Student.Student object at 0x10c92c400&gt;print(student) # &lt;py_class.Student.Student object at 0x10c92c400&gt; 可以看出，self和student的 内存地址 是一样的。代码示例 123456789'''调用'''# 创建实例对象student = Student('cwj',24, 'tianjin')student.print_info() # cwj, 24, tianjinstudent.get_age() # too old# 访问属性student.age = 19student.name = 'ddd' 访问限制虽然有访问限制的命名方式，但是Python本身没有任何机制阻止你干坏事，一切全靠自觉。 两个下划线开头的变量，声明为类内部的私有变量，不能在类的外部直接使用或访问：在变量前面添加__，即：__name。在类内部的方法中使用时 self.__private_attrs。 两个下划线开头的方法，声明为类内部的私有方法。不能在类地外部调用，在类的内部调用 self.__private_methods. 单下划线开头表示的protected类型的变量，只允许本身及其子类进行访问。 类的方法在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数代码示例: 123456789101112131415161718192021 # 此行代码貌似修改了 Student 类中的 __city 属性,实际这是为student添加了一个属性。 student.__city = 'beijing' # 而且输出结果也显示；__city 属性 的值也变成了：beijing print(student.__city) # beijing # 但是，当我们通过类自身的get()获取属性值时，发现还是之前初始化时的属性值。即：tianjin print(student.get_city()) # tianjin print(hasattr(student, 'name')) # True # 删除临时添加的 __city 属性 # del student.__city# print(student.__city) # AttributeError: 'Student' object has no attribute '__city' # 当我们通过类自身的set()方法修改 __city 属性值时，通过get()得到的属性值是修改之后的。 student.set_city('hk') print(student.get_city()) # hk # 由此可以得出：此时的 student.__city 与 student.set_city() 中的 __city 并不是同一个属性 # student.__city 中的 __city 是student的一个新的同名属性 student.print_info() # ddd, 19, hk Python内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串，即：注释 __name__: 类名 __module__: 类定义所在的模块（类的全名是__main__.className，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 代码示例 123456789101112131415# 由 类 进行调用 __dict__print(Student.__dict__) # &#123;'__module__': 'py_class.Student', '__init__': &lt;function Student.__init__ at 0x100ccf8c8&gt;, 'print_info': &lt;function Student.print_info at 0x100ccf950&gt;, 'get_age': &lt;function Student.get_age at 0x100ccf9d8&gt;, 'get_city': &lt;function Student.get_city at 0x100ccfa60&gt;, 'set_city': &lt;function Student.set_city at 0x100ccfae8&gt;, '__dict__': &lt;attribute '__dict__' of 'Student' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Student' objects&gt;, '__doc__': None&#125;# 由 对象 调用 __dict__ 方法类似于：java中的toString()print(student.__dict__) # &#123;'name': 'ddd', 'age': 19, '_Student__city': 'hk', '__city': 'beijing'&#125;print(student.__doc__) # None# 由 类 进行调用print(Student.__name__) # Studentprint(student.__module__) # py_class.Student# 由 类 进行调用print(Student.__bases__) # (&lt;class 'object'&gt;,) python对象的销毁垃圾回收 —— 引用计数 + 循环引用 引用计数法。当跟踪变量对象的引用计数变为0时，它将会被回收。但不是立即被回收，而是由‘解释器’在适当的时机将其回收。 循环引用。当两个对象相互引用，但是没有其他的变量引用他们。此时循环垃圾回收器将会工作。 代码示例 1del student.__city 继承支持多继承父类的构造器（__init__(self)）不会被自动调用，需要在子类中亲自专门调用python总是先在本类中查找调用的方法，找不到才会去父类中继续寻找 几个基础的重载方法 1.__init__(self,[]) 构造方法 2.__del__(self) 删除一个对象，dell obj 3.__repr__(self) 转化为供解释器读取的形式 4.__str__(self) 将值转化为始于人阅读的形式 5.__cmp__(self,x) 对象比较 代码示例 父类 123456789101112131415161718192021222324252627'''父类 1 ''' class Animal(object): def __init__(self, name, age): self.__name = name self.__age = age def get_name(self): return self.__name def get_age(self): return self.__age def set_name(self, name): self.__name = name def set_age(self, age): self.__age = age def run(self): print('Animal is running') '''父类 2''' class Pet(object): def play(self): print(self.__name + " is very good !") 子类 1234567891011121314151617181920212223242526272829303132333435363738from py_class.Animal import Animalfrom py_class.Pet import Pet# 多继承class Pig(Animal, Pet): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print('pig is running very slowly...')from py_class.Animal import Animal# 单继承class Dog(Animal): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print(self.__name + ' is running')from py_class.Animal import Animal# 单继承class Cat(Animal): def __init__(self, name, age): self.__name = name self.__age = age def run(self): print(self.__name + 'is running') 测试类 123456789101112131415161718from py_class.Animal import Animalfrom py_class.Dog import Dogfrom py_class.Cat import Catfrom py_class.PIg import Pigdog = Dog('wangwang', 1)dog.run()cat = Cat('miaomiao', 1)cat.run()pig = Pig('big pig', 100)pig.run() # pig is running very slowly...# pig.play() # big pig is very good !print(isinstance(cat, Animal)) # Trueprint(isinstance(cat, Cat)) # True'''由此可见，cat变量既是Cat类型，也是Animal类型''' 多态代码示例 1234567891011121314151617181920212223242526''' 多态的实现方式 1 类似于java这种静态语言的实现，必须传入Animal类型或其子类 # 多态的使用 将 父类 作为参数def run_test(animal): animal.run()'''''' 多态的实现方式 2 属于python的动态语言实现' 这种方式实现的结果与 方式 1 完全一样 原理： 不一定要传入Animal类型，只要保证传入的对象一个run()方法就可以了. 例如：传递的对象为ints，这不是Animal的任何一个子类，只要将赋予run()方法就足以。 动态语言的'鸭子类型'： 它并不要求严格的继承体系，一个对象只要"看起来像鸭子，走起路来像鸭子"，那么它就是鸭子。'''def run_test(ints): ints.run()# 多态的使用 实际参数为具体的子类，得到的结果为各个子类的具体表现run_test(Animal('Animal', 1)) # Animal is runningrun_test(Dog('Dog', 1)) # Dog is runningrun_test(Cat('Cat', 1)) # Catis runningrun_test(Pig('Cat', 1)) # pig is running very slowly... 获取对象信息 getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 12345678910111213141516171819202122232425262728'''isinstance() 查看一个变量的继承关系'''print(isinstance(cat, Animal)) # Trueprint(isinstance(cat, Cat)) # Trueprint(isinstance(pig, Animal)) # Trueprint(isinstance(pig, Pet)) # Trueprint(isinstance(pig, Pig)) # True''' type() 当使用继承关系时，使用type()不能一直向上得到他们的父类， 因此，对于有 继承关系 的类来说不合适'''print(type(123)) # &lt;class 'int'&gt;print(type(dog)) # &lt;class 'py_class.Dog.Dog'&gt;def compare(obj1, obj2): if type(obj1) == type(obj2): print(type(obj1) == type(obj2)) print(str(obj1) + '==' + str(obj2)) else: print(type(obj1) == type(obj2)) # False print(str(obj1) + '!=' + str(obj2))compare(dog, cat)'''获取一个对象所有的属性和方法'''print(dir(dog))# ['_Dog__age', '_Dog__name', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'get_age', 'get_name', 'run', 'set_age', 'set_name']]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 09-面向对象+临时变量、方法+@property+多继承]]></title>
    <url>%2FPython3%20%2009-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%2B%40property%2B%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 绑定临时变量和临时函数 – 不限定参数使用python语言`动态语言`这一特性。 绑定临时变量 为实例对象绑定临时变量 123456# 动态的将 new_name 属性绑定至 实例 中dog.new_name = 'new cwj'print(dog.new_name) # new cwj# 删除临时添加的 new_name 属性del dog.new_name 为类绑定临时变量 123456789# 动态的将 new_name_2 属性绑定至 Dog类 中Dog.new_name_2 = 'new cwj 2'print(dog.new_name_2) # new cwj 2dog2 = Dog('wangwang', 1)print(dog2.new_name_2) # new cwj 2'''可以看到 dog 与 dog2 两个实例都具有 new_name_2 属性，由此可见 new_name_2 属性已经动态的添加至Dog类中''' 绑定临时函数 为实例对象绑定临时函数 12345678910111213141516171819202122232425from types import MethodTypedef set_color(self, color): self.color = color# 给实例绑定一个方法dog.set_color = MethodType(set_color, dog)# 通过这个方法为临时的color赋值dog.set_color('red')# set_color()这个方法是临时赋给dog变量的，而不是赋给dog2的# dog2.set_color('green') # AttributeError: 'Dog' object has no attribute 'set_color'# 输出临时参数color的值print(dog.color) # red# 删除临时方法，删除此方法的同时，也删除了此方法内的历史变量del dog.set_color# 删除临时参数# del dog.color# 当删除临时方法后，此方法将不再能使用# dog.set_color('green') # AttributeError: 'Dog' object has no attribute 'set_color' 为类绑定临时函数 1234567891011121314151617# 定义一个临时的方法def set_color2(self, color): self.color = color# 将临时定义的方法绑定给 Dog这个类Dog.set_color2 = set_color2# Dog类的两个变量dog和dog2分别调用set_color2()dog.set_color2('blue')dog2.set_color2('black')# 测试临时函数是否对临时变量赋值成功print(dog2.color) # blackprint(dog.color) # blue# 删除临时的方法del Dog.set_color2 绑定临时变量和临时函数 – 限定参数 __slots__变量`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的. 除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__` 代码示例 12345678910111213141516171819202122'''声明Pet类'''class Pet(object): ''' 使用一个特殊的变量 __slots__，这个变量可以限制外部为Pet类添加的属性。 例如此处，只允许外部为Pet类添加 name 和 age 两个属性 ''' __slots__ = ('name2', 'age')'''调用Pet类'''pet = Pet()pet.name2 = 'big pig'pet.age = 2# 通过 __slots__ 变量的声明，color不允许被定义# pet.color = 'yellow' # AttributeError: 'Pet' object has no attribute 'color'# print(Pet.__doc__) # 输出注释print(pet.name2) # big pigprint(pet.age) # 2# pig 实例对象不能调用临时变量 name2，因为 __slots__变量定义的参数名称之能限定在它所在的类中，对子类不起作用# print(pig.name2) # AttributeError: name2 @property的使用既能检查参数，又可以`用类似属性`这样简单的方式来`访问类的变量` 实现 关键字：@property,@参数名.setter 代码示例 - Pet类 12345678910111213141516171819'''Pet类'''class Pet(object): def play(self): print(self.__name + " is very good !") '''@property的使用''' # 此处的 color 为 此类对外界声明的一个变量，即：是一个变量名 # 此方法相当于 get_color() @property def color(self): return self._color # 此方法相当于 set_color(self, color) @color.setter def color(self, color): if not isinstance(color, str): raise ValueError('input a str') self._color = color 代码示例 - 调用 123456# 错误的写法，验证对于参数的检验# pet.color = 123 # ValueError: input a strpet2 = Pet()# 为Pet类的color属性设置具体的参数pet2.color = 'grew'print(pet2.color) # grew 多继承在设计类的继承关系时，通常，主线都是单一继承下来的，如果需要“混入”额外的功能，通过多重继承就可以实现，一个类在继承了一个类的基础上，再次继承另一个类。这种设计通常称之为`MixIn`。 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 如： 12class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 08-模块]]></title>
    <url>%2FPython3%20%2008-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python Python所有的内置函数：https://docs.python.org/3/library/functions.html 定义在`python`中一个`.py`文件就是一个模块(Module) 优点 提高代码的可维护性 代码的复用性 避免函数名和变量名的冲突 为避免模块名命名冲突，引入了包(每一个包目录下都有一个文件：__init__.py。这个文件是必须存在的，否则python回将这个目录当成普通的目录，而不是一个python包。这个文件可以是空文件，也可以有代码。因为__init__.py本身就是一个模块(mycompany)) 模板1234567891011121314151617#!/usr/bin/env python3# _*_ coding:utf-8 _*_# 当前模块的文档注释，任何模块代码的第一行字符串都视为该模块文档的注释'A test module'# 使用'__author__'变量将作者的名字写入此模块__author__ = 'Yannis Cheng''''以上为python模块的标准文件模板''''''注意到这两行代码：'''if __name__=='__main__': test()'''当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。''' 安装第三方模块在Python中，安装第三方模块，是通过包管理工具`pip`完成的。 在Mac或者Linux下可能会并存`Python 3.X`和`Python 2.X`，此时的命令应该为`pip3` 函数&amp;变量 作用域 公开public：可以被直接引用，如’abs‘等。类似__name__这样的变量是特殊变量可以被直接引用。自己定义的变量一般不使用这种变量名。 非公开：_abc，__aabc python中并没有一种方法可以完全限制访问private函数访问，但是从编程习惯中不应该引用private函数或变量]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 06-闭包+匿名+装饰器+偏函数]]></title>
    <url>%2FPython3%20%2006-%E9%97%AD%E5%8C%85%2B%E5%8C%BF%E5%90%8D%2B%E8%A3%85%E9%A5%B0%E5%99%A8%2B%E5%81%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 参考：http://www.cnblogs.com/vamei/archive/2012/12/15/2772451.html 闭包闭包是函数式编程的重要语法结构，python是以`函数对象`为基础的，python一切皆对象。函数这一语法结构也是一个对象。 定义解释 在一个内部函数里，对在外部作用域的（非全局）变量进行引用，那么内部函数就认为是闭包closure ‘闭包’是‘词法闭包’的简称，是指应用了自由变量的函数。这个被引用的自由变量的将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 ‘闭包’是由函数和其他相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 ‘python’中的闭包：一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。而这个函数B就叫做闭包，在调用函数A时传递的参数就是自由变量。 闭包实际上就是一个简化的类，它提高了代码的复用性 闭包函数代码示例 123456789101112'''闭包示例代码inner_func就是一个闭包函数，它引用自由变量name。name就是inner_func()的环境变量'''def func01(name): def inner_func(age): print('name: ', name, 'age: ', age) return inner_funcbb = func01('cwj')bb(25) # name: cwj age: 25 关于闭包函数的使用问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152'''错误的闭包函数 1 闭包函数中， 闭包中的变量m不会修改外部函数中m的值。'''def foo(): m = 0 def fool(): m = 11 print(m) print(m) # 0 fool() # 11 print(m) # 0print(foo())'''错误的闭包函数 2 '''def foo2(): a = 1 def fool2(): # a = a +1 # UnboundLocalError: local variable 'a' referenced before assignment return a # 1 return fool2ccc = foo2() # 此时：ccc = fool2，ccc只是获得到了一个对象print(ccc()) # 此时：ccc = fool2(), ccc获取到的是一个实例flist = []for i in range(3): # 编写 1 # def foo3(x): def foo3(x, y = i): # 编写 1 的输出 # print(x + i) print(x + y) flist.append(foo3)for f in flist: f(2)'''编写 1 的运行结果为：444结果是4,4,4。这是因为当把函数加入flist列表里时，python还没有给i赋值，只有当执行时，再去找i的值是什么，这时在第一个for循环结束以后，i的值是2，所以以上代码的执行结果是4,4,4.编写 2 的运行结果为：234在程序里面经常会出现这类的循环语句，Python的问题就在于，当循环结束以后，循环体中的临时变量i不会销毁，而是继续存在于执行环境中。还有一个python的现象是，python的函数只有在执行时，才会去找函数体里的变量的值''' 闭包的作用 参考：http://www.jb51.net/article/54498.htm 闭包主要在函数开发中使用 当闭包函数执行完毕后，仍然能够保持住当前的运行环境 闭包可以根据外部作用域的局部变量来得到不同的结果 引用：闭包与并行运算 闭包有效的减少了函数所需定义的参数数目。这对于并行运算来说有重要的意义。在并行运算的环境下，我们可以让每台电脑负责一个函数，然后将一台电脑的输出和下一台电脑的输入串联起来。最终，我们像流水线一样工作，从串联的电脑集群一端输入数据，从另一端输出数据。这样的情境最适合只有一个参数输入的函数。闭包就可以实现这一目的。 并行运算正称为一个热点。这也是函数式编程又热起来的一个重要原因。函数式编程早在1950年代就已经存在，但应用并不广泛。然而，我们上面描述的流水线式的工作并行集群过程，正适合函数式编程。由于函数式编程这一天然优势，越来越多的语言也开始加入对函数式编程范式的支持。 匿名函数定义 匿名函数由关键字lambda表示。:前面的参数名表示函数的参数，:后面的表达式表示为函数执行具体操作的表达式。 ####特点 python对匿名函数的支持有限，只能在一些简单的情况下使用匿名函数 匿名函数有个数限制，只能有一个表达式，不用写return，返回值就是该表达式的结果。 代码示例 1234'''匿名函数的使用 - 1'''print(list(map(lambda x: x*x, [1, 2, 3, 4]))) # [1, 4, 9, 16]'''匿名函数的使用 - 2''' 装饰器定义在代码运行期间动态增加功能的方式，称之为“装饰器(decorator)” 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192'''原函数def now(): print('2017-07-16')now() # 2017-07-16''''''定义一个 now() 的 装饰器函数 log()'''def log(func_origin): def add_func(*args, **kwargs): print('call %s()' % func_origin.__name__) # 因为log()是一个decorator，所以接受一个函数作为参数，并返回一个函数。 # 返回原函数所具有的功能 return func_origin(*args, **kwargs) return add_func'''使用 装饰器函数 log()'''@log# @log 等价于 now = log(now)def now(): print('2017-07-16')'''调用被装饰器装饰的函数now()'''now()'''运行结果：call now()2017-07-16释义：由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。''''''需要传入参数的decorator, 即：3层嵌套'''def log2(text): def decorator(func): def wrap(*args, **kwargs): print('%s %s()' % (text, func.__name__)) # return func(*args, **kwargs) return func() # 输出结果中有：2017-07-16 # return func # 输出结果中没有：2017-07-16 return wrap return decorator'''3层嵌套的使用'''#@log2('execute')# @log2 等价于 now2 = log2('execute')(now2)def now2(): print('2017-07-16')now2 = log2('execute')(now2)now2()'''运行结果：def now():print('2017-07-16')''''''函数也是对象，它有__name__等属性，但经过decorator装饰之后的函数，它们的__name__已经从原来的'now2'变成了wrap'''print(now2.__name__) # wrapdef log3(text): def decorator3(func3): @functools.wraps(func3) # 词条语句等价于 # wrap3.__name__ = func3.__name__ # 需要把原始函数的__name__等属性复制到wrap3()函数中，否则，有些依赖函数签名的代码执行就会出错。 def wrap3(*args, **kwargs): print('%s %s()' % (text, func3.__name__)) # return func3() func3() return wrap3 return decorator3@log3('execute')def now3(): print('2017-07-16')now3()print('now3 name is : ', now3.__name__)'''运行结果execute now3()2017-07-16now3 name is : now3''' 偏函数定义当函数的参数个数太多，需要简化时，使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 代码示例 12345int2 = functools.partial(int, base=2)#等价于def int2(x, base=2): return int(x, base) functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 05-函数式编程-函数作为返回值]]></title>
    <url>%2FPython3%20%2005-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445'''求和运算'''def add_sum(*args): add = 0 for n in args: add = add + n return addprint(add_sum(1, 2, 3, 4, 5)) # 15'''将函数 -实例- 作为返回值'''def add_sum_func(*args): def my_sum(): add = 0 for n in args: add = add + n return add return my_sum()'''将函数 -对象- 作为返回值'''def add_sum_func_02(*args): def my_sum(): add = 0 for n in args: add = add + n return add return my_sum# 调用 add_sum_func()时，返回的不是函数求和的结果，而是求和函数本身，就是延迟了函数结果的实现print(add_sum_func(1, 2, 3, 4, 5)) # 15new_f = add_sum_func(1, 2, 3, 4, 5)print(new_f) # 15# print(new_f()) # TypeError: 'int' object is not callableprint(add_sum_func_02(1, 2, 3, 4, 5)) # &lt;function add_sum_func_02.&lt;locals&gt;.my_sum at 0x1021ef8c8&gt;new_f = add_sum_func_02(1, 2, 3, 4, 5)print(new_f) # &lt;function add_sum_func_02.&lt;locals&gt;.my_sum at 0x1021ef8c8&gt;print(new_f()) # 15'''释义'''''' 函数add_sum_func()与add_sum_func_02()的区别除了函数名字上有区别，在其函数内部只有一点不同，即返回值： 一个是：return my_sum()。带()表示返回的是 函数的数值，即：结果值。 另一个是：return my_sum。不带()表示返回的是 函数本身，即：函数所在内存的地址。 通过查看输出的结果可以清晰的对比出两者的不同。''']]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 04-迭代器]]></title>
    <url>%2FPython3%20%2004-%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 能够使用for循环的数据类型有以下几种： 集合：list、tuple、set、dict 构建类型generator，带yield的generator function 字符串类型：str 复习：可以使用isinstance()判断一个对象是否是Iterable对象。需要导包：from collections import Iterable 1isinstance)(x, Iterable) 迭代器可以被`next()`函数调用并不断返回下一个值的对象称为——迭代器（`Iterator`） 判断一个对象是否为迭代器 1isinstance(x, Iterator) 代码示例 123456789101112131415'''判断是否 可迭代'''print(isinstance((x for x in range(1, 10)), Iterator)) # 构建类型 Trueprint(isinstance([1, 2], Iterable)) # list类型 Trueprint(isinstance((1, 2), Iterable)) # tuple类型 Trueprint(isinstance(&#123;1, 2&#125;, Iterable)) # set类型 Trueprint(isinstance(&#123;'1': 'A', '2': 'B'&#125;, Iterable)) # dict类型 Trueprint(isinstance('ABC', Iterable)) # str类型 rue'''判断是否为 迭代器 对象'''print(isinstance((x for x in range(1, 10)), Iterator)) # 构建类型 Trueprint(isinstance([1, 2], Iterator)) # list类型 Falseprint(isinstance((1, 2), Iterator)) # tuple类型 Falseprint(isinstance(&#123;1, 2&#125;, Iterator)) # set类型 Falseprint(isinstance(&#123;'1': 'A', '2': 'B'&#125;, Iterator)) # dict类型 Falseprint(isinstance('ABC', Iterator)) # str类型 False]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 05-函数式编程-高阶函数]]></title>
    <url>%2FPython3%20%2005-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ `Python`对函数式编程提供部分支持。由于`Python`允许使用变量，因此，`Python`不是纯函数式编程语言。 函数与变量互指代码示例 12345x = abs # 函数名其实也是一个变量，变量之间是可以互指。print(x(-10)) # 10。此时，x就是一个求'绝对值'的函数abs = 10print(abs) # 10print(abs(10)) # TypeError: 'int' object is not callable。此时的abs已经不是一个函数，而是一个值为10的变量。 高阶函数将函数作为参数传入另一个函数，这样的函数被称为高阶函数。 代码示例 12345def high_func(z, y, f): return f(z) + f(y)# 将函数abs作为一个参数指向变量fprint(high_func(-1, -3, abs)) # 4 高阶函数 - map() map接收两个参数：一个是函数，另一个是Iterable， map函数的意义是：将传入的函数依次作用于每一个序列的每一个元素，并将结果作为新的Iterator返回 1234567891011121314151617181920212223242526272829303132333435363738def func(x): return x * x'''通过一行代码实现：序列中的每一个元素进行取平方运算，将结果作为list序列输出'''print(list(map(func, [1, 2, 3, 4, 5]))) # [1, 4, 9, 16, 25]v = map(func, [1, 2, 3, 4, 5])print(isinstance(v, Iterator)) # Trueprint(isinstance(v, Iterable)) # Trueprint(isinstance('abc', Iterator)) # False'''使用 next() 输出Iterator类型的对象 修改前'''# while True:# print(next(v))'''1StopIteration491625''''''修改后'''while True: try: print(next(v)) except StopIteration: break'''1491625''' 高阶函数 - reduce() 参数：两个参数。函数名，序列 作用：将结果继续和序列的下一元素做函数名指定的运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ls = [1, 2, 3, 4, 5]def fun_add(x, y): return x + yprint(reduce(fun_add, ls)) # 15.# 将序列 ls 中的数变成组合成一个整数def func_int(x, y): return x * 10 + yprint(reduce(func_int, ls)) # 12345def func_str(s): # 将字符串转换为int类型。根据`键`取对应的`值` return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s]# 将str类型变为int类型print(reduce(func_int, list(map(func_str, '1234567')))) # 1234567# 将以上方法编写为一个str类型转int的方法def func_str_to_int(s): def f_int(x, y): return x * 10 + y def f_str(ss): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[ss] return reduce(f_int, map(f_str, s))print(func_str_to_int('11223344')) # 11223344'''测试，将不规则的输入按照指定的要求输出。如：'AsdA' 'asdS' 输出后的结果为：'Asda', 'Asds' '''def func_rule(s): # if isinstance(s, str): if isinstance(s, list): def func_to_up(ss): return ss[0].upper() + ss[1::].lower() return list(map(func_to_up, s)) else: print('输入的参数类型有误！') return '-1'L1 = ['adam', 'LISA', 'barT']print(func_rule(L1)) # ['Adam', 'Lisa', 'Bart']'''求乘积'''ll = [3, 5, 7, 9]def prod(lll): def xx(x, y): return x * y return reduce(xx, lll)print(prod(ll)) # 945 高阶函数 - filter() 作用：过滤函数. True保留序列中的元素，False删除序列中的元素 1234567lf = [1, 2, 3, 4, 5]# 过滤一个序列中的偶数def func_odd(n): return n % 2 == 1print(list(filter(func_odd, lf))) # [1, 3, 5] 高阶函数 - sorted() 排序算法 1234567891011121314151617181920212223# 对list类型的数据排序ls01 = [1, -9, 10, 5, 23, -3]print(sorted(ls01)) # [-9, -3, 1, 5, 10, 23]# 高阶函数使用 按照绝对值进行排序print(sorted(ls01, key = abs)) # [1, -3, 5, -9, 10, 23]ls02 = ['asd', 'ffgd', 'fhfgh', 'werr', 'bnbm']# 高阶函数使用 对 字符串 进行排序 根据小写字母排序print(sorted(ls02, key=str.lower)) # ['asd', 'bnbm', 'ffgd', 'fhfgh', 'werr']# 高阶函数使用 对 字符串 进行排序 根据大写字母排序--实现方式1print(sorted(ls02, key=str.lower, reverse=True)) # ['werr', 'fhfgh', 'ffgd', 'bnbm', 'asd']L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]'''根据学生的名字排序'''print(sorted(L)) # [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]'''根据学生的成绩排序'''print(sorted(L, key=itemgetter(1))) # [('Bart', 66), ('Bob', 75), ('Lisa', 88), ('Adam', 92)] itemgetter()的使用 参考：http://www.cnblogs.com/zhoufankui/p/6274172.html operator.itemgetter函数用于获取对象指定的下标数据。如根据学生成绩排序的方法使用中：获取序列中tuple元素下标为1的数据 operator.itemgetter函数获取的不是数值，而是重新定义了一个函数，通过将该函数作用于对象上才能获取数据，如：将数值赋值给key 特点：itmegetter()中的参数可以不按照数字大小的顺序来填入，可以使用2，1这样的顺序，表示 先获取 下标为2的数据值，再获取下标为1的数据的值。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-生成器+切片]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E7%94%9F%E6%88%90%E5%99%A8%2B%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 高级特性——(slice)切片，表示为[::] 切片语法：[1:4:2] 数字’1’ 表示开始的索引位置 数字’4’ 表示结束的索引位置 数字’2’ 表示间隔的索引数 补充于：2017年07月18日16:29:53 Python序列切片操作：http://developer.51cto.com/art/201304/389771.htm 切片的方向与位置 对于序列结构数据来说，索引和步长都具有正负两个值任意一个序列结构数据的索引范围为: -len(consequence) 到 len(consequence)-1 范围内的连续整数。step 步长：默认为1，步长值不能为0。切片过程:从第1个想要的对象开始，到第1个不想要的对象结束 说明 正索引默认位置 负索引默认位置 序列方向说明 左 –&gt; 右 左 &lt;– 右 序列第一个元素位置 0 -len(consequence) 序列末元素位置 len(consequence)－1 -1 切片方向代码示例 12345678s3 = [1,2,3,4,5]print(s3[1:4:1]) # [2, 3, 4]print(s3[-4:-2]) # [2, 3]print(s3[-3:-1]) # [3, 4]print(s3[-5:]) # [1, 2, 3, 4, 5]print(s3[:]) # [1, 2, 3, 4, 5]print(s3[-1::-1]) # [5, 4, 3, 2, 1]print(s3[-1:]) # [5] range语法range(start, stop, step) 参考：http://www.nowamagic.net/academy/detail/1302446 根据start和stop确定范围，根据step设定步长 range与xrange 两者都能用于for循环中range 与 xrange 用法上完全相同，不同点是，产生的结果类型不同 range 产生的结果是 list xrange 产生的结果是 生成器 代码示例 123456789101112'''这两个输出的结果都是一样的，实际上有很多不同，''''''range会直接生成一个list对象'''&gt;&gt;&gt; range(5)[0, 1, 2, 3, 4]'''而xrange则不会直接生成一个list，而是每次调用返回其中的一个值'''&gt;&gt;&gt; xrange(5)xrange(5)&gt;&gt;&gt; list(xrange(5))[0, 1, 2, 3, 4]'''要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。''' 函数range的使用12345678910111213141516'''表示从1开始，到10之前（不包括10'''l = range(1, 10)'''从0开始（0可以省略），生成10个数'''ll = range(10)'''从0开始，生成10个数，公差为2（相邻的数之间间隔为2）'''lll = range(0, 10, 2)'''根据range的规则，生成指定的序列'''print(l) # range(1, 10)print(ll) # range(0, 10)print(list(l)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]print(list(ll)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]print(list(lll)) # [0, 2, 4, 6, 8]'''从缩影0开始，去之后索引+2对应的具体数值'''print(list(lll)[::2]) # [0, 4, 8] 使用range进行求和 123456sum = 0numbers = range(1, 10)for i in numbers: sum += iprint(sum)'''45''' 对list使用切片1234567891011l = ['cwj', 'serr', 'bob', 'jack']'''取3个元素 使用方法 切片（slice）,是指：取出一个范围内的元素''''''从索引0开始，直到3为止，但是不包括索引3，实际的取得索引为0，1，2 如果索引是从0开始的，0可以省略'''print(l[0:3]) # ['cwj', 'serr', 'bob']print(l[:3]) # ['cwj', 'serr', 'bob']'''倒着取出元素'''print(l[-3:]) # ['serr', 'bob', 'jack']print(l[0:-3]) # ['cwj'] 对str使用切片1234s = 'cwj, cwj, cwj, cwj'sp = s[::]print(sp) # cwj, cwj, cwj, cwjprint(sp[0:4:2]) # cj 对dict使用切片 – dict不适用与切片123print("对dict使用切片")d = &#123;'cwj': 150, 'zh': 145, 'ww': 234, 'cwj': 200&#125;# print(d[1:3]) # TypeError: unhashable type: 'slice' 对tuple使用切片1234567891011121314print(range(8)) # range(0, 8)ll5 = range(8) # range(0, 8)print(ll5)t = tuple(ll5)print(t) # (0, 1, 2, 3, 4, 5, 6, 7)lls = t[::]print('将 t序列 复制后的结果为：')print(lls)'''将 t序列 复制后的结果为：(0, 1, 2, 3, 4, 5, 6, 7)注意： tuple执行切片以后仍是一个tuple''' 对set使用切片1234s = set(lls)print(s) # &#123;0, 1, 2, 3, 4, 5, 6, 7&#125; 是set类型的数据spl = t[::]print(spl) # (0, 1, 2, 3, 4, 5, 6, 7) 使用range后是tuple类型的数据 迭代器 for 的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768s = 'ABC'for c in s: print(c)'''使用下标循环'''l = [1, 2, 3, 4]for i, value in enumerate(l): print(i, value)'''0 11 22 33 4'''for i, ch in enumerate(s): print(i, ch)'''0 A1 B2 C'''d = &#123;'A': 123, 'B': 456&#125;print(d) # &#123;'A': 123, 'B': 456&#125;for i, dict0 in enumerate(d): print(i, d.items())'''0 A1 B'''ls = [(1, 1), (2, 2), (3, 3)]for x, y in ls: print(x, y)'''1 12 23 3''''''列表生成器'''for x in range(1, 10): print(x * x)'''149162536496481''''''生成的序列后，进行计算'''print([x * x for x in range(1, 9)]) # [1, 4, 9, 16, 25, 36, 49, 64]'''生成序列后，新进行取余数预算，然后进行相乘运算'''print([x*x for x in range(1, 10) if x % 2 == 0]) # [4, 16, 36, 64]'''遍历两个字符串进行 排列组合'''print([m + n for m in 'ABC' for n in '123']) # ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']'''将dict类型的数据转换为 序列'''d = &#123;'A': 1, 'B': 2, 'C': 3&#125;print([k + ' = ' + str(v) for k, v in d.items()]) # 'A = 1', 'B = 2', 'C = 3'] yield关键字 定义generator函数的另一中方式： 当一个函数中含有关键字 yield时，这个函数就不在是一个普通的函数，而是一个generator函数 带有yield关键字的generator函数，执行流程与普通函数不同： - 普通函数：执行到return或者函数的最后一句时，退出函数。 - 带有yield关键字的generator函数，调用next()函数时执行操作，遇到yield()函数时，退出返回。当 再次执行此函数时从上次返回yield语句处继续执行 运行含有yield关键字的函数 123456789101112131415161718192021222324252627282930313233343536def p_yield(): print('step_01') yield 1 print('step_02') yield 2 print('step_03') yield 3# 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：o = p_yield()next(o) # step_01next(o) # step_02next(o) # step_03# next(o) # StopIterationdef fib(max): n, a, b = 0, 0, 1 #l = [] while n &lt; max: '''方法1 返回值：1 \n 2 \n 3 \n 4 \n 5''' # print(b) ''' 方法2 返回值：[1, 1, 2, 3, 5] 函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List来保存中间结果，而是通过 iterable 对象来迭代。 ''' #l.append(b) '''方法3 返回值：1 \n 1 \n 2 \n 3 \n 5. 使用yield关键字，使得生成的值为一个generator对象,而不是使用list占用大量的内存''' yield b a, b = b, a + b n = n + 1 #return l# print(fib(5)) yield关键字的使用 参考：https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/ yield关键字 使得一个普通的函数变成一个generator函数。Python解释器会将其视为一个generator，当for循环fib（5）函数的返回值时，实际调用的是iterable对象。 一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用， 但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。 虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值， 不仅代码简洁，而且执行流程异常清晰 12for n in fib(5): print(n) 区分：fib与fib(5) fib：是一个generator function 好比于：类的定义 fib(5)：是调用 fib 后返回的一个generator对象 好比于：类的实例化]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-返回值]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 在python交互环境中，使用本地文件自己定义的函数进入到文件所在的目录下后，将HelloWorld文件中的my_abs方法导入到交互环境中： from HelloWorld import my_abs Hello World 输出的是中文my_abs(-12)12 为系统函数建立别名12a = absprint(a(-90)) #90 空函数 - passpass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码 能运行起来。这样的函数适用于在上下文中，保持 整体逻辑思路 的通畅。 代码示例 12def nop(): pass 除了在函数体内使用之外，在其他语句中也可以使用：代码示例 12if age &gt;= 18: pass 函数参数检查 - isinstance()当我们自定义的函数传入了不恰当的参数时，python的函数能够检测出错误的参数，而我们自定义的函数则不能。当报错时，提示的错误信息和系统内置的函数提示的错误信息也不一样。我们应该完善我们自己定义的函数，使用isinstance()方法 代码示例 1234567891011def my_abs_good(x): # if not isinstance(x,(int, float)): raise TypeError('输入的参数类型异常') if x &gt; 0: return x else: return -xprint(my_abs_good(-2)) #2print(my_abs_good('a')) #TypeError: 输入的参数类型异常 判断一个数据类型是否为可迭代对象代码示例 123s = 'ABC'print(isinstance(s, Iterable)) # Trueprint(isinstance(123, Iterable)) # False 自定义函数的返回值 多个返回值 的本质是一个：tuple对象。只有一个返回值时，默认不显示() 多返回值 代码示例 123456789101112131415161718192021222324252627282930313233def getXY(x, y, step, angle = 0): nx = x + step * math.cos(angle) ny = y - step * math.cos(angle) #返回两个值 return nx, ny# 1x, y = getXY(10,20,100)print(x, y) #110.0 -80.0# 2x, y = (110.0, -80.0)print(x, y) #110.0 -80.0# 3z = getXY(10,20,100)print(z) #(110.0, -80.0)# 4z2 = (10)print(z2) #10'''比较 #1，#2，#3, #4 可以得出，函数的返回值其实是一个tuple对象,当返回值只有1个时，回省略掉()'''print(getXY(10,20,100)) #(110.0, -80.0)x, y, z = (10, 20, 100)print(x, y, z) #10 20 100print(x) #10'''在声明多个变量的同时，也将tuple对象的值对应的赋值给变量，很神奇！''' 没有返回值 return None 代码示例 12def noRetuen(): print('aaaa') 返回值小结 定义函数时，需要确定 函数名 和 参数个数； 如果有必要，可以先对参数的 数据类型 做检查； 函数体内部可以用 return 随时返回函数结果； 函数执行完毕也 没有return语句 时，自动 return None。 函数可以同时返回 多个值，但其实就是一个 tuple。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-数据-序列]]></title>
    <url>%2FPython3%20%2002-%E6%95%B0%E6%8D%AE-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 通过print()结果来区分各种序列类型 []是list ()是tuple {}是set {key:value, ...}是dict 说明：在序列声明时： list使用[] tuple与set使用()。其中声明set值时用到set关键字，以区分tuple dict使用{} set使用set() 关于集合–list和tuple list是python内置的、是有序的、可随时添加、删除其中元素的数据类型。通过[]来包裹内容 tuple是有序、”指向不可变“的另一种集合，称为”元组“。通过()来包裹内容 list使用print()后打印的结果为：`[]`` set使用print()后打印的结果为：{} 序列相加相同数据类型序列之间可以相加，不同数据类型序列不能相加 1.list 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051nameList = ['张三', '李四', '王五']print(nameList) #['张三', '李四', '王五']#增 方式-1：追加,只能添加到集合的末尾nameList.append('赵六')print(nameList) #['张三', '李四', '王五', '赵六']#增 方式-2：插入。参数1，添加的位置；参数2，插入的内容nameList.insert(1,'钱七')print(nameList) #['张三', '钱七', '李四', '王五', '赵六']#删nameList.pop(1)print(nameList) #['张三', '李四', '王五', '赵六']#删，无参数情况下默认删除最后一个元素nameList.pop()print(nameList) #['张三', '李四', '王五']#改 根据指定的下标，替换元素nameList[0] = '孙八'print(nameList) #['孙八', '李四', '王五']#查 输出集合的长度print(len(nameList)) #3#查 输出指定位置的元素 方式-1：从前向后，正序print(nameList[1]) #李四#查 输出指定位置的元素 方式-2：从后向前，倒序print(nameList[-1]) #王五#查 循环遍历，方式-1 forfor nameSingle in nameList: print(nameSingle)'''孙八李四王五'''#查 循环遍历，方式-2 whilecount = len(nameList)while count &gt; 0: print(nameList[(-count)]) count = count-1'''孙八李四王五''' 2.tuple 代码示例 123456789101112131415161718tupleValue = (1,2)#空的tupletupleValue01 = ()#只有1个元素的tuple定义时必须加一个逗号·,·，来消除歧义。若不加，则定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号。tupleValue02 = (1,)#一个“可变的”tuple：变的不是tuple的元素，而是其中的list的元素#tuple一开始指向的list并没有改成别的list，所以所谓的“不变”是说，tuple的每个元素，指向永远不变。# 即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！t = ('a', 'b', ['A', 'B'])print(t[2][0])print(t[2][1])'''AB''' 关于dict和set dict dict在其他语言中称为map，其存储的值是 无序 的，使用的键-值对（key-value）存储,用{}来包裹内容。 dict使用print()后打印的结果为：{‘mac’: 999999, ‘hp’: 777777, ‘ASUS’: 46567} dict默认是去重复的 注意: dict的key必须是不可变对象。 特点：和list相比 1.查询速度快 2.内存占用量大 dict代码示例 1234567891011121314151617181920d = &#123;'mac':999999, 'hp':777777, 'ASUS':46567&#125;#查print(d['mac']) #999999#改d['mac'] = 90000print(d['mac']) #90000#判断dict中是否存在当前的键 方法-1print('mac' in d) #Trueprint('lenvol' in d) #False#判断dict中是否存在当前的键 方法-2print(d.get('mac')) #90000print(d.get('lenvol')) #None#删d.pop('mac')print(d) #&#123;'hp': 777777, 'ASUS': 46567&#125; set set是 list的精简版，去掉其重复的元素，而且只存储key值，不存储value值。即set内部是无重复元素的。 set 不能放入 可变对象.因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素” set使用print()后显示的结果是：{} set中到的参数只能放一个。 注意: dict的key必须是不可变对象。 特点：和list相比 1.查询速度快 2.内存占用量大 set代码示例 12345678910111213141516171819202122l = [1,5,1,1,2,2,3,3,4,5]print(l) #[1, 5, 1, 1, 2, 2, 3, 3, 4, 5]print(len(l)) #10s = set(l)print(s) #&#123;1, 2, 3, 4, 5&#125;print(len(s)) #5s.add(7)print(s) #&#123;1, 2, 3, 4, 5, 7&#125;print(len(s)) #6s.remove(7)print(s) #&#123;1, 2, 3, 4, 5&#125;print(len(s)) #5s2 = set([4,5,6,7,8,9])#交集print((s &amp; s2)) #&#123;4, 5&#125;#并集print((s | s2)) #&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; 解释“不可变对象”代码示例 12345678910111213141516171819a = 'abc'print(a)print(a.replace('a','A'))print(a)'''abcAbcabc'''b = a.replace('a','A')print(b)print(a)print(b)'''AbcabcAbc''' 由上面的代码可以看出：在调用了变量a的replace()之后，立即输出变量a的值，此时变量a的值是修改后的，但是在次输出a的值时，还是原来的内容，即：变量a的内容最终并没有被修改。 那为什么立即输出a修改后的内容时是变化的呢？ 当我们把修改后a的值赋给变量b时，不管输出多少次b变量的值，其内容一直是不变的。也就是说：变量b存储的是一个新的内容，即一个新的str类型的对象。而这个新的str类型的对象是在变量a所指的对象的基础上修改之后的新对象。 结论就是：不可变对象修改后得到的对象是一个新的对象，而原有的对象保持不变 条件判断elif是else if的缩写，完全可以有多个elif 代码示例 1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环 1.for A in AList. 将‘AList集合’中的每一个元素赋值到‘变量A’中2.while n。只要条件’n‘满足，就将‘AList集合’中的每一个元素取出并赋值到变量中 for ... in ... while 遍历主要是使用: for in代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 ls = [1, 2, 3, 4, 5, 6, 7, 8, 9] sum02 = 0 for item in ls: print(item) sum02 = sum02 + item print(sum02) ''' 1 2 3 4 5 6 7 8 9 45 ''' d = &#123;'cwj': 150, 'zh': 145, 'ww': 234, 'cwj': 200&#125; print(d) # &#123;'cwj': 150, 'zh': 145, 'ww': 234&#125; print(len(d)) # 3 print(d.keys()) # dict_keys(['cwj', 'zh', 'ww']) dlk = list(d.keys()) print(dlk) # ['cwj', 'zh', 'ww'] dlks = set(dlk) print(dlks) # &#123;'zh', 'ww', 'cwj'&#125; dtk = tuple(d.keys()) print(dtk) # ('cwj', 'zh', 'ww') '''遍历方式 1''' for (key, value) in d.items(): print(key, value) ''' cwj 200 zh 145 ww 234 ''' '''遍历方式 2''' for key in d: print('dict[%s]\'s value is : ' % key, d[key]) ''' dict[cwj]'s value is : 200 dict[zh]'s value is : 145 dict[ww]'s value is : 234 ''' '''遍历方式 3 ，遍历到指定的key时，修改其元素''' for key in d.keys(): print(key) print(d[key]) if key == 'cwj': d[key] = 500 print('ok cwj,your grade has changed!') print(d) ''' cwj 200 ok cwj,your grade has changed! zh 145 ww 234 &#123;'cwj': 500, 'zh': 145, 'ww': 234&#125;''' 几个内置函数代码示例 1234567891011121314151617ll = [1, 2, 3, 4]ll2 = [5, 6, 7, 8]ll3 = [1, 2, 3, 4, 5, 6, 7, 8]ll4 = [2, 7, 4, 5, 0, 1, 9, 1]print(ll * 2) # [1, 2, 3, 4, 1, 2, 3, 4]print(ll + ll2) # [1, 2, 3, 4, 5, 6, 7, 8]# 不能相减# print(ll3 - ll2)# 成员资格# 检测 1 是否在 ll2序列 中， 使用 in 关键字返回值# 为：True or Falseprint(1 in ll2) # False# 获得序列中的最大值print(max(ll3)) # 8print(min(ll4)) # 0]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 02-函数-参数类型]]></title>
    <url>%2FPython3%20%2002-%E5%87%BD%E6%95%B0-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python 默认参数必须指向 不可变对象。 因为不变对象一旦创建，对象内部的数据就 不能修改，这样就减少了由于修改数据导致的错误。 此外，由于对象不变，多任务环境下同时读取对象 不需要加锁，同时读一点问题都没有。 函数参数的5种类型 1.必选参数2.默认参数3.可变参数4.关键字参数5.命名关键字参数组合参数注意： 函数参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 必选参数代码示例 1234def fun(num): print(num*num)fun(10) #100 默认参数代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041##默认参数示例 1: tag = 2,为默认参数def fun2(num, tag = 2): s = 1 while tag &gt; 0: tag = tag - 1 s = s * num return sprint(fun2(5)) #25print(fun2(5,3)) #125#默认参数示例 2def fun3(name, age = 6, city = 'beijing'): print("name is %s" % name) print("age is %d" % age) print("city is %s" % city)fun3('cwj')'''name is cwjage is 6city is beijing '''#默认参数在赋值时要注明： 参数名称fun3('cwj', age = 9)'''name is cwjage is 9city is beijing'''fun3('cwj', city='tinajin')'''name is cwjage is 6city is tinajin''' 可变参数可变参数（个数可变），其本质是 `tuple`集合，由函数返回的结果可以看出 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个`tuple` 代码示例 12345678910111213141516171819202122def fun4(*numbers): sum = 0 for num in numbers: sum = sum + num * num print(sum)fun4(2,3,4) #29'''*l表示把l这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见'''l = [2,3,4]fun4(*l) #29'''*t表示把t这个tuple的所有元素作为可变参数传进去。这种写法相当有用，而且很常见'''t = (2,3,4)fun4(*t) #29e#可变参数个数为0fun4() #0 关键字参数关键字参数本质 dict（实际参数为 键值对 即可） 而关键字参数允许你传入0个或任意个含 参数名的参数 ，这些关键字参数在函数 内部 自动组装为一个 dict。 12345678910111213141516171819202122232425262728293031323334353637383940414243def fun5(name, age, **keyWord): print('fun5-----') print("name is : ", name) print("age is : %d" % age) print("address is : ", keyWord)#传入1个关键字参数fun5('cwj', 24, address='tianjin')'''name is : cwjage is : 24address is : &#123;'address': 'tianjin'&#125;'''#传入多个关键字参数fun5('cwj', 24, address='beijing', weather='hot')'''name is : cwjage is : 24address is : &#123;'address': 'beijing', 'weather': 'hot'&#125;'''#传入0个参数fun5('cwj', 24)'''name is : cwjage is : 24address is : &#123;&#125;'''#在有现成dict类型的情况下#此处是将d这个dict类型对象的所有 key-value 用关键字参数导入到函数的**keyWord参数中，keyWord获得的是d的一份拷贝，对keyWord的改变将不会影响到函数外的d本身。d = &#123;'address': 'beijing', 'wether':'hot'&#125;fun5('cwj', 24,**d)name is : cwjage is : 24address is : &#123;'address': 'beijing', 'wether': 'hot'&#125; 命名关键字此种参数是用来 限制关键字参数 的名字，就是仅接受 已经命名的形参 的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455'''表示方法1：*，参数名1，参数名2'''def fun6(name, age, *, address, wethear): print('fun6-----') print("name is : ", name) print('age is : %d' % age) print('address is : %s' % address) print('wether is : ', wethear)fun6('cwj', 26, address='tianjin', wethear='hot')'''name is : cwjage is : 26address is : tianjinwether is : hot''''''表示方法2，若函数中已经含有一个'可变参数'，则之后的参数不需要在添加 * 符号'''def fun7(name, age, *keyWord, city, wether): print('fun7-----') print('name is : ', name) print('age is : ', age) print('keuWord is : ', keyWord) print('city is : ', city) print('wether is : ', wether)fun7('cwj', 24, 'xian', city='tianjin', wether='windy')'''name is : cwjage is : 24keuWord is : ('xian',)city is : tianjinwether is : windy''''''表示方法3：设置有默认值的命名关键字参数'''def fun8(name, *, city='beijng',wether): print(name, city, wether)fun8('cwj',wether='hot')'''cwj beijng hot'''def fun9(name): passfun9('cwj') 组合参数代码示例 12345678910111213141516171819202122232425262728293031# 参数 必须参数，可选参数，可变参数，关键字参数def fun10(name, age=19, *key_word, **city): print(name, age, key_word, city)# 参数 必须参数，可选参数，可变参数，命名关键字参数def fun11(name, age=19, *key_word, city, weather): print(name, age, *key_word, city, weather)# 参数 必须参数，可选参数，命名关键字参数def fun12(name, age=8, *, city, weather): print(name, age, city, weather)# 参数 可选参数，可变参数，命名关键字参数def fun13(age=23, *l_num, **key_word): print(age, l_num, key_word)l = [1, 2, 3]fun10('cwj', 24, *l) # cwj 24 (1, 2, 3) &#123;&#125;fun10('cwj', 24, *l, city='beijing') # cwj 24 (1, 2, 3) &#123;'city': 'beijing'&#125;fun11('cwj', 24, *l, city='tianjin', weather='hot') # cwj 24 1 2 3 tianjin hotfun12('cwj', age=24, city='xian', weather='very hot') # cwj 24 xian very hotfun12('cwj', 0, city='beijing', weather='windy') # cwj 0 beijing windyfun13(24, *l, fa='sss') # 24 (1, 2, 3) &#123;'fa': 'sss'&#125;]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux/Unix系统文件结构]]></title>
    <url>%2FLinux%3AUnix%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[总结 /bin系统有很多放置执行档的目录，但/bin比较特殊。 因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 /etc系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop /etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。 /etc/X11/ ：与XWindow有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 /lib系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /mediamedia是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 /opt这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 /root系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 /sbinLinux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srvsrv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 /tmp这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下： /lost+found这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 根目录下与开机过程有关的目录1234567除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 /usr 的意义与内容：依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。 /usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： /usr/X11R6/为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。/usr/bin/绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var 的意义与内容：如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。 /var/cache/应用程序本身运作过程中会产生的一些暂存档 /var/lib/程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。四. 目录树(directory tree) :在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 01-基础-基本数据类型]]></title>
    <url>%2FPython3%20%2001-%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[人生苦短，我用Python Python是一种计算机编程语言，使用Unicode编码，支持多语言(动态语言，因为变量本身不固定)。 是一种解释性语言在运行 .py 文件时需要通过 解释器 进行解释然后显示呢结果。 区分大小写 参考网站：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 Python代码创建方式 1.在 终端环境 中编写 2.在 文件 中编写 方式 1：在终端环境下 输入 python 进入python交互模式，在&gt;&gt;&gt;后名编写代码： 12300 + 100400 输入 exit() 退出python模式。 方式 2：在文件中 直接在文件中编写代码，然后打开终端进入文件所在目录，运行： 1python 文件名.py 语法1、采用缩进方式（4个空格） 2、大小写敏感，例如：`True`, `False`, `None` 注释 # coding=utf-8 使用Scrapy爬虫框架时应该添加此条语句表明注释是中文注释 # 单行注释 &#39;&#39;&#39; &#39;&#39;&#39;多行注释 符号 ：作用 :结尾表示时，缩进的语句视为代码块,如： 1234if ooo: XXXelse: XXX 字符串编码 参考：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000 ASCII、Unicode和UTF-8的关系在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。所以你看到很多网页的源码上会有类似的信息，表示该网页正是用的UTF-8编码 Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言 数据类型和变量 整数 浮点型 字符串 布尔值 空值 变量 常量 列表 字典 自定义数据类型 整数1，-1，0x123。 整数的除法在Python中有两种：/和//。 其中/表示除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数 1print(13/5) #2.6 另一种除法//称为地板除，两个整数的除法仍然是整数: 1print(13//5) #2 浮点型1.2， 1.23e9, 12.3e8， 1.23e-8 字符串（！此处划重点！） 字符串类型是str。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示。 使用 &#39; &#39; 或者 &quot; &quot; 表示的任意字符。其中包括 “‘”的用法 &quot;I&apos;m OK&quot; 既有&#39;又有&quot;的表示方法 I’m “OK”的用法： &apos;I \&apos;m \&quot;OK\&quot;&apos; 即：需要显示的特殊字符或者需要转义的字符用 \ 表示。 如果不需要转义当前字符，则可以使用 r&#39;&#39; 表示 &#39;&#39;内部不需要转义的字符，例如： 1print(r'"I\'m \"OK\""') 结果为： &quot;I\&apos;m \&quot;OK\&quot;&quot; 在&#39;&#39;&#39; &#39;&#39;&#39; 内可以不使用\n换行符而直接表示多行内容 123print('''line1line2line3''') 结果为： 123line1line2line3 布尔值 注意True和False的大小写，而且布尔值可以用and、or和not运算 测试代码： 123456789101112131415161718print(3 &gt; 2) #Trueprint(3 &lt; 2) #Falseif 3 &gt; 2 and 4 &lt; 5: print("3 &gt; 2")else: print("3 &lt; 2") #3 &gt; 2if 3 &gt; 2 or 4 &gt; 5: print("3 &gt; 2")else: print("3 &lt; 2") #3 &gt; 2if not 4 &lt; 5: print("3 &gt; 2")else: print((not 4 &lt; 5)) #False print("3 &lt; 2") #3 &lt; 2 空值 空值是用None表示的（注意大小写），但是None不能理解为0。 变量 Python与其他不同的是它的变量的类型是通过被赋予的值得类型决定的，即： 后者决定前者的类型。 Python的变量只是一个名字而已，数值内容及其类型才是重点，决定了变量名的实际意义。 变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错,例如Java是静态语言. 12345678a = 123print(a) #123a = "a是个变量名"print(a) #a是个变量名a = Trueprint(a) #Trueb = aprint(b) #True 常量 在Python中，通常用全部大写的变量名表示常量，全部大写的变量名表示常量只是一个习惯上的用法。 格式化输出 格式化输出字符串 – 同C语言，格式化与实际数据之间通过%连接 使用%，%运算符就是用来格式化字符串的，其中 %s 表示替换字符串，%d 表示替换整数，%f 表示替换浮点型%x 表示16进制 代码示例 12345678910name = input('请输入你的名字：') #请输入你的名字：yannisprint('Hello, %s ,你好啊~' % name) #Hello, yannis ,你好啊~age = input("请输入你的年龄： ")print("你的年龄为 %d，确认：%d" % (12,12)) #你的年龄为 12，确认：12#在不确定使用何种类型的数据时，用%s即可print('age is : %s; Gener: %s' % (32,False)) #age is : 32; Gener: False#字符串里面的%是一个普通字符时,需要转义，用%%来表示一个%print('增长率为：%d%%' % 7) #增长率为：7% 一个计算成绩比率的小代码 12345678910111213141516grade1 = input("请输入去年的成绩：")grade2 = input("请输入今年的成绩："#此处将str类型的grade1转换为int的10进制类型，参数：grade1表示待转换的数据，参数：10，表示进制num = int(grade1,10) - int(grade2,10)#此处将int类型的num转换为str类型print('num is : ' + str(num))print('abs is : %d' % abs(num))#将结果转换为float类型mPercent = float(((abs(num))/int(grade1,10))*100)print('mPercent is : ' + str(mPercent))#格式化输出结果print('成绩变化率为：%.2f%%' % mPercent)]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2FAndroid%20Activity%2F</url>
    <content type="text"><![CDATA[Activity 1. Activity生命周期1.1 生命周期图用户参与的情况下，Activity所经过的生命周期。 1.2 各个生命周期方法分析 onCreate() 表示Activity正在被创建，可以进行一些初始化的操作。 onRestart() 表示Activity正在重新启动。从不可见变为可见时，此方法就会被调用。若当前Activity执行 onPause() 和 onStop() 方法后，再次回到此Activity时，此方法将会被调用。 onStart() 表示此Activity即将被启动，即将开始时。此时Activity已经可见，但是还在后台，无法和用户交互。 onResume() 表示Activity已经可见，并且出现在前台。 onPause() 表示Activity正在停止。 onStop() 表示Activity即将停止。可以做一些回收工作，不能太耗时。 onDestroy() 表示Activity即将被销毁。可以做一些回收、资源释放操作。 1.3 各种生命周期方法执行过程 Activity第一次启动 onCreate() -&gt; onStart() -&gt; onResume() 当前Activity前台不可见时 onPause() -&gt; onResume() 当用户打开新的Activity时或者回退到桌面时，调用 onPause() -&gt; onStop() 从后台再次返回原Activity时，调用 onRestart()-&gt; onStart() -&gt; onResume() 回退桌面时，调用 onPause() -&gt; onStop() -&gt; onDestroy() 1.4 当启动ActivityB，遮盖ActivityA时当从当前的Activity A 打开Activity B时，Activity A将先执行 onPause() 方法，然后 Activity B 才执行 第一次启动时调用的声明周期方法。即：旧Activity先 onPause() ， 新Activity再启动。新Activity再启动后，旧Activity执行 onStop() 方法 2. 生命周期异常Activity被系统回收或者由于当前设备的Configuration发生改变而导致的Activity被销毁重建。 2.1 系统配置发生改变 导致Activity被杀死并被重建在这种状态下的生命周期： 意外时： Activity -&gt; onSaveInstanceState() -&gt; onDestroy() onSaveInstanceState()用来保存当前Activity状态，此方法将会在 onStop() 之前被调用。 重建时： Activity -&gt; onCreate() -&gt; onRestoreInstanceState() 2.2 内存不足导致 低优先级Activity 被杀死 优先级问题 前台Activity： 与用户进行交互的Activity，优先级最高 可见非前台Activity： 当前Activity弹出了一个对话框，原Activity虽可见，但是用户无法进行交互。 后台Activity： 优先级最低 如果一个进程中没有四大组件在执行，那么这个进程将会很快的被杀死。 3. Activity 启动模式：4种使用方式1： 1android:launchMode=&quot;standard&quot; 使用方式2： 1设置：FLAG_ACTIVITY_XXX 3.1 standard：标准模式。 对应Activity的 Flags ：FLAG_ACTIVITY_NEW_TASK 当搭配FLAG_ACTIVITY_CLEAR_TOP时，连同此Activity在内的Activity都要一同出栈。 每次启动一个Activity都会创建一个新的实例，不论这个实例是否已经存在。此模式下的Activity会默认进入启动它的Activity的所属栈中。 3.2 singleTop：栈顶（top）复用（single）模式。 对应Activity的 Flags ：FLAG_ACTIVITY_SINGLE_TOP 如果新Activity已经位于任务栈顶，那么此Activity将不会被重新创建，同时它的 onNewIntent() 将会被调用；如果任务栈中此Activity不在栈顶，那么将在栈顶创建新的Activity。 示例： 1：若A为栈底，C为栈顶，当ABC时，在此模式下启动C时，则仍为ABC。 2：若A为栈底，B为栈顶，当ACB时，在此模式下启动C时，任务栈为：ACBC。 3.3 singTask：栈内复用模式。 默认具 Activity的 Flags ：FLAG_ACTIVITY_CLEAR_TOP 。此 Flags 表示：它标记的Activity，当它启动时，在同一任务栈中的所有位于此Activity之上的Activity都要出栈。 如：之前栈内为：ABCD，当调用B后，栈内的情况变为：AB。 只要Activity在一个栈中存在，那么多次启动此Activity将不会重新创建该实例。默认具有 clearTop 功能 创建过程 1：启动 Activity A 时，若不存在A所需的任务栈，那么创建一个任务栈，然后创建 Activity A 的实例，将A实例压入任务栈中。 2：启动 Activity A 时，若存在A所需的的任务栈，看栈中是否存在 Activity A 实例，若存在，将其调到栈顶，并调用 onNewIntent() ；若不存在，创建A的实例，将其压入A所需的栈中。 生命周期： 第一次打开会执行 onCreate() -&gt; onStart() -&gt; onResume() 如果该Activity没有被destroy，重新打开执行 onNewIntent() -&gt; onRestart() -&gt; onStart() -&gt; onResume()e 3.4 singleInstance：单实例模式，加强版 singleTask。 在 singleTask 原有的特点基础之上，还加强了一点：设置了此模式的 Activity 只能单独的位于一个任务栈中。 注意：当调用到 onNewIntent(intent) 的时候，需要在 onNewIntent() 中使用 setIntent(intent) 赋值给Activity的Intent.否则，后续的 getIntent() 都是得到 旧Intent。 4. IntentFilter 匹配规则启动Activity分为两种：显式 + 隐式。如果二者同时存在的话以 显式 为主。 4.1 隐式调用隐式调用需要 Intent 能够匹配目标组件中的 IntentFilter 中的过滤信息。 只有一个 Intent 同时匹配这3个类别时，才能启动Activity，否则无法启动Activity。 一个Intent可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应Activity。 action匹配规则： 是一个字符串，系统预定义，可自定义一些。要求Intent中的action存在且必须和过滤中规则中的一个action相同。 categoryn匹配规则： 是一个字符串，系统预定义一些，可自定义。Intent中如果出现了category，那么不管有几个category，对于每一个category来说，它必须是过滤规则中已经存在的category。 注意：Intent不设置category也可以匹配。原因是系统在调用 startActivity() 或 startActivityForResult() 时会默认为Intent添加 android.intent.category.DEFAULT这个category。 所以，为了我们的Activity能够接受 隐式 调用，必须在 intent-filter 中指定以上这个category。 data 4.2 入口Activity，缺一不可1234&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&lt;/intent-filter&gt; 4.3 判断是否有Activity能够匹配 隐式 Intent。12public abstract List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent, @ResolveInfoFlags int flags);public abstract ResolveInfo resolveActivity(Intent intent, @ResolveInfoFlags int flags); 5. Activity的启动过程通过源代码中方法的调用流程来说明： 涉及到的类 Activity ActivityThread ActivityManager ActivityManagerService Application ApplicationThread ActivityStackSupervisor ActivityThread类： 中的 main(String[] args) 方法： 123456789101112131415161718192021 line : 6623public static void main(String[] args) &#123; Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();&#125; 在这个方法中调用了 attach() 方法： 123456789101112131415161718192021 line : 6478 private void attach(boolean system, long startSeq) &#123; if (!system) &#123; android.ddm.DdmHandleAppName.setAppName("&lt;pre-initialized&gt;", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try &#123; mgr.attachApplication(mAppThread, startSeq); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; else &#123; &#125; ViewRootImpl.addConfigCallback(configChangedCallback);&#125; 通过这个方法，我们可以看到 ActivityManager.getService() 得到的实例其实 IActivityManager接口，其具体实现是 ActivityManagerService类，在这个类中调用了 attachApplication(mAppThread, startSeq) 方法： 1234567891011line : 7932 @Overridepublic final void attachApplication(IApplicationThread thread, long startSeq) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq); Binder.restoreCallingIdentity(origId); &#125;&#125; 然后在这个方法中调用了 attachApplicationLocked() 方法： 123456789101112131415 line：7572private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled); // 注意这个方法的调用，在第11步的时候会讲到 mStackSupervisor.attachApplicationLocked(app)&#125; 需要注意的是：此处的 thread 变量实际是 IApplicationThread 接口，其实现为 ApplicationThread类，这个类是 ActivityThread类 中的 私有内部类，所以在这个方法中调用这个类的 bindApplication() 方法。 ，主要语句为： 1234 line : 858 public final void bindApplication(……) &#123; sendMessage(H.BIND_APPLICATION, data);&#125; 在收到发送的这条消息之后，在 ActivityThread类 中的 Handler类 的子类 H类 中对这条消息作出处理： 123456789101112line：1647 class H extends Handler &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125;&#125; 然后执行具体的 handleBindApplication() 方法，在这个方法中一流程分析为主的话，主要是一下这条语句： 12345line：5536private void handleBindApplication(AppBindData data) &#123; // line：5842 app = data.info.makeApplication(data.restrictedBackupMode, null);&#125; 在这个方法中，data.info.makeApplication() 这个方法的返回值是 Application类，具体实现是在 LoadedApk类 中的 `` 方法： 123456789line：1037public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; // 重要语句： app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); // 添加 Application 实例 mActivityThread.mAllApplications.add(app); &#125; 在 Instrumenttation类 中的 `` 方法中执行： 12345678line；1116static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); app.attach(context); return app;&#125; 然后执行 Application类 中的 attach() 方法: 12345line : 211final void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; 继续查看在第4步中提到过的 ActivityStackSupervisor类 中的 attachApplicationLocked() 方法： 1234567line ： 971boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; if (realStartActivityLocked(activity, app, top == activity /* andResume */, true /* checkConfig */)) &#123; didSomething = true; &#125;&#125; 在这个方法中调用了 ActivityStackSupervisor类 中的 realStartActivityLocked() 方法： 1line ： 1377 在 ActivityThread类 中的 handleRelaunchActivity() 方法 调用 handleRelaunchActivityInner()： 1234567line : 4595public void handleRelaunchActivity(ActivityClientRecord tmp, PendingTransactionActions pendingActions) &#123; handleRelaunchActivityInner(r, configChanges, tmp.pendingResults, tmp.pendingIntents, pendingActions, tmp.startsNotResumed, tmp.overrideConfig, "handleRelaunchActivity");&#125; 在 ActivityThread类 中的 handleRelaunchActivityInner() 方法 调用 handleLaunchActivity()： 12345678line：4746private void handleRelaunchActivityInner(ActivityClientRecord r, int configChanges, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingIntents, PendingTransactionActions pendingActions, boolean startsNotResumed, Configuration overrideConfig, String reason) &#123; handleLaunchActivity(r, pendingActions, customIntent);&#125; 通过接受 LAUNCH_ACTIVITY 消息，调用 handleRelaunchActivityLocally((IBinder) msg.obj); 语句 在 ActivityThread类 中的 handleLaunchActivity() 方法中： 1234567891011 line : 3024 /** * Extended implementation of activity launch. Used when server requests a launch or relaunch. */@Overridepublic Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; // 关键语句 final Activity a = performLaunchActivity(r, customIntent);&#125; 在 ActivityThread类 中的 performLaunchActivity() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113line : 2008/** Core implementation of activity launch. */private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to instantiate activity " + component + ": " + e.toString(), e); &#125; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, "Performing launch of " + r); if (localLOGV) Slog.v( TAG, r + ": app=" + app + ", appName=" + app.getPackageName() + ", pkg=" + r.packageInfo.getPackageName() + ", comp=" + r.intent.getComponent().toShortString() + ", dir=" + r.packageInfo.getAppDir()); if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onCreate()"); &#125; r.activity = activity; &#125; r.setState(ON_CREATE); mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to start activity " + component + ": " + e.toString(), e); &#125; &#125; return activity;&#125; 最终，重点来了：onCreate() 方法的调用： 123456line：2890if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);&#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state);&#125; 继续走： 1234567line：1282public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) &#123; prePerformCreate(activity); activity.performCreate(icicle, persistentState); postPerformCreate(activity);&#125; 马上就要接近终点了： 12345678910line ：7130final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; mCanEnterPictureInPicture = true; restoreHasCurrentPermissionRequest(icicle); if (persistentState != null) &#123; onCreate(icicle, persistentState); &#125; else &#123; onCreate(icicle); &#125;&#125; 在这个方法中调用了 onCreate().]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View-自定义- Canvas + Paint + Path]]></title>
    <url>%2FAndroid%20View-%E8%87%AA%E5%AE%9A%E4%B9%89-%20Canvas%20%2B%20Paint%20%2B%20Path%2F</url>
    <content type="text"><![CDATA[参考：http://www.jianshu.com/p/d2c7a837265e关于Paint资料非常丰富：http://www.jianshu.com/p/420da0f6e279非常系统的知识：http://hencoder.com/ui-1-1/ 前言 自己一直在学习许多技术大牛的技术博客，看他们是如何学习Android源码，看他们是如何分析当下流行、火热的技术以及框架的使用，可以说是他们的无私奉献、共享精神一直在支持着像我这样渴望学到更多，渴望技术升级的初学者。正所谓“穷则独善其身，达则兼济天下”。一直想着，如果自己有一天能够达到让自己满意的高度，也会将这样的方式继续传递，技术因为通过共享、传递才能得以实现其对社会的价值。 之前自己也学习过自定义View，也写过示例，在项目中也应用过，可都是写较为简单的。而自己写的随手笔记因为条理性、技术点太低（所以不敢称为技术博客），总是使自己不满意，也没有很好的传承下来。最近换了工作而且手头也比较闲，也是一个新的开始。所以秉着好记性不如烂笔头、博客记录成长的信条，将自己的所学、所悟记录下来。 基本自定义View的3个关键点 布局 绘制 触摸反馈 Android坐标系图片来自网络，忘记出处，如有侵权请联系我。 4个级别 Canvas Canvas.drawXXX()是自定义绘制的基本操作。可以绘制几何图形、文字、图片，在+Paint的常用方法。 裁剪范围（很酷的效果） 几何变换（很酷的效果） Paint ：Paint的使用 Path ：轮廓,路径 Canvas的使用 Canvas是“画布”的意思，拥有“绘制”的功能。 1. Canvas的使用需要4个基本元素： 一个Bitmap用于保存像素 一个Canvas来承载绘图调用（写入到位图） 一个绘图的基本元素（例如Rect，Path，文本，位图） 一支Paint（描述颜色和样式） 2. Canvas有两个构造方法： Canvas()：创建一个空的Canvas对象 Canvas(Bitmap bitmap)：用指定的位图构造一个Canvas对象 3. 常用绘制方法： translate()：画布移动 drawARGB()：用指定ARGB颜色填充画布上面的位图 drawRGB()：用指定RGB颜色填充画布上面的位图 drawColor()：用指定颜色填充画布上面的位图 drawArc()：画圆弧 startAngle：表示开始的角度sweepAngle：表示角度范围useCenter：表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。 1234567891011RectF rectF = new RectF(DensityUtil.dip2px(context, 100), DensityUtil.dip2px(context, 100), DensityUtil.dip2px(context, 220), DensityUtil.dip2px(context, 180));paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF, 0, 80, false, paint);paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF, -10, -80, true, paint);paint.setStyle(Paint.Style.FILL);canvas.drawArc(rectF, -100, -80, true, paint);paint.setStyle(Paint.Style.FILL);canvas.drawArc(rectF, -190, -80,false,paint); drawBitmap()：画位图 drawPicture() drawCircle() ：画圆 drawLine()：画直线 drawLines()：折线 drawOval()：画椭圆 drawRect()：画矩形 drawRoundRect()：画圆角矩形 drawPoint()：画点 drawPoints()：画一组点pts : 这个数组是点的坐标，每两个成一对offset : 表示跳过数组的前几个数再开始记坐标count : 表示一共要绘制几个点 1234567891011121314151617181920//圆点和方点的切换使用 paint.setStrokeCap(cap)：`ROUND` 是圆点，`BUTT` 或 `SQUARE` 是方点this.paint.setStrokeCap(Paint.Cap.ROUND);this.paint.setAntiAlias(true);this.paint.setStyle(Paint.Style.FILL);this.paint.setStrokeWidth(50);this.paint.setStrokeCap(Paint.Cap.ROUND);canvas.drawPoint(canvas.getWidth() / 2 - 200, canvas.getHeight() / 2, paint);paint.setStrokeCap(Paint.Cap.SQUARE);canvas.drawPoint(canvas.getWidth() / 2 + 200, canvas.getHeight() / 2, paint);paint.setStrokeCap(Paint.Cap.ROUND);this.paint.setStrokeWidth(10);float[] points = &#123;20,20, 50,50, 80,80,100,100,130,130,170,170,210,210,240,240,&#125;;canvas.translate(100,100);canvas.drawPoints(points,paint);canvas.translate(0,300);canvas.drawPoints(points,3,10,paint); drawPath()：画路径组合。这个方法是通过描述路径的方式来绘制图形的，它的 path 参数就是用来描述图形路径的对象 12345path.arcTo(canvas.getWidth() / 2 - 200, 380, canvas.getWidth() / 2, 580, 135, 225, false);path.arcTo(canvas.getWidth() / 2, 380, canvas.getWidth() / 2 + 200, 580, 180, 225, false);path.lineTo(canvas.getWidth() / 2, 720);path.close();canvas.drawPath(path, paint); 角度和划过度数 1234567RectF rectF1 = new RectF(200,100,300,200);paint.setStyle(Paint.Style.STROKE);canvas.drawArc(rectF1, 135, 225, true, paint);paint.setStyle(Paint.Style.STROKE);canvas.translate(100,0);canvas.drawArc(rectF1, 180, 225, true, paint); drawText()：画文本 drawTextOnPath()：根据路径画文本 drawPosText()：指定单个文字位置 arcTo(): 将指定的弧添加到路径作为新的轮廓。 Paint的使用画笔 1. Paint有3个构造方法：1.Paint():用默认设置创建一个Paint对象2.Paint(int flags):用特殊标记创建一个Paint对象3.Paint(Paint paint):用指定Paint对象的参数初始化一个新的Paint对象 ##2. 常用方法 reset() ：清空path的所有数据，但是不会清空FillType rewind() ：清除FillType及数据等，但会保留数据结构。这样可以快速重用，提高一定的性能 setARGB(int a, int r, int g, int b) : 画笔颜色 setColor(int color) : 画笔颜色 setAntiAlias(boolean aa)： 是否抗锯齿 setAlpha(int a) ：设置画笔透明度 setStrokeWidth(float width) ：画笔的粗细(线条的宽度) setXfermode(Xfermode xfermode) ：设置图像重叠时的处理方式 - 16种 setFillType()：2个图形重合的模式.类似前面讲解的xfermode,只有4个值：WINDING//默认值，取两个图形相交；EVEN_ODD//取不相交的部分；INVERSE_WINDING//反转相交；INVERSE_EVEN_ODD//反转不相交部分 setShader(Shader shader) ：设置着色器 setPathEffect(PathEffect effect) ：设置或者清除路径效果 - 6种 setShader(Shader shader) ：设置图像效果，可以绘制出各种渐变效果 setShadowLayer(float radius ,float dx,float dy,int color)：在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 setStrokeCap(Paint.Cap cap)：设置线冒样式(线头的装饰画法)，取值有: Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) setStrokeJoin(Paint.Join join)：设置线段连接处样式(折线的拐角装饰画法)，取值有：Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线) setStyle(Paint.Style style) 设置画笔样式”，画笔样式有三种: (1)Paint.Style.FILL：默认值，用这种风格绘制的几何图与文本将被填充，它画出来的是实心图 (2)Paint.Style.STROKE：用这种风格绘制的几何图与文本将被画出外边框，它画出来的是空心图 (3)Paint.Style.FILL_AND_STROKE：用这种风格绘制的几何图与文本将被填充并被画出外边框 3.设置“文字/字体“外观 setTextSize(float textSize) ：设置文字大小” setFakeBoldText(boolean fakeBoldText)：设置是否为粗体文字 setStrikeThruText(boolean strikeThruText) ：设置带有删除线效果 setUnderlineText(boolean underlineText) ：设置下划线 setTextAlign(Paint.Align align) ：设置开始绘图点位置,文本对齐方式 setTextScaleX(float scaleX) ：水平拉伸设置 setTextSkewX(float skewX) ：设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 setTypeface() ：置字体样式:Typeface.NORMAL - 正常体;Typeface.BOLD - 粗体;Typeface.ITALIC - 斜体;Typeface.BOLD_ITALIC - 粗斜体 4.字体样式(Typeface) create(String familyName, int style) ：直接通过指定字体名来加载系统中自带的文字样式 create(Typeface family, int style) ：通过其它Typeface变量来构建文字样式 createFromAsset(AssetManager mgr, String path) ：通过从Asset中获取外部字体来显示字体样式 createFromFile(String path) ：直接从路径创建 createFromFile(File path) ：从外部路径来创建字体样式 defaultFromStyle(int style) ：创建默认字体5. 字体设置 在assets目录下新建fonts目录，把ttf字体文件放到这。 程序中调用： 123456//得到AssetManagerAssetManager mgr=getAssets();//根据路径得到Typeface，注意"ttf文件命名不能使用中文,否则可能无法加载。Typeface tf=Typeface.createFromAsset(mgr, "fonts/ttf.ttf");//设置字体样式tv.setTypeface(tf); 6.文字所占的区域（范围）的设定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 注意:在使用FontMetrics时必须为同一个Paint对象,否则,无法获取文字正确的位置关系 */Paint paint12 = new Paint();paint12.setAntiAlias(true);paint12.setStrokeWidth(1);paint12.setStyle(Paint.Style.STROKE);paint12.setColor(Color.BLACK);paint12.setTextSize(100);Paint.FontMetrics fontMetrics = paint12.getFontMetrics();//可绘制的最高高度所在线float top;//可绘制的最低高度所在线float bottom;//系统建议的，绘制单个字符时，字符应当的最高高度所在线float ascent;//系统建议的，绘制单个字符时，字符应当的最低高度所在线float descent;/** * 建议在文本行之间添加的额外空格。 *///fontMetrics.leadingtop = 100 + fontMetrics.top;bottom = 100 + fontMetrics.bottom;ascent = 100 + fontMetrics.ascent;descent = 100 + fontMetrics.descent;//绘制文字canvas.drawText(strs,100,100,paint12);//------------------------令人惊喜的分割线---------------------canvas.translate(0,200);canvas.drawLine(100,100,1080,100,paintStyle(Color.RED,Paint.Style.STROKE));canvas.drawLine(100,top,1080,top,paint12);//可绘制的最高高度所在线canvas.drawLine(100,bottom,1080,bottom,paint12);//可绘制的最低高度所在线canvas.drawLine(100,ascent,1080,ascent,paint12);//系统建议的，绘制单个字符时，字符应当的最高高度所在线canvas.drawLine(100,descent,1080,descent,paint12);//系统建议的，绘制单个字符时，字符应当的最低高度所在线canvas.drawLine(100,0,100,100,paintStyle(Color.RED,Paint.Style.STROKE));float width = paint12.measureText(strs);//获取文字所占宽度float height = bottom - top;//获取文字所占高度Log.e(TAG, "onDraw width: " + width + ", height : " + height);//绘制文字所占区域的边框Path rectPath = new Path();RectF rectF2 = new RectF(100,top,width+100,bottom);//绘制文字paint12.setColor(Color.GREEN);canvas.drawRect(rectF2,paint12); Path1. 常用方法 moveTo() ：设定起始点 lineTo() ：画条直线(连续使用此方法,将会画出连续的线) close() ：封闭图形 addRect() ：矩形路径（使用此方法时首先绘制一个矩形,后续addXXX()使用类似） addRoundRect() ：绘制圆角矩形路径 addCircle() ：绘制原型路径 addCircle() ：绘制椭圆路径 addArc() ：绘制一段弧形路径 quadTo() ：绘制”贝塞尔曲线” 有4个方法 参数说明 Path.Direction有两个值： Path.Direction.CCW：是counter-clockwise缩写，指创建”逆时针”方向的矩形路径； Path.Direction.CW：是clockwise的缩写，指创建”顺时针”方向的矩形路径； 2. PathMeasure类的使用 参考:http://blog.csdn.net/cquwentao/article/details/51436852 (1) 123//path：需要测量的path//forceClosed：是否关闭pathpublic PathMeasure(Path path, boolean forceClosed) (2) 12//这里就是指定需要测量的path，同上。public void setPath(Path path, boolean forceClosed) (3) 123//返回当前path的"总"长度。PathMeasure pathMeasure = new PathMeasure(path, false);float length = pathMeasure.getLength(); (4) 123456public boolean getPosTan(float distance, float pos[], float tan[])//返回值是boolean，如过path为空，则返回false传入参数有三个： distance：传入距离起点的距离。 pos[]:意思是position，分别对应点的x，y坐标 tan[]：这个值比较难以理解。我们下面讲解下这个值的意义。 Path 有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算。 直接描述路径。1. 添加子图形 ：addXxx()添加的完整封闭图形（除了 addPath() ） 2. 画线（直线或曲线）：xxxTo() lineTo(float x, float y) / rLineTo(float x, float y) ：画直线 lineTo(x, y) 的参数是绝对坐标，而 rLineTo(x, y) 的参数是相对当前位置的相对坐标 （前缀 r 指的就是 relatively 「相对地」)。 所谓当前位置，即最后一次调用画 Path 的方法的终点位置。初始值为原点 (0, 0)。 quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2) ：画二次贝塞尔曲线 cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) ：画三次贝塞尔曲线 moveTo(float x, float y) / rMoveTo(float x, float y) ：移动到目标位置 设置图形起点。 1234paint.setStyle(Style.STROKE); path.lineTo(50, 50); // 斜线 path.moveTo(150, 50); // 移动 path.lineTo(150, 0); // 竖线 画弧形 arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(RectF oval, float startAngle, float sweepAngle) orceMoveTo ：绘制是要 抬一下笔移动过去，还是 直接拖着笔过去，区别在于是否留下移动的痕迹。 1234path.moveTo(100,0);path.lineTo(100,100);path.arcTo(100,100,300,300,-90,90,true);canvas.drawPath(path,paint); 1234path.moveTo(100,0);path.lineTo(100,100);path.arcTo(100,100,300,300,-90,90,false);canvas.drawPath(path,paint); addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) addArc(RectF oval, float startAngle, float sweepAngle) addArc() 只是一个直接使用了 forceMoveTo = true 的简化版 arcTo() 。 close() ：封闭当前子图形 当需要填充图形时（即 Paint.Style 为 FILL 或 FILL_AND_STROKE），Path 会自动封闭子图形。 辅助的设置或计算Path.setFillType(Path.FillType ft) 设置填充方式。 使用参考：http://hencoder.com/ui-1-1/ 3. 获取随机Path方法12345678910private Path getPath()&#123; Path path = new Path(); // 定义路径的起点 path.moveTo(0, 0); // 定义路径的各个点 for (int i = 0; i &lt;= 40; i++) &#123; path.lineTo(i*35, (float) (Math.random() * 150)); &#125; return path; &#125; Color：Android系统中颜色的常用表示方法有以下3种： int color = Color.BLUE; int color = Color.argb(150,200,0,100); 在xml文件中定义颜色； 1. 常用颜色： 方法 描述 Color.BLACK 黑色 Color.GREEN 绿色 Color.BLUE 蓝色 Color.LTGRAY 浅灰色 Color.CYAN 青绿色 Color.MAGENTA 红紫色 Color.DKGRAY 灰黑色 Color.RED 红色 Color.YELLOW 黄色 Color.TRANSPARENT 透明 Color.GRAY 灰色 Color.WHITE 白色 2. ColorFilter类的使用 参考:http://blog.csdn.net/cquwentao/article/details/51396466 ColorFilter主要用来处理颜色有3个子类: ColorMatrixColorFilter：颜色矩阵 LightingColorFilter：亮度 PorterDuffColorFilter：颜色的混合模式 2.1. ColorMatrixColorFilter这个类主要是使用matrix对颜色做运算，矩阵的形态如下： &quot;R&quot; &quot;G&quot; &quot;B&quot; &quot;A&quot; &quot;Red通道&quot; a[0] a[1] a[2] a[3] a[4] &quot;Green通道&quot; a[5] a[6] a[7] a[8] a[9] &quot;Blue通道&quot; a[10] a[11] a[12] a[13] a[14] &quot;Alpha通道&quot; a[15] a[16] a[17] a[18] a[19] RGB色彩和Alpha的终值计算方法如下： “Red通道” 终值 = a[0] srcR + a[1] srcG + a[2] srcB + a[3] srcA + a[4] “Green通道”终值 = a[5] srcR + a[6] srcG + a[7] srcB + a[8] srcA + a[9] “Blue通道” 终值 = a[10] srcR + a[11] srcG + a[12] srcB + a[13] srcA + a[14] “Alpha通道”终值 = a[15] srcR + a[16] srcG + a[17] srcB + a[18] srcA + a[19] “备注” srcR为原图Red通道值，srcG为原图Green通道值，srcB为原图Blue通道值，srcA为原图Alpha通道值。每个通道的源值和终值都在0到255的范围内。即使计算结果大于255或小于0，值都将被限制在0到255的范围内。 使用示例 1234567private final static float[] MATRIX = new float[] &#123; 0.5f, 0, 0, 0, 0, 0, 0.5f, 0, 0, 0, 0, 0, 0.5f, 0, 0, 0, 0, 0, 1, 0 &#125;; 2.2. LightingColorFilterLightingColorFilter是上面ColorMatrixColorFilter的一个简化版本，构造函数也比较简单构造函数 123public LightingColorFilter(int mul, int add) //mul代表multiply,也就是乘法 //add代表加法，也就是颜色偏移量 使用示例 12345Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(), R.drawable.home);canvas.drawBitmap(bitmap, 100, 0, paint);LightingColorFilter filter = new LightingColorFilter(0x888888, 0x000000);paint.setColorFilter(filter);canvas.drawBitmap(bitmap, 100, 500, paint); 计算方法 color = color mul／２５５+ add (计算结果大于等于255都指定为255)其中”color”可以为RGB三种通道中的”一种”，mul和add分别为通道对应的值。假设R通道的值就为R=R0x88/0xff+0 0x88/0xff肯定是小于1的，所以颜色变暗了。add的值越”大”,画面越”亮”. 2.3. PorterDuffColorFilter构造函数 123public PorterDuffColorFilter(int srcColor, PorterDuff.Mode mode) //srcColor源颜色， //mode是色彩的混合模式. 重绘方法1234567891011121314151617/*** 重绘方法* 在某个时候调用 onDraw（android.graphics.Canvas)* 这必须从UI线程调用。 要从非UI线程调用则调用 postInvalidate()*/public void invalidate() &#123; invalidate(true);&#125;/** *这是invalidate（）工作实际发生的地方。 一个完整的invalidate（）会导致绘图缓存无效，但是可以使用invalidateCache设置为false来调用此函数，以便在不需要该过程的情况下跳过该无效步骤。 * * @param invalidateCache此视图的绘图缓存是否也应该被无效。对于完全无效，这通常是正确的，但如果视图的内容或维度未更改，则可能会设置为false。 */void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考《Head First 设计模式》 参考：http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html 设计原则：封装变化多用组合，少用继承开闭原则 定义：装饰模式又名包装(Wrapper)模式。装饰者模式动态地将责任添加到对象上，是继承关系的一个替代方案。 描述： 装饰着可以在所委托装饰着的行为之前或者之后添加自己的行为，已达到特定的目的。 通过使用不同的具体装饰类以及这些装饰类的组合，可以创造出很多不同行为的组合。 装饰着与组件组合时，就是在加入新的行为，新的行为是由组合对象得来的。 如何封装的更好：装饰着模式（Decorator） + 工厂模式（Factory） + 生成器模式（Builder） 装饰模式中的角色有： 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 抽象装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为。行为来自装饰着和基础组件，或与其他装饰着之间的组合关系。 实际应用：java的I/O流 装饰者模式的缺点 ： 产生大量的类。 类型问题。某一个对象依赖特定类型的类型。 采用装饰着实例化组件时，将会增加代码复杂度，不但需要实例化组件，还有把组件包装进装饰者中。 示例：组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 饮料抽象类 */public abstract class Drink &#123; String describtion = "Drink"; int price = 0; /** * 打印 描述 */ public String getDescribtion()&#123; return describtion; &#125; /** * 行为：输出价格 */ public abstract int printPrice();&#125;/** * 具体牛奶饮料类 */public class MilkDrink extends Drink &#123; public MilkDrink()&#123; price = 11; describtion = "MilkDrink " + String.valueOf(price); &#125; @Override public int printPrice() &#123; return price; &#125;&#125;/** * 具体茶饮料类 */public class TeaDrink extends Drink &#123; public TeaDrink()&#123; price = 12; describtion = "TeaDrink " + String.valueOf(price); &#125; @Override public int printPrice() &#123; return price; &#125;&#125; 装饰者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 抽象 装饰者 */public abstract class CondimentDecorator extends Drink&#123; int condimentPrice= 0; public abstract int printPrice();&#125;/** * 抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为 */public class HoneyDecorator extends CondimentDecorator &#123; Drink mDrink; public HoneyDecorator(Drink drink)&#123; this.mDrink = drink; condimentPrice = 10; &#125; @Override public String getDescribtion() &#123; return "HoneyDecorator " + String.valueOf(condimentPrice) + " " + mDrink.getDescribtion(); &#125; @Override public int printPrice() &#123; return condimentPrice + mDrink.printPrice(); &#125;&#125;public class MochaDecorator extends CondimentDecorator &#123; Drink mDrink; /** * 使用抽象基类，践行 "开闭原则"：对扩展开放，对修改关闭 * @param drink 基类 */ public MochaDecorator(Drink drink)&#123; this.mDrink = drink; condimentPrice = 5; &#125; /** * 输出当前组合 */ public String getDescribtion()&#123; return "MochaDecorator " + String.valueOf(condimentPrice) + " " + mDrink.getDescribtion(); &#125; /** * 组合得到新的行为 * @return 当前组合价格 */ @Override public int printPrice() &#123; return condimentPrice + mDrink.printPrice(); &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132public class DecoratorMain &#123; public static void main(String[] args)&#123; //只有一个底料的茶饮料 Drink teaDrink = new TeaDrink(); System.out.println(teaDrink.getDescribtion()); System.out.println(teaDrink.printPrice()); /** * TeaDrink 12 * 12 */ //茶饮料 + 蜂蜜 //抽象装饰角色 继承 抽象构件角色，是为了有正确的类型，而不是继承它的行为 Drink honeyDecorator = new HoneyDecorator(teaDrink); System.out.println(honeyDecorator.getDescribtion()); System.out.println(honeyDecorator.printPrice()); /** * HoneyDecorator 10 + TeaDrink 12 * 22 */ //茶饮料 + 蜂蜜 + 摩卡 Drink mochaDecorator = new MochaDecorator(honeyDecorator); System.out.println(mochaDecorator.getDescribtion()); System.out.println(mochaDecorator.printPrice()); /** * MochaDecorator 5 + HoneyDecorator 10 + TeaDrink 12 * 27 */ &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《Head First 设计模式》 参考：http://blog.csdn.net/self_study/article/details/51628486 代理模式的角色：Subject：抽象主题类 该类的主要职责是声明真实主题与代理的共同接口方法，该类既可以是一个抽象类，也可以是一个接口； RealSubjct：真实主题类 该类也称为被委托类或被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户端则通过代理类间接地调用真实主题类中定义的方法； ProxySubject：代理类 该类也称为委托类或代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中对应的接口方法，以此起到代理的作用； Client：客户类 即使用代理类的部分。 代码描述创建一个抽象主题类 public abstract class MyObject { //代理与实际主题的共同方法 public abstract void operate(); } 真实主题 public class RealObject extends MyObject { @Override public void operate() { System.out.println(&quot;这是来自RealObject的方法处理&quot;); } } 代理主题 public class ProxyObject extends MyObject { private RealObject realObject; //在此类中调用真实的主题，因为是代理主题“代理”真实主题中的方法，需要用到真实主题的引用 public ProxyObject(RealObject realObject) { this.realObject = realObject; } @Override public void operate() { System.out.println(&quot;在处理“RealObject”之前，处理代理模式中自己的方法处理&quot;); //在此处调用真实主题中的同名方法。 realObject.operate(); System.out.println(&quot;在处理“RealObject”之后，处理代理模式中自己的方法处理&quot;); } } 测试 public class Proxy_DesignPattern { public static void main(String[] args){ ProxyObject proxyObject = new ProxyObject(new RealObject()); proxyObject.operate(); } } /** * 输出结果： * 在处理“RealObject”之前，处理代理模式中自己的方法处理 这是来自RealObject的方法处理 在处理“RealObject”之后，处理代理模式中自己的方法处理 */ 代理模式根据实际使用的场景也可以分为以下几种：远程代理（Remote Proxy） 为某个在不同的内存地址空间的对象提供局部代理，使系统可以将 Server 部分的实现隐藏，以便 Client 可以不必考虑 Server 的存在，类似于 C/S 模式（主要拦截并控制远程方法的调用，做代理防火墙之类的）； 虚拟代理（Virtual Proxy） 使用一个代理对象标识一个十分耗资源的对象，并在真正需要时才创建，实现一个延迟加载的机制； 保护代理（Protection Proxy） 使用代理控制对原始对象的访问，该类型的代理通常被用于原始对象有不同访问权限的情况； 智能引用（Smart Proxy） 在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数； 写时拷贝（克隆）代理（Copy-on-write Proxy） 其实是虚拟代理的一个分支，提供了拷贝大对象的时候只有在对象真正变化后才会进行拷贝（克隆）的操作，即延迟拷贝。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《Head First 设计模式》 OO基础 ：抽象OO原则 ：封装变化、针对接口编程、松耦合（多用组合，少用继承）观察者模式 ：在对象之间定义一对多的依赖，当一个对象的状态改变，其他对象都会收到通知并自动改变。 被观察者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public interface WeatherSet &#123; void register(WeatherOberver oberver); void unRegister(WeatherOberver oberver); void upData(WeatherData weatherData);&#125;/** * 主题（被观察者） */public class WeatherSetI implements WeatherSet&#123; List&lt;WeatherOberver&gt; oberverList; /** * 初始化存储观察者的集合 * 模块间的依赖应该是通过 抽象来实现的 */ public WeatherSetI() &#123; this.oberverList = new ArrayList&lt;WeatherOberver&gt;(); &#125; /** * 注册 * @param oberver 观察者 */ public void register(WeatherOberver oberver)&#123; if (oberverList.contains(oberver)) &#123; System.out.println("注意 : " + oberver.getClass().getName() + " 当前订阅者已经存在，无需订阅"); &#125; else &#123; oberverList.add(oberver); &#125; &#125; /** * 取消注册 * @param oberver 观察者 */ public void unRegister(WeatherOberver oberver)&#123; System.out.println("注意：" + oberver.getClass().getName() + " 已经不再订阅该消息，bye~bye~"); oberverList.remove(oberver); &#125; /** * 数据更新 * @param weatherData 数据Bean类 * * 设计原则：“不要打电话给我，我打电话给你”（上层调用下层，下层不调用上层） */ public void upData(WeatherData weatherData)&#123; System.out.println("注意：当前有 " + oberverList.size() + " 位订阅了该消息！"); for (WeatherOberver item : oberverList) &#123; item.getData(weatherData); &#125; &#125;&#125;/*** 数据Bean类*/public class WeatherData &#123; int temp; int pressure; public WeatherData(int temp, int pressure) &#123; this.temp = temp; this.pressure = pressure; &#125; public int getTemp() &#123; return temp; &#125; public void setTemp(int temp) &#123; this.temp = temp; &#125; public int getPressure() &#123; return pressure; &#125; public void setPressure(int pressure) &#123; this.pressure = pressure; &#125; @Override public String toString() &#123; return "WeatherData&#123;" + "temp=" + temp + ", pressure=" + pressure + '&#125;'; &#125;&#125; 观察者123456789101112131415161718192021222324252627282930313233/** * 观察者 接口 */public interface WeatherOberver &#123; /** * 数据更新行为 * @param weatherData 数据Bean类 */ void getData(WeatherData weatherData);&#125; public class WangObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("WangObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125;public class ZhangObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("ZhangObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125;public class LiObserver implements WeatherOberver &#123; @Override public void getData(WeatherData weatherData) &#123; System.out.println("LiObserver get data temp is : " + weatherData.getTemp() + ", pressure is : " + weatherData.getPressure()); &#125;&#125; 应用public class OberverMain { public static void main(String[] args){ WeatherOberver oberverWang = new WangObserver(); WeatherOberver oberverLi = new LiObserver(); WeatherOberver oberverZhang = new ZhangObserver(); WeatherSetI set = new WeatherSetI(); set.register(oberverWang); set.register(oberverLi); set.register(oberverZhang); set.upData(new WeatherData(12, 45)); /** * 注意：当前有 3 位订阅了该消息！ WangObserver get data temp is : 12, pressure is : 45 LiObserver get data temp is : 12, pressure is : 45 ZhangObserver get data temp is : 12, pressure is : 45 */ System.out.println(); set.unRegister(oberverLi); set.upData(new WeatherData(32, 100)); /** * 注意：observer.LiObserver 已经不再订阅该消息，bye~bye~ 注意：当前有 2 位订阅了该消息！ WangObserver get data temp is : 32, pressure is : 100 ZhangObserver get data temp is : 32, pressure is : 100 */ System.out.println(); set.register(oberverZhang); set.upData(new WeatherData(33, 97)); /** * 注意 : observer.ZhangObserver 当前订阅者已经存在，无需订阅 注意：当前有 2 位订阅了该消息！ WangObserver get data temp is : 33, pressure is : 97 ZhangObserver get data temp is : 33, pressure is : 97 */ } } 实例 Android的广播机制。 我们平时使用本地广播主要就是下面四个方法: LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this); localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter); localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver); localBroadcastManager.sendBroadcast(Intent intent) 调用registerReceiver方法注册广播，调用unregisterReceiver方法取消注册，之后直接使用sendBroadcast发送广播，发送广播之后，注册的广播会收到对应的广播信息，这就是典型的观察者模式 EventBus。 观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件： EventBus.getDefault().register(Object subscriber); EventBus.getDefault().unregister(Object subscriber); EventBus.getDefault().post(Object event); RxJava。 创建一个被观察者： Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; sub) { sub.onNext(&quot;Hello, world!&quot;); sub.onCompleted(); } } ); 创建一个观察者，也就是订阅者： Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() { @Override public void onNext(String s) { System.out.println(s); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { } }; 观察者进行事件的订阅 myObservable.subscribe(mySubscriber);]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考《Head First 设计模式》 参考：http://blog.csdn.net/sbsujjbcy/article/details/49302717 定义：用原型模式的实例创建对象的实例，同过拷贝这些原型模式的实例创建新的对象。 优点及适用场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 注意事项： 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。 深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝例如： prototype.list = (ArrayList) this.list.clone(); 示例//实现“原型模式”第一步：实现Cloneable接口 public class Person implements Cloneable{ private String name; private String address; private int age; private int height; private ArrayList&lt;String&gt; hobbies; public Person(String name, String address, int age, int height, ArrayList&lt;String&gt; hobbies) { this.name = name; this.address = address; this.age = age; this.height = height; this.hobbies = hobbies; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public ArrayList&lt;String&gt; getHobbies() { return hobbies; } public void setHobbies(ArrayList&lt;String&gt; hobbies) { this.hobbies = hobbies; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, height=&quot; + height + &quot;, hobbies=&quot; + hobbies + &apos;}&apos;; } //实现“原型模式”第二步：重写clone（） @Override protected Object clone() throws CloneNotSupportedException { Person person = (Person) super.clone(); person.name = this.name; person.address = this.address; person.age = this.age; person.height = this.height; //person.hobbies = this.hobbies; //此处使用使用深拷贝 person.hobbies = (ArrayList&lt;String&gt;) this.hobbies.clone(); return person; } } 使用 public class Prototype_DesignPattern { public static void main(String[] args){ ArrayList&lt;String&gt; hobbies = new ArrayList&lt;String&gt;(); hobbies.add(&quot;游泳&quot;); hobbies.add(&quot;足球&quot;); hobbies.add(&quot;自行车&quot;); Person person0 = new Person(&quot;张三&quot;,&quot;北京&quot;,24,177,hobbies); System.out.println(&quot;person0 is &quot; + person0.toString()); //原型模式的使用 try { Person person1 = (Person) person0.clone(); person1.setName(&quot;王哇&quot;); hobbies.remove(&quot;足球&quot;); person1.setHobbies(hobbies); System.out.println(&quot;person1 is &quot; + person1.toString()); Person person2 = (Person) person0.clone(); person2.setAge(44); System.out.println(&quot;person2 is &quot; + person2.toString()); } catch (CloneNotSupportedException e) { e.printStackTrace(); } System.out.println(&quot;person0 is &quot; + person0.toString()); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式与设计原则]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[参考《Head First 设计模式》 参考：http://blog.csdn.net/self_study/article/details/51234377 Pattern：模式PrinciPle：原则 设计模式不会直接进入你的“代码”中，而是先进入你的“大脑”中。 在设计模式中，所谓的实现一个接口“并不一定表示写一个类，并利用implement关键词实现某个java接口”。而是泛指“实现某个超类型（可以是接口或是类）的某个方法”。 设计模式： 设计模式是历经验证的OO(Object Oriented)设计经验，不是被发明的，是被发现的。 设计是一门艺术，总是有许多可取舍的地方。 如果找不到合适的设计模式，采用一些 设计原则 也是相当不错的。 好的OO系统设计必须是：可维护、可扩充、可复用的。 ６大设计原则：1. OCP**（Open Closed Principle）- 开闭原则：what 编写代码应该：面向扩展开放，对修改关闭。 尽量不要通过修改现有代码来满足需求。How 要利用扩展来适应变更。 接口 &gt; 抽象 &gt; 具体类。 针对接口编程，而不是针对实现。 多用组合，少用继承。 2. SRP（Single Responsibility Principle）- 单一职责原则：what 一个类、一个方法只做一件事（越简单的越可靠）。how 一个类应该只有一个引起变化的原因。避免潜在错误。 3. LSP（Liskov Substitution Principle）- 里氏替换原则：what 所有引用基类的地方都能透明的使用子类的对象。how 子类必须完全实现父类的方法。 子类可以拥有自己的属性和方法。 子类覆盖或实现父类方法时参数范围可以扩大。 子类覆盖或实现父类方法时返回值范围可以缩小。 4. DIP（Dependence Inversion Principle）- 依赖倒置原则：what 模块间的依赖应该通过抽象发生，具体类之间不应该有依赖关系。 接口或者抽象不依赖于实现类，否则就失去了抽象接口的意义。 实现 依赖于 接口或者抽象，即：底层依赖于高层。how 针对接口编程，而不是针对实现。 别打电话给我，我打电话给你（观察者模式）。 5. ISP（Interface Segregation Principle） - 接口隔离原则：what 使用接口时应该建立单一的接口，不应该建立过于臃肿的接口。 接口应该 “专” 而非 “多”，即：提供独立单一的接口。 6. LKP（Least Knowledge Principle） - 最少知识原则/迪米特法则 ( LOD )：what 一个对象应该对 “其他对象”有最少的了解。how 一个类对于另一个类而言，尽量减少“public”，对外只提供一个简洁的访问 自己的方法。 具体分类 1. 观察者模式 （有趣的事情发生了，可千万别错过！）定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 2. 装饰者模式 动态的将责任附加到对象上，若要扩展功能，装饰者模式提供了比“继承”更有弹性的替代方案。 3. 简单工厂模式 不是一个真正的模式，但是同“抽象工厂模式”和“工厂方法模式”一样，被用于封装创建对象的代码。 4. 抽象工厂模式 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 5. 工厂方法模式 定义了一个创建对象的接口，但由子类决定实例化的类是哪一个。工厂方法模式让类把实例化推迟到子类。 6. 单例模式 确保一个类只有一个实例，并提供一个全局的访问点。 7. 命令模式 将“请求”封装成对象，以便使用不同的请求、队列、或者日志来参数化其他对象。命令模式也支持可撤销的操作。 8. 适配器模式 将一个类的接口转换为期望的另一个接口，让原本接口不兼容的类可以兼容。 9. 模板模式 定义一个算法的骨架，将算法中的某些步骤延迟到子类中具体实现。使得子类在不改变算法结构的情况下，重新定义算法中的某些步骤。 10. 代理模式 - 保护 为另一个对象提供一个替身或占位符以访问这个对象，是基于访问权控制对对象的访问。 11. 代理模式 - 虚拟 作为创建开销大的对象的代表，虚拟代理经常是直到我们真正需要一个对象时才创建真正的对象。当对象在创建前和创建中时，由虚拟代理来扮演真正对象的替身，待真正对象创建后，虚拟代理就会将请求直接给真正的对象。 12. 代理模式 - 远程 好比远程对象的本地代表。 13. 迭代器模式 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露器内部的表示。 14. 组合模式 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合模式能让客户以一致的方式处理个别对象及组合对象。 15. 外观模式 提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。外观模式不仅简化一个接口，而且将客户以组件的一个子系统中解耦。 16. 策略模式 定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 17. 状态模式 允许对象在内部状态改变时改变它的行为，使对象看起来好像修改了它的类。 使用设计模式的好处 使用模式名称和其他人员进行开发或者开发团队沟通时，彼此之间交流的不只是模式名称，而是一整套模式背后所象征的质量、特性、约束。 思路清晰：他人能更清晰的了解你对设计的想法，团队之间对于设计的看法不会轻易产生误解。 宏观：使用设计模式谈论软件系统，能让你保持在“设计层次”，不会被纠缠于“对象”与“类”这种琐碎的实现细节上。 大家对设计模式都有深入的了解，更易提升自身水平。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《Head First 设计模式》- 单例模式 概念单例模式是一种对象创建模式，其用于产生一种具体的对象实例，确保系统中的一个类有且只有一个对象实例。 单例模式特点： 构造函数私有化，防止外部调用构造函数进行实例化。 必须定义一个静态函数获得该单例。 处理好线程同步问题。 实现方式1：饿汉模式只要在加载类的时候，这个类的实例就会被加载，所以被称为饿汉模式。 特点： 空间换时间，类加载慢（在加载类的同时，需要加载类的对象），但是获取对象的速度快，线程安全。 无法对instance实例实施懒加载。 无法实行懒加载的局限性为：譬如 SinglePattern 实例的创建是依赖参数或者配置文件的，在 getInstance()之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 123456789101112public class SinglePattern &#123; //饿汉模式 private static final SinglePattern singlePattern = new SinglePattern(); private SinglePattern() &#123; &#125; public static SinglePattern getInstance() &#123; return singlePattern; &#125;&#125; 2：懒汉模式 参考：https://blog.csdn.net/nsw911439370/article/details/50456231 类加载速度快（类加载时，不创建实例），但运行时加载对象慢（只有在外部第一次调用时才去创建对象。）。 特点：时间换空间，延迟加载。 synchronized关键字： synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。 写法-1：线程安全12345678910111213141516public class SinglePattern &#123; private static SinglePattern singlePattern = null; private SinglePattern() &#123; &#125; // synchronized 同步 public static synchronized SinglePattern getInstane() &#123; if (singlePattern == null) &#123; singlePattern = new SinglePattern(); &#125; return singlePattern; &#125;&#125; 这种实现方法是在获取实例的方法上添加了一个synchronized关键字，能够保证多线程下实例对象的唯一性。但是这样做有一个缺点就是当有其他的线程要去访问这个方法时，总要先拿到锁，才能执行方法里面的代码。若此实例已经创建，那么这个等待是费时的。于是修改为方法-2。 写法-2：双重检验锁12345678910111213141516171819202122public class SinglePattern &#123; private volatile static SinglePattern singlePattern = null; private SinglePattern() &#123; &#125; public static SinglePattern getInstance() &#123; // 先检查实例是否存在，如果不存在才进入下面的同步块 if (singlePattern == null) &#123; // 同步快，线程安全的创建实例 synchronized (SinglePattern.class) &#123; // 再次检查实例是否存在，如果不存在，才真正的创建实例 if (singlePattern == null) &#123; singlePattern = new SinglePattern(); &#125; &#125; &#125; return singlePattern; &#125;&#125; 在写法-2中使用了volatile关键字： volatile是轻量级的synchronized，保证了共享变量的可见性，可见性的意思是：当一个线程修改一个共享变量的数值时，另一个线程能够读到这个修改的值，确保共享变量能够准确和一致的更新。 使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。 使用了volatile关键字的原因： 如果不适用volatitle关键字，它是有问题。主要在于instance = new Singleton();，在 JVM 中这句话大概做了下面 3 件事情。 1231：给 instance 分配内存2：调用 Singleton 的构造函数来初始化成员变量3：将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用就会报错。 关于 2次空判定 与 synchronized 第一次判空：是为了提高运行效率，这种提高效率是在实例已经初始化的前提下。如果实例已经初始化了，每次调用此方时都要通过 synchronized 关键字进行阻塞，效率肯定不高；如果没有初始化，则是正好发挥了 synchronized 关键字的用处。 synchronized 关键字是为了防止多个线程同时调用 getInstance() 时，各个线程均初始化一次实例。 第二次判空：此处的判空条件是不能被省略掉的。如果没有此次判空，那么当 线程A 和 线程B 均通过第一次非空判定后，线程A先获取锁，初始化了实例，之后释放锁，然后线程B获取锁，线程B也进行了实例初始化。这样一来，实例化了2个实例。如果存在此次判定：当线程A释放对象锁后，线程B获取对象锁后，通过二次非空判定后，将不会在执行实例初始化。 3. 静态内部类特点： 这种写法使用JVM本身机制：单例的实例被声明成 static 和 final 变量保证了线程安全；由于 SingleInstance 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷； public class Singleton { private Singleton() { } public static class SingleInstance{ private static final Singleton SINGLETON = new Singleton(); } public static final Singleton getInstance(){ return SingleInstance.SINGLETON; } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Vim 命令]]></title>
    <url>%2FLinux-Vim%20%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Vim使用总结 vim命令vi有3个模式：插入模式、命令模式、低行模式。123插入模式：在此模式下可以输入字符，按ESC将回到命令模式。命令模式：可以移动光标、删除字符等。低行模式：可以保存文件、退出vi、设置vi、查找等功能(低行模式也可以看作是命令模式里的)。 打开文件、保存、关闭文件（vi命令模式下使用）1234567vi filename //打开filename文件,文件名称可以不存在:w //保存文件:w filename //保存至filename文件:q //退出编辑器，如果文件已修改请使用下面的命令:q! //退出编辑器，且不保存:wq //退出编辑器，且保存文件:wq! //强制保存内容退出 3.插入文本或行（vi命令模式下使用，执行下面命令后将进入插入模式，按ESC键可退出插入模式）1234567891011a //在当前光标位置的右边添加文本A //在当前行的末尾位置添加文本i //在当前光标位置的左边添加文本I //在当前行的开始处添加文本(非空字符的行首)O //在当前行的上面新建一行o //在当前行的下面新建一行R //替换(覆盖)当前光标位置及后面的若干文本J //合并光标所在行及下一行为一行(依然在命令模式) ``` ## 移动光标（vi命令模式下使用） 、使用上下左右方向键 、命令模式下： h：向左； l：向右； j：向下 ； k：向上； Backspace：向左； 空格键：向右； Enter：移动到下一行首、- 移动到上一行首。 $：跳至行末，0：跳至行首12 ## 删除、恢复字符或行（vi命令模式下使用） x //删除当前字符nx //删除从光标开始的n个字符dd //删除当前行ndd //向下删除当前行在内的n行d //删除光标所在行及下一行(共计删除2行)u //撤销上一步操作U //撤销对当前行的所有操作12 ## 搜索（vi命令模式下使用） /vpser //向光标下搜索vpser字符串?vpser //向光标上搜索vpser字符串n //向下搜索前一个搜素动作N //向上搜索前一个搜索动作12## 跳至指定行（vi命令模式下使用） n //跳n行n+ //向下跳n行n- //向上跳n行G //跳至文件的底部gg //跳至文件顶部12 ## 设置行号（vi命令模式下使用） :set nu //显示行号:set nonu //取消显示行号12 ## 复制、粘贴（vi命令模式下使用） yy //将当前行复制到缓存区，也可以用 “ayy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。nyy //将当前行向下n行复制到缓冲区，也可以用 “anyy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。yw //复制从光标开始到词尾的字符。nyw //复制从光标开始的n个单词。y^ //复制从光标到行首的内容。y$ //复制从光标到行尾的内容。p //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用”ap 进行粘贴。P //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用”aP 进行粘贴。12 ## 替换（vi命令模式下使用） :s/old/new //用new替换行中首次出现的old:s/old/new/g //用new替换行中所有的old:n,m s/old/new/g //用new替换从n到m行里所有的old:%s/old/new/g //用new替换当前文件里所有的old12## 编辑其他文件 :e otherfilename //编辑文件名为otherfilename的文件。12 ## 修改文件格式 :set fileformat=unix //将文件修改为unix格式，如win下面的文本文件在linux下会出现^M。12 ## 总结： 当如果不知道自己处在什么模式时可以按: 2次Esc键即可回到命令模式，会有最后提醒一点： 注意大小写！！！与￥123456 ---- # Linux中vim编辑注意事项&gt;2016年12月17日21:47:04 Ctrl s： 暂停该终端Ctrl q： 让终端继续运行Ctrl c： 中止当前正在执行的程序。Ctrl d： 相当于exit命令，退出当前会话。Ctrl z： 将当前运行的程序放到后台运行。与运行时加&amp;类似。Tab键自动补全命令。1234567----# Linux中Terminal快捷键的使用&gt;2017年 01月 09日 星期一 22:21:36 CST## 文件： shift + ctrl + T： 新标签页打开新的终端shift + ctrl + N： 新的窗口打开新的终端alt + w : 关闭终端alt + Q : 关闭全部终端12 ## 编辑： ctrl + C ： 复制ctrl + V ： 粘贴12 ## 查看： F11 ： 全屏ctrl + = : 放大ctrl + - ： 缩小ctrl + 0 ： 正常大小12 ## 查找： ctrl + F ： 查找ctrl + G ： 查找下一个ctrl + H ： 查找上一个ctrl + J ： 清除高亮查找12 ## 标签页： ctrl + pgup : 向上翻页ctrl + pgdn : 向下翻页shift + ctrl + pgup ： 标签内容移动之左侧标签shift + ctrl + pgdn ： 标签内容移动之右侧标签alt +数字 ： 切换至指定的标签页```]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Ubuntu 桌面使用命令]]></title>
    <url>%2FLinux-Ubuntu%20%E6%A1%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令使用参考 参考：https://www.cnblogs.com/yolanda-lee/p/4544573.html Ubuntu桌面环境快捷键：super（Win） ： 长按显示启动器快捷信息 super + 数字 ： 启动指定的应用 super + D ： 显示桌面 super + w : 所有窗口平铺 super + s : 显示所有的工作区 super + t : 打开回收站 alt + prt ： 对窗口截图 ctrl + h ： 显示隐藏文件.h开头 shift + prt ： 选取截图 shift + ctrl + T : 桌面打开终端（在同一窗口下，新的标签页） ctrl + w : 关闭应用 super + c : 搜索图片 super + v : 搜索视屏 super + a : 搜索应用 super + f : 搜索文件和文件夹 super + m : 搜索音乐 终端运行命令(简洁版) 2016年12月19日10:40:37 软件操作更新 apt-get update 安装 apt-get install 软件名称 卸载 apt-get remove 软件名称 高频率 作用 命令 清屏 clear 显示当前目录 pwd 显示用户 who 显示历史操作命令 history 组添加组 groupadd 组名 删除组 groupdel 组名 更改组信息 groupmod 组名 显示当前用户所属组 groups 用户查询历史登录 last [用户名] 切换用户 su 用户名 退出切换的用户 exit 相关文件 etc/group, etc/passwd, etc/shadow 查看当前用户 w/who 添加用户 useradd 用户名 删除用户 suerdel 用户名 更改用户信息 usermod 添加用户到组中 useradd -G 组名 用户名 （G:附加组，用户将创建一个与自己同名的组） useradd -g 组名 用户名 （g：表示用户所加入的主组） 用户修改密码 passwd 用户名 查询id值 id 将用户添加至已存在的组中 usermod -a -G 组名 用户名 更改用户主要所在组 usermod -g 组名 用户名 文件pwd 查看当前目录 cat （从第一行开始显示）查看文件内容 cat [-nTAEv] tac （从最后一行开始显示） nl （显示时输出行号） nl [-b{ a, t}n{ln,rn,rz}w ] more （分页显示） space 向下翻一页 enter 向下翻一行 q 立即退出 :f 立刻显示当前文件名及当前行数 /字符串 在当前显示内容中，向下查询【字符串】 less（同more，可以向前翻页） /字符串 向上查询 ？字符串 向下查询 n 重复前一个查询 N 反向重复前一个查询 q 离开 pagedown 向下翻页 pageuP 向上翻页 head （仅显示头几行） head [-n number] 文件 tail（仅显示尾几行） tail [-n number] 文件 od （以2进制的方式读取档案） 目录与文件查看 ls [-aAdfFhilrRSt] 目录名 （可以使用×作为匹配符）ls [--color={none,auto,always}] 目录名 ls [--full-time{mtime,ctime,atime}] 目录名 ll == ls -l ls -a （显示隐藏文件及目录） pwd -P （返回真实目录，非连接目录） 路径切换 cd 文件路径cd - (返回上一个工作目录) cd ~ （home目录） cd .. (返回上层文件) cd ../目录 （同一层目录中前往其他目录） cd ~用户名 （进入此用户的home目录） 创建文件vim 文件名 （方式1） touch 文件名(空) （方式2） echo “输入内容” &gt; 文件名.后缀 （方式3） echo “输入内容” &gt;&gt; 文件名.后缀 （方式3: 追加到文件末尾） sed (在某一行添加) 修改文件时间+创建文件touch(空) 时间分类mtime:内容变更时间； ctime：状态时间； atime：接收时间 touch [-mcadt] 创建目录 mkdirmkdir [-mp] 目录名 （m：权限，p：自动建立多层目录） 删除目录 rmrmdir [-p] 目录名 （p：当前目录包含多个目录，删除时连同自身删除）仅能删除空目录 1234567-f,--force忽略不存在的文件，从不给出提示-i,--interactive 进行交互式地删除-r,-R,--recursive 指示rm将参数中列出的全部目录和子目录均递归地删除-v,--verbose 详细显示进行的步骤 eg： 原文件路径： 删除时执行的操作 删除以-f开头的文件 1rm -- -f 删除任何.log文件，删除前逐一询问 1rm –i *.log 更改组 chgrpchgrp [-R] 组名 文件 （R：文件夹递归） 更改拥有者 chownchown [-R] 用户名 文件 chown [-R] 用户名：组名 文件 获取文件名basename 目录 获取目录dirname 目录 文件预设权限 umaskumask [-S] (查看权限预设) 022:表示被‘拿掉的权限’,即：u,g-w,o-w umask 002 （设置权限） 权限的分类基本属性 + 隐藏属性 + 特别S属性 更改权限属性 chmodchmod [-R] 777 文件名 chmod [-R] u=(+/-)rwx,g=(+/-)rwx,o=(+/-)rwx 文件名 设定隐藏属性 chattrchattr [+-=][ASacdistu] 文件或目录名 (最常用a，i) chattr +a：表示在原有参数的基础上，追加参数-append，表示只能向文件中添加数据，不能删除,多用于日志。 chattr +i：表示文件不能被删除，改名，设定链接关系，同时不能写入，追加内容。 显示隐藏属性 lsattrlsattr [-aR] 文件或目录名 SUID,SGID,SBIT 设定4：SUID（使用在非目录上） 2：SGID（目录与文件均可） 1：SBIT（使用在非文件上） e.g. chmod 4755 文件名 结果为：-rwsr-xr-x 文件的类型 filefile 文件路径 文件查询whereis/locate（通过数据库查询,所以在查询前最好更新数据书库，updatedb文件） which find不推荐使用（伤硬盘：原理是在硬盘上查找，耗时）使用×匹配文件 which [-a] 文件 whereis [-bmsu] 文件或目录 locate 文件名 touch命令命令功能：一般在使用make的时候可能会用到，用来 修改文件时间戳 ，或者 新建一个不存在的文件。 命令格式： touch [选项]…文件… 命令参数： 1234567891011-a 或--time = atime--time =access或--time=use 只更改存取时间-c 或--no-create 不建立任何文档-d 使用指定的日期时间，而非现在的时间-m 或--time=mtime或--time=modify 只更改变动时间-r 把指定文档或目录的日期时间，统统设成和参考文档和目录的日期时间相同-t 使用指定的日期，而非现在的时间 cat命令命令功能： 用途是 连接文件 或 标准输入并打印，它常与重定向符号配合使用，主要有三大功能： 一次显示整个文件：cat filename 从键盘创建一个文件：cat&gt;filename 只能创建新文件，不能编辑已有文件 将几个文件合并为一个文件：cat file1 file2&gt;file 命令格式： cat [选项] [文件]… 命令参数： 12345678-A,--show-all 等价于-vET-b,--number-nonblank 对非空输出行编号-e 等价于 –vE-E,--show-ends 在每行结束处显示$-n,--number 对输出的所有行编号，由1开始对所有输出的行数编号-s,--squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行-t 与-vT等价-T,--show-tabs 将跳格字符显示为^I cp命令命令功能： 将源文件复制至目标文件，或将多个源文件复制至目标文件。 命令格式： cp [选项]… [-T] 源 目的 cp [选项]… 源… 目录 cp [选项]… -t 目录 源… 命令参数： 123-i ,--interactive： 覆盖前询问（使前面的-n选项失效）-n ,--no-clobber： 不要覆盖已存在的文件（使前面的-i选项失效）-R,-r,--recursive 复制目录及目录内的所有项目 mv命令命令功能： 是 move 的缩写，可以用来 移动文件 或者将 文件改名 视mv命令中 第二个参数类型 的不同（是 目标文件 还是目标目录），mv命令将 文件重命名 或将其 移至 一个新的目录中。 当第二个参数类型是 文件 时：mv命令完成 文件重命名，此时，源 文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。 当第二个参数是 已存在的目录名 时：源文件或目录参数可以有多个，mv命令将各参数指定的源文件 均 移至目标目录中。 在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链接该文件的链接也将丢失。 命令格式： 1mv [选项] 源文件或目录 目标文件或目录 命令参数： 1234567-b ：若需要覆盖文件，则覆盖前先行备份-f ： force强制的意思，如果目标文件已存在，不会询问而直接覆盖-i ： 若目标文件已经存在时，就会询问是否覆盖。-t ： --target –directory，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 删除 rmrm [-rfi] 目录或文件 (若文件名中含有-，则用‘./’或者‘空格--空格’) 更新 2017年02月04日 星期六 18时34分42秒 查看磁盘空间大小命令 主要命令：df 详细命令：df -hl : 查看磁盘剩余空间（效果同 df -H） df -h : 查看每个根路径的分区大小 du -sh : [目录名] 返回该目录的大小 du -sm : [文件夹] 返回该文件夹总M数 fdisk -l : 查看硬盘分区 查看ip地址ifconfig 查看端口号主要命令 ： netstat 查看所有的服务端口: netstat -a 查看所有的服务端口，显示pid号 netstat -ap 查看某一（**）端口，则可以结合grep命令： netstat -ap | grep ** 如查看**端口，： lsof -i:** 若要停止使用这个端口的程序，使用kill +对应的pid kill pid 还有一个比较好用的命令，查看**端口： netstat -lnp | grep ** 查看端口号和运行程序： netstat -atunp | more 查看进程所用端口： netstat -tlnp|grep ** 卸载已经安装的软件命令： dpkg -l | grep appName apt-get remove appName 更新grep命令 参考：http://www.lai18.com/content/24612942.html 命令： 是linux中的搜索工具。可以用在搜索条件“过滤”。 用法： grep [选项] PATTERN 参数说明： [options] -c：只输出匹配行的计数。 -i：不区分大 小写(只适用于单字符)。 -h：查询多文件时不显示文件名。 -l：查询多文件时只输出包含匹配字符的文件名。 -n：显示匹配行及行号。 -s：不显示不存在或无匹配文本的错误信息。 -v：排除，不显示过滤的字符串的行；显示不包含匹配文本的所有行。 -E ：过滤多个字符串。 -o ：输出精确匹配的字符而不是默认的整行。 -f ：指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 Context control： -B 除了显示匹配的一行之外，并显示该行之前的num行 -A 除了显示匹配的一行之外，并显示该行之后的num行 -C 除了显示匹配的一行之外，并显示该行之前后各num行 grep &quot;String&quot; -B 10 test.txt #显示匹配的String行和String的前10行。 pattern正则表达式主要参数： \：忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 $: 匹配正则表达式的结束行。 \&lt;：从匹配正则表达 式的行开始。 \&gt;：到匹配正则表达式的行结束。 [ ]：单个字符，如 [Gg]rep 匹配Grep和grep。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求。 [^]：匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。 x\{m\}：重复字符x，m次，如：&apos;0\{5\}&apos;匹配包含5个0的行。 x\{m,\}：重复字符x,至少m次，如：&apos;0\{5,\}&apos;匹配至少有5个0的行。 x\{m,n\}：重复字符x，至少m次，不多于n次，如：&apos;0\{5,10\}&apos;匹配5 -- 10个0的行。 .：所有的单个字符。 *：有字符，长度可以为0。 tree命令1234brew install tree``` **解决 `tree` 不能显示 中文 问题：** tree -N``` -1. 清单选项 参数 说明 -a 列出所有文件 -d 仅列出目录。 -l 遵循像目录这样的符号链接。 -f 打印每个文件的完整路径前缀。 -x 仅保留在当前文件系统上。 -L level 层级目录。 -R 达到最高等级时重新运行树。 -P pattern 仅列出与给定模式相匹配的文件。 -I pattern 不要列出与给定模式匹配的文件。 –ignore-case 模式匹配时忽略大小写。 –matchdirs 在-P模式匹配中包含目录名称。 –noreport 关闭树列表末尾的文件/目录计数。 –charset X 使用字符集X作为终端/ HTML和缩进行输出。 –filelimit＃ 不要下载超过＃个文件的dirs。 –timefmt 根据格式打印和格式化时间。 -o filename 输出到文件而不是标准输出 -2. 文件选项 参数 说明 -q 将不可打印的字符打印为’？’ -N 按原样打印不可打印的字符。 -Q 用双引号引用文件名。 -p 打印每个文件的保护。 -u 显示文件所有者或UID号码。 -g 显示文件组所有者或GID号码。 -s 打印每个文件的字节大小。 -h 以更易读的方式打印尺寸。 –si 像-h，但在国际单位中使用（幂数为1000）。 -D 打印上次修改日期或（-c）状态更改。 -F 附加’/‘，’=’，’*’，’@’，’ ‘或’&gt;’按照ls -F –inodes 打印每个文件的inode编号 –device 打印每个文件所属的设备ID号 -3. 排序选项 参数 说明 -v 按文本字母数字排序文件。 -t 按上次修改时间对文件进行排序。 -c 按上次状态更改时间对文件进行排序。 -U 保留文件未排序。 -r 反转排序的顺序。 –dirsfirst 列出文件之前的目录（-U禁用）。 - sort X 选择排序：名称，版本，大小，mtime，ctime。 -4. 图形选项 参数 说明 -i 不要打印缩进线。 -A 打印ANSI线图形缩进线。 -S 使用CP437（控制台）图形缩进线打印。 -n 始终关闭着色（-C覆盖）。 -C 总是打开彩色。 -5. XML / HTML / JSON选项 参数 说明 -X 打印树的XML表示。 -J 打印出树的JSON表示。 -H baseHREF 以baseHREF作为顶层目录打印HTML格式。 -T 字符串用字符串替换默认的HTML标题和H1标题。 –nolinks 关闭HTML输出中的超链接。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Ubuntu16.04安装记录]]></title>
    <url>%2FLinux-Ubuntu16.04%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[以下省略“sudo”命令表示是在root权限下运行的 ubuntu16.04使用参考网址 Linux使用设置 &gt;&gt;网页 http://m.blog.csdn.net/article/details?id=51049513 Linux命令大全 &gt;&gt;网页 http://www.runoob.com/linux/linux-command-manual.html Linux命令大全–支持在线搜寻 http://man.linuxde.net/ 文档手册中心 –ChinaUnix &gt;&gt;网页 http://man.chinaunix.net/ Linux Kernel –ChinaUnix &gt;&gt;网页 http://man.chinaunix.net/tech/lyceum/linuxK/tlk.html Linux Git使用 &gt;&gt;网页 http://v.youku.com/v_show/id_XNzgwOTk0NDQw.html?f=22842023&amp;spm=a2hzp.8244740.0.0&amp;from=y1.7-1.1 以下省略“sudo”命令表示是在root权限下运行的 root登录 先设定一个root的密码： sudo passwd root root 登陆： su root cp -p /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak vi /etc/lightdm/lightdm.conf 在lightdm.conf最后增加一行： greeter-show-manual-login=true 重启后，即可用root登入。 系统没有声音Ubuntu在root用户下，为了安全考虑默认关闭系统的声音。 将root加到pulse和pulse-access组： usermod -a -G pulse-access root gpasswd -a root pulse gpasswd -a root pulse-access 编辑/etc/default/pulseaudio文件 cp -p /etc/default/pulseaudio/etc/default/pulseaudio.bak vim /etc/default/pulseaudio 修改以下两处 PULSEAUDIO_SYSTEM_START=1 DISALLOW_MODULE_LOADING=0 改为1和0，表示允许运行在system环境，允许动态加载模块。 重启计算机 有声音但在“系统设置”中无法调节声音： 运行： gedit /root/.profile 在文件的最后添加： pulseaudio --start --log-target=syslog 当在“系统设置”中出现“伪声音”时，且无法实际调节声音时： apt install pavucontrol pavucontrol 系统正常耳机没有声音 参考网址：http://www.linuxdiyf.com/linux/25529.html 终端运行 alsamixer 按M键把关闭的都大开（关闭的都显示的是MM），然后调节到合适的位置，白色为宜 最后一项Independ显示为ON表示耳机和音箱只能有一个有声音，按M键关闭则表示耳机和音箱可以同时有声音 （–未进行测试–） 若耳机还是没声音，可是试着运行 gedit /etc/modprobe.d/alsa-base.conf 在最后一行加入 #enable headphoneoptions snd-hda-intel power_save=10 power_save_controller=N model=6stack-dig 然后运行 apt-get remove alsa-base 然后重启 shutdown -r now 重启后运行 apt-get install alsa-base ubuntu16.04系统字体变成方框问题进入到字体的目录下/usr/share/fonts/，输入下面的命令： cd /usr/share/fonts/ 制作ubuntu16.04app启动图标 2016年12月15日15:40:42 在文件所在目录下新建一个Studio.desktop文件,并用gedit打开,然后将下面的内容复制进去并修改. [Desktop Entry] Name=应用的名称 Type=Application（不改） Icon=你的AndroidStudio解压目录的绝对路径/android-studio/bin/studio.png Exec=sh 你的AndroidStudio解压目录的绝对路径/android-studio/bin/studio.sh 保存退出(注意：每一行后面都不能有空格,否则失败) 右键该文件–&gt;属性–&gt;权限–&gt;选择“允许作为程序执行文件”,此时发现图标变了,双击打开App 安装ADB 2017年01月30日 星期一 15时57分56秒 参考： http://www.itdadao.com/articles/c15a299707p0.html http://www.jianshu.com/p/8768e5bccfa8 若apt-get install 失败： sudo add-apt-repository ppa:phablet-team/tools (原始ppa更好) sudo apt-get update sudo apt-get install android-tools-adb 出现异常： E: 无法获得锁 /var/lib/dpkg/lock – open (11: 资源临时不可用) E: 无法对管理目录(/var/lib/dpkg/)加锁，是不是另一个包管理程序在使用它？ 解决办法： 删除有问题的文件 安装 JDK + Eclipse + Apache Tomcat 2016年12月14日15:32:34以下省略“sudo”命令表示是在root权限下运行的 JDK8 （下载地址） http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz 在所在的文件夹目录下，可以直接打开terminal，跳过以下两句操作，直接进行环境配置 cd /Downloads tar -zxvf jdk-8u101-linux-x64.tar.gz 3.配置环境变量 gedit /etc/profile 在文件末尾添加以下内容： export JAVA_HOME=/home/lt/Java/jdk1.8.0_101(你的Jdk目录) export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 更新文件（必须执行） source /etc/profile notice！若在终端中出现:程序 ‘javac’ 已包含在下列软件包中： update-alternatives --install /usr/bin/javac javac /root/文档/jdk1.8.0_112/bin/javac 300 update-alternatives --install /usr/bin/java java /root/文档/jdk1.8.0_112/bin/java 300 Eclipse（eclipse安装工具） （下载地址） https://www.eclipse.org/downloads/download.php?file=/oomph/epp/neon/R/eclipse-inst-linux64.tar.gz 解压 tar -zxcf eclipse-inst-linux64.tar.gz 进入解后目录下,双击eclipse.inst运行安装程序 若有安装错误执行 mkdir jre cd jre ln -s （你的JDK目录/bin bin） Tomcat9 （下载地址） http://tomcat.apache.org/download-90.cgi 在所在的文件夹目录下，可以直接打开terminal，跳过以下两句操作，直接进行环境配置 cd Downloads/ unzip apache-tomcat-9.0.0.M9.zip 配置环境变量： export CATLINA_HOME=/home/lt/Java/apache-tomcat-9.0.0.M9（文件所在路径） sourse /etc/profile 安装MySQL+WorkBrench 2016年12月15日15:54:09 以下省略“sudo”命令表示是在root权限下运行的 ubuntu16.04安装mysql5.7未用sudo apt-get update未用sudo apt-get upgrade apt-get install mysql-server mysql-client apt-get install libmysqlclient-dev 自动安装会装上5.7的client端，中间会弹出提示框输入root的密码 安装完成之后检查是否成功。socket处于 listen 状态则表示安装成功 netstat -tap | grep mysql 未用sudo groupadd mysql未用sudo useradd -r -g mysql mysql 修改密码 未用sudo /usr/bin/mysqladmin -u root password 登陆mysql数据库可以通过如下命令： mysql -u root -p -u 用户名， -p 用户密码，输入后提示输入密码，此时输入密码就可以登录到mysql 安装客户端apt-get install mysql-workbench 安装RabbitVCS 2017年02月06日 星期一 14时04分24秒参考：http://blog.csdn.net/catshitone/article/details/48022315 注： 安装完毕后，注销LogOut，重新登录，在文件夹和文件夹内点击鼠标右键就用RabbitVCS操作工具了。 如果不能正常运行则输入： sudo apt-get install python-nautilus python-configobj python-gtk2 python-glade2 python-svn python-dbus python-dulwich subversion meld 再次更新软件包库： sudo apt-get update 注销LogOut，重新登录即可。 安装Terminator 2017年02月06日 星期一 15时53分34秒参考： http://www.jianshu.com/p/cee2de32ca28 安装： apt-get install terminator 卸载： apt-get remove terminator 快捷键(自定义之后的): 水平分割终端 : Ctrl+O 垂直分割终端 : Ctrl+E 搜索 : Ctrl+F 复制 : Ctrl+C 粘贴 : Ctrl+V clear屏幕 : Ctrl+G 关闭当前终端 : Ctrl+W 退出当前窗口 : Ctrl+Q 变化当前窗口位置 ：super+R 全屏状态 : F11 在垂直分割的终端中将分割条向右移动 :Ctrl+Right 在垂直分割的终端中将分割条向左移动 :Ctrl+Left 隐藏/显示滚动条 :Ctrl+Shift+S 配置文件（可参考）： [global_config] handle_size = -3 enabled_plugins = CustomCommandsMenu, LaunchpadCodeURLHandler, APTURLHandler, LaunchpadBugURLHandler title_transmit_fg_color = &quot;#000000&quot; suppress_multiple_term_dialog = True title_transmit_bg_color = &quot;#3e3838&quot; inactive_color_offset = 1.0 [keybindings] [profiles] [[default]] palette = &quot;#000000:#5a8e1c:#2d5f5f:#cdcd00:#1e90ff:#cd00cd:#00cdcd:#e5e5e5:#4c4c4c:#868e09:#00ff00:#ffff00:#4682b4:#ff00ff:#00ffff:#ffffff&quot; background_image = &quot;&quot; background_darkness = 0.68 scrollback_lines = 3000 background_type = transparent use_system_font = scroll_background = False show_titlebar = False cursor_shape = ibeam font = Liberation Mono 12 background_color = &quot;#0e2424&quot; foreground_color = &quot;#e8e8e8&quot; [layouts] [[default]] [[[child1]]] type = Terminal parent = window0 profile = default [[[window0]]] type = Window parent = &quot;&quot; size = 925, 570 [plugins] ubuntu安装Wine 参考：http://www.ubuntukylin.com/ukylin/forum.php?mod=viewthread&amp;tid=27068 安装源 sudo add-apt-repository ppa:wine/wine-builds sudo apt-get update 安装wine apt-get install wine1.8 卸载wine 1).卸载wine主程序，在终端里输入： sudo apt-get remove --purge wine 2).然后删除wine的目录文件： rm -r ~/.wine 3).卸载残留不用的软件包： sudo apt-get autoremove 终端中输入wine，检测是否安装完成 ubuntu安装WebStorm 2017年02月16日 星期四 12时31分00秒 参考：https://quanru.github.io/2016/04/17/%E4%BD%BF%E7%94%A8%20Linux%20%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91Web%E5%89%8D%E7%AB%AF/webstorm使用快捷键参考： http://blog.csdn.net/zghekuiwu/article/details/54382145 https://github.com/damao/Intellij-IDEA-F2E#%E6%B3%A8%E5%86%8C 下载： http://www.jetbrains.com/webstorm/index.html 解压下载的 gz 包，在bin/下运行： ./webstorm.sh WebStorm 默认情况下是需要收费的，可以申请为开源项目的贡献者来获得 licenses。 安装完成后，在 File - Settings - Plugins，选择需要安装的插件，例如 AngularJS、Markdown 等。 在 File - Settings - Directories 下，通过 Add content Root 来设置我们的项目路径 在 File - Settings - JavaScript - Libraries 下，勾选想要支持的库，建议全部勾上（如 NodeJS）。 在 File - Settings - Editor - Colors &amp; Fonts - Font 下，选择自己想要的主题， 然后 Save as… 保存自己想要的主题名称，设置字体为Ubuntu Mono， 字体设置为 16（貌似有点小，相当于 Eclipse 下的 12） 在 File - Settings - Appearance 下，勾选 Show line numbers 选项。 破解方式：选择line server 方式，输入： http://idea.iteblog.com/key.php 安装ubuntu主题 2016年12月15日14:54:25 安装主题管理工具： apt-get install unity-tweak-tool 安装主题 apt-add-repository ppa:numix/ppa apt-get update apt-get install numix-icon-theme-circle //安装图标 apt-get install numix-gtk-theme //安装主题 安装docky（Mac桌面下方的启动器） 参考网址：http://www.aichengxu.com/view/992905参考网址：http://www.noobslab.com/2014/11/mbuntu-macbuntu-1410-transformation.html install docky add-apt-repository ppa:docky-core/ppa apt-get update apt-get install docky apt-get remove docky docky 安装XX-Net 2017年02月04日 星期六 17时17分36秒 安装xx-net 安装firefox或者chrome 设置： 系统设置 --&gt; 网络 --&gt; 网络代理 --&gt; 方法：自动 配置：http://127.0.0.1:8086/proxy.pac 全局配置 重点： 此项目来自GitHub，可以直接clone到本地 需要使用到Google AppID，以此进行服务器部署，以达到真正上网的目的 使用host科学上网2016年12月15日16:04:07使用host文件进行翻墙 参考链接：https://laod.cn/hosts/2016-google-hosts.html 安装sbulime text32017年 01月 28日 星期六 15:05:31 CST 安装参考： http://www.cnblogs.com/unflynaomi/p/5704293.html 汉化，中文输入问题参考： http://blog.csdn.net/u013453604/article/details/48002127 汉化，无法输入中文资源： http://download.csdn.net/detail/u013453604/9049633 不能输入中文问题参考： http://www.cnblogs.com/mo-wang/p/5120484.html（步骤不全，修改的内容全面） http://www.liuqianfei.com/article/3e51f07d254b464995b0f4c94cc1d69c（步骤全面） 配置java，python，markdown： http://www.jianshu.com/p/58bf9e4d5b32 安装步骤： sudo add-apt-repository ppa:webupd8team/sublime-text-3 sudo apt-get update sudo apt-get install sublime-text-installer 安装：python3 apt install python3-pip 卸载 sublime text 命令： sudo apt-get remove sublime-text-installer 启动sublime text3 在terminal终端中输入：subl 打开指定的文件： subl 文件名 解决sublime无法输入中文的问题在进行所有操作时首先进行依赖包的安装：代码依赖于 gtk 2.0，编译 c 需要安装 build-essential。 sudo apt-get install build-essential libgtk2.0-dev 如果路径中含有空格，你必须使用双引号将路径括起来： $ subl &amp;quot;~/Documents/test/my test file.txt&amp;quot; 解决无法输入中文问题 - 2017年03月12日 星期日 15时17分24秒 参考：http://www.jianshu.com/p/03a9092c73e2亲测有效！ 解决事件输入问题 参考：https://my.oschina.net/antsky/blog/491146 WPS字体缺失 下载缺失的字体文件，然后复制到Linux系统中的/usr/share/fonts文件夹中。 国外下载地址：https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip 国内下载地址：https://pan.baidu.com/s/1eS6xIzosudo cp * /usr/share/fonts 执行以下命令,生成字体的索引信息： sudo mkfontscale sudo mkfontdir 运行fc-cache命令更新字体缓存。 sudo fc-cache 重启wps即可，字体缺失的提示不再出现。 WPS不能输入中文问题 参考:http://forum.ubuntu.org.cn/viewtopic.php?f=48&amp;t=476937原因：环境变量未正确设置，以上可以直接针对wps设置。 解决办法,终端输入: gedit /usr/bin/wps 在此文件中输入一下内容,#!/bin/bash之后: export XMODIFIERS=&quot;@im=fcitx&quot; export QT_IM_MODULE=&quot;fcitx&quot; 安装WeChat 2016年12月13日22:43:53 安装linux微信： 下载地址:https://github.com/geeeeeeeeek/electronic-wechat/releases apt-get install git git clone https://github.com/geeeeeeeeek/electronic-wechat.git cd electronic-wechat apt-get install npm apt-get install nodejs-legacy npm install &amp;&amp; npm start 官方推荐的安装方法： To clone and run this repository you’ll need Git and Node.js (which comes with npm) installed on your computer. From your command line: Clone this repository git clone https://github.com/geeeeeeeeek/electronic-wechat.git# Go into the repositorycd electronic-wechat# Install dependencies and run the app npm install &amp;&amp; npm start To pack into an app, simply type one of these: npm run build:osx npm run build:linux]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Alias 的使用]]></title>
    <url>%2FLinux-Alias%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[所有命令均在ubuntu16.04环境下完成，在不同环境下可能会有差异 alias介绍alias用于自定义快捷命令，避免总是使用相同的，重复的，冗长的命令来执行操作 alias的用法1.添加新的自定义快捷方式 alias 自定义新名字=&quot;操作命令&quot; 示例：将进入文档目录的命令定义为 cdd 新命令 alias cdd=&quot;cd /root/文档/&quot; 2.删除自定义的快捷方式： unalias 自定义新名字 示例：删除 cdd 新命令 unalias cdd 3.查询自定义快捷方式： alias alias的存储注： 若不保存在文件中，则只能在当前的`terminal`中使用,只有保存到文件中后才能供以后继续使用 来自～/.bashrc文档的介绍 Alias definitions.You may want to put all your additions into a separate file like ~/.bash_aliases, instead of adding them here directly. See /usr/share/doc/bash-doc/examples in the bash-doc package. 使用以下方式，将自定义的快捷键存入系统已有文件中。此文件位于/root/下: vim ~/.bashrc 使用以下方式，将自定义的快捷键存入”指定”的新文件中。此文件位于/root/下: vim ~/.bash_aliases 注： 对于以上两中方式，必须使用： source ~/.bash_aliases 命令更新文件，否则自定义快捷键将不会被找到，无法起作用。 个人快捷命令组合： ls 查询字段释义：http://blog.csdn.net/sjzs5590/article/details/8254527更多详细使用参考：用户目录下的 .bash_profile # Alias alias ll=&apos;ls -lh -G&apos; alias la=&quot;ls -lah -G&quot; # 显示size alias lls=&apos;ls -lSGh&apos; alias las=&quot;ls -laSGh&quot; # 显示行号 alias lln=&apos;ls -lh | nl&apos; alias lan=&quot;ls -lah | nl&quot; alias llns=&apos;ls -lSh | nl&apos; alias lans=&quot;ls -laSh | nl&quot; alias grep=&apos;grep --color&apos; # Hexo alias ohb=&apos;open &quot;/Users/yannischeng/Documents/HexoBLog&quot;&apos; alias ohbs=&apos;open &quot;/Users/yannischeng/Documents/HexoBLog/source/_posts&quot;&apos; alias chbl=&apos;cd &quot;/Users/yannischeng/Documents/HexoBLog&quot;&apos; alias chbsl=&apos;cd &quot;/Users/yannischeng/Documents/HexoBLog/source/_posts&quot;&apos; # python project alias opp=&apos;open /Users/yannischeng/PycharmProjects/First_Python_Project&apos; alias cppl=&apos;cd /Users/yannischeng/PycharmProjects/First_Python_Project&apos; # .bash_profile alias sup=&apos;source .bash_profile&apos; alias oup=&apos;open /Users/yannischeng/.bash_profile&apos; alias cupl=&apos;cd /Users/yannischeng/&apos; # open app alias om=&apos;open /Applications/MWeb.app&apos; alias oas=&apos;open /Applications/&quot;Android Studio&quot;.app&apos; alias osb=&apos;open /Applications/&quot;Sublime Text&quot;.app&apos; alias ogc=&apos;open /Applications/&quot;Google Chrome&quot;.app&apos; alias opc=&apos;open /Applications/PyCharm.app&apos; alias owc=&apos;open /Applications/WeChat.app&apos; alias od=&apos;open /Applications/Dictionary.app&apos; alias owm=&apos;open /Applications/NeteaseMusic.app&apos; # login mysql alias lms=&apos;mysql -u root -p&apos; # mytree alias mtree=&quot;find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos;&quot;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
